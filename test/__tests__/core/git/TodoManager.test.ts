import * as TodoManager from '../../../../src/core/git/TodoManager';
import fs from 'fs';

jest.mock('fs', () => ({
    promises: {
        readFile: jest.fn(),
        writeFile: jest.fn(),
    },
}));

const mockReadFile = fs.promises.readFile as jest.Mock;

describe('TodoManager', () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });

    describe('parseTodoFile', () => {
        test('should parse metadata and tasks correctly', async () => {
            const mockContent = `> Generated by Yuangs Git Plan at 2026-01-28
> Context: test context
> ðŸ“Š Progress: 0/2 tasks completed
- [ ] Task 1 [priority: high]
- [x] Task 2 [depends: 1] <!-- exec:done, review:10 -->`;

            mockReadFile.mockResolvedValue(mockContent);

            const result = await TodoManager.parseTodoFile('todo.md');

            expect(result.metadata.generatedAt).toBe('2026-01-28');
            expect(result.metadata.context).toBe('test context');
            expect(result.tasks).toHaveLength(2);

            expect(result.tasks[0]).toEqual({
                index: 0,
                description: 'Task 1 [priority: high]',
                completed: false,
                priority: 'high',
                attempts: 0
            });

            expect(result.tasks[1]).toEqual({
                index: 1,
                description: 'Task 2 [depends: 1]',
                completed: true,
                dependsOn: [0],
                execStatus: 'done',
                reviewScore: 10,
                attempts: 0
            });
        });
    });

    describe('getNextTask', () => {
        test('should return the next uncompleted task with met dependencies', () => {
            const tasks: TodoManager.TaskStatus[] = [
                { index: 0, description: 'Task 1', completed: true },
                { index: 1, description: 'Task 2', completed: false, dependsOn: [0] },
                { index: 2, description: 'Task 3', completed: false, dependsOn: [1] },
            ];

            const nextTask = TodoManager.getNextTask(tasks);
            expect(nextTask?.index).toBe(1);
        });

        test('should respect priority if multiple tasks are available', () => {
            const tasks: TodoManager.TaskStatus[] = [
                { index: 0, description: 'Task 1', completed: false, priority: 'low' },
                { index: 1, description: 'Task 2', completed: false, priority: 'high' },
            ];

            const nextTask = TodoManager.getNextTask(tasks);
            expect(nextTask?.index).toBe(1);
        });
    });

    describe('validateDependencies', () => {
        test('should detect circular dependencies', () => {
            const tasks: TodoManager.TaskStatus[] = [
                { index: 0, description: 'T1', completed: false, dependsOn: [1] },
                { index: 1, description: 'T2', completed: false, dependsOn: [0] },
            ];

            const validation = TodoManager.validateDependencies(tasks);
            expect(validation.valid).toBe(false);
            expect(validation.errors[0]).toContain('æ£€æµ‹åˆ°å¾ªçŽ¯ä¾èµ–');
        });

        test('should detect self dependency', () => {
            const tasks: TodoManager.TaskStatus[] = [
                { index: 0, description: 'T1', completed: false, dependsOn: [0] },
            ];

            const validation = TodoManager.validateDependencies(tasks);
            expect(validation.valid).toBe(false);
            expect(validation.errors.some(e => e.includes('ä¸èƒ½ä¾èµ–è‡ªå·±'))).toBe(true);
        });
    });

    describe('updateTaskStatus', () => {
        test('should update a task correctly', async () => {
            const mockContent = `- [ ] T1\n- [ ] T2`;
            mockReadFile.mockResolvedValue(mockContent);
            const mockWriteFile = fs.promises.writeFile as jest.Mock;

            await TodoManager.updateTaskStatus('todo.md', 1, { completed: true, execStatus: 'done' });

            expect(mockWriteFile).toHaveBeenCalledWith(
                'todo.md',
                '- [ ] T1\n- [x] T2 <!-- exec:done -->',
                'utf8'
            );
        });
    });

    describe('updateMetadata', () => {
        test('should update progress metadata', async () => {
            const mockContent = `> ðŸ“Š Progress: 0/2\n- [ ] T1`;
            mockReadFile.mockResolvedValue(mockContent);
            const mockWriteFile = fs.promises.writeFile as jest.Mock;

            await TodoManager.updateMetadata('todo.md', { progress: { completed: 1, total: 2 } });

            expect(mockWriteFile).toHaveBeenCalledWith(
                'todo.md',
                '> ðŸ“Š Progress: 1/2 tasks completed\n- [ ] T1',
                'utf8'
            );
        });
    });

    describe('getExecutionOrder', () => {
        test('should sort tasks topologically', () => {
            const tasks: TodoManager.TaskStatus[] = [
                { index: 0, description: 'T1', completed: false, dependsOn: [1] },
                { index: 1, description: 'T2', completed: false },
            ];

            const order = TodoManager.getExecutionOrder(tasks);
            expect(order).toEqual([1, 0]);
        });
    });
});
