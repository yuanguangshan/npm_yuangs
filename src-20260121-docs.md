# Project Documentation

- **Generated at:** 2026-01-21 00:21:42
- **Root Dir:** `src`
- **File Count:** 101
- **Total Size:** 307.65 KB

## üìÇ File List
- `agent/AgentRuntime.ts` (3.48 KB)
- `agent/actions.ts` (1.58 KB)
- `agent/context.ts` (0.49 KB)
- `agent/contextManager.ts` (1.79 KB)
- `agent/executor.ts` (5.27 KB)
- `agent/governance.ts` (2.19 KB)
- `agent/governance/bridge.ts` (1.13 KB)
- `agent/governance/core.ts` (1.22 KB)
- `agent/governance/ledger.ts` (0.48 KB)
- `agent/governance/sandbox/core.as.ts` (1.35 KB)
- `agent/index.ts` (0.28 KB)
- `agent/llm.ts` (2.61 KB)
- `agent/llmAdapter.ts` (2.66 KB)
- `agent/policy/engine.ts` (2.26 KB)
- `agent/policy/index.ts` (0.09 KB)
- `agent/policy/policies/noDangerousShell.ts` (1.79 KB)
- `agent/policy/types.ts` (0.49 KB)
- `agent/prompt.ts` (2.08 KB)
- `agent/replay/events.ts` (0.59 KB)
- `agent/replay/index.ts` (0.08 KB)
- `agent/replay/recorder.ts` (1.38 KB)
- `agent/replay/replayer.ts` (1.88 KB)
- `agent/selectModel.ts` (0.33 KB)
- `agent/skills.ts` (5.05 KB)
- `agent/state.ts` (2.32 KB)
- `agent/types.ts` (1.25 KB)
- `ai/client.ts` (4.50 KB)
- `ai/prompt.ts` (2.29 KB)
- `ai/types.ts` (0.09 KB)
- `api/index.ts` (0.03 KB)
- `api/registryAPI.ts` (2.69 KB)
- `audit/index.ts` (0.03 KB)
- `audit/timeline.ts` (9.21 KB)
- `cli.ts` (22.46 KB)
- `commands/capabilityCommands.ts` (4.84 KB)
- `commands/chatHistoryStorage.ts` (1.70 KB)
- `commands/contextBuffer.ts` (2.20 KB)
- `commands/contextStorage.ts` (0.69 KB)
- `commands/explainCommands.ts` (1.01 KB)
- `commands/gitContext.ts` (0.77 KB)
- `commands/handleAIChat.ts` (25.75 KB)
- `commands/handleAICommand.ts` (8.55 KB)
- `commands/handleConfig.ts` (2.28 KB)
- `commands/replayCommands.ts` (2.59 KB)
- `commands/shellCompletions.ts` (13.64 KB)
- `commands/skillsCommands.ts` (4.64 KB)
- `core/apps.ts` (1.63 KB)
- `core/autofix.ts` (0.61 KB)
- `core/capabilities.ts` (1.90 KB)
- `core/capabilityInference.ts` (0.93 KB)
- `core/capabilitySystem.ts` (3.15 KB)
- `core/completion.legacy.ts` (5.89 KB)
- `core/completion/builtin.ts` (0.84 KB)
- `core/completion/cache.ts` (1.07 KB)
- `core/completion/index.ts` (0.69 KB)
- `core/completion/path.ts` (1.04 KB)
- `core/completion/resolver.ts` (2.62 KB)
- `core/completion/types.ts` (0.50 KB)
- `core/completion/utils.ts` (0.26 KB)
- `core/configMerge.ts` (3.09 KB)
- `core/executionRecord.ts` (2.50 KB)
- `core/executionStore.ts` (2.44 KB)
- `core/executor.ts` (0.97 KB)
- `core/explain.ts` (2.99 KB)
- `core/fileReader.ts` (2.03 KB)
- `core/macros.ts` (2.36 KB)
- `core/modelMatcher.ts` (2.65 KB)
- `core/os.ts` (1.00 KB)
- `core/replayDiff.ts` (8.07 KB)
- `core/replayEngine.ts` (4.54 KB)
- `core/risk.ts` (0.48 KB)
- `core/validation.ts` (4.51 KB)
- `index.ts` (0.14 KB)
- `legacy/governance/GovernanceEngine.ts` (3.08 KB)
- `legacy/governance/GovernedAction.ts` (3.23 KB)
- `legacy/governance/actions/CodeChangeAction.ts` (4.61 KB)
- `legacy/governance/capability/token.ts` (3.47 KB)
- `legacy/governance/commands/diffEdit.ts` (9.38 KB)
- `legacy/governance/execution/sandbox.ts` (2.03 KB)
- `legacy/governance/fsm/stateMachine.ts` (2.59 KB)
- `legacy/governance/index.ts` (0.32 KB)
- `legacy/governance/review/diffParser.ts` (1.74 KB)
- `legacy/governance/review/render.ts` (1.83 KB)
- `legacy/governance/storage/store.ts` (2.83 KB)
- `legacy/governance/verification/CodeChangeGovernance.tla` (5.11 KB)
- `policy/model/ModelRegistry.ts` (2.11 KB)
- `policy/sampler.ts` (2.43 KB)
- `policy/syntaxHandler.ts` (4.74 KB)
- `policy/token/DefaultTokenPolicy.ts` (5.67 KB)
- `policy/token/TokenEstimator.ts` (4.00 KB)
- `registry/errors.ts` (0.80 KB)
- `registry/index.ts` (0.08 KB)
- `registry/manifest.ts` (2.12 KB)
- `registry/registry.ts` (7.72 KB)
- `risk/explainer.ts` (7.04 KB)
- `risk/index.ts` (0.03 KB)
- `types.d.ts` (0.17 KB)
- `utils/confirm.ts` (0.44 KB)
- `utils/history.ts` (0.89 KB)
- `utils/renderer.ts` (3.65 KB)
- `utils/syntaxHandler.ts` (12.54 KB)

---

## üìÑ `agent/AgentRuntime.ts`

````typescript
import chalk from 'chalk';
import { randomUUID } from 'crypto';
import { LLMAdapter } from './llmAdapter';
import { GovernanceService } from './governance';
import { ToolExecutor } from './executor';
import { ContextManager } from './contextManager';
import { evaluateProposal } from './governance/core';
import { ProposedAction } from './state';

export class AgentRuntime {
    private context: ContextManager;
    private executionId: string;

    constructor(initialContext: any) {
        this.context = new ContextManager(initialContext);
        this.executionId = randomUUID();
    }

    async run(userInput: string, mode: 'chat' | 'command' = 'chat') {
        let turnCount = 0;
        const maxTurns = 10;

        console.log(chalk.cyan(`\nüöÄ Agent Runtime v2.0 Starting (Execution ID: ${this.executionId})`));
        this.context.addMessage('user', userInput);

        while (turnCount < maxTurns) {
            console.log(chalk.blue(`\n--- Turn ${++turnCount} ---`));

            const model = 'Assistant';

            // Â§ÑÁêÜÁ±ªÂûã‰∏çÂÖºÂÆπÔºöÂ∞Ü tool role Êò†Â∞Ñ‰∏∫ system
            const messages = this.context.getMessages().map(msg => ({
                role: (msg.role === 'tool' ? 'system' : msg.role) as 'system' | 'user' | 'assistant',
                content: msg.content
            }));

            const thought = await LLMAdapter.think(
                messages,
                mode as any,
                undefined,
                GovernanceService.getPolicyManual()
            );

            if (thought.isDone) {
                console.log(chalk.green('\n‚úÖ Goal satisfied.'));
                break;
            }

            const action: ProposedAction = {
                id: randomUUID(),
                type: thought.type as any || 'answer',
                payload: thought.payload || { text: thought.raw },
                riskLevel: 'low',
                reasoning: thought.reasoning || ''
            };

            // === È¢ÑÊ£Ä (Pre-flight) ===
            const preCheck = evaluateProposal(action, GovernanceService.getRules(), GovernanceService.getLedgerSnapshot());
            if (preCheck.effect === 'deny') {
                console.log(chalk.red(`[PRE-FLIGHT] üõ°Ô∏è Policy Blocked: ${preCheck.reason}`));
                this.context.addMessage('system', `POLICY DENIED: ${preCheck.reason}. Find a different way.`);
                continue;
            }

            // === Ê≠£ÂºèÊ≤ªÁêÜ (WASM + ‰∫∫Â∑•/Ëá™Âä®) ===
            const decision = await GovernanceService.adjudicate(action);
            if (decision.status === 'rejected') {
                console.log(chalk.red(`[GOVERNANCE] ‚ùå Rejected: ${decision.reason}`));
                this.context.addMessage('system', `Rejected by Governance: ${decision.reason}`);
                continue;
            }

            // === ÊâßË°å ===
            console.log(chalk.yellow(`[EXECUTING] ‚öôÔ∏è ${action.type}...`));
            const result = await ToolExecutor.execute(action as any);

            if (result.success) {
                this.context.addToolResult(action.type, result.output);
                console.log(chalk.green(`[SUCCESS] Result: ${result.output.substring(0, 50)}...`));
            } else {
                this.context.addToolResult(action.type, `Error: ${result.error}`);
                console.log(chalk.red(`[ERROR] ${result.error}`));
            }
        }

        if (turnCount >= maxTurns) {
            console.log(chalk.red(`\n‚ö†Ô∏è Max turns (${maxTurns}) reached.`));
        }
    }
}

````

## üìÑ `agent/actions.ts`

````typescript
import { AgentAction } from './types';
import { exec } from 'child_process';
import { promisify } from 'util';
import chalk from 'chalk';
import readline from 'readline';

const execAsync = promisify(exec);

export async function executeAction(
    action: AgentAction,
    options?: { autoYes?: boolean }
): Promise<void> {
    if (action.type === 'print') {
        console.log(action.content);
        return;
    }

    if (action.type === 'confirm') {
        const ok = options?.autoYes || await confirm('Execute this action?');
        if (ok) {
            await executeAction(action.next, options);
        }
        return;
    }

    if (action.type === 'execute') {
        try {
            console.log(chalk.cyan(`\nExecuting: ${action.command}\n`));
            const { stdout, stderr } = await execAsync(action.command, {
                shell: typeof process.env.SHELL === 'string' ? process.env.SHELL : undefined
            });
            if (stdout) console.log(stdout);
            if (stderr) console.error(chalk.yellow(stderr));
        } catch (error: any) {
            console.error(chalk.red(`Execution failed: ${error.message}`));
            throw error;
        }
    }
}

async function confirm(message: string): Promise<boolean> {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
    });

    return new Promise((resolve) => {
        rl.question(chalk.cyan(`${message} (y/N): `), (answer) => {
            rl.close();
            resolve(answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes');
        });
    });
}

````

## üìÑ `agent/context.ts`

````typescript
import { AgentInput, AgentContext } from './types';
import { ContextBuffer } from '../commands/contextBuffer';

export function buildContext(input: AgentInput, contextBuffer: ContextBuffer): AgentContext {
    const items = contextBuffer.export();

    return {
        files: items.map(item => ({
            path: item.path,
            content: item.content,
        })),
        gitDiff: undefined, // Will be enhanced later
        history: [], // Will be populated from conversation history
    };
}

````

## üìÑ `agent/contextManager.ts`

````typescript
import crypto from 'crypto';
import { GovernanceContext } from './state';

export class ContextManager {
  private messages: Array<{ role: string; content: string; timestamp: number }> = [];
  private maxHistorySize = 50;

  constructor(initialContext?: GovernanceContext) {
    if (initialContext?.history) {
      this.messages = initialContext.history.map(msg => ({
        ...msg,
        timestamp: Date.now()
      }));
    }

    if (initialContext?.input) {
      this.addMessage('user', initialContext.input);
    }
  }

  addMessage(role: string, content: string): void {
    this.messages.push({
      role,
      content,
      timestamp: Date.now()
    });

    if (this.messages.length > this.maxHistorySize) {
      this.messages = this.messages.slice(-this.maxHistorySize);
    }
  }

  addToolResult(toolName: string, result: string): void {
    const content = `Tool ${toolName} returned:\n${result}`;
    this.addMessage('tool', content);
  }

  addObservation(observation: string): void {
    this.addMessage('system', observation);
  }

  getMessages(): Array<{ role: 'system' | 'user' | 'assistant' | 'tool'; content: string }> {
    return this.messages.map(({ role, content }) => ({ 
      role: role as 'system' | 'user' | 'assistant' | 'tool', 
      content 
    }));
  }

  getRecentMessages(count: number): Array<{ role: string; content: string; timestamp: number }> {
    return this.messages.slice(-count);
  }

  getHash(): string {
    const content = JSON.stringify(this.messages);
    return crypto.createHash('sha256').update(content).digest('hex');
  }

  getSnapshot() {
    return {
      inputHash: this.getHash(),
      systemPromptVersion: 'v1.0.0',
      toolSetVersion: 'v1.0.0',
      recentMessages: this.getRecentMessages(10)
    };
  }

  clear(): void {
    this.messages = [];
  }
}

````

## üìÑ `agent/executor.ts`

````typescript
import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs/promises';
import path from 'path';
import { ProposedAction, ToolExecutionResult } from './state';

const execAsync = promisify(exec);

export class ToolExecutor {
  static async execute(action: ProposedAction): Promise<ToolExecutionResult> {
    const { type, payload } = action;

    try {
      switch (type) {
        case 'tool_call':
          return await this.executeTool(payload);
        
        case 'shell_cmd':
          return await this.executeShell(payload.command);
        
        case 'code_diff':
          return await this.executeDiff(payload.diff);
        
        case 'answer':
          return {
            success: true,
            output: payload.content || '',
            artifacts: []
          };
        
        default:
          return {
            success: false,
            error: `Unknown action type: ${type}`,
            output: ''
          };
      }
    } catch (error: any) {
      return {
        success: false,
        error: error.message || String(error),
        output: ''
      };
    }
  }

  private static async executeTool(payload: any): Promise<ToolExecutionResult> {
    const toolName = payload.tool_name;

    switch (toolName) {
      case 'read_file':
        return await this.toolReadFile(payload.parameters);
      
      case 'write_file':
        return await this.toolWriteFile(payload.parameters);
      
      case 'list_files':
        return await this.toolListFiles(payload.parameters);
      
      case 'web_search':
        return {
          success: false,
          error: 'web_search not implemented yet',
          output: ''
        };
      
      default:
        return {
          success: false,
          error: `Unknown tool: ${toolName}`,
          output: ''
        };
    }
  }

  private static async toolReadFile(params: any): Promise<ToolExecutionResult> {
    const filePath = params.path;
    try {
      const content = await fs.readFile(filePath, 'utf-8');
      return {
        success: true,
        output: content,
        artifacts: [filePath]
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.message,
        output: ''
      };
    }
  }

  private static async toolWriteFile(params: any): Promise<ToolExecutionResult> {
    const filePath = params.path;
    const content = params.content;
    
    try {
      await fs.mkdir(path.dirname(filePath), { recursive: true });
      await fs.writeFile(filePath, content, 'utf-8');
      return {
        success: true,
        output: `Successfully wrote ${filePath}`,
        artifacts: [filePath]
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.message,
        output: ''
      };
    }
  }

  private static async toolListFiles(params: any): Promise<ToolExecutionResult> {
    const dirPath = params.path || '.';
    const recursive = params.recursive || false;
    
    try {
      const files = await this.getFiles(dirPath, recursive);
      return {
        success: true,
        output: JSON.stringify(files, null, 2),
        artifacts: files.map(f => f.path)
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.message,
        output: ''
      };
    }
  }

  private static async getFiles(dir: string, recursive: boolean): Promise<Array<{ path: string; type: string }>> {
    const entries = await fs.readdir(dir, { withFileTypes: true });
    const files: Array<{ path: string; type: string }> = [];

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      
      if (entry.isDirectory()) {
        files.push({ path: fullPath, type: 'directory' });
        if (recursive) {
          const subFiles = await this.getFiles(fullPath, recursive);
          files.push(...subFiles);
        }
      } else {
        files.push({ path: fullPath, type: 'file' });
      }
    }

    return files;
  }

  private static async executeShell(command: string): Promise<ToolExecutionResult> {
    try {
      const { stdout, stderr } = await execAsync(command, {
        maxBuffer: 10 * 1024 * 1024,
        cwd: process.cwd()
      });

      const output = stdout || stderr || '';
      
      return {
        success: true,
        output,
        artifacts: []
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.message,
        output: error.stdout || error.stderr || ''
      };
    }
  }

  private static async executeDiff(diff: string): Promise<ToolExecutionResult> {
    try {
      const tempFile = path.join(process.cwd(), '.yuangs_temp.patch');
      await fs.writeFile(tempFile, diff, 'utf-8');

      const { stdout, stderr } = await execAsync(`git apply --check ${tempFile}`, {
        cwd: process.cwd()
      });

      const { stdout: applyOutput } = await execAsync(`git apply ${tempFile}`, {
        cwd: process.cwd()
      });

      await fs.unlink(tempFile);

      return {
        success: true,
        output: applyOutput || 'Diff applied successfully',
        artifacts: ['.yuangs_temp.patch']
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.message,
        output: error.stdout || error.stderr || 'Failed to apply diff'
      };
    }
  }
}

````

## üìÑ `agent/governance.ts`

````typescript
import { ProposedAction, GovernanceDecision } from './state';
import { evaluateProposal, PolicyRule, RiskEntry } from './governance/core';
import { RiskLedger } from './governance/ledger';
import { WasmGovernanceBridge } from './governance/bridge';
import jsyaml from 'js-yaml';
import fs from 'fs';
import path from 'path';

export class GovernanceService {
  private static rules: PolicyRule[] = [];
  private static ledger = new RiskLedger();
  private static initialized = false;

  static async init() {
    if (this.initialized) return;
    this.loadPolicy();
    await WasmGovernanceBridge.init();
    this.initialized = true;
  }

  private static loadPolicy() {
    try {
      const policyPath = path.join(process.cwd(), 'policy.yaml');
      if (fs.existsSync(policyPath)) {
        const content = fs.readFileSync(policyPath, 'utf8');
        const config = jsyaml.load(content) as any;
        this.rules = config.rules || [];
      }
    } catch (e) {
      this.rules = [];
    }
  }

  static getRules(): PolicyRule[] {
    return this.rules;
  }

  static getLedgerSnapshot(): RiskEntry[] {
    return this.ledger.getSnapshot();
  }

  static getPolicyManual(): string {
    return this.rules.map(r => `- ${r.id}: ${r.reason} (${r.effect})`).join('\n');
  }

  static async adjudicate(action: ProposedAction): Promise<GovernanceDecision> {
    await this.init();

    // 1. WASM Áâ©ÁêÜÂ±ÇÊ†∏È™å
    const wasmResult = WasmGovernanceBridge.evaluate(action, this.rules, this.ledger.getSnapshot());
    if (wasmResult.effect === 'deny') {
      return { status: 'rejected', by: 'policy', reason: wasmResult.reason || 'WASM Denied', timestamp: Date.now() };
    }

    // 2. ÈÄªËæëÂ±ÇÊ†∏È™å
    const logicResult = evaluateProposal(action, this.rules, this.ledger.getSnapshot());
    if (logicResult.effect === 'deny') {
      return { status: 'rejected', by: 'policy', reason: logicResult.reason || 'Policy Denied', timestamp: Date.now() };
    }

    if (logicResult.effect === 'allow') {
      this.ledger.record(action.type);
      return { status: 'approved', by: 'policy', timestamp: Date.now() };
    }

    // 3. ‰∫∫Â∑•Âπ≤È¢ÑÂÖúÂ∫ï (Ê®°Êãü)
    return { status: 'approved', by: 'human', timestamp: Date.now() };
  }
}

````

## üìÑ `agent/governance/bridge.ts`

````typescript
import fs from 'fs';
import path from 'path';

export class WasmGovernanceBridge {
    private static instance: any = null;

    static async init(): Promise<boolean> {
        try {
            const loader = require('@assemblyscript/loader');
            const wasmPath = path.join(process.cwd(), 'build', 'release.wasm');

            if (!fs.existsSync(wasmPath)) {
                return false;
            }

            const wasmModule = await loader.instantiate(fs.readFileSync(wasmPath));
            this.instance = wasmModule.exports;
            return true;
        } catch (e) {
            return false;
        }
    }

    static evaluate(proposal: any, rules: any, ledger: any): any {
        if (!this.instance) return { effect: 'error', reason: 'WASM not initialized' };

        const { __newString, __getString, evaluate } = this.instance;

        const pPtr = __newString(JSON.stringify(proposal));
        const rPtr = __newString(JSON.stringify(rules));
        const lPtr = __newString(JSON.stringify(ledger));

        const resultPtr = evaluate(pPtr, rPtr, lPtr);
        return JSON.parse(__getString(resultPtr));
    }
}

````

## üìÑ `agent/governance/core.ts`

````typescript
import { ProposedAction } from '../state';

export interface PolicyRule {
    id: string;
    when: { type?: string; pattern?: string; max_per_minute?: number };
    effect: 'allow' | 'deny' | 'require_approval';
    reason?: string;
}

export interface RiskEntry {
    ts: number;
    actionType: string;
}

export function evaluateProposal(
    action: ProposedAction,
    rules: PolicyRule[],
    ledger: RiskEntry[]
): { effect: string; reason?: string } {
    const now = Date.now();
    for (const rule of rules) {
        const typeMatch = !rule.when.type || rule.when.type === action.type;
        const payloadStr = JSON.stringify(action.payload);
        const patternMatch = !rule.when.pattern || new RegExp(rule.when.pattern, 'i').test(payloadStr);

        if (typeMatch && patternMatch) {
            if (rule.when.max_per_minute) {
                const count = ledger.filter(e => e.ts > now - 60000 && e.actionType === action.type).length;
                if (count >= rule.when.max_per_minute) return { effect: 'deny', reason: `Rate limit: ${rule.id}` };
            }
            return { effect: rule.effect, reason: rule.reason };
        }
    }
    return { effect: 'require_approval', reason: 'Default human review required' };
}

````

## üìÑ `agent/governance/ledger.ts`

````typescript
import { RiskEntry } from './core';

export class RiskLedger {
    private entries: RiskEntry[] = [];

    record(actionType: string): void {
        this.entries.push({
            ts: Date.now(),
            actionType
        });
        this.cleanup();
    }

    getSnapshot(): RiskEntry[] {
        return [...this.entries];
    }

    private cleanup(): void {
        const oneHourAgo = Date.now() - 3600000;
        this.entries = this.entries.filter(e => e.ts > oneHourAgo);
    }
}

````

## üìÑ `agent/governance/sandbox/core.as.ts`

````typescript
/**
 * yuangs Governance WASM Sandbox
 * ËøôÈáåÁöÑ‰ª£Á†ÅÂú®ÊâßË°åÊó∂‰∏é Node.js ÂÜÖÂ≠òÂÆåÂÖ®ÈöîÁ¶ª
 */

// ÁÆÄÂçïÁöÑËæÖÂä©ÂáΩÊï∞ÔºöÊ£ÄÊü•Â≠óÁ¨¶‰∏≤ÂåÖÂê´ÔºàWASM ÂÜÖÈÉ®ÂÆûÁé∞Ôºâ
function includes(source: string, target: string): boolean {
    return source.indexOf(target) != -1;
}

/**
 * Ê†∏ÂøÉË£ÅÂÜ≥ÂØºÂá∫ÂáΩÊï∞
 * @param proposal ÊèêÊ°àÂ≠óÁ¨¶‰∏≤
 * @param rules ËßÑÂàôÂ≠óÁ¨¶‰∏≤ÔºàYAML ËΩ¨Êç¢ÂêéÁöÑ JSONÔºâ
 * @param ledger Ë¥¶Êú¨Â≠óÁ¨¶‰∏≤
 */
export function evaluate(proposal: string, rules: string, ledger: string): string {
    // 1. Êö¥ÂäõÈòªÊñ≠ÔºöÊúÄÂ∫ïÂ±ÇÁöÑÁâ©ÁêÜÈò≤Á∫øÔºàÂç≥‰æøÂ§ñÈÉ®ÈÄªËæëË¢´Ê±°ÊüìÔºåËøôÈáå‰πüÊòØÊ≠ªÁöÑÔºâ
    if (proposal.includes("rm -rf /") || proposal.includes("sudo rm")) {
        return '{"effect": "deny", "reason": "WASM_SANDBOX: Ê£ÄÊµãÂà∞ÊØÅÁÅ≠ÊÄßÂëΩ‰ª§ÔºåÂº∫Âà∂ÈòªÊñ≠"}';
    }

    // 2. Ê£ÄÊü•ÈÄüÁéáÔºàÂü∫‰∫éË¥¶Êú¨ÈïøÂ∫¶Ôºâ
    // ÂÅáËÆæÊàë‰ª¨‰∏çÊÉ≥ËÆ© AI Âú®Áü≠Êó∂Èó¥ÂÜÖËøûÁª≠ÊèêËÆÆË∂ÖËøá 50 Ê¨°
    if (ledger.length > 5000) { // ÁÆÄÂçïÈÄöËøáÂ≠óÁ¨¶‰∏≤ÈïøÂ∫¶Ê®°ÊãüÂºÇÂ∏∏Ë¥¶Êú¨
        return '{"effect": "deny", "reason": "WASM_SANDBOX: Ë¥¶Êú¨ÂºÇÂ∏∏ËÜ®ËÉÄÔºåÂèØËÉΩÈÅ≠ÂèóÊãíÁªùÊúçÂä°ÊîªÂáª"}';
    }

    // 3. ÈÄªËæëÈÄè‰º†
    // Âú®ÂÆûÈôÖÁîü‰∫ß‰∏≠ÔºåÊàë‰ª¨‰ºöÂú®ËøôÈáåËß£Êûê JSON rules„ÄÇ
    // ÁõÆÂâçÁâàÊú¨Êàë‰ª¨ÂÖàÁ°Æ‰øùÁâ©ÁêÜÈìæË∑ØÊâìÈÄö„ÄÇ
    return '{"effect": "allow", "reason": "WASM_SANDBOX: Áâ©ÁêÜÈöîÁ¶ªÂ±ÇÈ™åËØÅÈÄöËøá"}';
}

````

## üìÑ `agent/index.ts`

````typescript
export { AgentRuntime } from './AgentRuntime';
export * from './state';
export { LLMAdapter } from './llmAdapter';
export { GovernanceService } from './governance';
export { ToolExecutor } from './executor';
export { ContextManager } from './contextManager';
export * from './skills';

````

## üìÑ `agent/llm.ts`

````typescript
import { AgentPrompt, LLMResult } from './types';
import { callAI_Stream } from '../ai/client';
import axios from 'axios';
import { DEFAULT_AI_PROXY_URL, DEFAULT_MODEL, DEFAULT_ACCOUNT_TYPE, type AIRequestMessage } from '../core/validation';
import fs from 'fs';
import path from 'path';
import os from 'os';
import { safeParseJSON } from '../core/validation';

const CONFIG_FILE = path.join(os.homedir(), '.yuangs.json');

function getUserConfig(): any {
    if (fs.existsSync(CONFIG_FILE)) {
        try {
            const content = fs.readFileSync(CONFIG_FILE, 'utf8');
            return JSON.parse(content);
        } catch (e) { }
    }
    return {};
}

export async function runLLM({
    prompt,
    model,
    stream,
    onChunk,
}: {
    prompt: AgentPrompt;
    model: string;
    stream: boolean;
    onChunk?: (s: string) => void;
}): Promise<LLMResult> {
    const start = Date.now();

    if (stream) {
        let raw = '';
        await callAI_Stream(prompt.messages, model, (chunk) => {
            raw += chunk;
            onChunk?.(chunk);
        });
        return {
            rawText: raw,
            latencyMs: Date.now() - start,
        };
    }

    // Non-streaming mode with optional schema
    const config = getUserConfig();
    const url = config.aiProxyUrl || DEFAULT_AI_PROXY_URL;

    const headers = {
        'Content-Type': 'application/json',
        'X-Client-ID': 'npm_yuangs',
        'Origin': 'https://cli.want.biz',
        'Referer': 'https://cli.want.biz/',
        'account': config.accountType || DEFAULT_ACCOUNT_TYPE,
        'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Mobile/15E148 Safari/604.1',
        'Accept': 'application/json'
    };

    const data = {
        model: model || config.defaultModel || DEFAULT_MODEL,
        messages: prompt.messages,
        stream: false
    };

    try {
        const response = await axios.post(url, data, { headers });
        const rawText = response.data.choices[0]?.message?.content || '';

        let parsed = undefined;
        if (prompt.outputSchema) {
            const parseResult = safeParseJSON(rawText, prompt.outputSchema, {});
            if (parseResult.success) {
                parsed = parseResult.data;
            }
        }

        return {
            rawText,
            parsed,
            latencyMs: Date.now() - start,
        };
    } catch (error: any) {
        const errorMsg = error.response?.data?.error?.message || error.response?.data?.message || error.message || 'Êú™Áü•ÈîôËØØ';
        throw new Error(`AI ËØ∑Ê±ÇÂ§±Ë¥•: ${errorMsg}`);
    }
}

````

## üìÑ `agent/llmAdapter.ts`

````typescript
import { AgentThought } from './state';
import { runLLM } from './llm';
import { AgentPrompt } from './types';
import type { AIRequestMessage } from '../core/validation';
import { getUserConfig } from '../ai/client';

export class LLMAdapter {
  static async think(
    messages: AIRequestMessage[],
    mode: 'chat' | 'command' | 'command+exec' = 'chat',
    onChunk?: (chunk: string) => void,
    customSystemPrompt?: string
  ): Promise<AgentThought> {
    const prompt: AgentPrompt = {
      system: customSystemPrompt || `You are yuangs AI Assistant. You are operating in Governance-First ReAct Loop mode.
      
Available action types:
- tool_call: Call a tool (read_file, write_file, web_search, shell)
- code_diff: Apply a code diff using unified diff format
- shell_cmd: Execute a shell command
- answer: Provide a final answer without any tool calls

When you need to perform an action, output your plan in this JSON format:
{
  "action_type": "tool_call" | "code_diff" | "shell_cmd" | "answer",
  "tool_name": string,  // for tool_call
  "parameters": object,
  "command": string,    // for shell_cmd
  "diff": string,       // for code_diff
  "content": string,     // for answer
  "reasoning": string    // Explain why you're taking this action
}

If the task is complete and no more actions are needed, output:
{
  "is_done": true,
  "final_answer": string
}`,
      messages,
    };

    const config = getUserConfig();
    const model = config.defaultModel || 'Assistant';

    const result = await runLLM({
      prompt,
      model,
      stream: !!onChunk,
      onChunk
    });

    return this.parseThought(result.rawText);
  }

  private static parseThought(raw: string): AgentThought {
    try {
      const jsonMatch = raw.match(/```json\n([\s\S]*?)\n```/) || raw.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[1] || jsonMatch[0]);

        if (parsed.is_done) {
          return {
            raw,
            parsedPlan: parsed,
            isDone: true,
            type: 'answer'
          };
        }

        return {
          raw,
          parsedPlan: parsed,
          isDone: false,
          type: parsed.action_type || 'tool_call',
          payload: {
            tool_name: parsed.tool_name,
            parameters: parsed.parameters,
            command: parsed.command,
            diff: parsed.diff,
            content: parsed.content
          },
          reasoning: parsed.reasoning || ''
        };
      }
    } catch (e) {
      console.warn('[LLMAdapter] Failed to parse JSON output, using raw text');
    }

    return {
      raw,
      parsedPlan: {},
      isDone: false,
      type: 'answer',
      reasoning: raw
    };
  }
}

````

## üìÑ `agent/policy/engine.ts`

````typescript
import { Policy, PolicyContext, PolicyResult } from './types';
import { RiskLevel } from '../state';

export class PolicyEngine {
  private policies: Map<string, Policy> = new Map();

  registerPolicy(policy: Policy): void {
    this.policies.set(policy.name, policy);
  }

  unregisterPolicy(name: string): void {
    this.policies.delete(name);
  }

  async evaluate(context: PolicyContext): Promise<PolicyResult> {
    let finalResult: PolicyResult = {
      allowed: true,
      reason: 'All policies passed'
    };

    for (const [name, policy] of this.policies) {
      const result = await policy.evaluate(context);
      
      if (!result.allowed) {
        return {
          allowed: false,
          reason: `Policy "${name}" blocked: ${result.reason}`,
          requiresEscalation: result.requiresEscalation || false,
          suggestedActions: result.suggestedActions
        };
      }

      if (result.requiresEscalation) {
        finalResult.requiresEscalation = true;
        finalResult.suggestedActions = result.suggestedActions;
      }
    }

    return finalResult;
  }

  evaluateRisk(action: { type: string; payload: any }): RiskLevel {
    const { type, payload } = action;

    if (type === 'tool_call') {
      const toolName = payload.tool_name;
      
      const lowRiskTools = ['read_file', 'list_files', 'web_search'];
      if (lowRiskTools.includes(toolName)) {
        return 'low';
      }

      const mediumRiskTools = ['write_file', 'shell'];
      if (mediumRiskTools.includes(toolName)) {
        const cmd = payload.parameters?.command || payload.command || '';
        if (this.containsDangerousCommand(cmd)) {
          return 'high';
        }
        return 'medium';
      }

      return 'medium';
    }

    if (type === 'shell_cmd') {
      const cmd = payload.command || '';
      if (this.containsDangerousCommand(cmd)) {
        return 'high';
      }
      return 'medium';
    }

    return 'low';
  }

  private containsDangerousCommand(cmd: string): boolean {
    const dangerousPatterns = [
      /rm\s+-rf\s+\//,
      /rm\s+-rf\s+~/,
      />\s*\/dev\/null/,
      /dd\s+if=/,
      /mkfs/,
      /format/,
      /sudo\s+rm/
    ];

    return dangerousPatterns.some(pattern => pattern.test(cmd));
  }
}

export const policyEngine = new PolicyEngine();

````

## üìÑ `agent/policy/index.ts`

````typescript
export * from './types';
export * from './engine';
export * from './policies/noDangerousShell';

````

## üìÑ `agent/policy/policies/noDangerousShell.ts`

````typescript
import { Policy, PolicyContext, PolicyResult } from '../types';
import { RiskLevel } from '../../state';

export class NoDangerousShellPolicy implements Policy {
  name = 'no-dangerous-shell';
  description = 'Prevents execution of dangerous shell commands';

  evaluate(context: PolicyContext): PolicyResult {
    const { action } = context;

    if (action.type === 'shell_cmd') {
      const command = action.payload?.command || '';
      
      const dangerousPatterns = [
        { pattern: /rm\s+-rf\s+\//, name: 'rm -rf /', risk: 'high' },
        { pattern: /rm\s+-rf\s+~/, name: 'rm -rf ~', risk: 'high' },
        { pattern: />\s*\/dev\/null/, name: 'Redirect to /dev/null', risk: 'medium' },
        { pattern: /dd\s+if=/, name: 'dd command', risk: 'high' },
        { pattern: /mkfs/, name: 'mkfs (filesystem creation)', risk: 'high' },
        { pattern: /format/, name: 'format command', risk: 'high' },
        { pattern: /sudo\s+rm/, name: 'sudo rm', risk: 'high' },
        { pattern: /chmod\s+777\s+\/(?!dev)/, name: 'chmod 777 on system', risk: 'high' },
        { pattern: /:\s*~\(\)/, name: 'fork bomb', risk: 'high' }
      ];

      for (const { pattern, name, risk } of dangerousPatterns) {
        if (pattern.test(command)) {
          return {
            allowed: false,
            reason: `Dangerous command detected: ${name} (${risk} risk)`,
            requiresEscalation: risk === 'high',
            suggestedActions: [
              `Review the command: "${command}"`,
              'Consider using safer alternatives',
              'Break down the operation into smaller, safer steps'
            ]
          };
        }
      }
    }

    return {
      allowed: true,
      reason: 'No dangerous patterns detected'
    };
  }
}

export const noDangerousShellPolicy = new NoDangerousShellPolicy();

````

## üìÑ `agent/policy/types.ts`

````typescript
import { RiskLevel } from '../state';

export interface PolicyContext {
  action: {
    type: string;
    payload: any;
  };
  user?: {
    permissions: string[];
  };
  environment?: {
    isProduction: boolean;
  };
}

export interface PolicyResult {
  allowed: boolean;
  reason?: string;
  requiresEscalation?: boolean;
  suggestedActions?: string[];
}

export interface Policy {
  name: string;
  description: string;
  evaluate(context: PolicyContext): PolicyResult | Promise<PolicyResult>;
}

````

## üìÑ `agent/prompt.ts`

````typescript
import {
    AgentIntent,
    AgentContext,
    AgentMode,
    AgentPrompt,
} from './types';
import { buildCommandPrompt as buildCommandPromptString } from '../ai/prompt';
import { getOSProfile } from '../core/os';
import { getMacros } from '../core/macros';
import { aiCommandPlanSchema } from '../core/validation';
import { getRelevantSkills } from './skills';

export function buildPrompt(
    intent: AgentIntent,
    context: AgentContext,
    mode: AgentMode,
    input: string
): AgentPrompt {
    if (mode === 'chat') {
        return buildChatPrompt(context, input);
    }

    return buildCommandPromptObject(input, context);
}

function buildChatPrompt(
    context: AgentContext,
    input: string
): AgentPrompt {
    const messages: any[] = [
        ...(context.history ?? []),
    ];

    // Add context files if available
    if (context.files && context.files.length > 0) {
        const contextDesc = context.files.map(f =>
            `File: ${f.path}\n\`\`\`\n${f.content}\n\`\`\``
        ).join('\n\n');

        messages.push({
            role: 'system',
            content: `Context:\n${contextDesc}`,
        });
    }

    messages.push({
        role: 'user',
        content: input,
    });

    return {
        system: 'You are a helpful AI assistant with expertise in software development, system administration, and problem-solving.',
        messages,
    };
}

function buildCommandPromptObject(
    input: string,
    context: AgentContext
): AgentPrompt {
    const os = getOSProfile();
    const macros = getMacros();
    const skills = getRelevantSkills(input);
    let promptText = buildCommandPromptString(input, os, macros);

    if (skills.length > 0) {
        const skillList = skills.map(s => `- ${s.name}: ÂΩìÈÅáÂà∞ "${s.whenToUse}" Êó∂Ôºå‰Ω†ÂèØ‰ª•ÂèÇËÄÉËÆ°Âàí: ${s.planTemplate.goal}`).join('\n');
        promptText = `„ÄêÂèÇËÄÉÊäÄËÉΩÂ∫ì„Äë\n${skillList}\n\n${promptText}`;
    }

    return {
        messages: [
            {
                role: 'user',
                content: promptText,
            },
        ],
        outputSchema: aiCommandPlanSchema,
    };
}

````

## üìÑ `agent/replay/events.ts`

````typescript
export type EventType = 
  | 'state_transition'
  | 'llm_call'
  | 'tool_execution'
  | 'governance_decision'
  | 'observation_recorded'
  | 'evaluation_result'
  | 'error_occurred';

export interface RuntimeEvent {
  id: string;
  timestamp: number;
  executionId: string;
  type: EventType;
  data: {
    from?: string;
    to?: string;
    action?: any;
    decision?: any;
    result?: any;
    error?: string;
  };
  metadata?: Record<string, any>;
}

export interface EventRecorder {
  record(event: RuntimeEvent): void;
  flush(): Promise<void>;
  getEvents(executionId?: string): RuntimeEvent[];
}

````

## üìÑ `agent/replay/index.ts`

````typescript
export * from './events';
export * from './recorder';
export * from './replayer';

````

## üìÑ `agent/replay/recorder.ts`

````typescript
import { RuntimeEvent, EventRecorder } from './events';
import fs from 'fs/promises';
import path from 'path';
import { randomUUID } from 'crypto';

export class FileEventRecorder implements EventRecorder {
  private events: RuntimeEvent[] = [];
  private logFile: string;
  private flushInterval: number = 1000;

  constructor(logDir: string = '.yuangs_events') {
    this.logFile = path.join(logDir, `events_${Date.now()}.jsonl`);
  }

  async record(event: RuntimeEvent): Promise<void> {
    this.events.push(event);

    if (this.events.length >= this.flushInterval) {
      await this.flush();
    }
  }

  async flush(): Promise<void> {
    if (this.events.length === 0) return;

    const logDir = path.dirname(this.logFile);
    await fs.mkdir(logDir, { recursive: true });

    const content = this.events
      .map(e => JSON.stringify(e))
      .join('\n') + '\n';

    await fs.appendFile(this.logFile, content, 'utf8');
    this.events = [];
  }

  getEvents(executionId?: string): RuntimeEvent[] {
    if (!executionId) {
      return [...this.events];
    }

    return this.events.filter(e => e.executionId === executionId);
  }
}

export const createEvent = (
  executionId: string,
  type: RuntimeEvent['type'],
  data: RuntimeEvent['data'],
  metadata?: RuntimeEvent['metadata']
): RuntimeEvent => ({
  id: randomUUID(),
  timestamp: Date.now(),
  executionId,
  type,
  data,
  metadata
});

````

## üìÑ `agent/replay/replayer.ts`

````typescript
import { RuntimeEvent } from './events';

export interface ReplayerOptions {
  speed?: number;
  stopOnError?: boolean;
  dryRun?: boolean;
}

export class EventReplayer {
  private events: RuntimeEvent[] = [];
  private currentIndex: number = 0;
  private options: Required<ReplayerOptions>;

  constructor(events: RuntimeEvent[], options: ReplayerOptions = {}) {
    this.events = events;
    this.options = {
      speed: options.speed || 1,
      stopOnError: options.stopOnError !== undefined ? options.stopOnError : true,
      dryRun: options.dryRun || false
    };
  }

  hasNext(): boolean {
    return this.currentIndex < this.events.length;
  }

  next(): RuntimeEvent | null {
    if (!this.hasNext()) {
      return null;
    }

    return this.events[this.currentIndex++];
  }

  reset(): void {
    this.currentIndex = 0;
  }

  async replay(onEvent: (event: RuntimeEvent, options: Required<ReplayerOptions>) => Promise<void>): Promise<void> {
    this.reset();
    let hasError = false;

    while (this.hasNext() && !hasError) {
      const event = this.next();

      if (!event) break;

      try {
        await onEvent(event, this.options);

        if (event.type === 'error_occurred') {
          hasError = true;
          if (this.options.stopOnError) {
            break;
          }
        }

        if (this.options.speed > 1) {
          const delay = 100 / this.options.speed;
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      } catch (error: any) {
        console.error(`[Replay] Error at event ${event.id}:`, error.message);
        hasError = true;
      }
    }

    return;
  }

  getSummary(): {
    total: number;
    completed: number;
    errors: number;
  } {
    const errors = this.events.filter(e => e.type === 'error_occurred').length;
    
    return {
      total: this.events.length,
      completed: this.currentIndex,
      errors
    };
  }
}

````

## üìÑ `agent/selectModel.ts`

````typescript
import { AgentIntent } from './types';
import { getUserConfig } from '../ai/client';

export function selectModel(
    intent: AgentIntent,
    override?: string
): string {
    if (override) return override;

    const config = getUserConfig();
    const defaultModel = config.defaultModel || 'Assistant';

    return defaultModel;
}

````

## üìÑ `agent/skills.ts`

````typescript
import fs from 'fs';
import path from 'path';
import os from 'os';
import chalk from 'chalk';

export interface Skill {
    id: string;
    name: string;
    description: string;
    whenToUse: string; // Ëß¶ÂèëÂú∫ÊôØÊèèËø∞
    planTemplate: any;

    // ËØÑ‰ª∑ÊåáÊ†á
    successCount: number;
    failureCount: number;
    confidence: number; // 0 ~ 1, ÂàùÂßã 0.5

    // Êó∂Èó¥Êà≥
    lastUsed: number;
    createdAt: number;

    // ÊòØÂê¶ÂêØÁî®
    enabled: boolean;
}

const SKILLS_FILE = path.join(os.homedir(), '.yuangs_skills.json');
let skillLibrary: Skill[] = [];

// === Persistence Logic ===

function loadSkills() {
    if (fs.existsSync(SKILLS_FILE)) {
        try {
            const data = fs.readFileSync(SKILLS_FILE, 'utf-8');
            skillLibrary = JSON.parse(data);
        } catch (e) {
            console.error(chalk.yellow(`Failed to load skills from ${SKILLS_FILE}, starting empty.`));
            skillLibrary = [];
        }
    }
}

function saveSkills() {
    try {
        fs.writeFileSync(SKILLS_FILE, JSON.stringify(skillLibrary, null, 2));
    } catch (e) {
        console.error(chalk.red(`Failed to save skills to ${SKILLS_FILE}`));
    }
}

// Initialize on load
loadSkills();

// === Existing Logic with Save Hooks ===

/**
 * ËÆ°ÁÆóÊäÄËÉΩÂàÜ (0 ~ 1)
 */
export function computeSkillScore(skill: Skill, now: number = Date.now()): number {
    const totalUses = skill.successCount + skill.failureCount;
    const successRate = totalUses === 0 ? 0.5 : skill.successCount / totalUses;

    // Êó∂Èó¥Ë°∞Âáè (Freshness): ÂçäË°∞ÊúüÁ∫¶ 14 Â§©
    const idleDays = (now - skill.lastUsed) / (1000 * 60 * 60 * 24);
    const freshness = Math.exp(-idleDays / 14);

    // ÁªºÂêàÂæóÂàÜ: 45% ÊàêÂäüÁéá + 35% Êñ∞È≤úÂ∫¶ + 20% ÁΩÆ‰ø°Â∫¶
    return (0.45 * successRate) + (0.35 * freshness) + (0.20 * skill.confidence);
}

/**
 * Êõ¥Êñ∞ÊäÄËÉΩÁä∂ÊÄÅ (ÊâßË°åÂêéË∞ÉÁî®)
 */
export function updateSkillStatus(skillId: string, success: boolean) {
    const skill = skillLibrary.find(s => s.id === skillId);
    if (!skill) return;

    skill.lastUsed = Date.now();
    if (success) {
        skill.successCount++;
        // ÊàêÂäüÂ•ñÂä±: ÁΩÆ‰ø°Â∫¶ÁºìÊÖ¢ÊèêÂçá
        skill.confidence = Math.min(1, skill.confidence + 0.05);
    } else {
        skill.failureCount++;
        // Â§±Ë¥•ÊÉ©ÁΩö: ÊÉ©ÁΩöÂäõÂ∫¶Â§ß‰∫éÂ•ñÂä±ÔºåÈò≤Ê≠¢Á≥ªÁªü‚ÄúËá™Âó®‚Äù
        skill.confidence = Math.max(0, skill.confidence - 0.1);
    }

    saveSkills(); // Persist changes
}

/**
 * Ëá™Âä®Â≠¶‰π†Êñ∞ÊäÄËÉΩ
 */
export function learnSkillFromRecord(record: any, success: boolean = true) {
    if (record.mode === 'chat' || !record.llmResult.plan) return;

    const existingSkill = skillLibrary.find(s => s.name === record.llmResult.plan?.goal);

    if (existingSkill) {
        updateSkillStatus(existingSkill.id, success);
        return;
    }

    // Âè™ÊúâÊàêÂäüÁöÑËÆ∞ÂΩïÊâçË¢´Â≠¶‰∏∫Êñ∞ÊäÄËÉΩ
    if (!success) return;

    const now = Date.now();
    skillLibrary.push({
        id: record.id,
        name: record.llmResult.plan.goal,
        description: `Ëá™Âä®Â≠¶‰π†ÁöÑÊäÄËÉΩ: ${record.llmResult.plan.goal}`,
        whenToUse: record.input.rawInput,
        planTemplate: record.llmResult.plan,
        successCount: 1,
        failureCount: 0,
        confidence: 0.5,
        lastUsed: now,
        createdAt: now,
        enabled: true
    });

    // ÊØèÂ≠¶‰π†‰∏ÄÊ¨°ÔºåÂ∞ùËØïÊ∏ÖÁêÜ‰∏ÄÊ¨°‚ÄúÂÜ∑‚ÄùÊäÄËÉΩ
    reapColdSkills();

    saveSkills(); // Persist changes
}

/**
 * Á≠õÈÄâÂπ∂ÊéíÂ∫èÊäÄËÉΩ (Áî®‰∫éÊ≥®ÂÖ• Prompt)
 */
export function getRelevantSkills(input: string, limit: number = 3): Skill[] {
    const now = Date.now();

    return skillLibrary
        // 1. Âü∫Á°ÄÁ≠õÈÄâ: ÂâîÈô§ËØÑÂàÜËøá‰ΩéÁöÑÊäÄËÉΩ (Á°¨Ê∑òÊ±∞ÈòàÂÄº 0.3)
        .filter(s => computeSkillScore(s, now) >= 0.3)
        // 2. ËøáÊª§Â∑≤Á¶ÅÁî®ÁöÑÊäÄËÉΩ
        .filter(s => s.enabled !== false)
        // 3. ÊéíÂ∫è: ÊåâÁªºÂêàÂàÜÊéíÂ∫è
        .sort((a, b) => computeSkillScore(b, now) - computeSkillScore(a, now))
        // 4. Âèñ‰∏äÈôê
        .slice(0, limit);
}

/**
 * Ê∏ÖÁêÜËøáÊúüÊàñ‰ΩéË¥®ÊäÄËÉΩ (Reaper)
 */
export function reapColdSkills() {
    const now = Date.now();
    const initialCount = skillLibrary.length;

    skillLibrary = skillLibrary.filter(skill => {
        const score = computeSkillScore(skill, now);
        const idleDays = (now - skill.lastUsed) / (1000 * 60 * 60 * 24);

        // Êª°Ë∂≥‰ª•‰∏ã‰ªª‰∏ÄÊù°‰ª∂ÂàôÊ∑òÊ±∞:
        // 1. ÂæóÂàÜÊûÅ‰Ωé‰∏îÈïøÊúü‰∏çÁî®
        if (score < 0.25 && idleDays > 30) return false;
        // 2. Â§±Ë¥•ÁéáÊûÅÈ´ò‰∏îÂ∞ùËØïËøá‰∏ÄÂÆöÊ¨°Êï∞
        if (skill.failureCount > 5 && (skill.successCount / (skill.successCount + skill.failureCount)) < 0.2) return false;

        return true;
    });

    // Âº∫Âà∂‰øùÊåÅÂÆπÈáè
    if (skillLibrary.length > 100) {
        // Â¶ÇÊûúËøòË∂ÖÊ†áÔºåÁßªÈô§ÂæóÂàÜÊúÄ‰ΩéÁöÑÈÇ£‰∏™
        skillLibrary.sort((a, b) => computeSkillScore(a, now) - computeSkillScore(b, now));
        skillLibrary.shift();
    }

    if (skillLibrary.length !== initialCount) {
        saveSkills(); // Persist if changes happened
    }
}

export function getAllSkills(): Skill[] {
    return [...skillLibrary];
}

````

## üìÑ `agent/state.ts`

````typescript
import { randomUUID } from 'crypto';

export type AgentState = 
  | 'IDLE' 
  | 'THINKING' 
  | 'PROPOSING' 
  | 'GOVERNING' 
  | 'EXECUTING' 
  | 'OBSERVING' 
  | 'EVALUATING' 
  | 'TERMINAL';

export type RiskLevel = 'low' | 'medium' | 'high';

export interface ProposedAction {
  id: string;
  type: 'tool_call' | 'code_diff' | 'shell_cmd' | 'answer';
  payload: any;
  riskLevel: RiskLevel;
  reasoning: string;
}

export type GovernanceDecision = 
  | { status: 'approved'; by: 'policy' | 'human'; timestamp: number }
  | { status: 'rejected'; by: 'policy' | 'human'; reason: string; timestamp: number }
  | { 
      status: 'modified'; 
      by: 'human'; 
      originalActionId: string;
      modifiedAction: ProposedAction;
      modificationReason: string;
      timestamp: number;
    };

export type EvaluationOutcome = 
  | { kind: 'continue'; reason: 'incomplete' | 'failure_retry' }
  | { kind: 'terminate'; reason: 'goal_satisfied' | 'user_abort' | 'max_turns_exceeded' }
  | { kind: 'pause'; reason: 'await_human_input' };

export interface AgentThought {
  raw: string;
  parsedPlan: any;
  isDone: boolean;
  type?: 'tool_call' | 'code_diff' | 'shell_cmd' | 'answer';
  payload?: any;
  reasoning?: string;
}

export interface ExecutionTurn {
  turnId: number;
  startTime: number;
  endTime?: number;
  contextSnapshot: {
    inputHash: string;
    systemPromptVersion: string;
    toolSetVersion: string;
    recentMessages: Array<{ role: string; content: string; timestamp: number }>;
  };
  thought?: AgentThought;
  proposedAction?: ProposedAction;
  governance?: GovernanceDecision;
  executionResult?: {
    success: boolean;
    output: string;
    error?: string;
    artifacts?: string[];
  };
  observation?: {
    summary: string;
    artifacts: string[];
    truncated?: boolean;
  };
  evaluation?: EvaluationOutcome;
}

export interface GovernanceLoopConfig {
  maxTurns: number;
  autoApproveLowRisk: boolean;
  verbose: boolean;
}

export interface ToolExecutionResult {
  success: boolean;
  output: string;
  error?: string;
  artifacts?: string[];
}

export interface GovernanceContext {
  input: string;
  mode: 'chat' | 'command' | 'command+exec';
  history: AIRequestMessage[];
  files?: Array<{ path: string; content: string }>;
}

interface AIRequestMessage {
  role: 'user' | 'assistant' | 'system' | 'tool';
  content: string;
}

````

## üìÑ `agent/types.ts`

````typescript
import type { AIRequestMessage } from '../core/validation';
// import { AgentPlan } from './plan';

export type AgentMode = 'chat' | 'command' | 'command+exec';

export interface AgentInput {
    rawInput: string;
    stdin?: string;
    context?: AgentContext;
    options?: {
        model?: string;
        stream?: boolean;
        autoYes?: boolean;
        verbose?: boolean;
    };
}

export interface AgentContext {
    files?: Array<{ path: string; content: string }>;
    gitDiff?: string;
    history?: AIRequestMessage[];
}

export interface AgentIntent {
    type: 'chat' | 'shell' | 'analysis';
    capabilities: {
        reasoning?: boolean;
        code?: boolean;
        longContext?: boolean;
        streaming?: boolean;
    };
}

export interface AgentPrompt {
    system?: string;
    messages: AIRequestMessage[];
    outputSchema?: any;
}

export interface LLMResult {
    rawText: string;
    parsed?: any;
    plan?: any;
    latencyMs: number;
    tokens?: {
        prompt: number;
        completion: number;
        total: number;
    };
    costUsd?: number;
}

export type AgentAction =
    | { type: 'print'; content: string }
    | { type: 'confirm'; next: AgentAction }
    | { type: 'execute'; command: string; risk: 'low' | 'medium' | 'high' };

````

## üìÑ `ai/client.ts`

````typescript
import axios from 'axios';
import fs from 'fs';
import path from 'path';
import os from 'os';
import { DEFAULT_AI_PROXY_URL, DEFAULT_MODEL, DEFAULT_ACCOUNT_TYPE, type UserConfig, type AIRequestMessage } from '../core/validation';
import { loadChatHistory, saveChatHistory } from '../commands/chatHistoryStorage';

const CONFIG_FILE = path.join(os.homedir(), '.yuangs.json');

let conversationHistory: AIRequestMessage[] = [];

// ÂàùÂßãÂåñÊó∂Âä†ËΩΩÊåÅ‰πÖÂåñÁöÑËÅäÂ§©ÂéÜÂè≤ËÆ∞ÂΩï
loadChatHistory().then(history => {
    conversationHistory = history;
});

export function addToConversationHistory(role: 'system' | 'user' | 'assistant', content: string) {
    conversationHistory.push({ role, content });
    if (conversationHistory.length > 20) {
        conversationHistory = conversationHistory.slice(-20);
    }
    // ÂêåÊó∂‰øùÂ≠òÂà∞ÊåÅ‰πÖÂåñÂ≠òÂÇ®
    saveChatHistory(conversationHistory);
}

export function clearConversationHistory() {
    conversationHistory = [];
    // ÂêåÊó∂Ê∏ÖÈô§ÊåÅ‰πÖÂåñÂ≠òÂÇ®
    saveChatHistory(conversationHistory);
}

export function getConversationHistory() {
    return conversationHistory;
}

export function getUserConfig(): UserConfig {
    if (fs.existsSync(CONFIG_FILE)) {
        try {
            const content = fs.readFileSync(CONFIG_FILE, 'utf8');
            return JSON.parse(content) as UserConfig;
        } catch (e) { }
    }
    return {};
}

export async function askAI(prompt: string, model?: string): Promise<string> {
    const config = getUserConfig();
    const url = config.aiProxyUrl || DEFAULT_AI_PROXY_URL;

    const headers = {
        'Content-Type': 'application/json',
        'X-Client-ID': 'npm_yuangs',
        'Origin': 'https://cli.want.biz',
        'Referer': 'https://cli.want.biz/',
        'account': config.accountType || DEFAULT_ACCOUNT_TYPE,
        'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Mobile/15E148 Safari/604.1',
        'Accept': 'application/json'
    };

    const data = {
        model: model || config.defaultModel || DEFAULT_MODEL,
        messages: [{ role: 'user', content: prompt }],
        stream: false
    };

    try {
        const response = await axios.post(url, data, { headers });
        const content = response.data?.choices?.[0]?.message?.content;
        return content || '';
    } catch (error: any) {
        const errorMsg = error.response?.data?.error?.message || error.response?.data?.message || error.message || 'Êú™Áü•ÈîôËØØ';
        throw new Error(`AI ËØ∑Ê±ÇÂ§±Ë¥•: ${errorMsg}`);
    }
}

export async function callAI_Stream(messages: AIRequestMessage[], model: string | undefined, onChunk: (content: string) => void): Promise<void> {
    const config = getUserConfig();
    const url = config.aiProxyUrl || DEFAULT_AI_PROXY_URL;

    const response = await axios({
        method: 'post',
        url: url,
        data: {
            model: model || config.defaultModel || DEFAULT_MODEL,
            messages: messages,
            stream: true
        },
        responseType: 'stream',
        headers: {
            'Content-Type': 'application/json',
            'X-Client-ID': 'npm_yuangs',
            'Origin': 'https://cli.want.biz',
            'Referer': 'https://cli.want.biz/',
            'account': config.accountType || DEFAULT_ACCOUNT_TYPE,
            'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Mobile/15E148 Safari/604.1',
            'Accept': 'application/json'
        }
    });

    return new Promise((resolve, reject) => {
        let buffer = '';
        response.data.on('data', (chunk: Buffer) => {
            buffer += chunk.toString();
            let lines = buffer.split('\n');
            buffer = lines.pop() || '';

            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine.startsWith('data: ')) {
                    const data = trimmedLine.slice(6);
                    if (data === '[DONE]') {
                        resolve();
                        return;
                    }
                    try {
                        const parsed = JSON.parse(data);
                        const content = parsed.choices[0]?.delta?.content || '';
                        if (content) onChunk(content);
                    } catch (e) { }
                }
            }
        });
        response.data.on('error', reject);
        response.data.on('end', () => {
            resolve();
        });
    });
}

````

## üìÑ `ai/prompt.ts`

````typescript
import { OSProfile } from '../core/os';
import type { Macro } from '../core/validation';

export function buildCommandPrompt(
    userInput: string,
    os: OSProfile,
    macros?: Record<string, Macro>,
    context?: string
): string {
    const macroContext = macros && Object.keys(macros).length > 0
        ? `
„ÄêÂèØÂ§çÁî®ÁöÑÂø´Êç∑Êåá‰ª§ (Macros)„Äë
‰ª•‰∏ãÊòØÂèØ‰ª•Áõ¥Êé•Â§çÁî®ÁöÑÂ∑≤È™åËØÅÂëΩ‰ª§„ÄÇ‰ºòÂÖàÂ§çÁî®Ëøô‰∫õÊåá‰ª§ÔºåËÄå‰∏çÊòØÁîüÊàêÊñ∞ÂëΩ‰ª§Ôºö

${Object.entries(macros).map(([name, macro]) => `  - ${name}: ${macro.description || '(Êó†ÊèèËø∞)'}`).join('\n')}

ÂΩìÁî®Êà∑ÁöÑÈúÄÊ±Ç‰∏éÊüê‰∏™ Macro ÂåπÈÖçÊàñÁõ∏‰ººÊó∂Ôºö
1. ‰ºòÂÖà‰ΩøÁî®ËØ• Macro
2. Âú® JSON ËæìÂá∫‰∏≠‰ΩøÁî® "macro" Â≠óÊÆµÊåáÂÆö Macro ÂêçÁß∞ÔºåËÄå‰∏çÊòØ "command" Â≠óÊÆµ
3. ‰ªÖÂú®Ê≤°ÊúâÂêàÈÄÇ Macro Êó∂ÊâçÁîüÊàêÊñ∞ÂëΩ‰ª§
`
        : '';

    return `
‰Ω†ÊòØ‰∏Ä‰∏™‰∏ì‰∏öÁöÑÂëΩ‰ª§Ë°å‰∏ìÂÆ∂„ÄÇ

„ÄêÁ≥ªÁªüÁéØÂ¢É„Äë
- Êìç‰ΩúÁ≥ªÁªü: ${os.name}
- Shell: ${os.shell}
- find ÂÆûÁé∞: ${os.find}
- stat ÂÆûÁé∞: ${os.stat}

„ÄêËßÑÂàô„Äë
- ÂëΩ‰ª§ÂøÖÈ°ª‰∏éÂΩìÂâçÁ≥ªÁªüÂÖºÂÆπ„ÄÇ
- Â¶ÇÊûúÊòØ macOS (BSD):
  - ‰∏çÂÖÅËÆ∏‰ΩøÁî® find -printf
  - ‰ºòÂÖà‰ΩøÁî® stat -f
- Â¶ÇÊûúÊòØ Linux (GNU):
  - ÂèØ‰ΩøÁî® find -printf
- ÈªòËÆ§‰∏ç‰ΩøÁî® sudo„ÄÇ
- Á°Æ‰øùËæìÂá∫ÁöÑÂëΩ‰ª§ÊòØÂçïË°åÊàñËÄÖ‰ΩøÁî® && ËøûÊé•„ÄÇ
- ‰∏çË¶ÅËß£ÈáäÔºåÂè™ËæìÂá∫Á¨¶Âêà‰ª•‰∏ã JSON ÁªìÊûÑÁöÑÊñáÊú¨„ÄÇ
- ‰ºòÂÖàÂ§çÁî®Â∑≤È™åËØÅÁöÑÂø´Êç∑Êåá‰ª§ÔºàMacrosÔºâÔºåÊØè‰∏™ Macro ÈÉΩÊòØÁªèËøá‰∫∫Â∑•È™åËØÅÁöÑÂèØÈù†ÂëΩ‰ª§„ÄÇÂú®ÁîüÊàêÊñ∞ÂëΩ‰ª§ÂâçÔºåÊ£ÄÊü•ÊòØÂê¶Â∑≤Êúâ Macro ÂèØ‰ª•ÂÆåÊàê‰ªªÂä°„ÄÇ

${macroContext}

„ÄêËæìÂá∫ JSON ÁªìÊûÑ„Äë
{
  "plan": "ÁÆÄË¶ÅËØ¥Êòé‰Ω†ÂáÜÂ§áÊâßË°åÁöÑÊ≠•È™§",
  "command": "ÂèØÁõ¥Êé•ÊâßË°åÁöÑ shell ÂëΩ‰ª§Ôºà‰ªÖÂΩìÊ≤°ÊúâÂêàÈÄÇ Macro Êó∂Êèê‰æõÔºâ",
  "macro": "Ë¶ÅÂ§çÁî®ÁöÑ Macro ÂêçÁß∞Ôºà‰ºòÂÖà‰ΩøÁî®Ôºå‰∏é command ‰∫åÈÄâ‰∏ÄÔºâ",
  "risk": "low | medium | high"
}

„Äê‰∏ä‰∏ãÊñá‰ø°ÊÅØ„Äë
${context || 'Êó†'}

„ÄêÁî®Êà∑ÈúÄÊ±Ç„Äë
${userInput}
`;
}

export function buildFixPrompt(
    originalCmd: string,
    stderr: string,
    os: OSProfile
): string {
    return `
ËØ•ÂëΩ‰ª§Âú® ${os.name} ‰∏äÊâßË°åÂ§±Ë¥•Ôºö

ÂëΩ‰ª§Ôºö
${originalCmd}

ÈîôËØØ‰ø°ÊÅØÔºö
${stderr}

ËØ∑ÁîüÊàê‰∏Ä‰∏™ **${os.name} ÂÖºÂÆπ** ÁöÑÁ≠â‰ª∑ÂëΩ‰ª§„ÄÇ
‰æùÁÑ∂Âè™ËæìÂá∫ JSON Ê†ºÂºè„ÄÇÊ≥®ÊÑèÔºöËøôÊòØ‰øÆÂ§çÂëΩ‰ª§Ôºå‰∏çÈúÄË¶ÅÊ£ÄÊü• Macro„ÄÇ

{
  "plan": "‰øÆÂ§çËØ¥Êòé",
  "command": "‰øÆÂ§çÂêéÁöÑÂëΩ‰ª§",
  "risk": "low | medium | high"
}
`;
}

````

## üìÑ `ai/types.ts`

````typescript
export { AICommandPlan, type AICommandPlan as AICommandPlanType } from '../core/validation';

````

## üìÑ `api/index.ts`

````typescript
export * from './registryAPI';

````

## üìÑ `api/registryAPI.ts`

````typescript
import { MacroRegistry } from '../registry/registry';
import { RiskExplainer, createCapabilityGraph } from '../risk/explainer';
import type { MacroManifest, MacroPublishOptions, Capability } from '../registry/manifest';
import type { RiskAssessment } from '../risk/explainer';

export class RegistryAPI {
  private registry: MacroRegistry;
  private riskExplainer: RiskExplainer;

  constructor(storagePath?: string) {
    this.registry = new MacroRegistry({ storagePath });
    this.riskExplainer = new RiskExplainer(createCapabilityGraph());
  }

  async initialize(): Promise<void> {
    await this.registry.initialize();
  }

  async publishMacro(
    id: string,
    version: string,
    description: string,
    requires: Capability[],
    author: string,
    options: MacroPublishOptions = {}
  ): Promise<MacroManifest> {
    const manifest: Omit<MacroManifest, 'checksum'> = {
      id,
      version,
      description,
      author,
      createdAt: Date.now(),
      state: 'draft',
      requires
    };

    return await this.registry.publish(manifest, options);
  }

  async getMacro(id: string, version?: string): Promise<MacroManifest | null> {
    return await this.registry.get(id, version);
  }

  async listMacros(filters?: {
    state?: 'draft' | 'approved' | 'deprecated';
    author?: string;
    tags?: string[];
  }): Promise<MacroManifest[]> {
    return await this.registry.list(filters);
  }

  async approveMacro(id: string, version: string, approvedBy: string): Promise<MacroManifest> {
    return await this.registry.approve(id, version, approvedBy);
  }

  async deprecateMacro(id: string, version?: string): Promise<MacroManifest> {
    return await this.registry.deprecate(id, version);
  }

  async assessMacroRisk(id: string, version?: string): Promise<RiskAssessment | null> {
    const manifest = await this.registry.get(id, version);
    if (!manifest) {
      return null;
    }

    return this.riskExplainer.explainRisk(manifest);
  }

  async compareMacroVersions(id: string, oldVersion: string, newVersion: string) {
    const oldManifest = await this.registry.get(id, oldVersion);
    const newManifest = await this.registry.get(id, newVersion);

    if (!oldManifest || !newManifest) {
      throw new Error('One or both versions not found');
    }

    return this.registry.compareCapabilities(oldManifest, newManifest);
  }

  async getMacroVersions(id: string) {
    return await this.registry.getVersions(id);
  }

  async explainCapability(capability: Capability): Promise<string> {
    return this.riskExplainer.explainCapability(capability);
  }

  async expandCapabilities(capabilities: Capability[]): Promise<Capability[]> {
    return this.riskExplainer.expandCapabilities(capabilities);
  }
}

````

## üìÑ `audit/index.ts`

````typescript
export * from './timeline';

````

## üìÑ `audit/timeline.ts`

````typescript
import type { ExecutionTurn } from '../agent/state';

export type AuditEventType =
  | 'macro_started'
  | 'macro_finished'
  | 'state_transition'
  | 'capability_requested'
  | 'capability_granted'
  | 'capability_denied'
  | 'human_approval_requested'
  | 'human_approved'
  | 'human_rejected'
  | 'tool_executed'
  | 'error_occurred';

export interface AuditEvent {
  id: string;
  timestamp: number;
  executionId: string;
  type: AuditEventType;
  data: {
    macroId?: string;
    macroVersion?: string;
    turnId?: number;
    fromState?: string;
    toState?: string;
    capability?: string;
    reason?: string;
    toolName?: string;
    toolParams?: any;
    success?: boolean;
    error?: string;
    approver?: string;
    duration?: number;
  };
  metadata?: Record<string, any>;
}

export interface ExecutionTimeline {
  executionId: string;
  startTime: number;
  endTime?: number;
  events: AuditEvent[];
  summary: ExecutionSummary;
}

export interface ExecutionSummary {
  totalDuration?: number;
  totalTurns: number;
  successfulTurns: number;
  failedTurns: number;
  capabilitiesRequested: Set<string>;
  capabilitiesGranted: Set<string>;
  capabilitiesDenied: Set<string>;
  toolsUsed: Map<string, number>;
  errors: Array<{ turn: number; message: string }>;
  humanApprovals: number;
  humanRejections: number;
}

export interface EffectsSummary {
  filesRead: string[];
  filesWritten: string[];
  filesModified: string[];
  commandsExecuted: Array<{ command: string; success: boolean }>;
  networkRequests: Array<{ url: string; method?: string }>;
  secretsAccessed: string[];
}

export class AuditTimeline {
  private events: AuditEvent[] = [];
  private executionId: string;
  private startTime: number;

  constructor(executionId: string) {
    this.executionId = executionId;
    this.startTime = Date.now();
  }

  record(event: Omit<AuditEvent, 'id' | 'timestamp' | 'executionId'>): void {
    this.events.push({
      id: this.generateEventId(),
      timestamp: Date.now(),
      executionId: this.executionId,
      ...event
    });
  }

  recordTurn(turn: ExecutionTurn): void {
    const startTime = Date.now();

    this.record({
      type: 'macro_started',
      data: {
        turnId: turn.turnId
      }
    });

    if (turn.proposedAction) {
      this.record({
        type: 'capability_requested',
        data: {
          capability: turn.proposedAction.type
        }
      });
    }

    if (turn.governance) {
      if (turn.governance.status === 'approved' && turn.governance.by === 'human') {
        this.record({
          type: 'human_approval_requested',
          data: {
            approver: turn.governance.by
          }
        });

        this.record({
          type: 'human_approved',
          data: {
            approver: turn.governance.by
          }
        });
      } else if (turn.governance.status === 'rejected') {
        this.record({
          type: 'human_approval_requested',
          data: {}
        });

        this.record({
          type: 'human_rejected',
          data: {
            reason: (turn.governance as any).reason
          }
        });
      }
    }

    if (turn.executionResult) {
      if (turn.proposedAction?.type === 'tool_call') {
        this.record({
          type: 'tool_executed',
          data: {
            toolName: turn.proposedAction.payload?.tool_name,
            toolParams: turn.proposedAction.payload?.parameters,
            success: turn.executionResult.success
          }
        });
      }

      if (!turn.executionResult.success) {
        this.record({
          type: 'error_occurred',
          data: {
            error: turn.executionResult.error
          }
        });
      }
    }

    const duration = Date.now() - startTime;
    this.record({
      type: 'macro_finished',
      data: {
        duration
      }
    });
  }

  generateTimeline(): ExecutionTimeline {
    const summary = this.generateSummary();

    return {
      executionId: this.executionId,
      startTime: this.startTime,
      endTime: this.events.length > 0 ? this.events[this.events.length - 1].timestamp : undefined,
      events: this.events,
      summary
    };
  }

  generateEffectsSummary(turns: ExecutionTurn[]): EffectsSummary {
    const effects: EffectsSummary = {
      filesRead: [],
      filesWritten: [],
      filesModified: [],
      commandsExecuted: [],
      networkRequests: [],
      secretsAccessed: []
    };

    for (const turn of turns) {
      if (turn.proposedAction?.type === 'tool_call') {
        const toolName = turn.proposedAction.payload?.tool_name;
        const params = turn.proposedAction.payload?.parameters;

        switch (toolName) {
          case 'read_file':
            if (params?.path && turn.executionResult?.success) {
              effects.filesRead.push(params.path);
            }
            break;

          case 'write_file':
            if (params?.path && turn.executionResult?.success) {
              effects.filesWritten.push(params.path);
            }
            break;

          case 'list_files':
            if (params?.path && turn.executionResult?.success) {
              effects.filesModified.push(params.path);
            }
            break;
        }
      }

      if (turn.proposedAction?.type === 'shell_cmd' && turn.executionResult) {
        effects.commandsExecuted.push({
          command: turn.proposedAction.payload?.command,
          success: turn.executionResult.success
        });
      }
    }

    return effects;
  }

  toJSON(): string {
    return JSON.stringify(this.generateTimeline(), null, 2);
  }

  toMarkdown(): string {
    const timeline = this.generateTimeline();
    let markdown = `# Execution Timeline\n\n`;
    markdown += `**Execution ID:** ${timeline.executionId}\n`;
    markdown += `**Start Time:** ${new Date(timeline.startTime).toISOString()}\n`;
    if (timeline.endTime) {
      markdown += `**End Time:** ${new Date(timeline.endTime).toISOString()}\n`;
      markdown += `**Duration:** ${((timeline.endTime - timeline.startTime) / 1000).toFixed(2)}s\n`;
    }
    markdown += `\n`;

    markdown += `## Summary\n\n`;
    markdown += `- Total Turns: ${timeline.summary.totalTurns}\n`;
    markdown += `- Successful: ${timeline.summary.successfulTurns}\n`;
    markdown += `- Failed: ${timeline.summary.failedTurns}\n`;
    markdown += `- Human Approvals: ${timeline.summary.humanApprovals}\n`;
    markdown += `- Human Rejections: ${timeline.summary.humanRejections}\n`;
    markdown += `\n`;

    markdown += `## Events\n\n`;
    for (const event of timeline.events) {
      markdown += `### ${event.type}\n`;
      markdown += `- **Time:** ${new Date(event.timestamp).toISOString()}\n`;
      if (event.data.capability) {
        markdown += `- **Capability:** ${event.data.capability}\n`;
      }
      if (event.data.toolName) {
        markdown += `- **Tool:** ${event.data.toolName}\n`;
      }
      if (event.data.reason) {
        markdown += `- **Reason:** ${event.data.reason}\n`;
      }
      if (event.data.error) {
        markdown += `- **Error:** ${event.data.error}\n`;
      }
      markdown += `\n`;
    }

    return markdown;
  }

  private generateSummary(): ExecutionSummary {
    const capabilitiesRequested = new Set<string>();
    const capabilitiesGranted = new Set<string>();
    const capabilitiesDenied = new Set<string>();
    const toolsUsed = new Map<string, number>();
    const errors: Array<{ turn: number; message: string }> = [];
    let humanApprovals = 0;
    let humanRejections = 0;
    let successfulTurns = 0;
    let failedTurns = 0;

    for (const event of this.events) {
      switch (event.type) {
        case 'capability_requested':
          if (event.data.capability) {
            capabilitiesRequested.add(event.data.capability);
          }
          break;

        case 'capability_granted':
          if (event.data.capability) {
            capabilitiesGranted.add(event.data.capability);
          }
          break;

        case 'capability_denied':
          if (event.data.capability) {
            capabilitiesDenied.add(event.data.capability);
          }
          break;

        case 'tool_executed':
          if (event.data.toolName) {
            const count = toolsUsed.get(event.data.toolName) || 0;
            toolsUsed.set(event.data.toolName, count + 1);
          }
          break;

        case 'human_approved':
          humanApprovals++;
          successfulTurns++;
          break;

        case 'human_rejected':
          humanRejections++;
          failedTurns++;
          break;

        case 'error_occurred':
          if (event.data.error) {
            errors.push({
              turn: event.data.turnId || 0,
              message: event.data.error
            });
            failedTurns++;
          }
          break;
      }
    }

    const endTime = this.events.length > 0 ? this.events[this.events.length - 1].timestamp : Date.now();

    return {
      totalDuration: endTime - this.startTime,
      totalTurns: successfulTurns + failedTurns,
      successfulTurns,
      failedTurns,
      capabilitiesRequested,
      capabilitiesGranted,
      capabilitiesDenied,
      toolsUsed,
      errors,
      humanApprovals,
      humanRejections
    };
  }

  private generateEventId(): string {
    return `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}

````

## üìÑ `cli.ts`

````typescript
#!/usr/bin/env node
import chalk from 'chalk';
import path from 'path';
import fs from 'fs';
import os from 'os';
import { Command } from 'commander';
import { handleAICommand } from './commands/handleAICommand';
import { handleAIChat } from './commands/handleAIChat';
import { handleConfig } from './commands/handleConfig';
import { registerCapabilityCommands } from './commands/capabilityCommands';
import { getAllCommands, getCommandSubcommands, getCommandDescription, installBashCompletion, installZshCompletion, complete, setProgramInstance } from './core/completion';
import { loadAppsConfig, openUrl, DEFAULT_APPS } from './core/apps';
import { getMacros, saveMacro, runMacro } from './core/macros';
import { getCommandHistory } from './utils/history';
import { handleSpecialSyntax } from './utils/syntaxHandler';
import { registerRegistryCommands } from './commands/registryCommands';
import { registerExplainCommands } from './commands/explainCommands';
import { registerReplayCommands } from './commands/replayCommands';
import { registerSkillsCommands } from './commands/skillsCommands';
// import { createDiffEditCommand } from './governance/commands/diffEdit';

// Mandatory Node.js version check
const majorVersion = Number(process.versions.node.split('.')[0]);
if (majorVersion < 18) {
    console.error(chalk.red(`Error: yuangs requires Node.js >= 18. Current version: ${process.version}`));
    process.exit(1);
}

const packageJson = JSON.parse(fs.readFileSync(path.join(__dirname, '../package.json'), 'utf8'));
const version = packageJson.version;

const program = new Command();

program
    .name('yuangs')
    .description('ËãëÂπøÂ±±ÁöÑ‰∏™‰∫∫ÂëΩ‰ª§Ë°åÂ∑•ÂÖ∑')
    .version(version, '-V, --version');

setProgramInstance(program);

async function readStdin(): Promise<string> {
    if (process.stdin.isTTY) return '';
    return new Promise((resolve) => {
        let data = '';
        process.stdin.setEncoding('utf8');
        process.stdin.on('data', chunk => data += chunk);
        process.stdin.on('end', () => resolve(data));
        // Simple timeout to avoid hanging if no input
        setTimeout(() => resolve(data), 2000);
    });
}

function parseOptionsFromArgs(args: string[]): {
    exec: boolean;
    model?: string;
    withContent: boolean;
} {
    return {
        exec: args.includes('-e') || args.includes('--exec'),
        model: getArgValue(args, ['-m', '--model']) || getModelFromShortcuts(args),
        withContent: args.includes('-w') || args.includes('--with-content')
    };
}

function getModelFromShortcuts(args: string[]): string | undefined {
    if (args.includes('-p')) return 'Assistant';
    if (args.includes('-f')) return 'Assistant';
    if (args.includes('-l')) return 'Assistant';
    return undefined;
}

function getArgValue(args: string[], flags: string[]): string | undefined {
    for (let i = 0; i < args.length; i++) {
        for (const flag of flags) {
            if (args[i] === flag && i + 1 < args.length && !args[i + 1].startsWith('-')) {
                return args[i + 1];
            }
        }
    }
    return undefined;
}

program
    .command('ai [question...]')
    .description('Âêë AI ÊèêÈóÆ')
    .option('-e, --exec', 'ÁîüÊàêÂπ∂ÊâßË°å Linux ÂëΩ‰ª§')
    .option('-m, --model <model>', 'ÊåáÂÆö AI Ê®°Âûã')
    .option('-p', '‰ΩøÁî® Pro Ê®°Âûã')
    .option('-f', '‰ΩøÁî® Flash Ê®°Âûã')
    .option('-l', '‰ΩøÁî® Lite Ê®°Âûã')
    .option('-w, --with-content', 'Âú®ÁÆ°ÈÅìÊ®°Âºè‰∏ãËØªÂèñÊñá‰ª∂ÂÜÖÂÆπ')
    .option('--verbose', 'ËØ¶ÁªÜËæìÂá∫ÔºàÊòæÁ§∫ Capability ÂåπÈÖçËØ¶ÊÉÖÔºâ')
    .action(async (questionArgs, options) => {
        const stdinData = await readStdin();
        let question = Array.isArray(questionArgs) ? questionArgs.join(' ').trim() : questionArgs || '';

        if (stdinData) {
            if (options.withContent) {
                const { parseFilePathsFromLsOutput, readFilesContent, buildPromptWithFileContent } = await import('./core/fileReader');
                const filePaths = parseFilePathsFromLsOutput(stdinData);
                const contentMap = readFilesContent(filePaths);
                question = buildPromptWithFileContent(stdinData, filePaths, contentMap, question || undefined);
            } else {
                question = `‰ª•‰∏ãÊòØËæìÂÖ•ÂÜÖÂÆπÔºö\n\n${stdinData}\n\nÊàëÁöÑÈóÆÈ¢òÊòØÔºö${question || 'ÂàÜÊûê‰ª•‰∏äÂÜÖÂÆπ'}`;
            }
        }

        let model = options.model;
        if (options.p) model = 'Assistant';
        if (options.f) model = 'Assistant';
        if (options.l) model = 'Assistant';

        const { AgentRuntime } = await import('./agent');
        const runtime = new AgentRuntime({
            input: question,
            mode: options.exec ? 'command' : 'chat',
            model: model || 'Assistant'
        });

        await runtime.run(question || '', options.exec ? 'command' : 'chat');
    });

program
    .command('list')
    .description('ÂàóÂá∫ÊâÄÊúâÂ∫îÁî®')
    .action(() => {
        const apps = loadAppsConfig();
        console.log(chalk.bold.cyan('\nüì± Â∫îÁî®ÂàóË°®\n'));
        Object.entries(apps).forEach(([key, url]) => {
            console.log(`  ${chalk.green('‚óè')} ${chalk.bold(key.padEnd(10))} ${chalk.blue(url)}`);
        });
    });

program
    .command('history')
    .description('Êü•ÁúãÂèäÊâßË°åÂëΩ‰ª§ÂéÜÂè≤')
    .option('-l, --last', 'ÊâßË°å‰∏ä‰∏ÄÊù°ÂëΩ‰ª§')
    .action(async (options) => {
        const history = getCommandHistory();
        if (history.length === 0) {
            console.log(chalk.gray('ÊöÇÊó†ÂëΩ‰ª§ÂéÜÂè≤\n'));
            return;
        }

        if (options.last) {
            const lastItem = history[0]; // history is unshift-ed, so 0 is latest
            console.log(chalk.bold.cyan('\nüìã ‰∏ä‰∏ÄÊ¨°ÊâßË°åÁöÑÂëΩ‰ª§:\n'));
            console.log(chalk.white(`${lastItem.command}`));
            console.log(chalk.gray(`ÈóÆÈ¢ò: ${lastItem.question}\n`));

            const rlLast = require('node:readline/promises').createInterface({
                input: process.stdin,
                output: process.stdout
            });
            const confirmLast = await rlLast.question(chalk.cyan('Á°ÆËÆ§ÂÜçÊ¨°ÊâßË°å? (y/N): '));
            rlLast.close();

            if (confirmLast.toLowerCase() === 'y' || confirmLast.toLowerCase() === 'yes') {
                const { exec } = require('child_process');
                console.log(chalk.bold.cyan('ÊâßË°å‰∏≠...\n'));
                exec(lastItem.command, (error: any, stdout: string, stderr: string) => {
                    if (stdout) console.log(stdout);
                    if (stderr) console.error(chalk.red(stderr));
                    if (error) console.error(chalk.red(error.message));
                    process.exit(0);
                });
                return;
            } else {
                console.log(chalk.gray('Â∑≤ÂèñÊ∂àÊâßË°å'));
            }
            return;
        }

        console.log(chalk.bold.cyan('\nüìã ÂëΩ‰ª§ÂéÜÂè≤\n'));
        history.forEach((item, index) => {
            console.log(`${index + 1}. ${chalk.white(item.command)}`);
            console.log(chalk.gray(`   ÈóÆÈ¢ò: ${item.question}\n`));
        });

        const rlHistory = require('node:readline/promises').createInterface({
            input: process.stdin,
            output: process.stdout
        });
        const indexInput = await rlHistory.question(chalk.cyan('ËæìÂÖ•Â∫èÂè∑ÈÄâÊã©ÂëΩ‰ª§ (Áõ¥Êé•ÂõûËΩ¶ÂèñÊ∂à): '));
        rlHistory.close();

        if (indexInput.trim()) {
            const index = parseInt(indexInput) - 1;
            if (index >= 0 && index < history.length) {
                const targetCommand = history[index].command;
                console.log(chalk.yellow(`\nÂç≥Â∞ÜÊâßË°å: ${targetCommand}\n`));
                const rlConfirm = require('node:readline/promises').createInterface({
                    input: process.stdin,
                    output: process.stdout
                });
                const confirm = await rlConfirm.question(chalk.cyan('Á°ÆËÆ§ÊâßË°å? (y/N): '));
                rlConfirm.close();

                if (confirm.toLowerCase() === 'y' || confirm.toLowerCase() === 'yes') {
                    const { exec } = require('child_process');
                    console.log(chalk.bold.cyan('ÊâßË°å‰∏≠...\n'));
                    exec(targetCommand, (error: any, stdout: string, stderr: string) => {
                        if (stdout) console.log(stdout);
                        if (stderr) console.error(chalk.red(stderr));
                        if (error) console.error(chalk.red(error.message));
                        process.exit(0);
                    });
                    return;
                } else {
                    console.log(chalk.gray('Â∑≤ÂèñÊ∂àÊâßË°å'));
                }
            } else {
                console.log(chalk.red('Êó†ÊïàÁöÑÂ∫èÂè∑'));
            }
        }
    });

program
    .command('config')
    .description('ÁÆ°ÁêÜÊú¨Âú∞ÈÖçÁΩÆ (~/.yuangs.json)')
    .argument('[action]', 'get, set, list')
    .argument('[key]', 'ÈÖçÁΩÆÈ°πÂêçÁß∞')
    .argument('[value]', 'ÈÖçÁΩÆÈ°πÂÄº')
    .action(handleConfig);

program
    .command('macros')
    .description('Êü•ÁúãÊâÄÊúâÂø´Êç∑Êåá‰ª§')
    .action(() => {
        const allMacros = getMacros();
        console.log(chalk.bold.cyan('\nüöÄ Âø´Êç∑Êåá‰ª§ÂàóË°®\n'));
        Object.keys(allMacros).forEach(name => {
            console.log(`  ${chalk.white(name)}: ${chalk.gray(allMacros[name].commands)}`);
        });
    });

program
    .command('save <name>')
    .description('‰øùÂ≠òÂø´Êç∑Êåá‰ª§')
    .option('-l, --from-last', 'save last executed AI command')
    .option('-g, --global', 'add alias to ~/.zshrc')
    .action(async (name, options) => {
        const addToZshrc = (aliasName: string) => {
            const zshrcPath = path.join(os.homedir(), '.zshrc');
            if (fs.existsSync(zshrcPath)) {
                const aliasLine = `alias ${aliasName}="yuangs run ${aliasName}"`;
                try {
                    const content = fs.readFileSync(zshrcPath, 'utf8');
                    if (!content.includes(aliasLine)) {
                        fs.appendFileSync(zshrcPath, `\n${aliasLine}\n`);
                        console.log(chalk.green(`‚úì Â∑≤Ê∑ªÂä† alias Âà∞ ~/.zshrc`));
                        console.log(chalk.yellow(`‚ÑπÔ∏è  ËØ∑ËøêË°å "source ~/.zshrc" ‰ª•ÁîüÊïà`));
                    } else {
                        console.log(chalk.yellow(`‚ÑπÔ∏è  Alias "${aliasName}" Â∑≤Â≠òÂú®‰∫é ~/.zshrc`));
                    }
                } catch (err) {
                    console.error(chalk.red(`‚ùå Êó†Ê≥ïÂÜôÂÖ• ~/.zshrc: ${(err as Error).message}`));
                }
            } else {
                console.log(chalk.red(`‚ùå Êú™ÊâæÂà∞ ~/.zshrc`));
            }
        };

        if (options.fromLast) {
            const history = getCommandHistory();
            if (history.length === 0) {
                console.log(chalk.red('‚ùå ÊöÇÊó† AI ÂëΩ‰ª§ÂéÜÂè≤'));
                return;
            }
            const lastItem = history[0];

            saveMacro(name, lastItem.command, `Saved from: ${lastItem.question}`);
            console.log(chalk.green(`‚úì Â∑≤Â∞ÜÊúÄËøë‰∏ÄÊù° AI ÂëΩ‰ª§‰øùÂ≠ò‰∏∫ "${name}"`));
            console.log(chalk.gray(`  Command: ${lastItem.command}`));

            if (options.global) {
                addToZshrc(name);
            }
            return;
        }

        const rl = require('node:readline/promises').createInterface({
            input: process.stdin,
            output: process.stdout
        });
        const cmd = await rl.question(chalk.cyan('ËØ∑ËæìÂÖ•Ë¶Å‰øùÂ≠òÁöÑÂëΩ‰ª§: '));
        saveMacro(name, cmd);
        console.log(chalk.green(`‚úì Âø´Êç∑Êåá‰ª§ "${name}" Â∑≤‰øùÂ≠ò`));
        rl.close();

        if (options.global) {
            addToZshrc(name);
        }
    });

program
    .command('run <name>')
    .description('ÊâßË°åÂø´Êç∑Êåá‰ª§')
    .action((name) => {
        if (runMacro(name)) {
            console.log(chalk.green(`‚úì Ê≠£Âú®ÊâßË°å "${name}"...`));
        } else {
            console.log(chalk.red(`ÈîôËØØ: Âø´Êç∑Êåá‰ª§ "${name}" ‰∏çÂ≠òÂú®`));
        }
    });

program
    .command('completion [shell]')
    .description('ÁîüÊàêÂπ∂ÂÆâË£Ö Shell Ë°•ÂÖ®ËÑöÊú¨')
    .action(async (shell) => {
        const shellType = shell || process.env.SHELL?.split('/').pop() || 'bash';

        if (!['bash', 'zsh'].includes(shellType)) {
            console.log(chalk.red('ÈîôËØØ: ‰∏çÊîØÊåÅÁöÑ shell Á±ªÂûã'));
            console.log(chalk.gray('ÊîØÊåÅÁöÑÁ±ªÂûã: bash, zsh'));
            process.exit(1);
        }

        console.log(chalk.cyan(`\nÊ≠£Âú®‰∏∫ ${shellType} ÂÆâË£Ö yuangs Ë°•ÂÖ®...\n`));

        let success = false;
        if (shellType === 'bash') {
            success = await installBashCompletion(program);
        } else if (shellType === 'zsh') {
            success = await installZshCompletion(program);
        }

        if (success) {
            console.log(chalk.green('‚úì Ë°•ÂÖ®ÂÆâË£ÖÊàêÂäüÔºÅ\n'));
            console.log(chalk.yellow('ËØ∑ÈáçÊñ∞Âä†ËΩΩ shell ÈÖçÁΩÆ:'));
            console.log(chalk.gray(`  ${shellType === 'bash' ? 'source ~/.bashrc' : 'source ~/.zshrc'}\n`));
        } else {
            console.log(chalk.red('‚úó Ë°•ÂÖ®ÂÆâË£ÖÂ§±Ë¥•\n'));
            process.exit(1);
        }
    });

program
    .command('_complete')
    .description('(internal) unified completion entry')
    .option('--words <json>', 'JSON encoded argv')
    .option('--current <index>', 'Current word index')
    .action(async (options) => {
        try {
            const words = JSON.parse(options.words);
            const currentIndex = Number(options.current);

            const res = await complete({ words, currentIndex });

            console.log(res.items.map(i => i.label).join(' '));
        } catch {
            console.log('');
            process.exit(0);
        }
    });

registerCapabilityCommands(program);
registerRegistryCommands(program);
registerExplainCommands(program);
registerReplayCommands(program);
registerSkillsCommands(program);

// Add governance diff-edit command
// const diffEditCmd = createDiffEditCommand();
// program.addCommand(diffEditCmd);

program
    .command('help')
    .description('ÊòæÁ§∫Â∏ÆÂä©‰ø°ÊÅØ')
    .action(() => {
        console.log(chalk.bold.cyan('\nüé® ËãëÂπøÂ±±ÁöÑ‰∏™‰∫∫Â∫îÁî®ÂêØÂä®Âô® (Modular TSÁâà)\n'));
        console.log(chalk.yellow(`ÂΩìÂâçÁâàÊú¨: ${version}`));
        console.log(chalk.white('‰ΩøÁî®ÊñπÊ≥ï:') + chalk.gray(' yuangs <ÂëΩ‰ª§> [ÂèÇÊï∞]\n'));
        console.log(chalk.bold('ÂëΩ‰ª§ÂàóË°®:'));
        console.log(`  ${chalk.green('ai')} "<ÈóÆÈ¢ò>"      Âêë AI ÊèêÈóÆ`);
        console.log(`    ${chalk.gray('-e')}              ÁîüÊàêÂπ∂ÊâßË°å Linux ÂëΩ‰ª§ (OS ÊÑüÁü•)`);
        console.log(`  ${chalk.green('list')}              ÂàóÂá∫ÊâÄÊúâÂ∫îÁî®`);
        console.log(`  ${chalk.green('history')}           Êü•ÁúãÂëΩ‰ª§ÂéÜÂè≤`);
        console.log(`  ${chalk.green('config')}            ÁÆ°ÁêÜÊú¨Âú∞ÈÖçÁΩÆ (~/.yuangs.json)`);
        console.log(`  ${chalk.green('macros')}            Êü•ÁúãÊâÄÊúâÂø´Êç∑Êåá‰ª§`);
        console.log(`  ${chalk.green('save')} <ÂêçÁß∞>      ‰øùÂ≠òÂø´Êç∑Êåá‰ª§`);
        console.log(`  ${chalk.green('run')} <ÂêçÁß∞>        ÊâßË°åÂø´Êç∑Êåá‰ª§`);
        console.log(`  ${chalk.green('registry')}          Macro Registry ÁÆ°ÁêÜ`);
        console.log(`  ${chalk.green('diff-edit')}         ‰ª£Á†ÅÂèòÊõ¥Ê≤ªÁêÜ (propose/approve/exec/list/status)`);
        console.log(`  ${chalk.green('help')}              ÊòæÁ§∫Â∏ÆÂä©‰ø°ÊÅØ\n`);
    });

const apps = loadAppsConfig();

program
    .command('shici')
    .description('ÊâìÂºÄÂè§ËØóËØç PWA')
    .action(() => {
        const url = apps['shici'] || DEFAULT_APPS['shici'];
        console.log(chalk.green(`‚úì Ê≠£Âú®ÊâìÂºÄ shici...`));
        openUrl(url);
    });

program
    .command('dict')
    .description('ÊâìÂºÄËã±ËØ≠ËØçÂÖ∏')
    .action(() => {
        const url = apps['dict'] || DEFAULT_APPS['dict'];
        console.log(chalk.green(`‚úì Ê≠£Âú®ÊâìÂºÄ dict...`));
        openUrl(url);
    });

program
    .command('pong')
    .description('ÊâìÂºÄ Pong Ê∏∏Êàè')
    .action(() => {
        const url = apps['pong'] || DEFAULT_APPS['pong'];
        console.log(chalk.green(`‚úì Ê≠£Âú®ÊâìÂºÄ pong...`));
        openUrl(url);
    });

program
    .argument('[command]', 'Ëá™ÂÆö‰πâÂ∫îÁî®ÂëΩ‰ª§')
    .action((command) => {
        if (command && apps[command]) {
            openUrl(apps[command]);
        } else {
            program.outputHelp();
        }
    });

async function main() {
    const args = process.argv.slice(2);

    const knownCommands = ['ai', 'list', 'history', 'config', 'macros', 'save', 'run', 'help', 'shici', 'dict', 'pong', 'capabilities', 'completion', '_complete_subcommand', '_describe', 'registry', 'explain', 'replay', 'skills', 'diff-edit'];
    const globalFlags = ['-h', '--help', '-V', '--version', '-v'];
    const firstArg = args[0];
    const isKnownCommand = firstArg && knownCommands.includes(firstArg);
    const isGlobalFlag = firstArg && globalFlags.includes(firstArg);

    if (args.length === 0 && !await readStdin()) {
        console.log(chalk.bold.cyan('\nüé® ËãëÂπøÂ±±ÁöÑ‰∏™‰∫∫Â∫îÁî®ÂêØÂä®Âô® (Modular TSÁâà)\n'));
        console.log(chalk.yellow(`ÂΩìÂâçÁâàÊú¨: ${version}`));
        program.outputHelp();
        process.exit(0);
    }

    if (!isKnownCommand && !isGlobalFlag) {
        const stdinData = await readStdin();

        if (stdinData || args.length > 0) {
            const options = parseOptionsFromArgs(args);
            let question = args.filter(arg => !arg.startsWith('-')).join(' ');

            if (stdinData) {
                // Ê£ÄÊü• stdin Êï∞ÊçÆÊòØÂê¶ÊòØÁâπÊÆäËØ≠Ê≥ï
                const stdinTrimmed = stdinData.trim();
                const isStdinSpecialSyntax = stdinTrimmed.startsWith('@') ||
                    stdinTrimmed.startsWith('#') ||
                    stdinTrimmed === ':ls' ||
                    stdinTrimmed === ':clear' ||
                    stdinTrimmed === ':cat' ||
                    stdinTrimmed.startsWith(':cat ');

                if (isStdinSpecialSyntax) {
                    const result = await handleSpecialSyntax(stdinData, '');

                    if (result.processed) {
                        // Â¶ÇÊûúÁâπÊÆäËØ≠Ê≥ïË¢´Â§ÑÁêÜÔºå‰ΩøÁî®Â§ÑÁêÜÁªìÊûú‰Ωú‰∏∫ÈóÆÈ¢ò
                        if (result.result) {
                            question = result.result;
                        } else {
                            // Â¶ÇÊûúÊ≤°ÊúâÁªìÊûúÔºåÂèØËÉΩÂè™ÊòØÊâßË°å‰∫ÜÂëΩ‰ª§ÔºåÁõ¥Êé•ÈÄÄÂá∫
                            process.exit(0);
                        }
                    } else {
                        // Â¶ÇÊûúÊ≤°ÊúâË¢´Â§ÑÁêÜÔºåÁªßÁª≠‰ΩøÁî®ÂéüÂßãÈóÆÈ¢ò
                        console.log('Ë≠¶Âëä: Êú™ËÉΩÂ§ÑÁêÜÁâπÊÆäËØ≠Ê≥ïÔºå‰ΩøÁî®ÂéüÂßãËæìÂÖ•');
                        if (options.withContent) {
                            const { parseFilePathsFromLsOutput, readFilesContent, buildPromptWithFileContent } = await import('./core/fileReader');
                            const filePaths = parseFilePathsFromLsOutput(stdinData);
                            const contentMap = readFilesContent(filePaths);
                            question = buildPromptWithFileContent(stdinData, filePaths, contentMap, question || undefined);
                        } else {
                            question = `‰ª•‰∏ãÊòØËæìÂÖ•ÂÜÖÂÆπÔºö\n\n${stdinData}\n\nÊàëÁöÑÈóÆÈ¢òÊòØÔºö${question || 'ÂàÜÊûê‰ª•‰∏äÂÜÖÂÆπ'}`;
                        }
                    }
                } else {
                    if (options.withContent) {
                        const { parseFilePathsFromLsOutput, readFilesContent, buildPromptWithFileContent } = await import('./core/fileReader');
                        const filePaths = parseFilePathsFromLsOutput(stdinData);
                        const contentMap = readFilesContent(filePaths);
                        question = buildPromptWithFileContent(stdinData, filePaths, contentMap, question || undefined);
                    } else {
                        question = `‰ª•‰∏ãÊòØËæìÂÖ•ÂÜÖÂÆπÔºö\n\n${stdinData}\n\nÊàëÁöÑÈóÆÈ¢òÊòØÔºö${question || 'ÂàÜÊûê‰ª•‰∏äÂÜÖÂÆπ'}`;
                    }
                }
            }

            // Â¶ÇÊûú question Êú¨Ë∫´ÂåÖÂê´ÁâπÊÆäËØ≠Ê≥ïÔºàÊ≤°Êúâ stdin Êàñ stdin ‰∏çÊòØÁâπÊÆäËØ≠Ê≥ïÔºâ
            const isSpecialSyntaxPrefix = (q: string) => {
                const t = q.trim();
                return t.startsWith('@') || t.startsWith('#') || t === ':ls' || t === ':clear' || t === ':cat' || t.startsWith(':cat ');
            };

            if (!stdinData || !isSpecialSyntaxPrefix(stdinData)) {
                const questionTrimmed = (question || '').trim();
                const isQuestionSpecialSyntax = isSpecialSyntaxPrefix(questionTrimmed);

                if (isQuestionSpecialSyntax) {
                    const result = await handleSpecialSyntax(question, stdinData);

                    if (result.processed) {
                        // Â¶ÇÊûúÁâπÊÆäËØ≠Ê≥ïË¢´Â§ÑÁêÜ
                        if (result.result) {
                            // Ê£ÄÊü•ÊòØÂê¶ÊòØÁÆ°ÁêÜÂëΩ‰ª§ÔºàÂ¶Ç :ls, :clear, :catÔºâÔºåËøô‰∫õÂëΩ‰ª§ÁöÑÁªìÊûúÂ∫îËØ•Áõ¥Êé•ËæìÂá∫
                            const trimmedQuestion = question.trim();
                            const isManagementCommand = trimmedQuestion === ':ls' ||
                                trimmedQuestion === ':clear' ||
                                trimmedQuestion === ':cat' ||
                                trimmedQuestion.startsWith(':cat ');

                            if (isManagementCommand) {
                                // Áõ¥Êé•ËæìÂá∫ÁªìÊûúÂπ∂ÈÄÄÂá∫
                                console.log(result.result);
                                process.exit(0);
                            } else {
                                // ÂØπ‰∫éÊñá‰ª∂/ÁõÆÂΩïÂºïÁî®ÔºåÂ∞ÜÁªìÊûú‰Ωú‰∏∫ÈóÆÈ¢ò‰º†ÈÄíÁªôAI
                                question = result.result;
                            }
                        } else {
                            // Â¶ÇÊûúÊ≤°ÊúâÁªìÊûúÔºåÂèØËÉΩÂè™ÊòØÊâßË°å‰∫ÜÂëΩ‰ª§ÔºåÁõ¥Êé•ÈÄÄÂá∫
                            process.exit(0);
                        }
                    } else {
                        // Â¶ÇÊûúÊ≤°ÊúâË¢´Â§ÑÁêÜÔºåÁªßÁª≠‰ΩøÁî®ÂéüÂßãÈóÆÈ¢ò
                        console.log('Ë≠¶Âëä: Êú™ËÉΩÂ§ÑÁêÜÁâπÊÆäËØ≠Ê≥ïÔºå‰ΩøÁî®ÂéüÂßãËæìÂÖ•');
                    }
                }
            }

            let model = options.model;
            if (options.exec) {
                await handleAICommand(question, { execute: false, model, verbose: options.withContent });
            } else {
                await handleAIChat(question || null, model);
            }
            process.exit(0);
        }
    }

    program.parse();
}

main().catch(err => {
    console.error('Fatal error:', err);
    process.exit(1);
});

````

## üìÑ `commands/capabilityCommands.ts`

````typescript
import chalk from 'chalk';
import { Command } from 'commander';
import { AtomicCapability, COMPOSITE_CAPABILITIES } from '../core/capabilities';
import { CapabilitySystem } from '../core/capabilitySystem';
import { CapabilityRequirement } from '../core/modelMatcher';
import { listExecutionRecords } from '../core/executionStore';
import { ReplayMode } from '../core/replayEngine';

export function registerCapabilityCommands(program: Command): void {
  const capProgram = program.command('capabilities').description('Capability system commands (new architecture)');

  capProgram
    .command('explain')
    .description('Explain current configuration with sources')
    .action(() => {
      const system = new CapabilitySystem();
      console.log(chalk.bold.cyan('\nüìã Configuration Snapshot\n'));
      console.log(system.explainConfig());
    });

  capProgram
    .command('match')
    .description('Test capability matching')
    .argument('<capabilities...>', 'Required capabilities (e.g., text_generation reasoning)')
    .action((capabilities) => {
      const system = new CapabilitySystem();

      const { AtomicCapability } = require('../core/capabilities');

      const requirement: CapabilityRequirement = {
        required: capabilities as any,
        preferred: [],
      };

      const result = system.matchCapability(requirement);

      console.log(chalk.bold.cyan('\nü§ñ Capability Match Result\n'));

      if (!result.selected) {
        console.log(chalk.red('‚ùå No model satisfies requirements\n'));
        result.candidates.forEach(c => {
          console.log(chalk.yellow(`${c.modelName} (${c.provider}):`));
          console.log(chalk.gray(`  ${c.reason}\n`));
        });
        return;
      }

      console.log(chalk.green(`‚úÖ Selected: ${result.selected.name} (${result.selected.provider})\n`));

      console.log(chalk.bold('Capability coverage:'));
      result.selected.atomicCapabilities.forEach(cap => {
        console.log(chalk.green(`  ‚úì ${cap}`));
      });

      if (result.fallbackOccurred) {
        console.log(chalk.yellow('\n‚ö†Ô∏è  Fallback was used'));
      }

      console.log(chalk.bold('\nAll candidates:'));
      result.candidates.forEach(c => {
        const icon = c.hasRequired ? chalk.green('‚úì') : chalk.red('‚úó');
        console.log(`  ${icon} ${c.modelName} (${c.provider})`);
        console.log(chalk.gray(`    ${c.reason}\n`));
      });
    });

  capProgram
    .command('list')
    .description('List all available capabilities')
    .action(() => {
      console.log(chalk.bold.cyan('\nüì¶ Available Capabilities\n'));

      console.log(chalk.bold('Atomic Capabilities:'));
      Object.values(AtomicCapability).forEach(cap => {
        console.log(`  - ${chalk.green(cap)}`);
      });

      console.log(chalk.bold('\nComposite Capabilities:'));
      COMPOSITE_CAPABILITIES.forEach(comp => {
        console.log(`  - ${chalk.cyan(comp.name)}`);
        console.log(chalk.gray(`    Composed of: ${comp.composedOf.join(', ')}`));
      });
    });

  capProgram
    .command('history')
    .description('List execution history')
    .option('-l, --limit <n>', 'Limit number of records', '10')
    .action((options) => {
      const limit = parseInt(options.limit);
      const records = listExecutionRecords(limit);

      if (records.length === 0) {
        console.log(chalk.gray('üì≠ No execution history found\n'));
        return;
      }

      console.log(chalk.bold.cyan(`\nüìã Execution History (last ${records.length})\n`));

      records.forEach((record, idx) => {
        const status = record.outcome.success
          ? chalk.green('‚úì')
          : chalk.red('‚úó');
        const model = record.decision.selectedModel?.name || 'N/A';
        const time = new Date(record.meta.timestamp).toLocaleString();

        console.log(`${status} ${chalk.white(record.id)}`);
        console.log(chalk.gray(`  Command: ${record.meta.commandName}`));
        console.log(chalk.gray(`  Model: ${model}`));
        console.log(chalk.gray(`  Time: ${time}\n`));
      });
    });

  capProgram
    .command('replay <id>')
    .description('Replay an execution')
    .option('-s, --strict', 'Strict replay (use exact model)')
    .option('-c, --compatible', 'Compatible replay (allow fallback)')
    .option('-v, --verbose', 'Verbose output')
    .action(async (id, options) => {
      const system = new CapabilitySystem();

      let mode: ReplayMode = 'strict';
      if (options.compatible) mode = 'compatible';

      const result = await system.replayExecution(id, {
        mode,
        skipAI: true,
        verbose: options.verbose,
      });

      if (result.success) {
        console.log(chalk.green(`\n‚úÖ ${result.message}\n`));
        if (result.executedModel) {
          console.log(chalk.gray(`Model: ${result.executedModel}`));
        }
      } else {
        console.log(chalk.red(`\n‚ùå ${result.message}\n`));
      }
    });
}

````

## üìÑ `commands/chatHistoryStorage.ts`

````typescript
import fs from 'fs';
import { promisify } from 'util';
import path from 'path';
import os from 'os';
import { AIRequestMessage } from '../core/validation';

const CHAT_HISTORY_DIR = path.resolve(os.homedir(), '.yuangs_chat_history');
const CHAT_HISTORY_FILE = path.join(CHAT_HISTORY_DIR, 'chat_history.json');

const readFileAsync = promisify(fs.readFile);
const writeFileAsync = promisify(fs.writeFile);
const mkdirAsync = promisify(fs.mkdir);
const rmAsync = promisify(fs.rm);

export async function loadChatHistory(): Promise<AIRequestMessage[]> {
    if (fs.existsSync(CHAT_HISTORY_FILE)) {
        try {
            const raw = await readFileAsync(CHAT_HISTORY_FILE, 'utf-8');
            const data = JSON.parse(raw);

            // È™åËØÅÊï∞ÊçÆÁªìÊûÑ
            if (Array.isArray(data) && data.every(msg =>
                typeof msg === 'object' &&
                ['user', 'assistant', 'system'].includes(msg.role) &&
                typeof msg.content === 'string'
            )) {
                return data as AIRequestMessage[];
            }
        } catch (e) {
            console.warn('Ë≠¶Âëä: Âä†ËΩΩËÅäÂ§©ÂéÜÂè≤ËÆ∞ÂΩïÂ§±Ë¥•Ôºå‰ΩøÁî®Á©∫ÂéÜÂè≤ËÆ∞ÂΩï');
        }
    }
    return [];
}

export async function saveChatHistory(history: AIRequestMessage[]) {
    try {
        await mkdirAsync(CHAT_HISTORY_DIR, { recursive: true });
        await writeFileAsync(CHAT_HISTORY_FILE, JSON.stringify(history, null, 2));
    } catch (e) {
        console.error('ÈîôËØØ: ‰øùÂ≠òËÅäÂ§©ÂéÜÂè≤ËÆ∞ÂΩïÂ§±Ë¥•:', e);
    }
}

export async function clearChatHistory() {
    try {
        await rmAsync(CHAT_HISTORY_FILE, { force: true });
    } catch (e) {
        console.error('ÈîôËØØ: Ê∏ÖÈô§ËÅäÂ§©ÂéÜÂè≤ËÆ∞ÂΩïÂ§±Ë¥•:', e);
    }
}

````

## üìÑ `commands/contextBuffer.ts`

````typescript
export type ContextItem = {
    type: 'file' | 'directory';
    path: string;
    alias?: string;
    content: string;
    summary?: string;
    tokens: number;
};

const estimateTokens = (text: string) => Math.ceil(text.length / 4);

export class ContextBuffer {
    private items: ContextItem[] = [];
    private maxTokens = 32000; // Á∫¶ 12.8 ‰∏áÂ≠óÁ¨¶

    add(item: Omit<ContextItem, 'tokens'>, bypassTokenLimit: boolean = false) {
        const tokens = estimateTokens(item.content);
        this.items.push({ ...item, tokens });
        if (!bypassTokenLimit) {
            this.trimIfNeeded();
        }
    }

    clear() {
        this.items = [];
    }

    list() {
        return this.items.map((item, i) => ({
            index: i + 1,
            type: item.type,
            path: item.path,
            alias: item.alias,
            tokens: item.tokens,
            summary: item.summary
        }));
    }

    isEmpty() {
        return this.items.length === 0;
    }

    export() {
        return this.items;
    }

    import(items: ContextItem[]) {
        this.items = items;
    }

    private totalTokens() {
        return this.items.reduce((sum, i) => sum + i.tokens, 0);
    }

    private trimIfNeeded() {
        while (this.totalTokens() > this.maxTokens) {
            this.items.shift();
        }
    }

    buildPrompt(userInput: string): string {
        if (this.isEmpty()) return userInput;

        const contextBlock = this.items.map(item => {
            const title = item.alias
                ? `[Context Item] ${item.type}: ${item.alias} (${item.path})`
                : `[Context Item] ${item.type}: ${item.path}`;

            const body = item.summary ?? item.content;

            return `${title}\n---\n${body}\n---`;
        }).join('\n\n');

        return `
# Áü•ËØÜ‰∏ä‰∏ãÊñá (Knowledge Context)
‰Ω†ÁõÆÂâçÁöÑ‰ºöËØùÂ∑≤Âä†ËΩΩ‰ª•‰∏ãÂèÇËÄÉËµÑÊñô„ÄÇÂú®ÂõûÁ≠îÁî®Êà∑ÈóÆÈ¢òÊó∂ÔºåËØ∑‰ºòÂÖàÂèÇËÄÉËøô‰∫õÂÜÖÂÆπÔºö

${contextBlock}

# ‰ªªÂä°ËØ¥Êòé
Âü∫‰∫é‰∏äËø∞Êèê‰æõÁöÑ‰∏ä‰∏ãÊñáÔºàÂ¶ÇÊûúÊúâÔºâÔºåÂõûÁ≠îÁî®Êà∑ÁöÑÈóÆÈ¢ò„ÄÇÂ¶ÇÊûú‰∏ä‰∏ãÊñá‰∏≠ÂåÖÂê´Ê∫êÁ†ÅÔºåËØ∑Â∞ÜÂÖ∂ËßÜ‰∏∫‰Ω†ÂΩìÂâçÁöÑ‚ÄúÁúüÁêÜÊù•Ê∫ê‚Äù„ÄÇ

Áî®Êà∑ÈóÆÈ¢òÔºö
${userInput}
`;
    }
}
// Test change for git diff
// Another test change (unstaged)

````

## üìÑ `commands/contextStorage.ts`

````typescript
import fs from 'fs/promises';
import path from 'path';
import { ContextItem } from './contextBuffer';

const CONTEXT_DIR = path.resolve(process.cwd(), '.ai');
const CONTEXT_FILE = path.join(CONTEXT_DIR, 'context.json');

export async function loadContext(): Promise<ContextItem[]> {
    try {
        const raw = await fs.readFile(CONTEXT_FILE, 'utf-8');
        return JSON.parse(raw);
    } catch {
        return [];
    }
}

export async function saveContext(items: ContextItem[]) {
    await fs.mkdir(CONTEXT_DIR, { recursive: true });
    await fs.writeFile(CONTEXT_FILE, JSON.stringify(items, null, 2));
}

export async function clearContextStorage() {
    await fs.rm(CONTEXT_FILE, { force: true });
}

````

## üìÑ `commands/explainCommands.ts`

````typescript
import chalk from 'chalk';
import { Command } from 'commander';
import { explainExecution } from '../core/explain';
import { loadExecutionRecord, listExecutionRecords } from '../core/executionStore';

export function registerExplainCommands(program: Command): void {
  program
    .command('explain [id]')
    .description('Explain an execution (use "last" for most recent)')
    .action((id) => {
      let record;

      if (!id || id === 'last') {
        const records = listExecutionRecords(1);
        if (records.length === 0) {
          console.log(chalk.red('‚ùå No execution records found\n'));
          return;
        }
        record = records[0];
        console.log(chalk.gray(`Showing most recent execution: ${record.id}\n`));
      } else {
        record = loadExecutionRecord(id);
        if (!record) {
          console.log(chalk.red(`‚ùå Execution record "${id}" not found\n`));
          return;
        }
      }

      const explanation = explainExecution(record);
      console.log(explanation);
    });
}

````

## üìÑ `commands/gitContext.ts`

````typescript
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

async function run(cmd: string): Promise<string | null> {
    try {
        const { stdout } = await execAsync(cmd, { maxBuffer: 1024 * 1024 });
        return stdout.trim() || null;
    } catch {
        return null;
    }
}

export async function getGitContext() {
    const staged = await run('git diff --staged');
    const unstaged = await run('git diff');

    if (!staged && !unstaged) return null;

    let result = `‰ª•‰∏ãÊòØ Git ÂèòÊõ¥ÂÜÖÂÆπÔºö\n`;

    if (staged) {
        result += `\n„ÄêÂ∑≤ÊöÇÂ≠ò„Äë\n\`\`\`diff\n${staged}\n\`\`\`\n`;
    }

    if (unstaged) {
        result += `\n„ÄêÊú™ÊöÇÂ≠ò„Äë\n\`\`\`diff\n${unstaged}\n\`\`\`\n`;
    }

    return result;
}

````

## üìÑ `commands/handleAIChat.ts`

````typescript
import chalk from 'chalk';
import ora from 'ora';
import readline from 'readline';
import { callAI_Stream, getConversationHistory, addToConversationHistory, clearConversationHistory } from '../ai/client';
import fs from 'fs';
import path from 'path';
import { buildPromptWithFileContent, readFilesContent } from '../core/fileReader';
import { exec } from 'child_process';
import { promisify } from 'util';
import { ContextBuffer } from './contextBuffer';
import { loadContext, saveContext, clearContextStorage } from './contextStorage';
import { getGitContext } from './gitContext';
import {
    Mode,
    detectMode,
    createCompleter,
    executeCommand as shellExecuteCommand,
    listPlugins
} from './shellCompletions';
import { StreamMarkdownRenderer } from '../utils/renderer';
const execAsync = promisify(exec);

function findCommonPrefix(strings: string[]): string {
    if (strings.length === 0) return '';
    if (strings.length === 1) return strings[0];

    let common = '';
    const first = strings[0];

    for (let i = 0; i < first.length; i++) {
        const char = first[i];
        if (strings.every(s => s[i] === char)) {
            common += char;
        } else {
            break;
        }
    }

    return common;
}

async function executeCommand(filePath: string, command?: string) {
    const fullPath = path.resolve(filePath);
    const commandStr = command || '';

    if (command) {
        const { stdout, stderr } = await exec(commandStr, { cwd: path.dirname(fullPath) });
        console.log(stdout);
        if (stderr) console.error(chalk.red(stderr));
    } else {
        const { stdout, stderr } = await exec(fullPath, { cwd: process.cwd() });
        console.log(stdout);
        if (stderr) console.error(chalk.red(stderr));
    }
}

async function readFileContent(filePath: string): Promise<string> {
    const fullPath = path.resolve(filePath);
    return await fs.promises.readFile(fullPath, 'utf-8');
}

async function showFileSelector(rl: readline.Interface): Promise<string | null> {
    return new Promise((resolve) => {
        try {
            const currentDir = process.cwd();
            const files = fs.readdirSync(currentDir);

            if (files.length === 0) {
                console.log(chalk.yellow('ÂΩìÂâçÁõÆÂΩï‰∏∫Á©∫\n'));
                resolve(null);
                return;
            }

            console.log(chalk.bold.cyan('üìÅ ÂΩìÂâçÁõÆÂΩïÊñá‰ª∂ÂàóË°®:\n'));

            files.forEach((file, index) => {
                const fullPath = path.join(currentDir, file);
                const isDir = fs.statSync(fullPath).isDirectory();
                const icon = isDir ? chalk.cyan('üìÅ') : chalk.green('üìÑ');
                const padding = (index + 1).toString().padStart(2);
                console.log(`  [${padding}] ${icon} ${file}`);
            });
            console.log();

            rl.question(chalk.cyan('ËØ∑ÈÄâÊã©Êñá‰ª∂ (ËæìÂÖ•Â∫èÂè∑ÔºåÊàñÊåâ Enter ËøîÂõû): '), (choice) => {
                if (choice.trim() === '') {
                    console.log(chalk.gray('Â∑≤ÂèñÊ∂àÈÄâÊã©\n'));
                    resolve(null);
                    return;
                }

                const index = parseInt(choice) - 1;
                if (isNaN(index) || index < 0 || index >= files.length) {
                    console.log(chalk.red('Êó†ÊïàÁöÑÂ∫èÂè∑\n'));
                    resolve(null);
                    return;
                }

                const selectedFile = files[index];
                console.log(chalk.green(`‚úì Â∑≤ÈÄâÊã©: ${selectedFile}\n`));
                resolve(selectedFile);
            });
        } catch (error) {
            console.error(chalk.red(`ËØªÂèñÁõÆÂΩïÂ§±Ë¥•: ${error}\n`));
            resolve(null);
        }
    });
}

async function handleFileReference(filePath: string, question?: string): Promise<string> {
    const fullPath = path.resolve(filePath);

    if (!fs.existsSync(fullPath) || !fs.statSync(fullPath).isFile()) {
        console.log(chalk.red(`ÈîôËØØ: Êñá‰ª∂ "${filePath}" ‰∏çÂ≠òÂú®Êàñ‰∏çÊòØ‰∏Ä‰∏™Êñá‰ª∂\n`));
        return question || '';
    }

    const spinner = ora(chalk.cyan('Ê≠£Âú®ËØªÂèñÊñá‰ª∂...')).start();

    try {
        const content = fs.readFileSync(fullPath, 'utf-8');
        const relativePath = path.relative(process.cwd(), fullPath);

        const contentMap = new Map<string, string>();
        contentMap.set(relativePath, content);

        const prompt = buildPromptWithFileContent(
            `Êñá‰ª∂: ${relativePath}`,
            [relativePath],
            contentMap,
            question || `ËØ∑ÂàÜÊûêÊñá‰ª∂: ${relativePath}`
        );

        spinner.stop();
        console.log(chalk.green(`‚úì Â∑≤ËØªÂèñÊñá‰ª∂: ${relativePath}\n`));
        return prompt;
    } catch (error) {
        spinner.stop();
        console.error(chalk.red(`ËØªÂèñÊñá‰ª∂Â§±Ë¥•: ${error}\n`));
        return question || '';
    }
}

async function handleFileReferenceInput(input: string): Promise<string> {
    const match = input.match(/^@\s*(.+?)\s*(?:\n(.*))?$/s);
    if (!match) {
        console.log(chalk.yellow('Ê†ºÂºèÈîôËØØÔºåÊ≠£Á°ÆÁî®Ê≥ï: @Êñá‰ª∂Ë∑ØÂæÑ [ÈóÆÈ¢ò]\n'));
        return '';
    }

    const filePath = match[1].trim();
    const question = match[2] ? match[2].trim() : '';
    return handleFileReference(filePath, question);
}

async function handleDirectoryReference(input: string): Promise<string> {
    const match = input.match(/^#\s*(.+?)\s*(?:\n(.*))?$/s);
    if (!match) {
        console.log(chalk.yellow('Ê†ºÂºèÈîôËØØÔºåÊ≠£Á°ÆÁî®Ê≥ï: # ÁõÆÂΩïË∑ØÂæÑ [ÈóÆÈ¢ò]\n'));
        return input;
    }

    const dirPath = match[1].trim();
    const question = match[2] ? match[2].trim() : 'ËØ∑ÂàÜÊûêËøô‰∏™ÁõÆÂΩï‰∏ãÁöÑÊñá‰ª∂';

    const fullPath = path.resolve(dirPath);

    if (!fs.existsSync(fullPath) || !fs.statSync(fullPath).isDirectory()) {
        console.log(chalk.red(`ÈîôËØØ: ÁõÆÂΩï "${dirPath}" ‰∏çÂ≠òÂú®Êàñ‰∏çÊòØ‰∏Ä‰∏™ÁõÆÂΩï\n`));
        return question;
    }

    const spinner = ora(chalk.cyan('Ê≠£Âú®ËØªÂèñÊñá‰ª∂...')).start();

    try {
        const findCommand = process.platform === 'darwin' || process.platform === 'linux'
            ? `find "${fullPath}" -type f`
            : `dir /s /b "${fullPath}"`;

        const { stdout } = await execAsync(findCommand);
        const filePaths = stdout.trim().split('\n').filter(f => f);

        spinner.stop();

        if (filePaths.length === 0) {
            console.log(chalk.yellow(`ÁõÆÂΩï "${dirPath}" ‰∏ãÊ≤°ÊúâÊñá‰ª∂\n`));
            return question;
        }

        const contentMap = readFilesContent(filePaths);

        const prompt = buildPromptWithFileContent(
            `ÁõÆÂΩï: ${dirPath}\nÊâæÂà∞ ${filePaths.length} ‰∏™Êñá‰ª∂`,
            filePaths.map(p => path.relative(process.cwd(), p)),
            contentMap,
            question
        );

        console.log(chalk.green(`‚úì Â∑≤ËØªÂèñ ${contentMap.size} ‰∏™Êñá‰ª∂\n`));
        return prompt;
    } catch (error) {
        spinner.stop();
        console.error(chalk.red(`ËØªÂèñÁõÆÂΩïÂ§±Ë¥•: ${error}\n`));
        return question;
    }
}

export async function handleAIChat(initialQuestion: string | null, model?: string) {
    if (initialQuestion) {
        // ÂÖàÊ£ÄÊü•ÊòØÂê¶‰∏∫ÁâπÊÆäËØ≠Ê≥ï
        const { handleSpecialSyntax } = await import('../utils/syntaxHandler');
        const result = await handleSpecialSyntax(initialQuestion);
        
        if (result.processed) {
            // Â¶ÇÊûúÊòØÁÆ°ÁêÜÂëΩ‰ª§Ôºà:ls, :cat, :clearÔºâÔºåÁõ¥Êé•ËæìÂá∫ÁªìÊûú
            if (result.result) {
                console.log(result.result);
            }
            return;
        }
        
        // ‰∏çÊòØÁâπÊÆäËØ≠Ê≥ïÔºåÊ≠£Â∏∏ÂèëÁªô AI
        await askOnceStream(initialQuestion, model);
        return;
    }

    console.log(chalk.bold.cyan('\nü§ñ ËøõÂÖ• AI ‰∫§‰∫íÊ®°Âºè (ËæìÂÖ• exit ÈÄÄÂá∫)\n'));

    const contextBuffer = new ContextBuffer();
    const persisted = await loadContext();
    contextBuffer.import(persisted);

    if (persisted.length > 0) {
        console.log(chalk.yellow(`üì¶ Â∑≤ÊÅ¢Â§ç ${persisted.length} Êù°‰∏ä‰∏ãÊñá\n`));
    }

    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
        terminal: true,
        completer: createCompleter(),
        historySize: 1000
    });

    readline.emitKeypressEvents(process.stdin);

    process.stdin.on('keypress', (str, key) => {
        if (key.ctrl && key.name === 'r') {
            rl.write(null, { ctrl: true, name: 'r' });
        }
    });

    // Helper to wrap rl.question in a Promise
    const ask = (query: string): Promise<string> => {
        return new Promise((resolve) => {
            rl.question(query, (answer) => {
                resolve(answer);
            });
        });
    };

    try {
        while (true) {
            const input = await ask(chalk.green('‰Ω†Ôºö'));
            const trimmed = input.trim();

            // === Âú∫ÊôØ 5.1: ÂéüÂ≠êÊâßË°å (:exec) ===
            if (trimmed.startsWith(':exec ')) {
                const cmd = trimmed.slice(6).trim();
                if (cmd) {
                    console.log(chalk.cyan(`\n‚ö°Ô∏è [Atomic Exec] ${cmd}\n`));
                    rl.pause();
                    try {
                        await shellExecuteCommand(cmd, (code) => {
                            if (code !== 0) console.log(chalk.red(`Exited with ${code}`));
                        });
                    } finally {
                        rl.resume();
                    }
                }
                continue;
            }

            if (trimmed.startsWith('@')) {
                rl.pause();
                try {
                    // Êñ∞Â¢ûÔºöÊîØÊåÅÊâßË°åÂëΩ‰ª§ÁöÑËØ≠Ê≥ï
                    // @ filename:command - Ê∑ªÂä†Âπ∂ÊâßË°åÂëΩ‰ª§
                    // @!filename - Ê∑ªÂä†Âπ∂Á´ãÂç≥ÊâßË°åÊñá‰ª∂

                    const execMatch = trimmed.match(/^@\s*(.+?)\s*:\s*([^].*)?$/);
                    const immediateExecMatch = trimmed.match(/^@\s*!\s*(.+?)$/);

                    if (execMatch && execMatch[2]) {
                        // @ filename:command - Ê∑ªÂä†Âπ∂ÊâßË°åÂëΩ‰ª§
                        const filePath = execMatch[1].trim();
                        const commandStr = execMatch[2].trim();

                        const content = await readFileContent(filePath);

                        contextBuffer.add({
                            type: 'file',
                            path: filePath,
                            content
                        });

                        const displayName = filePath;
                        console.log(chalk.green(`‚úì Â∑≤Âä†ÂÖ•Êñá‰ª∂‰∏ä‰∏ãÊñá: ${displayName}\n`));
                        
                        await saveContext(contextBuffer.export());
                        
                        console.log(chalk.cyan(`‚ö°Ô∏è  Ê≠£Âú®ÊâßË°å: ${commandStr}\n`));
                        
                        const { stdout, stderr } = await exec(commandStr, { cwd: path.dirname(filePath) });
                        console.log(stdout);
                        if (stderr) console.error(chalk.red(stderr));

                        await saveContext(contextBuffer.export());
                        console.log(chalk.green(`‚úì ÊâßË°åÂÆåÊàê\n`));

                        rl.resume();
                        continue;
                    }

                    if (immediateExecMatch) {
                        // Âú∫ÊôØ 3.2: @!filename - Ê∑ªÂä†ËÑöÊú¨Ê∫êÁ†ÅÂπ∂ÊçïËé∑ÊâßË°åËæìÂá∫
                        const filePath = immediateExecMatch[1].trim();
                        const fullPath = path.resolve(filePath);

                        if (fs.existsSync(fullPath)) {
                            // 1. ËØªÂèñÊ∫êÁ†Å
                            const sourceContent = await readFileContent(filePath);
                            
                            console.log(chalk.cyan(`‚ö°Ô∏è Ê≠£Âú®ÊâßË°åÂπ∂ÊçïËé∑: ${filePath}\n`));
                            
                            // 2. ÊâßË°åÂπ∂ÊçïËé∑
                            const { stdout, stderr } = await execAsync(`chmod +x "${fullPath}" && "${fullPath}"`, { cwd: process.cwd() });
                            console.log(stdout); // ÂÆûÊó∂ÊâìÂç∞ÁªôÁî®Êà∑Áúã
                            if (stderr) console.error(chalk.red(stderr));

                            // 3. ÊûÑÈÄ†ÁªÑÂêà‰∏ä‰∏ãÊñá (Â•ëÁ∫¶ÔºöÂëΩ‰ª§ÂÜÖÂÆπ + ÂÆûÈôÖËæìÂá∫)
                            const combinedContent = `
=== Source: ${filePath} ===
\`\`\`bash
${sourceContent}
\`\`\`

=== Stdout ===
\`\`\`
${stdout}
\`\`\`

=== Stderr ===
\`\`\`
${stderr}
\`\`\`
`;

                            contextBuffer.add({
                                type: 'file',
                                path: `${filePath} [Run Log]`,
                                alias: 'Execution Log',
                                content: combinedContent
                            });
                            
                            await saveContext(contextBuffer.export());
                            console.log(chalk.green(`\n‚úì Â∑≤ÊçïËé∑ËÑöÊú¨Ê∫êÁ†ÅÂèäÊâßË°åÊó•ÂøóÂà∞‰∏ä‰∏ãÊñá\n`));
                        } else {
                            console.log(chalk.red(`ÈîôËØØ: Êñá‰ª∂ ${filePath} ‰∏çÂ≠òÂú®`));
                        }

                        rl.resume();
                        continue;
                    }

                    // Â¢ûÂº∫ÁöÑÂåπÈÖçÊ®°ÂºèÔºåÊîØÊåÅË°åÂè∑ÊåáÂÆö: @ filepath:startLine-endLine as alias
                    const match = trimmed.match(/^@\s*(.+?)(?::(\d+)(?:-(\d+))?)?(?:\s+as\s+(.+))?$/);
                    const filePath = match?.[1] ?? (await showFileSelector(rl));
                    const lineStart = match?.[2] ? parseInt(match[2]) : null;
                    const lineEnd = match?.[3] ? parseInt(match[3]) : null;
                    const alias = match?.[4];

                    if (!filePath) continue;

                    const absolutePath = path.resolve(filePath);
                    let content = await fs.promises.readFile(absolutePath, 'utf-8');

                    // Â¶ÇÊûúÊåáÂÆö‰∫ÜË°åÂè∑ËåÉÂõ¥ÔºåÂàôÊèêÂèñÁõ∏Â∫îË°å
                    if (lineStart !== null) {
                        const lines = content.split('\n');

                        // È™åËØÅË°åÂè∑ËåÉÂõ¥
                        if (lineStart < 1 || lineStart > lines.length) {
                            console.log(chalk.red(`\nÈîôËØØ: Ëµ∑ÂßãË°åÂè∑ ${lineStart} Ë∂ÖÂá∫Êñá‰ª∂ËåÉÂõ¥ (Êñá‰ª∂ÂÖ±Êúâ ${lines.length} Ë°å)\n`));
                            rl.resume();
                            continue;
                        }

                        const startIdx = lineStart - 1; // ËΩ¨Êç¢‰∏∫Êï∞ÁªÑÁ¥¢ÂºïÔºà‰ªé0ÂºÄÂßãÔºâ
                        let endIdx = lineEnd ? Math.min(lineEnd, lines.length) : lines.length; // Â¶ÇÊûúÊú™ÊåáÂÆöÁªìÊùüË°åÔºåÂàôÂà∞Êñá‰ª∂Êú´Â∞æ

                        if (lineEnd && (lineEnd < lineStart || lineEnd > lines.length)) {
                            console.log(chalk.red(`\nÈîôËØØ: ÁªìÊùüË°åÂè∑ ${lineEnd} Ë∂ÖÂá∫ÊúâÊïàËåÉÂõ¥ (Â∫îÂú® ${lineStart}-${lines.length} ‰πãÈó¥)\n`));
                            rl.resume();
                            continue;
                        }

                        // ÊèêÂèñÊåáÂÆöËåÉÂõ¥ÁöÑË°å
                        content = lines.slice(startIdx, endIdx).join('\n');

                        // Êõ¥Êñ∞Ë∑ØÂæÑÊòæÁ§∫ÔºåÂåÖÂê´Ë°åÂè∑‰ø°ÊÅØ
                        const rangeInfo = lineEnd ? `${lineStart}-${lineEnd}` : `${lineStart}`;
                        const pathWithRange = `${filePath}:${rangeInfo}`;

                        contextBuffer.add({
                            type: 'file',
                            path: pathWithRange,
                            alias,
                            content
                        }, true); // bypassTokenLimit = true
                    } else {
                        // ÂéüÂßãË°å‰∏∫ÔºöÊ∑ªÂä†Êï¥‰∏™Êñá‰ª∂
                        contextBuffer.add({
                            type: 'file',
                            path: filePath,
                            alias,
                            content
                        });
                    }

                    await saveContext(contextBuffer.export());
                    const displayName = alias ? `${alias} (${filePath}${lineStart !== null ? `:${lineStart}${lineEnd ? `-${lineEnd}` : ''}` : ''})` :
                        (filePath + (lineStart !== null ? `:${lineStart}${lineEnd ? `-${lineEnd}` : ''}` : ''));
                    console.log(chalk.green(`‚úÖ Â∑≤Âä†ÂÖ•Êñá‰ª∂‰∏ä‰∏ãÊñá: ${displayName}\n`));
                } catch (err: unknown) {
                    const message = err instanceof Error ? err.message : String(err);
                    console.error(chalk.red(`\n[Â§ÑÁêÜÈîôËØØ]: ${message}\n`));
                } finally {
                    rl.resume();
                }
                continue;
            }

            if (trimmed.startsWith('#')) {
                rl.pause();
                try {
                    const match = trimmed.match(/^#\s*(.+?)\s*(?:\n(.*))?$/s);
                    if (!match) {
                        console.log(chalk.yellow('Ê†ºÂºèÈîôËØØÔºåÊ≠£Á°ÆÁî®Ê≥ï: # ÁõÆÂΩïË∑ØÂæÑ\n'));
                        rl.resume();
                        continue;
                    }

                    const dirPath = match[1].trim();
                    const fullPath = path.resolve(dirPath);

                    if (!fs.existsSync(fullPath) || !fs.statSync(fullPath).isDirectory()) {
                        console.log(chalk.red(`ÈîôËØØ: ÁõÆÂΩï "${dirPath}" ‰∏çÂ≠òÂú®Êàñ‰∏çÊòØ‰∏Ä‰∏™ÁõÆÂΩï\n`));
                        rl.resume();
                        continue;
                    }

                    const findCommand = process.platform === 'darwin' || process.platform === 'linux'
                        ? `find "${fullPath}" -type f`
                        : `dir /s /b "${fullPath}"`;

                    const { stdout } = await execAsync(findCommand);
                    const filePaths = stdout.trim().split('\n').filter(f => f);

                    if (filePaths.length === 0) {
                        console.log(chalk.yellow(`ÁõÆÂΩï "${dirPath}" ‰∏ãÊ≤°ÊúâÊñá‰ª∂\n`));
                        rl.resume();
                        continue;
                    }

                    const contentMap = readFilesContent(filePaths);

                    // ÈÄê‰∏™Ê∑ªÂä†Êñá‰ª∂ÔºåËÄå‰∏çÊòØÂ∞ÜÊâÄÊúâÂÜÖÂÆπÂêàÂπ∂‰∏∫‰∏Ä‰∏™Â§ßÁöÑÁõÆÂΩïÈ°π
                    // ËøôÊ†∑ÂèØ‰ª•Êõ¥Â•ΩÂú∞ÊéßÂà∂token‰ΩøÁî®ÔºåÂπ∂‰øùÁïô‰πãÂâçÁöÑ‰∏ä‰∏ãÊñá
                    let addedCount = 0;
                    for (const [filePath, content] of contentMap) {
                        // Ê£ÄÊü•Âçï‰∏™Êñá‰ª∂Â§ßÂ∞èÔºåÂ¶ÇÊûúÂ§™Â§ßÂàôË∑≥Ëøá
                        const fileTokens = Math.ceil(content.length / 4);
                        if (fileTokens > 2000) { // ÈôêÂà∂Âçï‰∏™Êñá‰ª∂‰∏çË∂ÖËøá2000 tokens
                            console.log(chalk.yellow(`‚ö†Ô∏è  Ë∑≥ËøáÂ§ßÊñá‰ª∂: ${filePath} (Â§™Â§ß)`));
                            continue;
                        }

                        contextBuffer.add({
                            type: 'file',  // Êîπ‰∏∫fileÁ±ªÂûãÔºåÂõ†‰∏∫ÂÆûÈôÖ‰∏äÊòØÂçï‰∏™Êñá‰ª∂
                            path: filePath,
                            content: content
                        });
                        addedCount++;

                        // Ê£ÄÊü•ÊòØÂê¶ËææÂà∞tokenÈôêÂà∂ÔºåÂ¶ÇÊûúËææÂà∞ÂàôÂÅúÊ≠¢Ê∑ªÂä†Êõ¥Â§öÊñá‰ª∂
                        // Êàë‰ª¨ÈúÄË¶ÅÊâãÂä®ËÆ°ÁÆóÊÄªtokensÔºåÂõ†‰∏∫totalTokensÊòØÁßÅÊúâÊñπÊ≥ï
                        const totalTokens = contextBuffer.export().reduce((sum, item) => sum + item.tokens, 0);
                        if (totalTokens > 30000) { // Áïô2000 token‰ΩôÈáè
                            console.log(chalk.yellow(`‚ö†Ô∏è  ËææÂà∞tokenÈôêÂà∂ÔºåÂÅúÊ≠¢Ê∑ªÂä†Êõ¥Â§öÊñá‰ª∂`));
                            break;
                        }
                    }

                    await saveContext(contextBuffer.export());
                } catch (err: unknown) {
                    const message = err instanceof Error ? err.message : String(err);
                    console.error(chalk.red(`\n[Â§ÑÁêÜÈîôËØØ]: ${message}\n`));
                } finally {
                    rl.resume();
                }
                continue;
            }

            if (['exit', 'quit', 'bye'].includes(trimmed.toLowerCase())) {
                console.log(chalk.cyan('üëã ÂÜçËßÅÔºÅ'));
                break;
            }

            if (trimmed === '/clear') {
                clearConversationHistory();
                console.log(chalk.yellow('‚úì ÂØπËØùÂéÜÂè≤Â∑≤Ê∏ÖÁ©∫\n'));
                continue;
            }

            if (trimmed === '/history') {
                const history = getConversationHistory();
                if (history.length === 0) {
                    console.log(chalk.gray('ÊöÇÊó†ÂØπËØùÂéÜÂè≤\n'));
                } else {
                    history.forEach((msg) => {
                        const prefix = msg.role === 'user' ? chalk.green('‰Ω†: ') : chalk.blue('AI: ');
                        console.log(prefix + msg.content);
                    });
                }
                continue;
            }

            if (trimmed === ':ls') {
                const list = contextBuffer.list();
                if (list.length === 0) {
                    console.log(chalk.gray('üì≠ ÂΩìÂâçÊ≤°Êúâ‰∏ä‰∏ãÊñá\n'));
                } else {
                    console.table(list);
                }
                continue;
            }

            if (trimmed === ':cat' || trimmed.startsWith(':cat ')) {
                const parts = trimmed.split(' ');
                const index = parts.length > 1 ? parseInt(parts[1]) : null;
                const items = contextBuffer.export();

                if (items.length === 0) {
                    console.log(chalk.gray('üì≠ ÂΩìÂâçÊ≤°Êúâ‰∏ä‰∏ãÊñáÂÜÖÂÆπÂèØÊü•ÈòÖ\n'));
                } else if (index !== null) {
                    if (index < 1 || index > items.length) {
                        console.log(chalk.red(`‚ùå Á¥¢Âºï ${index} Ë∂ÖÂá∫ËåÉÂõ¥ (1-${items.length})\n`));
                    } else {
                        const item = items[index - 1];
                        console.log(chalk.cyan(`\n=== [${index}] ${item.path} ===`));
                        console.log(item.content);
                        console.log(chalk.cyan(`=== End ===\n`));
                    }
                } else {
                    console.log(chalk.cyan('\n=== ÂΩìÂâçÂÆåÊï¥‰∏ä‰∏ãÊñáÂÜÖÂÆπ ==='));
                    items.forEach((item, i) => {
                        console.log(chalk.yellow(`\n--- [${i + 1}] ${item.path} ---`));
                        console.log(item.content);
                    });
                    console.log(chalk.cyan('\n==========================\n'));
                }
                continue;
            }

            if (trimmed === ':clear') {
                contextBuffer.clear();
                await clearContextStorage();
                console.log(chalk.yellow('üßπ ‰∏ä‰∏ãÊñáÂ∑≤Ê∏ÖÁ©∫ÔºàÂê´ÊåÅ‰πÖÂåñÔºâ\n'));
                continue;
            }

            if (trimmed === ':plugins') {
                const plugins = listPlugins();
                if (plugins.length === 0) {
                    console.log(chalk.gray('üì≠ ÂΩìÂâçÊ≤°ÊúâÂä†ËΩΩÁöÑÊèí‰ª∂\n'));
                } else {
                    console.log(chalk.cyan('Â∑≤Âä†ËΩΩÁöÑÊèí‰ª∂:\n'));
                    plugins.forEach(p => console.log(chalk.green(`  - ${p}`)));
                    console.log();
                }
                continue;
            }

            if (!trimmed) continue;

            const mode = detectMode(trimmed);

            if (mode === 'command') {
                rl.pause();
                try {
                    await shellExecuteCommand(trimmed, (code) => {
                        if (code !== 0) {
                            console.log(chalk.red(`\n[command exited with code ${code}]\n`));
                        }
                    });
                } catch (err: unknown) {
                    const message = err instanceof Error ? err.message : String(err);
                    console.error(chalk.red(`\n[Command Error]: ${message}`));
                } finally {
                    rl.resume();
                }
                continue;
            }

            let finalPrompt = contextBuffer.isEmpty()
                ? trimmed
                : contextBuffer.buildPrompt(trimmed);

            const gitContext = await getGitContext();

            if (gitContext) {
                finalPrompt = `
${gitContext}

${finalPrompt}
`;
            }

            try {
                rl.pause();
                await askOnceStream(finalPrompt, model);

                // IMPORTANT: Removed auto-clearing of contextBuffer.
                // Keeping it for follow-up questions until :clear is called.
            } catch (err: unknown) {
                const message = err instanceof Error ? err.message : String(err);
                console.error(chalk.red(`\n[AI execution error]: ${message}`));
            } finally {
                rl.resume();
            }
        }
    } catch (criticalErr: unknown) {
        const message = criticalErr instanceof Error ? criticalErr.message : String(criticalErr);
        console.error(chalk.red(`\n[Critical Loop Error]: ${message}`));
    } finally {
        rl.close();
    }
}

async function askOnceStream(question: string, model?: string) {
    const messages = [...getConversationHistory()];
    messages.push({ role: 'user', content: question });

    const spinner = ora(chalk.cyan('AI Ê≠£Âú®ÊÄùËÄÉ...')).start();
    
    // ÂàùÂßãÂåñÊ∏≤ÊüìÂô®
    const renderer = new StreamMarkdownRenderer(chalk.bold.blue('ü§ñ AIÔºö'), spinner);

    try {
        await callAI_Stream(messages, model, (chunk) => {
            renderer.onChunk(chunk);
        });

        const fullResponse = renderer.finish();

        addToConversationHistory('user', question);
        addToConversationHistory('assistant', fullResponse);
    } catch (error: any) {
        if (spinner.isSpinning) {
            spinner.stop();
        }
        throw error;
    }
}

````

## üìÑ `commands/handleAICommand.ts`

````typescript
import chalk from 'chalk';
import ora from 'ora';
import { getOSProfile } from '../core/os';
import { buildCommandPrompt } from '../ai/prompt';
import { askAI } from '../ai/client';
import { exec } from '../core/executor';
import { assessRisk } from '../core/risk';
import { autoFixCommand } from '../core/autofix';
import { confirm } from '../utils/confirm';
import { saveHistory } from '../utils/history';
import { safeParseJSON, AICommandPlan, AIFixPlan } from '../core/validation';
import { getMacros, runMacro } from '../core/macros';
import { CapabilitySystem } from '../core/capabilitySystem';
import { inferCapabilityRequirement } from '../core/capabilityInference';
import { CapabilityMatchResult } from '../core/modelMatcher';
import { ContextBuffer } from './contextBuffer';
import { loadContext, saveContext } from './contextStorage';

function validateAIPlan(obj: any): obj is AICommandPlan {
    return (
        typeof obj === 'object' &&
        obj !== null &&
        typeof obj.plan === 'string' &&
        ['low', 'medium', 'high'].includes(obj.risk) &&
        (typeof obj.command === 'string' || typeof obj.macro === 'string')
    );
}

export async function handleAICommand(
    userInput: string,
    options: { execute: boolean; model?: string; dryRun?: boolean; autoYes?: boolean; verbose?: boolean }
) {
    const os = getOSProfile();
    const macros = getMacros();
    const capabilitySystem = new CapabilitySystem();
    const spinner = ora(chalk.cyan('üß† AI Ê≠£Âú®ËßÑÂàí‰∏≠...')).start();

    const startTime = Date.now();

    try {
        const requirement = inferCapabilityRequirement(userInput);

        let matchResult: CapabilityMatchResult;
        let selectedModel: string;

        if (options.model) {
            matchResult = {
                selected: null,
                candidates: [],
                fallbackOccurred: false,
            };

            selectedModel = options.model;
        } else {
            matchResult = capabilitySystem.matchCapability(requirement);
            selectedModel = matchResult.selected?.name || 'Assistant';
        }

        spinner.stop();
        
        // Load context
        const contextBuffer = new ContextBuffer();
        const persistedContext = await loadContext();
        contextBuffer.import(persistedContext);
        const contextStr = contextBuffer.isEmpty() ? '' : contextBuffer.buildPrompt('');

        const prompt = buildCommandPrompt(userInput, os, macros, contextStr);
        const raw = await askAI(prompt, selectedModel);

        const { aiCommandPlanSchema } = require('../core/validation');
        const parseResult = safeParseJSON(raw, aiCommandPlanSchema, {} as AICommandPlan);

        if (!parseResult.success) {
            console.log(chalk.red('\n‚ùå AI ËæìÂá∫‰∏çÊòØÂêàÊ≥ï JSON:'));
            console.log(raw);
            console.log(chalk.gray('\nÈ™åËØÅÈîôËØØ: ' + parseResult.error.issues.map((e: any) => e.message).join(', ')));
            return { code: 1 };
        }

        const plan = parseResult.data;

        const isUsingMacro = !!plan.macro;
        let actualCommand = plan.macro ? macros[plan.macro]?.commands : plan.command;

        if (!actualCommand) {
            console.log(chalk.red('\n‚ùå Êó†ÊïàÁöÑËÆ°ÂàíÔºö'));
            if (plan.macro) {
                console.log(chalk.red(`Êú™ÊâæÂà∞Âêç‰∏∫ "${plan.macro}" ÁöÑ Macro`));
            } else {
                console.log(chalk.red('Êú™Êèê‰æõÊúâÊïàÁöÑÂëΩ‰ª§'));
            }
            return { code: 1 };
        }

        const commandToExecute: string = actualCommand;
        const finalRisk = assessRisk(commandToExecute, plan.risk);

        console.log(chalk.bold.cyan('\nüß† ËÆ°Âàí: ') + plan.plan);

        if (isUsingMacro) {
            console.log(chalk.bold.green('‚ú® Â§çÁî® Macro: ') + chalk.yellow(plan.macro!));
            console.log(chalk.gray('   (Â∑≤È™åËØÅÁöÑÂëΩ‰ª§ÔºåÊó†ÈúÄÈáçÊñ∞ÁîüÊàê)'));
        } else {
            console.log(chalk.bold.green('üíª ÂëΩ‰ª§: ') + chalk.yellow(commandToExecute));
        }

        const riskColor = finalRisk === 'high' ? chalk.red : (finalRisk === 'medium' ? chalk.yellow : chalk.green);
        console.log(chalk.bold('‚ö†Ô∏è  È£éÈô©Âà§Êñ≠: ') + riskColor(finalRisk.toUpperCase()));

        if (options.verbose) {
            console.log(chalk.bold.cyan('\nüîç Capability ÂåπÈÖçËØ¶ÊÉÖ:'));
            console.log(chalk.gray(`  Áî®Êà∑ÊÑèÂõæËÉΩÂäõ: ${requirement.required.join(', ')}`));
            console.log(chalk.gray(`  ‰ΩøÁî®ÁöÑÊ®°Âûã: ${selectedModel}`));

            if (matchResult.selected) {
                console.log(chalk.gray(`  Ê®°ÂûãËÉΩÂäõË¶ÜÁõñ: ${matchResult.selected.atomicCapabilities.join(', ')}`));
            }

            if (matchResult.fallbackOccurred) {
                console.log(chalk.yellow('  ‚ö†Ô∏è  Ëß¶Âèë‰∫Ü Fallback'));
            }

            matchResult.candidates.forEach(c => {
                const icon = c.hasRequired ? chalk.green('‚úì') : chalk.red('‚úó');
                console.log(chalk.gray(`  ${icon} ${c.modelName}: ${c.reason}`));
            });
        }

        if (options.dryRun) {
            console.log(chalk.gray('\n[Dry Run] ‰ªÖÊ®°ÊãüÔºå‰∏çÊâßË°åÂëΩ‰ª§„ÄÇ'));
            return { code: 0 };
        }

        console.log(chalk.gray('‚îÄ'.repeat(50)));
        if (isUsingMacro) {
            console.log(chalk.yellow('‚ö†Ô∏è  Ê≥®ÊÑè: AI Ê≠£Âú®Â§çÁî®Â∑≤È™åËØÅÁöÑ Macro„ÄÇ'));
        } else {
            console.log(chalk.yellow('‚ö†Ô∏è  Ê≥®ÊÑè: ‰ª•‰∏äÂëΩ‰ª§Áî± AI ÁîüÊàêÔºåËØ∑Âú®ÊâßË°åÂâç‰ªîÁªÜÊ£ÄÊü•„ÄÇ'));
            console.log(chalk.gray('   AI ÂèØËÉΩ‰ºöÁäØÈîôÔºåÂÆâÂÖ®Áî±ÊÇ®ÊéåÊéß„ÄÇ'));
        }
        console.log(chalk.gray('‚îÄ'.repeat(50)));

        let shouldExecute = options.execute || options.autoYes;

        if (!shouldExecute) {
            shouldExecute = await confirm('ÊòØÂê¶ÊâßË°åËØ•ÂëΩ‰ª§Ôºü');
        }

        if (!shouldExecute) {
            console.log(chalk.gray('ÊâßË°åÂ∑≤ÂèñÊ∂à„ÄÇ'));
            return { code: 1 };
        }

        console.log(chalk.gray('\nÊâßË°å‰∏≠...\n'));
        let result: { code: number | null; stdout?: string; stderr?: string };

        if (isUsingMacro) {
            const macroSuccess = runMacro(plan.macro!);
            result = { code: 0, stdout: '', stderr: '' };
            console.log(chalk.green('‚úì Macro Â∑≤ÊâßË°å'));
        } else {
            result = await exec(commandToExecute);
        }

        const latencyMs = Date.now() - startTime;

        if (!isUsingMacro && result.code !== 0 && result.code !== null) {
            console.log(chalk.red('\n‚ùå ÊâßË°åÂ§±Ë¥•ÔºåÂ∞ùËØïËá™Âä®‰øÆÂ§ç...'));
            const fixedPlan = await autoFixCommand(
                commandToExecute,
                result.stderr!,
                os,
                selectedModel
            );

            if (fixedPlan && fixedPlan.command) {
                console.log(chalk.bold.cyan('üîÅ ‰øÆÂ§çÊñπÊ°à: ') + fixedPlan.plan);
                console.log(chalk.bold.green('üíª ‰øÆÂ§çÂëΩ‰ª§: ') + chalk.yellow(fixedPlan.command));

                const retry = await confirm('ÊòØÂê¶ÊâßË°å‰øÆÂ§çÂêéÁöÑÂëΩ‰ª§Ôºü');
                if (retry) {
                    console.log(chalk.gray('\nÊ≠£Âú®ÈáçËØï...\n'));
                    result = await exec(fixedPlan.command);
                    if (result.code === 0) {
                        saveHistory({
                            question: userInput,
                            command: fixedPlan.command,
                        });
                        console.log(chalk.green('\n‚úì ‰øÆÂ§çÂëΩ‰ª§ÊâßË°åÊàêÂäüÂπ∂Â∑≤Â≠òÂÖ•ÂéÜÂè≤Â∫ì'));
                        return result;
                    }
                }
            }
        }

        if (result.code === 0) {
            saveHistory({
                question: userInput,
                command: commandToExecute,
            });

            if (isUsingMacro) {
                console.log(chalk.green('\n‚úì Macro ÊâßË°åÊàêÂäüÂπ∂Â∑≤Â≠òÂÖ•ÂéÜÂè≤Â∫ì'));
            } else {
                console.log(chalk.green('\n‚úì ÊâßË°åÊàêÂäüÂπ∂Â∑≤Â≠òÂÖ•ÂéÜÂè≤Â∫ì'));
            }

            if (!isUsingMacro) {
                capabilitySystem.createAndSaveExecutionRecord(
                    'ai-command',
                    requirement,
                    matchResult,
                    commandToExecute
                );
            }

            // Clear context after successful one-shot command execution
            await saveContext([]);
        }

        return result;
    } catch (error: unknown) {
        const message = error instanceof Error ? error.message : String(error);
        spinner.fail(chalk.red('ÂèëÁîüÈîôËØØ: ' + message));
        return { code: 1 };
    }
}

````

## üìÑ `commands/handleConfig.ts`

````typescript
import fs from 'fs';
import path from 'path';
import os from 'os';
import chalk from 'chalk';
import { parseUserConfig, userConfigSchema, type UserConfig } from '../core/validation';

const CONFIG_FILE = path.join(os.homedir(), '.yuangs.json');

export function handleConfig(args: string[]) {
    const action = args[0]; // get, set, list

    if (!action || action === 'list') {
        const config = readConfig();
        console.log(chalk.bold.cyan('\n‚öôÔ∏è  ÂΩìÂâçÈÖçÁΩÆ (~/.yuangs.json):\n'));
        if (Object.keys(config).length === 0) {
            console.log(chalk.gray('  (ÈÖçÁΩÆÊñá‰ª∂‰∏çÂ≠òÂú®Êàñ‰∏∫Á©∫)'));
        } else {
            Object.entries(config).forEach(([key, value]) => {
                console.log(`  ${chalk.white(key)}: ${chalk.green(value)}`);
            });
        }
        console.log('\n‰ΩøÁî®ÊñπÊ≥ï:');
        console.log(chalk.gray('  yuangs config set <key> <value>'));
        console.log(chalk.gray('  yuangs config get <key>\n'));
        return;
    }

    if (action === 'set') {
        const key = args[1];
        const value = args[2];
        if (!key || !value) {
            console.log(chalk.red('ÈîôËØØ: ËØ∑Êèê‰æõ key Âíå value„ÄÇ‰æãÂ¶Ç: yuangs config set defaultModel gemini-2.5-flash-lite'));
            return;
        }
        const config = readConfig();
        config[key] = value;
        writeConfig(config);
        console.log(chalk.green(`‚úì Â∑≤Â∞Ü ${key} ËÆæÁΩÆ‰∏∫ ${value}`));
        return;
    }

    if (action === 'get') {
        const key = args[1];
        if (!key) {
            console.log(chalk.red('ÈîôËØØ: ËØ∑Êèê‰æõ key„ÄÇ‰æãÂ¶Ç: yuangs config get defaultModel'));
            return;
        }
        const config = readConfig();
        if (config[key] !== undefined) {
            console.log(config[key]);
        } else {
            console.log(chalk.yellow(`ÈÖçÁΩÆÈ°π ${key} ‰∏çÂ≠òÂú®`));
        }
        return;
    }
}

function readConfig(): UserConfig {
    if (fs.existsSync(CONFIG_FILE)) {
        try {
            return parseUserConfig(fs.readFileSync(CONFIG_FILE, 'utf8'));
        } catch (e) {
            return {};
        }
    }
    return {};
}

function writeConfig(config: UserConfig) {
    const validated = userConfigSchema.parse(config);
    fs.writeFileSync(CONFIG_FILE, JSON.stringify(validated, null, 2));
}

````

## üìÑ `commands/replayCommands.ts`

````typescript
import chalk from 'chalk';
import { Command } from 'commander';
import { CapabilitySystem } from '../core/capabilitySystem';
import { ReplayMode } from '../core/replayEngine';
import { diffExecution, formatReplayDiff } from '../core/replayDiff';
import { loadExecutionRecord, listExecutionRecords } from '../core/executionStore';

export function registerReplayCommands(program: Command): void {
  program
    .command('replay <id>')
    .description('Replay an execution')
    .option('-s, --strict', 'Strict replay (use exact model)')
    .option('-c, --compatible', 'Compatible replay (allow fallback)')
    .option('-r, --re-evaluate', 'Re-evaluate with current config')
    .option('-v, --verbose', 'Verbose output')
    .option('--dry', 'Dry run - show what would happen without executing')
    .option('--explain', 'Show explanation before replay')
    .option('--diff', 'Show diff between original and current config')
    .action(async (id, options) => {
      const system = new CapabilitySystem();

      let mode: ReplayMode = 'strict';
      if (options.compatible) mode = 'compatible';
      if (options.reEvaluate) mode = 're-evaluate';

      // Handle diff option
      if (options.diff) {
        const record = loadExecutionRecord(id);
        if (!record) {
          console.log(chalk.red(`‚ùå Execution record "${id}" not found\n`));
          return;
        }

        // Create a "current" record with current config
        const currentConfig = system.loadMergedConfig();
        const currentRecord: any = {
          ...record,
          configSnapshot: currentConfig,
          decision: {
            ...record.decision,
            // In a real scenario, we'd re-evaluate the decision
            // For now, use the same decision
          },
        };

        const diff = diffExecution(record, currentRecord);
        console.log(formatReplayDiff(diff));

        // If --diff is combined with --dry, exit after showing diff
        if (options.dry) {
          console.log(chalk.gray('\n[Dry] Diff shown, no execution\n'));
          return;
        }

        // Otherwise, proceed with replay
        console.log('');
      }

      const result = await system.replayExecution(id, {
        mode,
        skipAI: true,
        verbose: options.verbose,
        dry: options.dry,
        explain: options.explain,
      });

      if (result.success) {
        console.log(chalk.green(`‚úÖ ${result.message}`));
        if (result.executedModel) {
          console.log(chalk.gray(`Model: ${result.executedModel}`));
        }
      } else {
        console.log(chalk.red(`‚ùå ${result.message}`));
      }
    });
}

````

## üìÑ `commands/shellCompletions.ts`

````typescript
import readline from 'readline';
import fs from 'fs';
import path from 'path';
import { spawn } from 'child_process';
import { execSync } from 'child_process';

/* ========================================
   TYPE DEFINITIONS
   ======================================== */

export type Mode = 'chat' | 'file' | 'dir' | 'command';

export interface CompletionContext {
    line: string;
    cursor: number;
    mode: Mode;
    cwd: string;
}

export interface CommandPlugin {
    command: string;
    complete(args: string[], context: CompletionContext): string[];
}

/* ========================================
   PROJECT CONTEXT
   ======================================== */

let PROJECT_ROOT: string | null = null;

export function findProjectRoot(start = process.cwd()): string {
    if (PROJECT_ROOT) return PROJECT_ROOT;

    let dir = start;
    const MAX_DEPTH = 10;
    let depth = 0;

    while (dir !== path.dirname(dir) && depth < MAX_DEPTH) {
        if (fs.existsSync(path.join(dir, 'package.json')) ||
            fs.existsSync(path.join(dir, '.git'))) {
            PROJECT_ROOT = dir;
            return dir;
        }
        dir = path.dirname(dir);
        depth++;
    }

    PROJECT_ROOT = start;
    return start;
}

const PRIORITY_DIRS = ['src', 'packages', 'apps', 'lib', 'components'];

export function sortEntries(entries: fs.Dirent[]): fs.Dirent[] {
    return entries.sort((a, b) => {
        const ai = PRIORITY_DIRS.indexOf(a.name);
        const bi = PRIORITY_DIRS.indexOf(b.name);

        if (ai === -1 && bi === -1) return 0;
        if (ai === -1) return 1;
        if (bi === -1) return -1;
        return ai - bi;
    });
}

/* ========================================
   CACHING SYSTEM
   ======================================== */

interface CacheEntry<T> {
    ts: number;
    value: T;
}

const cache = new Map<string, CacheEntry<any>>();
const TTL = 2000; // 2 seconds

export function cached<T>(key: string, fn: () => T): T {
    const now = Date.now();
    const hit = cache.get(key);

    if (hit && now - hit.ts < TTL) {
        return hit.value;
    }

    const value = fn();
    cache.set(key, { ts: now, value });
    return value;
}

export function clearCache(): void {
    cache.clear();
}

/* ========================================
   MODE DETECTION
   ======================================== */

export function detectMode(line: string): Mode {
    const trimmed = line.trimStart();

    // Check for explicit command prefixes
    if (trimmed.startsWith('$') || trimmed.startsWith('!')) {
        return 'command';
    }

    const tokens = line.split(/\s+/);
    const last = tokens[tokens.length - 1];

    // Check for file reference (@)
    if (last?.startsWith('@')) {
        return 'file';
    }

    // Check for directory reference (#)
    if (last?.startsWith('#')) {
        return 'dir';
    }

    // Check if first token is a command (fish-style)
    const first = tokens[0];
    if (first) {
        const commands = loadCommands();
        if (commands.includes(first)) {
            return 'command';
        }
    }

    // Default to chat mode
    return 'chat';
}

/* ========================================
   COMMAND COMPLETION (PATH)
   ======================================== */

let commandCache: string[] | null = null;

// Common shell builtins that should always be available
const SHELL_BUILTINS = [
    'cd', 'pwd', 'ls', 'mkdir', 'rmdir', 'rm', 'cp', 'mv', 'cat',
    'echo', 'grep', 'find', 'head', 'tail', 'less', 'more',
    'chmod', 'chown', 'touch', 'ln', 'df', 'du', 'free',
    'ps', 'top', 'kill', 'killall', 'bg', 'fg', 'jobs',
    'export', 'unset', 'env', 'alias', 'unalias',
    'history', 'type', 'which', 'whereis', 'man',
    'sleep', 'wait', 'date', 'cal', 'uptime', 'uname',
    'tar', 'gzip', 'gunzip', 'zip', 'unzip',
    'curl', 'wget', 'ssh', 'scp', 'rsync'
];

export function loadCommands(): string[] {
    return cached('PATH_COMMANDS', () => {
        const paths = process.env.PATH?.split(path.delimiter) ?? [];
        const cmds = new Set<string>(SHELL_BUILTINS);

        for (const p of paths) {
            try {
                for (const f of fs.readdirSync(p)) {
                    cmds.add(f);
                }
            } catch {
                // Ignore directories we can't read
            }
        }

        commandCache = [...cmds];
        return commandCache;
    });
}

export function completeCommands(partial: string): string[] {
    return loadCommands().filter(cmd => cmd.startsWith(partial));
}

/* ========================================
   FILE/DIRECTORY COMPLETION
   ======================================== */

function splitToken(line: string): { prefix: string; token: string } {
    const match = line.match(/(.+?\s)?([^\s]*)$/);
    return {
        prefix: match?.[1] ?? '',
        token: match?.[2] ?? ''
    };
}

export function completePath(
    raw: string,
    type: 'file' | 'dir'
): string[] {
    // Remove sigil (@ or #)
    const withoutSigil = raw.slice(1);

    // Handle case: only sigil (e.g., "@")
    if (!withoutSigil) {
        const currentDir = process.cwd();
        try {
            let entries = fs.readdirSync(currentDir, { withFileTypes: true });
            entries = sortEntries(entries);
            return entries
                .filter(e => type === 'file' ? e.isFile() : e.isDirectory())
                .map(e => (type === 'file' ? '@' : '#') + e.name);
        } catch {
            return [];
        }
    }

    // Extract base directory and partial name
    const baseDir = withoutSigil.includes(path.sep)
        ? path.dirname(withoutSigil)
        : '.';

    const partial = withoutSigil.includes(path.sep)
        ? path.basename(withoutSigil)
        : withoutSigil;

    const resolvedBase = path.resolve(baseDir);

    if (!fs.existsSync(resolvedBase) || !fs.statSync(resolvedBase).isDirectory()) {
        return [];
    }

    let entries: fs.Dirent[];
    try {
        entries = fs.readdirSync(resolvedBase, { withFileTypes: true });
        entries = sortEntries(entries);
    } catch {
        return [];
    }

    return entries
        .filter(e => {
            const matchesPrefix = e.name.startsWith(partial);
            if (!matchesPrefix) return false;
            return type === 'file' ? e.isFile() : e.isDirectory();
        })
        .map(e => {
            const fullName = (baseDir === '.' ? '' : baseDir + path.sep) + e.name;
            const sigil = type === 'file' ? '@' : '#';
            return sigil + fullName;
        });
}

/* ========================================
   FILE:LINE COMPLETION
   ======================================== */

export function completeFileWithLine(token: string): string[] {
    const [filePath, linePart] = token.slice(1).split(':');

    if (!filePath) {
        return completePath('@' + token, 'file');
    }

    const absolutePath = path.resolve(filePath);

    if (!fs.existsSync(absolutePath)) {
        return [];
    }

    if (linePart !== undefined) {
        // Suggest common line numbers
        const lineNums = ['1', '10', '20', '50', '100', '200'];
        const matches = lineNums.filter(ln => ln.startsWith(linePart));
        return matches.map(ln => '@' + filePath + ':' + ln);
    }

    // File exists, add colon for line input
    return ['@' + filePath + ':'];
}

/* ========================================
   ARGUMENT COMPLETION (GIT, etc.)
   ======================================== */

export function completeGitArgs(args: string[]): string[] {
    try {
        if (args.length <= 1) {
            // Complete subcommands
            const subcommands = [
                'add', 'branch', 'checkout', 'commit', 'diff',
                'log', 'merge', 'pull', 'push', 'rebase',
                'status', 'reset', 'revert', 'stash'
            ];
            return subcommands.filter(cmd => cmd.startsWith(args[1] || ''));
        }

        if (args[1] === 'checkout' && args.length <= 2) {
            // Complete branches
            try {
                const branches = execSync('git branch --all', {
                    encoding: 'utf8',
                    cwd: process.cwd()
                });
                return branches
                    .split('\n')
                    .map(l => l.replace(/^[* ]+/, '').trim())
                    .filter(b => b && b.startsWith(args[2] || ''));
            } catch {
                return [];
            }
        }
    } catch {
        // Not in a git repo or git not available
    }

    return [];
}

/* ========================================
   SMART COMPLETER (Main Entry)
   ======================================== */

export function createCompleter(): readline.Completer {
    return (line: string) => {
        try {
            const mode = detectMode(line);
            const { prefix, token } = splitToken(line);

            if (mode === 'file' && token.startsWith('@')) {
                if (token.includes(':')) {
                    // File:line mode
                    const matches = completeFileWithLine(token);
                    return [matches, token];
                }

                // File completion
                const matches = completePath(token, 'file');
                return [matches, token];
            }

            if (mode === 'dir' && token.startsWith('#')) {
                // Directory completion
                const matches = completePath(token, 'dir');
                return [matches, token];
            }

            if (mode === 'command') {
                // Command completion
                const cmdLine = line.replace(/^[$!]/, '');
                const parts = cmdLine.split(/\s+/);
                const cmd = parts[0];
                const current = parts[parts.length - 1] || '';

                // Git argument completion
                if (cmd === 'git') {
                    const matches = completeGitArgs(parts);
                    const filtered = matches.filter(m => m.startsWith(current));
                    return [filtered, current];
                }

                // General command completion
                const matches = completeCommands(current);
                return [matches, current];
            }

            // Default: no completion in chat mode
            return [[], line];
        } catch (error) {
            // Fail gracefully
            return [[], line];
        }
    };
}

/* ========================================
   COMMAND EXECUTION
   ======================================== */

export async function executeCommand(
    cmdLine: string,
    onExit?: (code: number | null) => void
): Promise<void> {
    const trimmed = cmdLine.trim();
    const command = trimmed.replace(/^[$!]\s*/, '');

    const child = spawn(command, {
        stdio: 'inherit',
        shell: true,
        cwd: process.cwd()
    });

    child.on('exit', (code) => {
        if (onExit) {
            onExit(code);
        }
    });

    child.on('error', (err) => {
        console.error(`\n[Command Error]: ${err.message}`);
        if (onExit) {
            onExit(1);
        }
    });

    return new Promise((resolve) => {
        child.on('close', () => resolve());
    });
}

/* ========================================
   GHOST TEXT (Suggestions)
   ======================================== */

let currentGhostText = '';

export function predictGhostText(line: string): string {
    const mode = detectMode(line);

    if (mode === 'command') {
        const cmdLine = line.replace(/^[$!]/, '');

        // Git suggestions
        if (cmdLine === 'git ch') return 'eckout';
        if (cmdLine === 'git st') return 'atus';
        if (cmdLine === 'git co') return 'mmit';

        // NPM suggestions
        if (cmdLine === 'npm r') return 'un dev';
        if (cmdLine === 'npm b') return 'uild';

        // LS suggestions
        if (cmdLine === 'ls -') return 'la';

        // Common patterns
        if (cmdLine === 'gi') return 't';
    }

    return '';
}

export function renderGhost(rl: readline.Interface): void {
    if (!currentGhostText) return;
    process.stdout.write(`\x1b[90m${currentGhostText}\x1b[0m`);
}

export function clearGhost(rl: readline.Interface): void {
    if (currentGhostText) {
        process.stdout.write(`\x1b[2K\r`);
        currentGhostText = '';
    }
}

export function updateGhost(line: string): void {
    currentGhostText = predictGhostText(line);
}

/* ========================================
   PLUGIN SYSTEM
   ======================================== */

const plugins = new Map<string, CommandPlugin>();
const PLUGIN_DIR = path.join(findProjectRoot(), '.shell', 'plugins');

export function loadPlugins(): void {
    if (!fs.existsSync(PLUGIN_DIR)) {
        try {
            fs.mkdirSync(PLUGIN_DIR, { recursive: true });
        } catch {
            // Can't create plugin directory
        }
        return;
    }

    try {
        for (const file of fs.readdirSync(PLUGIN_DIR)) {
            if (file.endsWith('.js') || file.endsWith('.ts')) {
                try {
                    const pluginPath = path.join(PLUGIN_DIR, file);
                    const plugin = require(pluginPath);
                    if (plugin.command && plugin.complete) {
                        plugins.set(plugin.command, plugin);
                    }
                } catch {
                    // Invalid plugin
                }
            }
        }
    } catch {
        // Can't read plugin directory
    }
}

export function getPlugin(command: string): CommandPlugin | undefined {
    return plugins.get(command);
}

export function listPlugins(): string[] {
    return [...plugins.keys()];
}

/* ========================================
   INITIALIZE
   ======================================== */

export function initialize(): void {
    findProjectRoot();
    loadPlugins();
    loadCommands();
}

// Auto-initialize on import
initialize();

````

## üìÑ `commands/skillsCommands.ts`

````typescript
import chalk from 'chalk';
import { Command } from 'commander';
import { getAllSkills, computeSkillScore, Skill } from '../agent/skills';
import fs from 'fs';
import path from 'path';
import os from 'os';

const SKILLS_FILE = path.join(os.homedir(), '.yuangs_skills.json');

function loadSkills() {
    if (fs.existsSync(SKILLS_FILE)) {
        try {
            const data = fs.readFileSync(SKILLS_FILE, 'utf-8');
            return JSON.parse(data);
        } catch (e) {
            return [];
        }
    }
    return [];
}

function saveSkills(skills: any[]) {
    try {
        fs.writeFileSync(SKILLS_FILE, JSON.stringify(skills, null, 2));
    } catch (e) {
        console.error(chalk.red(`Failed to save skills to ${SKILLS_FILE}`));
    }
}

export function registerSkillsCommands(program: Command): void {
    const skillsProgram = program.command('skills').description('Skill management commands');

    skillsProgram
        .command('list')
        .description('List all skills')
        .action(() => {
            const skills = getAllSkills();
            const now = Date.now();

            if (skills.length === 0) {
                console.log(chalk.gray('üì≠ No skills found\n'));
                return;
            }

            console.log(chalk.bold.cyan(`\nüì¶ Skills (${skills.length})\n`));

            skills.forEach((skill) => {
                const status = skill.enabled ? chalk.green('‚úî') : chalk.gray('‚äò');
                const score = computeSkillScore(skill, now);
                const daysAgo = Math.floor((now - skill.lastUsed) / (1000 * 60 * 60 * 24));

                console.log(`${status} ${chalk.bold(skill.name)}`);
                console.log(chalk.gray(`  Confidence: ${(score * 100).toFixed(0)}%`));
                console.log(chalk.gray(`  Success: ${skill.successCount} / Failure: ${skill.failureCount}`));
                console.log(chalk.gray(`  Last used: ${daysAgo === 0 ? 'today' : `${daysAgo} days ago`}\n`));
            });
        });

    skillsProgram
        .command('explain <name>')
        .description('Explain a specific skill')
        .action((name) => {
            const skills = getAllSkills();
            const skill = skills.find(s => s.name === name || s.id === name);

            if (!skill) {
                console.log(chalk.red(`‚ùå Skill "${name}" not found\n`));
                return;
            }

            console.log(chalk.bold.cyan(`\nüìñ Skill Details: ${skill.name}\n`));
            console.log(chalk.white(`Description: ${skill.description}`));
            console.log(chalk.gray(`\nWhen to use:`));
            console.log(chalk.white(`  ${skill.whenToUse}`));
            console.log(chalk.gray(`\nMetrics:`));
            console.log(chalk.white(`  Success: ${skill.successCount} / Failure: ${skill.failureCount}`));
            console.log(chalk.white(`  Confidence: ${(skill.confidence * 100).toFixed(0)}%`));
            console.log(chalk.white(`  Enabled: ${skill.enabled ? 'Yes' : 'No'}`));
            console.log(chalk.gray(`\nCreated: ${new Date(skill.createdAt).toLocaleString()}`));
            console.log(chalk.gray(`Last used: ${new Date(skill.lastUsed).toLocaleString()}\n`));
        });

    skillsProgram
        .command('disable <name>')
        .description('Disable a skill')
        .action((name) => {
            const skills = loadSkills() as Skill[];
            const skillIndex = skills.findIndex(s => s.name === name || s.id === name);

            if (skillIndex === -1) {
                console.log(chalk.red(`‚ùå Skill "${name}" not found\n`));
                return;
            }

            if (!skills[skillIndex].enabled) {
                console.log(chalk.yellow(`‚ÑπÔ∏è  Skill "${name}" is already disabled\n`));
                return;
            }

            skills[skillIndex].enabled = false;
            saveSkills(skills);
            console.log(chalk.green(`‚úì Skill "${name}" has been disabled\n`));
        });

    skillsProgram
        .command('enable <name>')
        .description('Enable a skill')
        .action((name) => {
            const skills = loadSkills() as Skill[];
            const skillIndex = skills.findIndex(s => s.name === name || s.id === name);

            if (skillIndex === -1) {
                console.log(chalk.red(`‚ùå Skill "${name}" not found\n`));
                return;
            }

            if (skills[skillIndex].enabled) {
                console.log(chalk.yellow(`‚ÑπÔ∏è  Skill "${name}" is already enabled\n`));
                return;
            }

            skills[skillIndex].enabled = true;
            saveSkills(skills);
            console.log(chalk.green(`‚úì Skill "${name}" has been enabled\n`));
        });
}

````

## üìÑ `core/apps.ts`

````typescript
import { exec } from 'child_process';
import fs from 'fs';
import path from 'path';
import yaml from 'js-yaml';
import os from 'os';
import { DEFAULT_APPS, parseAppsConfig } from './validation';

export { DEFAULT_APPS };

export function loadAppsConfig(): Record<string, string> {
    const configPaths = [
        path.join(process.cwd(), 'yuangs.config.json'),
        path.join(process.cwd(), 'yuangs.config.yaml'),
        path.join(process.cwd(), 'yuangs.config.yml'),
        path.join(process.cwd(), '.yuangs.json'),
        path.join(process.cwd(), '.yuangs.yaml'),
        path.join(process.cwd(), '.yuangs.yml'),
        path.join(os.homedir(), '.yuangs.json'),
        path.join(os.homedir(), '.yuangs.yaml'),
        path.join(os.homedir(), '.yuangs.yml'),
    ];

    for (const configPath of configPaths) {
        if (fs.existsSync(configPath)) {
            try {
                const configContent = fs.readFileSync(configPath, 'utf8');
                let config: Record<string, string>;
                if (configPath.endsWith('.yaml') || configPath.endsWith('.yml')) {
                    config = yaml.load(configContent) as Record<string, string>;
                } else {
                    config = parseAppsConfig(configContent);
                }
                return config;
            } catch (error) { }
        }
    }
    return DEFAULT_APPS;
}


export function openUrl(url: string) {
    let command;
    switch (process.platform) {
        case 'darwin': command = `open "${url}"`; break;
        case 'win32': command = `start "${url}"`; break;
        default: command = `xdg-open "${url}"`; break;
    }
    exec(command);
}

````

## üìÑ `core/autofix.ts`

````typescript
import { OSProfile } from './os';
import { buildFixPrompt } from '../ai/prompt';
import { askAI } from '../ai/client';
import { safeParseJSON, AIFixPlan, aiFixPlanSchema } from './validation';

export async function autoFixCommand(
    originalCmd: string,
    stderr: string,
    os: OSProfile,
    model?: string
): Promise<AIFixPlan | null> {
    const prompt = buildFixPrompt(originalCmd, stderr, os);
    const raw = await askAI(prompt, model);

    const parseResult = safeParseJSON(raw, aiFixPlanSchema, {} as AIFixPlan);

    if (!parseResult.success) {
        return null;
    }

    return parseResult.data;
}

````

## üìÑ `core/capabilities.ts`

````typescript
export enum AtomicCapability {
  TEXT_GENERATION = 'text_generation',
  CODE_GENERATION = 'code_generation',
  TOOL_CALLING = 'tool_calling',
  LONG_CONTEXT = 'long_context',
  REASONING = 'reasoning',
  STREAMING = 'streaming',
}

export interface CompositeCapability {
  name: string;
  composedOf: AtomicCapability[];
}

export const COMPOSITE_CAPABILITIES: CompositeCapability[] = [
  {
    name: 'interactive_agent',
    composedOf: [AtomicCapability.TOOL_CALLING, AtomicCapability.REASONING],
  },
  {
    name: 'large_repo_analysis',
    composedOf: [AtomicCapability.LONG_CONTEXT, AtomicCapability.REASONING],
  },
  {
    name: 'safe_code_editing',
    composedOf: [AtomicCapability.CODE_GENERATION, AtomicCapability.REASONING],
  },
];

export enum ConstraintCapability {
  PREFER_DETERMINISTIC = 'prefer_deterministic',
  LOW_COST = 'low_cost',
  FAST_RESPONSE = 'fast_response',
}

export const CAPABILITY_VERSION = '1.0';

export function isAtomicCapability(value: string): value is AtomicCapability {
  return Object.values(AtomicCapability).includes(value as AtomicCapability);
}

export function isConstraintCapability(value: string): value is ConstraintCapability {
  return Object.values(ConstraintCapability).includes(value as ConstraintCapability);
}

export function resolveCompositeCapability(name: string): AtomicCapability[] {
  const composite = COMPOSITE_CAPABILITIES.find(c => c.name === name);
  if (!composite) {
    throw new Error(`Unknown composite capability: ${name}`);
  }
  return composite.composedOf;
}

export function expandCapabilities(
  capabilities: Array<AtomicCapability | string>
): Set<AtomicCapability> {
  const result = new Set<AtomicCapability>();

  for (const cap of capabilities) {
    if (isAtomicCapability(cap)) {
      result.add(cap);
    } else {
      const atomicCaps = resolveCompositeCapability(cap);
      atomicCaps.forEach(c => result.add(c));
    }
  }

  return result;
}

````

## üìÑ `core/capabilityInference.ts`

````typescript
import { AtomicCapability } from '../core/capabilities';
import type { CapabilityRequirement } from '../core/modelMatcher';

export function inferCapabilityRequirement(userInput: string): CapabilityRequirement {
  const required: AtomicCapability[] = [];

  const input = userInput.toLowerCase();

  if (input.includes('‰ª£Á†Å') || input.includes('script') || input.includes('Êñá‰ª∂') || input.includes('create') || input.includes('write')) {
    required.push(AtomicCapability.CODE_GENERATION);
  }

  if (input.includes('ÂàÜÊûê') || input.includes('ÁêÜËß£') || input.includes('Ëß£Èáä') || input.includes('Êé®ÁêÜ')) {
    required.push(AtomicCapability.REASONING);
  }

  if (input.includes('Èïø') || input.includes('large') || input.includes('‰ªìÂ∫ì') || input.includes('ÁõÆÂΩï') || input.includes('ÊâÄÊúâÊñá‰ª∂')) {
    required.push(AtomicCapability.LONG_CONTEXT);
  }

  return {
    required: Array.from(new Set(required)),
    preferred: [],
  };
}

````

## üìÑ `core/capabilitySystem.ts`

````typescript
import {
  CapabilityRequirement,
  matchModelWithFallback,
  ModelCapabilities,
  CapabilityMatchResult,
} from './modelMatcher';
import {
  mergeConfigs,
  loadConfigAt,
  dumpConfigSnapshot,
  getConfigFilePaths,
  MergedConfig,
} from './configMerge';
import {
  createExecutionRecord,
  ExecutionRecord,
} from './executionRecord';
import {
  saveExecutionRecord,
  loadExecutionRecord,
  listExecutionRecords,
} from './executionStore';
import { replayEngine, ReplayOptions, ReplayResult } from './replayEngine';

export class CapabilitySystem {
  private primaryModels: ModelCapabilities[] = [];
  private fallbackModels: ModelCapabilities[] = [];

  constructor() {
    this.initializeDefaultModels();
  }

  private initializeDefaultModels(): void {
    // ÂàùÂßãÂåñ‰∏∫Á©∫Êï∞ÁªÑÔºåËÆ©ÈÖçÁΩÆÊñá‰ª∂Êàê‰∏∫‰∏ªË¶ÅÊù•Ê∫ê
    this.primaryModels = [];
    this.fallbackModels = [];
  }

  matchCapability(requirement: CapabilityRequirement): CapabilityMatchResult {
    const allModels = this.getAllModels();
    const primaryModels = [...this.primaryModels, ...this.loadCustomModels()];
    return matchModelWithFallback(
      primaryModels,
      this.fallbackModels,
      requirement
    );
  }

  loadMergedConfig(): MergedConfig {
    const builtin = {
      aiProxyUrl: 'https://aiproxy.want.biz/v1/chat/completions',
      defaultModel: 'Assistant',
      accountType: 'paid',
    };

    const filePaths = getConfigFilePaths();
    const projectConfig = filePaths.project ? loadConfigAt(filePaths.project) : null;
    const userGlobal = loadConfigAt(filePaths.userGlobal);

    return mergeConfigs(builtin, userGlobal, projectConfig, null);
  }

  loadCustomModels(): ModelCapabilities[] {
    const filePaths = getConfigFilePaths();
    const projectConfig = filePaths.project ? loadConfigAt(filePaths.project) : null;
    const userGlobal = loadConfigAt(filePaths.userGlobal);

    const customModelsArray = [];
    if (userGlobal?.models && Array.isArray(userGlobal.models)) {
      customModelsArray.push(...userGlobal.models as ModelCapabilities[]);
    }
    if (projectConfig?.models && Array.isArray(projectConfig.models)) {
      customModelsArray.push(...projectConfig.models as ModelCapabilities[]);
    }

    return customModelsArray;
  }

  getAllModels(): ModelCapabilities[] {
    const customModels = this.loadCustomModels();
    return [...this.primaryModels, ...this.fallbackModels, ...customModels];
  }

  createAndSaveExecutionRecord(
    commandName: string,
    requirement: CapabilityRequirement,
    matchResult: CapabilityMatchResult,
    command?: string
  ): string {
    const config = this.loadMergedConfig();
    const record = createExecutionRecord(
      commandName,
      requirement,
      config,
      matchResult,
      { success: matchResult.selected !== null },
      command
    );

    const filePath = saveExecutionRecord(record);
    return record.id;
  }

  replayExecution(recordId: string, options: ReplayOptions): Promise<ReplayResult> {
    return replayEngine.replay(recordId, options);
  }

  explainConfig(): string {
    const config = this.loadMergedConfig();
    return dumpConfigSnapshot(config);
  }
}

export const capabilitySystem = new CapabilitySystem();

````

## üìÑ `core/completion.legacy.ts`

````typescript
import fs from 'fs';
import path from 'path';
import { Command } from 'commander';
import { loadAppsConfig } from './apps';
import { getMacros } from './macros';
export function getAllCommands(program: Command): string[] {
    const commands: string[] = [];

    program.commands.forEach(cmd => {
        if (cmd.name()) {
            commands.push(cmd.name());
        }
        if (cmd.aliases()) {
            commands.push(...cmd.aliases());
        }
    });

    try {
        const apps = loadAppsConfig();
        Object.keys(apps).forEach(app => {
            if (!commands.includes(app)) {
                commands.push(app);
            }
        });
    } catch {
    }

    try {
        const macros = getMacros();
        Object.keys(macros).forEach(macro => {
            if (!commands.includes(macro)) {
                commands.push(macro);
            }
        });
    } catch {
    }

    return [...new Set(commands)].sort();
}

/**
 * Ëé∑ÂèñÂëΩ‰ª§ÁöÑÂ≠êÂëΩ‰ª§ÊàñÂèÇÊï∞
 */
export function getCommandSubcommands(program: Command, commandName: string): string[] {
    const command = program.commands.find(cmd => cmd.name() === commandName);
    if (!command) return [];

    const subcommands: string[] = [];

    command.commands.forEach(cmd => {
        if (cmd.name()) {
            subcommands.push(cmd.name());
        }
    });

    command.options.forEach(opt => {
        opt.flags.split(/[, ]+/).forEach(flag => {
            if (flag.startsWith('--')) {
                subcommands.push(flag);
            } else if (flag.startsWith('-')) {
                subcommands.push(flag);
            }
        });
    });

    return [...new Set(subcommands)].sort();
}

/**
 * ÁîüÊàê Bash Ë°•ÂÖ®ËÑöÊú¨
 */
export function generateBashCompletion(program: Command): string {
    const commands = getAllCommands(program);

    return `#!/bin/bash
# yuangs bash completion

_yuangs_completion() {
    local cur prev words cword
    _init_completion || return

    # Ë°•ÂÖ®ÂëΩ‰ª§Âêç
    if [[ \${COMP_CWORD} -eq 1 ]]; then
        COMPREPLY=($(compgen -W '${commands.join(' ')}' -- "\${cur}"))
        return
    fi

    # Ë°•ÂÖ®Â≠êÂëΩ‰ª§ÂíåÂèÇÊï∞
    local cmd="\${words[1]}"
    case "\${cmd}" in
        ${commands.map(cmd => `
        ${cmd})
            case "\${prev}" in
                -m|--model)
                    COMPREPLY=($(compgen -W "gemini-2.5-flash-lite gemini-2.5-pro" -- "\${cur}"))
                    ;;
                *)
                    COMPREPLY=($(compgen -W "$(yuangs _complete_subcommand ${cmd})" -- "\${cur}"))
                    ;;
            esac
            ;;
        `).join('\n')}

        *)
            ;;
    esac
}

complete -F _yuangs_completion yuangs
`;
}

/**
 * ÁîüÊàê Zsh Ë°•ÂÖ®ËÑöÊú¨
 */
export function generateZshCompletion(program: Command): string {
    const commands = getAllCommands(program);

    return `#compdef yuangs
# yuangs zsh completion

_yuangs() {
    local -a commands
    commands=(
${commands.map(cmd => `        '${cmd}:$(yuangs _describe ${cmd})'`).join('\n')}
    )

    if (( CURRENT == 2 )); then
        _describe 'command' commands
    else
        local cmd="\${words[2]}"
        case "\${cmd}" in
${commands.map(cmd => `
            ${cmd})
                _values 'options' $(yuangs _complete_subcommand ${cmd})
                ;;
`).join('\n')}
            *)
                ;;
        esac
    fi
}

_yuangs
`;
}

export async function installBashCompletion(program: Command): Promise<boolean> {
    const bashrcPath = path.join(process.env.HOME || '', '.bashrc');
    const bashCompletionDir = path.join(process.env.HOME || '', '.bash_completion.d');

    try {
        if (!fs.existsSync(bashCompletionDir)) {
            fs.mkdirSync(bashCompletionDir, { recursive: true });
        }

        const completionPath = path.join(bashCompletionDir, 'yuangs-completion.bash');
        const completionScript = generateBashCompletion(program);

        fs.writeFileSync(completionPath, completionScript, { mode: 0o644 });
        const sourceLine = `# yuangs completion
if [ -f ~/.bash_completion.d/yuangs-completion.bash ]; then
    source ~/.bash_completion.d/yuangs-completion.bash
fi
`;

        let bashrc = '';
        if (fs.existsSync(bashrcPath)) {
            bashrc = fs.readFileSync(bashrcPath, 'utf-8');
        }

        if (!bashrc.includes('yuangs-completion.bash')) {
            fs.appendFileSync(bashrcPath, `\n${sourceLine}`);
        }

        return true;
    } catch (error) {
        console.error('ÂÆâË£Ö Bash Ë°•ÂÖ®Â§±Ë¥•:', error);
        return false;
    }
}

export async function installZshCompletion(program: Command): Promise<boolean> {
    const zshrcPath = path.join(process.env.HOME || '', '.zshrc');
    const zfuncDir = path.join(process.env.HOME || '', '.zfunctions');

    try {
        if (!fs.existsSync(zfuncDir)) {
            fs.mkdirSync(zfuncDir, { recursive: true });
        }

        const completionPath = path.join(zfuncDir, '_yuangs');
        const completionScript = generateZshCompletion(program);

        fs.writeFileSync(completionPath, completionScript, { mode: 0o644 });
        let zshrc = '';
        if (fs.existsSync(zshrcPath)) {
            zshrc = fs.readFileSync(zshrcPath, 'utf-8');
        }

        const fpathLine = 'fpath=(~/.zfunctions $fpath)';
        const autoloadLine = 'autoload -U compinit && compinit';

        if (!zshrc.includes('fpath=')) {
            fs.appendFileSync(zshrcPath, `\n${fpathLine}`);
        }

        if (!zshrc.includes('autoload -U compinit')) {
            fs.appendFileSync(zshrcPath, `\n${autoloadLine}`);
        }

        return true;
    } catch (error) {
        console.error('ÂÆâË£Ö Zsh Ë°•ÂÖ®Â§±Ë¥•:', error);
        return false;
    }
}

/**
 * Ëé∑ÂèñÂëΩ‰ª§ÊèèËø∞ÔºàÁî®‰∫éË°•ÂÖ®ÊèêÁ§∫Ôºâ
 */
export function getCommandDescription(program: Command, commandName: string): string {
    const command = program.commands.find(cmd => cmd.name() === commandName);
    return command?.description() || '';
}

````

## üìÑ `core/completion/builtin.ts`

````typescript
import type { CompletionItem } from './types';

export function getBuiltinCommands(): Array<{ name: string; description: string }> {
  return [
    { name: 'ai', description: 'Âêë AI ÊèêÈóÆ' },
    { name: 'list', description: 'ÂàóÂá∫ÊâÄÊúâÂ∫îÁî®' },
    { name: 'history', description: 'Êü•ÁúãÂèäÊâßË°åÂëΩ‰ª§ÂéÜÂè≤' },
    { name: 'config', description: 'ÁÆ°ÁêÜÊú¨Âú∞ÈÖçÁΩÆ' },
    { name: 'macros', description: 'Êü•ÁúãÊâÄÊúâÂø´Êç∑Êåá‰ª§' },
    { name: 'save', description: '‰øùÂ≠òÂø´Êç∑Êåá‰ª§' },
    { name: 'run', description: 'ÊâßË°åÂø´Êç∑Êåá‰ª§' },
    { name: 'help', description: 'ÊòæÁ§∫Â∏ÆÂä©‰ø°ÊÅØ' },
    { name: 'completion', description: 'ÂÆâË£Ö Shell Ë°•ÂÖ®' },
    { name: 'shici', description: 'ÊâìÂºÄÂè§ËØóËØç PWA' },
    { name: 'dict', description: 'ÊâìÂºÄËã±ËØ≠ËØçÂÖ∏' },
    { name: 'pong', description: 'ÊâìÂºÄ Pong Ê∏∏Êàè' }
  ];
}

````

## üìÑ `core/completion/cache.ts`

````typescript
import type { CompletionItem } from './types';

export class CompletionCache {
  private static instance: CompletionCache;
  private cache: Map<string, CompletionItem[]>;
  private timestamp: number;
  private readonly ttl: number = 5000;

  private constructor() {
    this.cache = new Map();
    this.timestamp = Date.now();
  }

  static getInstance(): CompletionCache {
    if (!CompletionCache.instance) {
      CompletionCache.instance = new CompletionCache();
    }
    return CompletionCache.instance;
  }

  get(key: string): CompletionItem[] | null {
    const now = Date.now();
    if (now - this.timestamp > this.ttl) {
      this.cache.clear();
      this.timestamp = now;
      return null;
    }
    return this.cache.get(key) || null;
  }

  set(key: string, items: CompletionItem[]): void {
    this.cache.set(key, items);
  }

  invalidate(): void {
    this.cache.clear();
    this.timestamp = 0;
  }

  invalidatePattern(pattern: RegExp): void {
    for (const key of this.cache.keys()) {
      if (pattern.test(key)) {
        this.cache.delete(key);
      }
    }
  }
}

````

## üìÑ `core/completion/index.ts`

````typescript
import { CompletionRequest, CompletionResponse } from './types';
import { resolveCompletion } from './resolver';

export async function complete(
  req: CompletionRequest
): Promise<CompletionResponse> {
  if (!Array.isArray(req.words)) {
    return { items: [], isPartial: false };
  }

  if (
    typeof req.currentIndex !== 'number' ||
    req.currentIndex < 0 ||
    req.currentIndex >= req.words.length
  ) {
    return { items: [], isPartial: false };
  }

  return resolveCompletion(req);
}

export { setProgramInstance } from './resolver';

export {
  getAllCommands,
  getCommandSubcommands,
  getCommandDescription,
  installBashCompletion,
  installZshCompletion
} from '../completion.legacy';

````

## üìÑ `core/completion/path.ts`

````typescript
import fs from 'fs';
import path from 'path';

export type PathKind = 'file' | 'dir';

export function resolvePathSuggestions(
  input: string,
  kind: PathKind
): string[] {
  const cwd = process.cwd();
  const normalized = input.replace(/^~(?=$|\/)/, process.env.HOME || '');
  const isDirInput = normalized.endsWith(path.sep);

  const baseDir = isDirInput
    ? path.resolve(cwd, normalized)
    : path.resolve(cwd, path.dirname(normalized));

  const prefix = isDirInput ? '' : path.basename(normalized);

  try {
    const entries = fs.readdirSync(baseDir, { withFileTypes: true });
    return entries
      .filter(e => !e.name.startsWith('.'))
      .filter(e => {
        if (kind === 'file') return e.isFile();
        return e.isDirectory();
      })
      .filter(e => e.name.startsWith(prefix))
      .map(e => {
        const fullPath = path.join(baseDir, e.name);
        const suggestion = e.isDirectory()
          ? fullPath + path.sep
          : fullPath;
        return suggestion.replace(/^\\/g, '');
      });
  } catch {
    return [];
  }
}

````

## üìÑ `core/completion/resolver.ts`

````typescript
import { CompletionRequest, CompletionResponse, CompletionItem } from './types';
import { unique } from './utils';
import { getBuiltinCommands } from './builtin';
import { loadAppsConfig } from '../apps';
import { getMacros } from '../macros';
import { Command } from 'commander';

let programInstance: Command | null = null;

export function setProgramInstance(program: Command): void {
  programInstance = program;
}

function getProgramInstance(): Command {
  return programInstance || ({} as Command);
}

export async function resolveCompletion(
  req: CompletionRequest
): Promise<CompletionResponse> {
  const { words, currentIndex } = req;

  const currentWord = words[currentIndex] ?? '';
  const previousWord = words[currentIndex - 1] ?? '';

  if (currentIndex === 1) {
    return completeTopLevel(currentWord);
  }

  return completeSubcommand(words.slice(1, currentIndex), currentWord, previousWord);
}

function completeTopLevel(prefix: string): CompletionResponse {
  const items: CompletionItem[] = [];

  const commands = getBuiltinCommands();
  commands.forEach(cmd => {
    items.push({ label: cmd.name });
  });

  try {
    const apps = loadAppsConfig();
    Object.keys(apps).forEach(name => {
      if (!items.find(i => i.label === name)) {
        items.push({ label: name });
      }
    });
  } catch {}

  try {
    const macros = getMacros();
    Object.keys(macros).forEach(name => {
      if (!items.find(i => i.label === name)) {
        items.push({ label: name });
      }
    });
  } catch {}

  const filtered = items.filter(item => item.label.startsWith(prefix));

  return {
    items: unique(filtered),
    isPartial: true
  };
}

function completeSubcommand(
  path: string[],
  prefix: string,
  prev: string
): CompletionResponse {
  const items: CompletionItem[] = [];

  if (prev === '--model' || prev === '-m') {
    items.push(
      { label: 'gemini-2.5-flash-lite' },
      { label: 'gemini-2.5-pro' },
      { label: 'Assistant' },
      { label: 'GPT-4o-mini' }
    );
  } else if (path.length > 0) {
    const baseCommand = path[0];
    const cmd = getProgramInstance().commands.find((c: any) => c.name() === baseCommand);

    if (cmd) {
      cmd.options.forEach((opt: any) => {
        opt.flags.split(/[, ]+/).forEach((flag: string) => {
          if (flag.startsWith('-') && !flag.startsWith('--')) {
            items.push({ label: flag });
          }
        });
      });

      cmd.commands.forEach((subcmd: any) => {
        items.push({ label: subcmd.name() });
      });
    }
  }

  const filtered = items.filter(item => item.label.startsWith(prefix));

  return {
    items: unique(filtered),
    isPartial: true
  };
}

````

## üìÑ `core/completion/types.ts`

````typescript
// core/completion/types.ts

/**
 * yuangs Completion Protocol v1.1
 * ÁªàÊÄÅË°•ÂÖ®ÂçèËÆÆ - ÂîØ‰∏Ä„ÄÅÂº∫Á∫¶Êùü
 */

export interface CompletionRequest {
  /**
   * ÂÆåÊï¥ argvÔºå‰∏çÂåÖÂê´ node
   * e.g. ['yuangs', 'ai', 'chat', '--m']
   */
  words: string[];

  /**
   * cursor ÊâÄÂú® index
   */
  currentIndex: number;
}

export interface CompletionItem {
  label: string;
  insertText?: string;
  detail?: string;
}

export interface CompletionResponse {
  items: CompletionItem[];
  isPartial: boolean;
}

````

## üìÑ `core/completion/utils.ts`

````typescript
import { CompletionItem } from './types';

export function unique(items: CompletionItem[]): CompletionItem[] {
  const seen = new Set<string>();
  return items.filter(i => {
    if (seen.has(i.label)) return false;
    seen.add(i.label);
    return true;
  });
}

````

## üìÑ `core/configMerge.ts`

````typescript
import fs from 'fs';
import path from 'path';
import os from 'os';
import yaml from 'js-yaml';

export type ConfigSource = 'built-in' | 'user-global' | 'project' | 'command-override';

export interface ConfigFieldSource<T = unknown> {
  value: T;
  source: ConfigSource;
  filePath?: string;
}

export interface MergedConfig {
  aiProxyUrl: ConfigFieldSource<string>;
  defaultModel: ConfigFieldSource<string>;
  accountType: ConfigFieldSource<'free' | 'pro'>;
  [key: string]: ConfigFieldSource<unknown>;
}

export function loadConfigAt(filePath: string): Record<string, unknown> | null {
  if (!fs.existsSync(filePath)) {
    return null;
  }

  try {
    const content = fs.readFileSync(filePath, 'utf8');
    if (filePath.endsWith('.yaml') || filePath.endsWith('.yml')) {
      return yaml.load(content) as Record<string, unknown>;
    }
    return JSON.parse(content);
  } catch (error) {
    console.warn(`Failed to load config from ${filePath}:`, error);
    return null;
  }
}

export function mergeConfigs(
  builtin: Record<string, unknown>,
  userGlobal: Record<string, unknown> | null,
  project: Record<string, unknown> | null,
  commandOverride: Record<string, unknown> | null
): MergedConfig {
  const merged: MergedConfig = {} as MergedConfig;

  const addField = (key: string, value: unknown, source: ConfigSource, filePath?: string) => {
    merged[key] = { value, source, filePath };
  };

  Object.entries(builtin).forEach(([key, value]) => {
    addField(key, value, 'built-in');
  });

  if (userGlobal) {
    Object.entries(userGlobal).forEach(([key, value]) => {
      addField(key, value, 'user-global', path.join(os.homedir(), '.yuangs.json'));
    });
  }

  if (project) {
    Object.entries(project).forEach(([key, value]) => {
      addField(key, value, 'project');
    });
  }

  if (commandOverride) {
    Object.entries(commandOverride).forEach(([key, value]) => {
      addField(key, value, 'command-override');
    });
  }

  return merged;
}

export function dumpConfigSnapshot(config: MergedConfig): string {
  const output: Record<string, any> = {};

  Object.entries(config).forEach(([key, field]) => {
    output[key] = {
      value: field.value,
      source: field.source,
      filePath: field.filePath,
    };
  });

  return JSON.stringify(output, null, 2);
}

function findProjectConfig(cwd = process.cwd()): string | null {
  let dir = cwd;
  const configFiles = ['.yuangs.json', '.yuangs.yaml', '.yuangs.yml', 'yuangs.config.json'];

  while (dir && dir !== path.dirname(dir)) {
    for (const filename of configFiles) {
      const candidate = path.join(dir, filename);
      if (fs.existsSync(candidate)) {
        return candidate;
      }
    }
    dir = path.dirname(dir);
  }

  const root = path.parse(cwd).root;
  for (const filename of configFiles) {
    const rootCandidate = path.join(root, filename);
    if (fs.existsSync(rootCandidate)) {
      return rootCandidate;
    }
  }

  return null;
}

export function getConfigFilePaths(): {
  userGlobal: string;
  project: string | null;
} {
  return {
    userGlobal: path.join(os.homedir(), '.yuangs.json'),
    project: findProjectConfig(),
  };
}

````

## üìÑ `core/executionRecord.ts`

````typescript
import { MergedConfig } from './configMerge';
import { ModelCapabilities, CapabilityMatchExplanation } from './modelMatcher';
import { CapabilityRequirement } from './modelMatcher';
import { Skill } from '../agent/skills';

export interface ExecutionMeta {
  commandName: string;
  timestamp: string;
  toolVersion: string;
  projectPath: string;
  args?: any;
  rawInput?: string;
  replayable?: boolean;
  version?: string;
}

export interface CapabilityIntent {
  required: string[];
  preferred: string[];
  capabilityVersion: string;
}

export interface ModelDecision {
  candidateModels: CapabilityMatchExplanation[];
  selectedModel: ModelCapabilities | null;
  usedFallback: boolean;
  fallbackReason?: string;
  strategy?: string;
  reason?: string;
  skills?: Skill[];
}

export interface ExecutionOutcome {
  success: boolean;
  failureReason?: 'capability-mismatch' | 'provider-error' | 'user-abort' | 'timeout' | 'other';
  tokenCount?: number;
  latencyMs?: number;
}

export interface ExecutionRecord {
  id: string;
  meta: ExecutionMeta;
  intent: CapabilityIntent;
  configSnapshot: MergedConfig;
  decision: ModelDecision;
  outcome: ExecutionOutcome;
  command?: string;
}

export function createExecutionId(): string {
  return `exec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

export function createExecutionRecord(
  commandName: string,
  requirement: CapabilityRequirement,
  config: MergedConfig,
  matchResult: any,
  outcome: Partial<ExecutionOutcome> = {},
  command?: string
): ExecutionRecord {
  const version = require('../../package.json').version;

  return {
    id: createExecutionId(),
    meta: {
      commandName,
      timestamp: new Date().toISOString(),
      toolVersion: version,
      projectPath: process.cwd(),
      version,
      replayable: true,
    },
    intent: {
      required: requirement.required.map(String),
      preferred: requirement.preferred.map(String),
      capabilityVersion: require('./capabilities').CAPABILITY_VERSION,
    },
    configSnapshot: config,
    decision: {
      candidateModels: matchResult.candidates || [],
      selectedModel: matchResult.selected,
      usedFallback: matchResult.fallbackOccurred,
    },
    outcome: {
      success: outcome.success ?? false,
      ...outcome,
    },
    command,
  };
}

export function serializeExecutionRecord(record: ExecutionRecord): string {
  return JSON.stringify(record, null, 2);
}

export function deserializeExecutionRecord(json: string): ExecutionRecord {
  return JSON.parse(json) as ExecutionRecord;
}

````

## üìÑ `core/executionStore.ts`

````typescript
import fs from 'fs';
import path from 'path';
import os from 'os';
import { ExecutionRecord, serializeExecutionRecord, deserializeExecutionRecord } from './executionRecord';

const RECORD_DIR = path.join(os.homedir(), '.yuangs', 'executions');

export function ensureRecordDir(): void {
  if (!fs.existsSync(RECORD_DIR)) {
    fs.mkdirSync(RECORD_DIR, { recursive: true });
  }
}

export function saveExecutionRecord(record: ExecutionRecord): string {
  ensureRecordDir();

  const filename = `${record.id}.json`;
  const filepath = path.join(RECORD_DIR, filename);

  fs.writeFileSync(filepath, serializeExecutionRecord(record), 'utf8');

  return filepath;
}

export function loadExecutionRecord(id: string): ExecutionRecord | null {
  ensureRecordDir();

  const filename = `${id}.json`;
  const filepath = path.join(RECORD_DIR, filename);

  if (!fs.existsSync(filepath)) {
    return null;
  }

  try {
    const content = fs.readFileSync(filepath, 'utf8');
    return deserializeExecutionRecord(content);
  } catch (error) {
    console.error(`Failed to load execution record ${id}:`, error);
    return null;
  }
}

export function listExecutionRecords(limit: number = 50): ExecutionRecord[] {
  ensureRecordDir();

  const files = fs.readdirSync(RECORD_DIR)
    .filter(f => f.endsWith('.json'))
    .sort((a, b) => {
      const statA = fs.statSync(path.join(RECORD_DIR, a));
      const statB = fs.statSync(path.join(RECORD_DIR, b));
      return statB.mtimeMs - statA.mtimeMs;
    })
    .slice(0, limit);

  const records: ExecutionRecord[] = [];

  for (const file of files) {
    const record = loadExecutionRecord(file.replace('.json', ''));
    if (record) {
      records.push(record);
    }
  }

  return records;
}

export function deleteExecutionRecord(id: string): boolean {
  ensureRecordDir();

  const filename = `${id}.json`;
  const filepath = path.join(RECORD_DIR, filename);

  if (!fs.existsSync(filepath)) {
    return false;
  }

  try {
    fs.unlinkSync(filepath);
    return true;
  } catch (error) {
    console.error(`Failed to delete execution record ${id}:`, error);
    return false;
  }
}

export function clearAllExecutionRecords(): void {
  ensureRecordDir();

  const files = fs.readdirSync(RECORD_DIR).filter(f => f.endsWith('.json'));

  for (const file of files) {
    const filepath = path.join(RECORD_DIR, file);
    try {
      fs.unlinkSync(filepath);
    } catch (error) {
      console.error(`Failed to delete ${filepath}:`, error);
    }
  }
}

````

## üìÑ `core/executor.ts`

````typescript
import { spawn } from 'child_process';

export type ExecResult = {
    stdout: string;
    stderr: string;
    code: number | null;
};

export async function exec(command: string): Promise<ExecResult> {
    return new Promise((resolve) => {
        let stdout = '';
        let stderr = '';

        // Use user's preferred shell back with full support for their environment
        const shell = process.env.SHELL || true;
        const child = spawn(command, [], { shell });

        child.stdout.on('data', (data) => {
            stdout += data.toString();
            process.stdout.write(data);
        });

        child.stderr.on('data', (data) => {
            stderr += data.toString();
            process.stderr.write(data);
        });

        child.on('close', (code) => {
            resolve({ stdout, stderr, code });
        });

        child.on('error', (err) => {
            stderr += err.message;
            resolve({ stdout, stderr, code: 1 });
        });
    });
}

````

## üìÑ `core/explain.ts`

````typescript
import { ExecutionRecord } from './executionRecord';
import { computeSkillScore, Skill } from '../agent/skills';

/**
 * Explain Output Spec v1
 * - Stable, human-readable, diff-friendly
 * - No side effects
 * - Do NOT change without bumping spec version
 */
export function explainExecution(record: ExecutionRecord): string {
  const lines: string[] = [];

  lines.push('=== Execution Explanation ===');

  /* =========================
   * [1] Command
   * ========================= */
  lines.push('[1] Command');
  lines.push(`- Name: ${record.meta.commandName ?? 'N/A'}`);

  if (record.command) {
    lines.push(`- Args: ${record.command}`);
  }

  if (record.meta.rawInput) {
    lines.push(`- Raw: ${record.meta.rawInput}`);
  }
  lines.push('');

  /* =========================
   * [2] Decision
   * ========================= */
  const decision = record.decision ?? {};

  lines.push('[2] Decision');
  lines.push(`- Strategy: ${decision.strategy ?? 'capability-match'}`);
  lines.push(
    `- Selected Model: ${decision.selectedModel?.name ?? 'N/A'}`
  );
  lines.push(
    `- Reason: ${decision.reason ?? 'Capability-based selection with fallback support'}`
  );
  lines.push('');

  /* =========================
   * [3] Model
   * ========================= */
  const model = decision.selectedModel;

  lines.push('[3] Model');
  lines.push(`- Name: ${model?.name ?? 'N/A'}`);
  lines.push(`- Provider: ${model?.provider ?? 'N/A'}`);
  lines.push(`- Context Window: ${model?.contextWindow ?? 'default'}`);
  lines.push(`- Cost Profile: ${model?.costProfile ?? 'default'}`);
  lines.push('');

  /* =========================
   * [4] Skills
   * ========================= */
  lines.push('[4] Skills');

  const skills: Skill[] = decision.skills ?? [];
  const now = Date.now();

  if (skills.length === 0) {
    lines.push('- (none)');
  } else {
    const scored = skills
      .map(skill => ({
        skill,
        score: computeSkillScore(skill, now),
      }))
      .sort((a, b) => b.score - a.score);

    for (const { skill, score } of scored) {
      const totalUses = skill.successCount + skill.failureCount;
      const successRate =
        totalUses === 0 ? 0.5 : skill.successCount / totalUses;

      lines.push(`- ${skill.name}`);
      lines.push(`    score: ${score.toFixed(3)}`);
      lines.push(`    confidence: ${skill.confidence.toFixed(3)}`);
      lines.push(`    successRate: ${successRate.toFixed(3)}`);
      lines.push(`    enabled: ${skill.enabled}`);
      lines.push(
        `    lastUsed: ${new Date(skill.lastUsed).toISOString()}`
      );
    }
  }
  lines.push('');

  /* =========================
   * [5] Meta
   * ========================= */
  lines.push('[5] Meta');
  lines.push(`- Execution ID: ${record.id}`);
  lines.push(
    `- Timestamp: ${new Date(record.meta.timestamp).toISOString()}`
  );
  lines.push(`- Replayable: ${record.meta.replayable ?? true}`);
  lines.push(`- Version: ${record.meta.version ?? 'unknown'}`);

  lines.push('=============================');

  return lines.join('\n');
}

````

## üìÑ `core/fileReader.ts`

````typescript
import fs from 'fs';
import path from 'path';

export function parseFilePathsFromLsOutput(output: string): string[] {
    const lines = output.trim().split('\n');
    const filePaths: string[] = [];

    for (const line of lines) {
        const parts = line.trim().split(/\s+/);
        const lastPart = parts[parts.length - 1];
        
        if (lastPart && !lastPart.startsWith('-') && lastPart !== '.' && lastPart !== '..') {
            filePaths.push(lastPart);
        }
    }

    return filePaths;
}

export function readFilesContent(filePaths: string[]): Map<string, string> {
    const contentMap = new Map<string, string>();

    for (const filePath of filePaths) {
        try {
            const fullPath = path.resolve(filePath);
            if (fs.existsSync(fullPath) && fs.statSync(fullPath).isFile()) {
                const content = fs.readFileSync(fullPath, 'utf-8');
                contentMap.set(filePath, content);
            }
        } catch (error) {
            console.error(`Êó†Ê≥ïËØªÂèñÊñá‰ª∂: ${filePath}`);
        }
    }

    return contentMap;
}

export function buildPromptWithFileContent(
    originalOutput: string,
    filePaths: string[],
    contentMap: Map<string, string>,
    question?: string
): string {
    let prompt = '';

    prompt += '## Êñá‰ª∂ÂàóË°®\n';
    prompt += '```\n';
    prompt += originalOutput;
    prompt += '```\n\n';

    if (contentMap.size > 0) {
        prompt += '## Êñá‰ª∂ÂÜÖÂÆπ\n\n';
        for (const [filePath, content] of contentMap) {
            prompt += `### ${filePath}\n`;
            prompt += '```\n';
            const maxChars = 5000;
            const truncated = content.length > maxChars 
                ? content.substring(0, maxChars) + '\n... (ÂÜÖÂÆπËøáÈïøÂ∑≤Êà™Êñ≠)'
                : content;
            prompt += truncated;
            prompt += '\n```\n\n';
        }
    }

    if (question) {
        prompt += `\n## ÊàëÁöÑÈóÆÈ¢ò\n${question}`;
    } else {
        prompt += '\n## ÊàëÁöÑÈóÆÈ¢ò\nËØ∑ÂàÜÊûê‰ª•‰∏äÊñá‰ª∂ÂàóË°®ÂíåÊñá‰ª∂ÂÜÖÂÆπ';
    }

    return prompt;
}

````

## üìÑ `core/macros.ts`

````typescript
import fs from 'fs';
import path from 'path';
import os from 'os';
import { parseMacros, type Macro } from './validation';

const USER_MACROS_FILE = path.join(os.homedir(), '.yuangs_macros.json');

export type { Macro };

function loadMacrosFromFile(filePath: string): Record<string, Macro> {
    if (fs.existsSync(filePath)) {
        try {
            return parseMacros(fs.readFileSync(filePath, 'utf8'));
        } catch (e) { }
    }
    return {};
}

function findProjectMacros(cwd = process.cwd()): string | null {
    let dir = cwd;
    while (dir && dir !== path.dirname(dir)) {
        const candidate = path.join(dir, 'yuangs_macros.json');
        if (fs.existsSync(candidate)) {
            return candidate;
        }
        dir = path.dirname(dir);
    }
    // Check root one last time
    const rootCandidate = path.join(targetRoot(dir), 'yuangs_macros.json');
    if (fs.existsSync(rootCandidate)) return rootCandidate;
    
    return null;
}

// Helper to reliably stop at root (dirname('/') is '/')
function targetRoot(dir: string) {
    return path.parse(dir).root;
}

export function getMacros(): Record<string, Macro> {
    const userMacros = loadMacrosFromFile(USER_MACROS_FILE);
    
    const projectMacrosPath = findProjectMacros();
    const projectMacros = projectMacrosPath ? loadMacrosFromFile(projectMacrosPath) : {};

    return {
        ...userMacros,
        ...projectMacros // Project overrides User
    };
}

export function saveMacro(name: string, commands: string, description: string = '') {
    // Only load USER macros for saving
    const macros = loadMacrosFromFile(USER_MACROS_FILE);
    macros[name] = {
        commands,
        description,
        createdAt: new Date().toISOString()
    };
    fs.writeFileSync(USER_MACROS_FILE, JSON.stringify(macros, null, 2));
    return true;
}

export function deleteMacro(name: string) {
    // Only delete from USER macros
    const macros = loadMacrosFromFile(USER_MACROS_FILE);
    if (macros[name]) {
        delete macros[name];
        fs.writeFileSync(USER_MACROS_FILE, JSON.stringify(macros, null, 2));
        return true;
    }
    return false;
}

export function runMacro(name: string) {
    const macros = getMacros();
    const macro = macros[name];
    if (!macro) return false;

    const { spawn } = require('child_process');
    spawn(macro.commands, [], { shell: true, stdio: 'inherit' });
    return true;
}

````

## üìÑ `core/modelMatcher.ts`

````typescript
import { AtomicCapability, ConstraintCapability, expandCapabilities } from './capabilities';

export interface ModelCapabilities {
  name: string;
  provider: string;
  atomicCapabilities: AtomicCapability[];
  contextWindow?: number;
  costProfile?: 'low' | 'medium' | 'high';
}

export interface CapabilityRequirement {
  required: AtomicCapability[];
  preferred: AtomicCapability[];
  constraints?: ConstraintCapability[];
}

export interface CapabilityMatchExplanation {
  modelName: string;
  provider: string;
  hasRequired: boolean;
  hasPreferred: AtomicCapability[];
  missingRequired: AtomicCapability[];
  reason: string;
}

export interface CapabilityMatchResult {
  selected: ModelCapabilities | null;
  candidates: CapabilityMatchExplanation[];
  fallbackOccurred: boolean;
}

export function matchModel(
  models: ModelCapabilities[],
  requirement: CapabilityRequirement
): CapabilityMatchResult {
  const explanations: CapabilityMatchExplanation[] = [];

  for (const model of models) {
    const hasRequired = requirement.required.every(cap =>
      model.atomicCapabilities.includes(cap)
    );

    const missingRequired = requirement.required.filter(cap =>
      !model.atomicCapabilities.includes(cap)
    );

    const hasPreferred = requirement.preferred.filter(cap =>
      model.atomicCapabilities.includes(cap)
    );

    const explanation: CapabilityMatchExplanation = {
      modelName: model.name,
      provider: model.provider,
      hasRequired,
      hasPreferred,
      missingRequired,
      reason: hasRequired
        ? `Has all required capabilities. Matches ${hasPreferred.length}/${requirement.preferred.length} preferred.`
        : `Missing required capabilities: ${missingRequired.map(c => String(c)).join(', ')}`,
    };

    explanations.push(explanation);
  }

  const matchingModels = explanations.filter(e => e.hasRequired);

  if (matchingModels.length === 0) {
    return {
      selected: null,
      candidates: explanations,
      fallbackOccurred: false,
    };
  }

  const bestMatch = matchingModels[0];
  const selectedModel = models.find(m => m.name === bestMatch.modelName);

  return {
    selected: selectedModel || null,
    candidates: explanations,
    fallbackOccurred: false,
  };
}

export function matchModelWithFallback(
  models: ModelCapabilities[],
  fallbackModels: ModelCapabilities[],
  requirement: CapabilityRequirement
): CapabilityMatchResult {
  const primaryResult = matchModel(models, requirement);

  if (primaryResult.selected) {
    return primaryResult;
  }

  const fallbackResult = matchModel(fallbackModels, requirement);

  return {
    ...fallbackResult,
    fallbackOccurred: fallbackResult.selected !== null,
  };
}

````

## üìÑ `core/os.ts`

````typescript
export type OSProfile = {
    name: string;
    shell: string;
    find: 'bsd' | 'gnu';
    stat: 'bsd' | 'gnu';
};

export function getOSProfile(): OSProfile {
    switch (process.platform) {
        case 'darwin':
            return {
                name: 'macOS',
                shell: 'zsh',
                find: 'bsd',
                stat: 'bsd',
            };
        case 'linux':
            return {
                name: 'Linux',
                shell: 'bash',
                find: 'gnu',
                stat: 'gnu',
            };
        case 'win32':
            return {
                name: 'Windows',
                shell: 'cmd',
                find: 'gnu', // Win32 find is different, but for AI context let's assume GNU style tools if they are there, or just label it.
                stat: 'gnu',
            };
        default:
            return {
                name: process.platform,
                shell: 'sh',
                find: 'gnu',
                stat: 'gnu',
            };
    }
}

````

## üìÑ `core/replayDiff.ts`

````typescript
import { ExecutionRecord } from './executionRecord';
import { computeSkillScore } from '../agent/skills';

export interface ReplayDiffResult {
  decisionDiff: DecisionDiff;
  modelDiff: ModelDiff;
  skillsDiff: SkillsDiff;
}

interface DecisionDiff {
  changed: boolean;
  strategyChanged: boolean;
  modelChanged: boolean;
  reasonChanged: boolean;
  before?: {
    strategy: string;
    selectedModel: string;
    reason: string;
  };
  after?: {
    strategy: string;
    selectedModel: string;
    reason: string;
  };
}

interface ModelDiff {
  changed: boolean;
  nameChanged: boolean;
  providerChanged: boolean;
  before?: {
    name: string;
    provider: string;
    contextWindow: number | string;
    costProfile: string;
  };
  after?: {
    name: string;
    provider: string;
    contextWindow: number | string;
    costProfile: string;
  };
}

interface SkillsDiff {
  added: SkillChange[];
  removed: SkillChange[];
  changed: SkillChange[];
}

interface SkillChange {
  name: string;
  score?: number;
  enabled?: boolean;
  confidence?: number;
  successRate?: number;
  lastUsed?: string;
}

export function diffExecution(
  original: ExecutionRecord,
  current: ExecutionRecord
): ReplayDiffResult {
  return {
    decisionDiff: diffDecision(original, current),
    modelDiff: diffModel(original, current),
    skillsDiff: diffSkills(original, current),
  };
}

function diffDecision(original: ExecutionRecord, current: ExecutionRecord): DecisionDiff {
  const origDecision = original.decision;
  const currDecision = current.decision;

  const strategyChanged = origDecision?.strategy !== currDecision?.strategy;
  const modelChanged = origDecision?.selectedModel?.name !== currDecision?.selectedModel?.name;
  const reasonChanged = origDecision?.reason !== currDecision?.reason;

  return {
    changed: strategyChanged || modelChanged || reasonChanged,
    strategyChanged,
    modelChanged,
    reasonChanged,
    before: {
      strategy: origDecision?.strategy ?? 'N/A',
      selectedModel: origDecision?.selectedModel?.name ?? 'N/A',
      reason: origDecision?.reason ?? 'N/A',
    },
    after: {
      strategy: currDecision?.strategy ?? 'N/A',
      selectedModel: currDecision?.selectedModel?.name ?? 'N/A',
      reason: currDecision?.reason ?? 'N/A',
    },
  };
}

function diffModel(original: ExecutionRecord, current: ExecutionRecord): ModelDiff {
  const origModel = original.decision.selectedModel;
  const currModel = current.decision.selectedModel;

  if (!origModel || !currModel) {
    return {
      changed: true,
      nameChanged: true,
      providerChanged: true,
      before: origModel ? {
        name: origModel.name,
        provider: origModel.provider,
        contextWindow: origModel.contextWindow ?? 'default',
        costProfile: origModel.costProfile ?? 'default',
      } : undefined,
      after: currModel ? {
        name: currModel.name,
        provider: currModel.provider,
        contextWindow: currModel.contextWindow ?? 'default',
        costProfile: currModel.costProfile ?? 'default',
      } : undefined,
    };
  }

  const nameChanged = origModel.name !== currModel.name;
  const providerChanged = origModel.provider !== currModel.provider;

  return {
    changed: nameChanged || providerChanged,
    nameChanged,
    providerChanged,
    before: {
      name: origModel.name,
      provider: origModel.provider,
      contextWindow: origModel.contextWindow ?? 'default',
      costProfile: origModel.costProfile ?? 'default',
    },
    after: {
      name: currModel.name,
      provider: currModel.provider,
      contextWindow: currModel.contextWindow ?? 'default',
      costProfile: currModel.costProfile ?? 'default',
    },
  };
}

function diffSkills(original: ExecutionRecord, current: ExecutionRecord): SkillsDiff {
  const origSkills = original.decision.skills ?? [];
  const currSkills = current.decision.skills ?? [];

  const origSkillMap = new Map(origSkills.map(s => [s.name, s]));
  const currSkillMap = new Map(currSkills.map(s => [s.name, s]));

  const added: SkillChange[] = [];
  const removed: SkillChange[] = [];
  const changed: SkillChange[] = [];

  const now = Date.now();

  // Find added and changed skills
  for (const skill of currSkills) {
    const origSkill = origSkillMap.get(skill.name);

    if (!origSkill) {
      // Added
      const score = computeSkillScore(skill, now);
      const totalUses = skill.successCount + skill.failureCount;
      const successRate = totalUses === 0 ? 0.5 : skill.successCount / totalUses;

      added.push({
        name: skill.name,
        score,
        enabled: skill.enabled,
        confidence: skill.confidence,
        successRate,
        lastUsed: new Date(skill.lastUsed).toISOString(),
      });
    } else {
      // Check if changed
      const origScore = computeSkillScore(origSkill, now);
      const currScore = computeSkillScore(skill, now);
      const origTotalUses = origSkill.successCount + origSkill.failureCount;
      const currTotalUses = skill.successCount + skill.failureCount;
      const origSuccessRate = origTotalUses === 0 ? 0.5 : origSkill.successCount / origTotalUses;
      const currSuccessRate = currTotalUses === 0 ? 0.5 : skill.successCount / currTotalUses;

      if (
        Math.abs(origScore - currScore) > 0.001 ||
        origSkill.enabled !== skill.enabled ||
        Math.abs(origSuccessRate - currSuccessRate) > 0.001
      ) {
        changed.push({
          name: skill.name,
          score: currScore,
          enabled: skill.enabled,
          confidence: skill.confidence,
          successRate: currSuccessRate,
          lastUsed: new Date(skill.lastUsed).toISOString(),
        });
      }
    }
  }

  // Find removed skills
  for (const skill of origSkills) {
    if (!currSkillMap.has(skill.name)) {
      const score = computeSkillScore(skill, now);
      const totalUses = skill.successCount + skill.failureCount;
      const successRate = totalUses === 0 ? 0.5 : skill.successCount / totalUses;

      removed.push({
        name: skill.name,
        score,
        enabled: skill.enabled,
        confidence: skill.confidence,
        successRate,
        lastUsed: new Date(skill.lastUsed).toISOString(),
      });
    }
  }

  return {
    added,
    removed,
    changed,
  };
}

export function formatReplayDiff(diff: ReplayDiffResult): string {
  const lines: string[] = [];

  lines.push('=== Replay Diff ===');

  // [Decision]
  lines.push('[Decision]');
  if (!diff.decisionDiff.changed) {
    lines.push('- no change');
  } else {
    if (diff.decisionDiff.strategyChanged) {
      lines.push(`- strategy: ${diff.decisionDiff.before?.strategy} ‚Üí ${diff.decisionDiff.after?.strategy}`);
    }
    if (diff.decisionDiff.modelChanged) {
      lines.push(`- selectedModel: ${diff.decisionDiff.before?.selectedModel} ‚Üí ${diff.decisionDiff.after?.selectedModel}`);
    }
    if (diff.decisionDiff.reasonChanged) {
      lines.push(`- reason:`);
      lines.push(`    before: "${diff.decisionDiff.before?.reason}"`);
      lines.push(`    after: "${diff.decisionDiff.after?.reason}"`);
    }
  }
  lines.push('');

  // [Model]
  lines.push('[Model]');
  if (!diff.modelDiff.changed) {
    lines.push('- no change');
  } else {
    if (diff.modelDiff.nameChanged) {
      lines.push(`- name: ${diff.modelDiff.before?.name} ‚Üí ${diff.modelDiff.after?.name}`);
    }
    if (diff.modelDiff.providerChanged) {
      lines.push(`- provider: ${diff.modelDiff.before?.provider} ‚Üí ${diff.modelDiff.after?.provider}`);
    }
  }
  lines.push('');

  // [Skills]
  lines.push('[Skills]');
  if (diff.skillsDiff.added.length === 0 &&
      diff.skillsDiff.removed.length === 0 &&
      diff.skillsDiff.changed.length === 0) {
    lines.push('- no change');
  } else {
    for (const skill of diff.skillsDiff.added) {
      lines.push(`+ added: ${skill.name} (score=${skill.score?.toFixed(3)})`);
    }
    for (const skill of diff.skillsDiff.removed) {
      lines.push(`- removed: ${skill.name}`);
    }
    for (const skill of diff.skillsDiff.changed) {
      lines.push(`~ changed: ${skill.name} (score=${skill.score?.toFixed(3)}, enabled=${skill.enabled})`);
    }
  }

  lines.push('===================');

  return lines.join('\n');
}

````

## üìÑ `core/replayEngine.ts`

````typescript
import chalk from 'chalk';
import { ExecutionRecord } from './executionRecord';
import { loadExecutionRecord } from './executionStore';
import { explainExecution } from './explain';

export type ReplayMode = 'strict' | 'compatible' | 're-evaluate';

export interface ReplayOptions {
  mode: ReplayMode;
  skipAI?: boolean;
  verbose?: boolean;
  dry?: boolean;
  explain?: boolean;
  diff?: boolean;
}

export interface ReplayResult {
  success: boolean;
  message: string;
  executedModel?: string;
  deviationReason?: string;
}

export class ReplayEngine {
  async replay(recordId: string, options: ReplayOptions = { mode: 'strict' }): Promise<ReplayResult> {
    const record = loadExecutionRecord(recordId);

    if (!record) {
      return {
        success: false,
        message: `Execution record ${recordId} not found`,
      };
    }

    // NOTE: --diff implicitly enables --explain
    if (options.diff) {
      options.explain = true;
    }

    if (options.explain) {
      console.log(explainExecution(record));
      console.log('');

      if (options.dry) {
        return {
          success: true,
          message: '[Explain + Dry] Explanation shown, no execution',
        };
      }
    }

    if (options.mode === 'strict') {
      return this.strictReplay(record, options);
    }

    if (options.mode === 'compatible') {
      return this.compatibleReplay(record, options);
    }

    return this.reEvaluate(record, options);
  }

  private async strictReplay(
    record: ExecutionRecord,
    options: ReplayOptions
  ): Promise<ReplayResult> {
    const selectedModel = record.decision.selectedModel;

    if (options.verbose || options.dry) {
      console.log(chalk.cyan('[Strict Replay]'));
      console.log(chalk.gray(`  Original Model: ${selectedModel?.name || 'N/A'}`));
      console.log(chalk.gray(`  Original Provider: ${selectedModel?.provider || 'N/A'}`));
      console.log(chalk.gray(`  Original Timestamp: ${record.meta.timestamp}`));
      console.log(chalk.gray(`  Original Command: ${record.meta.commandName}`));
    }

    if (options.dry) {
      return {
        success: true,
        message: '[Dry Replay] Command not executed',
        executedModel: selectedModel?.name ?? undefined,
      };
    }

    if (options.skipAI) {
      return {
        success: true,
        message: 'Strict replay prepared (AI execution skipped)',
        executedModel: selectedModel?.name ?? undefined,
      };
    }

    if (!record.command) {
      return {
        success: false,
        message: 'Strict replay: No command to execute (command not stored in record)',
        executedModel: selectedModel?.name ?? undefined,
      };
    }

    const { exec } = require('./executor');

    try {
      console.log(chalk.gray('[Strict Replay] Executing with original parameters...'));
      const result = await exec(record.command);

      return {
        success: result.code === 0 || result.code === null,
        message: result.code === 0 || result.code === null
          ? 'Strict replay completed successfully'
          : `Strict replay failed with code ${result.code}`,
        executedModel: selectedModel?.name ?? undefined,
      };
    } catch (error: unknown) {
      const message = error instanceof Error ? error.message : String(error);
      return {
        success: false,
        message: `Strict replay error: ${message}`,
        executedModel: selectedModel?.name ?? undefined,
      };
    }
  }

  private async compatibleReplay(
    record: ExecutionRecord,
    options: ReplayOptions
  ): Promise<ReplayResult> {
    const originalModel = record.decision.selectedModel;

    if (options.verbose) {
      console.log(chalk.cyan('[Compatible Replay]'));
      console.log(chalk.gray(`  Original Model: ${originalModel?.name || 'N/A'}`));
      console.log(chalk.gray(`  Will attempt fallback if original unavailable`));
    }

    return {
      success: false,
      message: 'Compatible replay not yet implemented in Phase 1',
      executedModel: originalModel?.name,
      deviationReason: 'Phase 1 only supports strict replay',
    };
  }

  private async reEvaluate(
    record: ExecutionRecord,
    options: ReplayOptions
  ): Promise<ReplayResult> {
    if (options.verbose) {
      console.log(chalk.cyan('[Re-evaluate]'));
      console.log(chalk.gray(`  Will re-run capability matching with current config`));
      console.log(chalk.gray(`  Original Intent: ${record.intent.required.join(', ')}`));
    }

    return {
      success: false,
      message: 'Re-evaluate not yet implemented in Phase 1',
    };
  }
}

export const replayEngine = new ReplayEngine();

````

## üìÑ `core/risk.ts`

````typescript
export function assessRisk(command: string, aiRisk: 'low' | 'medium' | 'high'): 'low' | 'medium' | 'high' {
    const HIGH_RISK_PATTERNS = [
        /\brm\b/i,
        /\bsudo\b/i,
        /\bmv\b/i,
        /\bdd\b/i,
        /\bchmod\b/i,
        /\bchown\b/i,
        />\s*\/dev\//,
        /:\(\)\s*\{.*\}/, // Fork bomb
        /\bmkfs\b/i,
    ];

    const hasHighRisk = HIGH_RISK_PATTERNS.some(pattern => pattern.test(command));

    if (hasHighRisk) return 'high';
    return aiRisk;
}

````

## üìÑ `core/validation.ts`

````typescript
import { z } from 'zod';

export type UserConfig = {
    defaultModel?: string;
    aiProxyUrl?: string;
    accountType?: 'free' | 'pro';
    [key: string]: string | undefined;
};

export type AppsConfig = Record<string, string>;

export type AIRequestMessage = {
    role: 'system' | 'user' | 'assistant';
    content: string;
};

export type AIResponse = {
    choices?: Array<{
        message?: {
            content?: string;
        };
        delta?: {
            content?: string;
        };
    }>;
};

export const DEFAULT_AI_PROXY_URL = 'https://aiproxy.want.biz/v1/chat/completions';
export const DEFAULT_MODEL = 'Assistant';
export const DEFAULT_ACCOUNT_TYPE = 'free' as const;

export const DEFAULT_APPS = {
    shici: 'https://wealth.want.biz/shici/index.html',
    dict: 'https://wealth.want.biz/pages/dict.html',
    pong: 'https://wealth.want.biz/pages/pong.html'
} as const;

export const aiCommandPlanSchema = z.object({
    plan: z.string().describe('Explanation of the command'),
    command: z.string().optional().describe('The shell command to execute'),
    macro: z.string().optional().describe('Name of an existing macro to reuse'),
    risk: z.enum(['low', 'medium', 'high']).describe('Risk level assessment')
}).refine(data => data.command || data.macro, {
    message: 'Either command or macro must be provided'
});

export type AICommandPlan = z.infer<typeof aiCommandPlanSchema>;

export const aiFixPlanSchema = z.object({
    plan: z.string().describe('Fix explanation'),
    command: z.string().describe('The fixed shell command (always required for fixes)'),
    risk: z.enum(['low', 'medium', 'high']).describe('Risk level assessment')
});

export type AIFixPlan = z.infer<typeof aiFixPlanSchema>;

export const userConfigSchema = z.object({
    defaultModel: z.string().optional(),
    aiProxyUrl: z.string().url().optional(),
    accountType: z.enum(['free', 'pro']).optional()
});

export const appsConfigSchema = z.record(z.string(), z.string());

export const macroSchema = z.object({
    commands: z.string(),
    description: z.string(),
    createdAt: z.string()
});

export type Macro = z.infer<typeof macroSchema>;

export const historyEntrySchema = z.object({
    question: z.string(),
    command: z.string(),
    time: z.string()
});

export type HistoryEntry = z.infer<typeof historyEntrySchema>;

export function extractJSON(raw: string): string {
    let jsonContent = raw.trim();

    if (jsonContent.includes('```json')) {
        jsonContent = jsonContent.split('```json')[1].split('```')[0].trim();
    }
    else if (jsonContent.includes('```')) {
        jsonContent = jsonContent.split('```')[1].split('```')[0].trim();
    }

    const firstBrace = jsonContent.indexOf('{');
    const lastBrace = jsonContent.lastIndexOf('}');

    if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
        jsonContent = jsonContent.substring(firstBrace, lastBrace + 1);
    }

    return jsonContent;
}

export function safeParseJSON<T>(
    raw: string,
    schema: z.ZodSchema<T>,
    fallback: T
): { success: true; data: T } | { success: false; error: z.ZodError } {
    try {
        const jsonContent = extractJSON(raw);
        const result = schema.safeParse(JSON.parse(jsonContent));

        if (result.success) {
            return { success: true, data: result.data };
        } else {
            return { success: false, error: result.error };
        }
    } catch (error) {
        if (error instanceof z.ZodError) {
            return { success: false, error };
        }
        return {
            success: false,
            error: new z.ZodError([
                {
                    code: z.ZodIssueCode.custom,
                    message: `Failed to parse JSON: ${error instanceof Error ? error.message : String(error)}`,
                    path: []
                }
            ])
        };
    }
}

export function parseUserConfig(content: string): UserConfig {
    return userConfigSchema.parse(JSON.parse(content));
}

export function parseAppsConfig(content: string): AppsConfig {
    return appsConfigSchema.parse(JSON.parse(content)) as AppsConfig;
}

export function parseMacros(content: string): Record<string, Macro> {
    const parsed = JSON.parse(content);
    const macros: Record<string, Macro> = {};

    for (const [name, value] of Object.entries(parsed)) {
        macros[name] = macroSchema.parse(value);
    }

    return macros;
}

export function parseCommandHistory(content: string): HistoryEntry[] {
    const parsed = JSON.parse(content);
    return z.array(historyEntrySchema).parse(parsed);
}

````

## üìÑ `index.ts`

````typescript
// This file is empty because yuangs is a CLI-first project.
// We don't expose any public library APIs to avoid breaking changes.
export { };

````

## üìÑ `legacy/governance/GovernanceEngine.ts`

````typescript
import { GovernedAction, ExecutionContext, ApprovalSource } from "./GovernedAction";

/**
 * Governance engine - single point of control for all governed actions
 * Enforces "No Diff Without Review. No Execution Without Approval."
 */
export class GovernanceEngine {
  private actions = new Map<string, GovernedAction>();
  private revokedActions = new Set<string>();

  register(action: GovernedAction): void {
    if (this.revokedActions.has(action.id)) {
      throw new Error(
        `Governance violation: action ${action.id} was revoked`
      );
    }
    this.actions.set(action.id, action);
  }

  getAction(id: string): GovernedAction | undefined {
    return this.actions.get(id);
  }

  listActions(): GovernedAction[] {
    return Array.from(this.actions.values());
  }

  requestApproval(id: string): void {
    const action = this.actions.get(id);

    if (!action) {
      throw new Error(`Action not found: ${id}`);
    }

    action.propose();

    console.log(`[PROPOSED] ${action.kind}:${id}`);
    console.log(`Rationale: ${action.rationale}`);
  }

  approve(id: string, by: ApprovalSource): void {
    const action = this.actions.get(id);

    if (!action) {
      throw new Error(`Action not found: ${id}`);
    }

    if (by !== "human") {
      throw new Error(`Governance violation: only human can approve`);
    }

    action.approve(by);

    console.log(`[APPROVED] ${action.kind}:${id} by ${by}`);
  }

  reject(id: string, reason: string): void {
    const action = this.actions.get(id);

    if (!action) {
      throw new Error(`Action not found: ${id}`);
    }

    action.reject(reason);

    console.log(`[REJECTED] ${action.kind}:${id}`);
    console.log(`Reason: ${reason}`);
  }

  async execute(id: string, ctx: ExecutionContext): Promise<void> {
    const action = this.actions.get(id);

    if (!action) {
      throw new Error(`Action not found: ${id}`);
    }

    if (action.state !== "APPROVED") {
      throw new Error(
        `Governance violation: execute() called on ${action.kind}:${id} in state ${action.state}, must be APPROVED`
      );
    }

    const result = await action.execute(ctx);

    if (!result.ok) {
      throw new Error(
        `Execution failed: ${result.error || "unknown error"}`
      );
    }

    console.log(`[EXECUTED] ${action.kind}:${id}`);
  }

  async observe(id: string): Promise<void> {
    const action = this.actions.get(id);

    if (!action) {
      throw new Error(`Action not found: ${id}`);
    }

    const obs = await action.observe();

    console.log(`[OBSERVED] ${action.kind}:${id}`);
    console.log(`Files changed: ${obs.changedFiles.length}`);
  }

  verify(id: string, obs: any): boolean {
    const action = this.actions.get(id);

    if (!action) {
      throw new Error(`Action not found: ${id}`);
    }

    const verified = action.verify(obs);

    if (verified) {
      console.log(`[VERIFIED] ${action.kind}:${id}`);
    }

    return verified;
  }

  revoke(id: string): void {
    this.actions.delete(id);
    this.revokedActions.add(id);
  }

  has(id: string): boolean {
    return this.actions.has(id) && !this.revokedActions.has(id);
  }
}

````

## üìÑ `legacy/governance/GovernedAction.ts`

````typescript
/**
 * Core Governance Types and Interfaces
 *
 * This module defines the foundational types for the Code Change Governance System.
 * All actions must implement GovernedAction and follow strict state transitions.
 */

/**
 * Valid governance states for any action
 * No action can skip states or bypass approval
 */
export type GovernanceState =
  | "DRAFT"
  | "PROPOSED"
  | "APPROVED"
  | "EXECUTED"
  | "OBSERVED"
  | "VERIFIED"
  | "REJECTED";

/**
 * Approval can only come from humans - no auto-approval
 */
export type ApprovalSource = "human";

/**
 * Provenance tracking for reproducibility and audit
 */
export interface ActionProvenance {
  /** The agent that created this action */
  agentId: string;

  /** Hash of the plan that generated this action */
  planHash: string;

  /** Parent action if this is a fix/repair attempt */
  parentAction?: string;

  /** When this action was created */
  createdAt: number;
}

/**
 * Execution context for running actions
 */
export interface ExecutionContext {
  executor: ActionExecutor;
  snapshot?: string;
}

/**
 * Result from executing an action
 */
export interface ExecutionResult {
  ok: boolean;
  error?: string;
  executedAt?: number;
  snapshotAfter?: string;
}

/**
 * Observation data after execution
 */
export interface Observation {
  gitDiff: string;
  changedFiles: string[];
  executionTime: number;
}

/**
 * Action executor interface (filesystem operations)
 * This is the ONLY place where filesystem changes can happen
 */
export interface ActionExecutor {
  applyDiff(diff: string): Promise<void>;

  readFile(path: string): Promise<string>;

  writeFile(path: string, content: string): Promise<void>;

  deleteFile(path: string): Promise<void>;
}

/**
 * Core interface that ALL governed actions must implement
 * This enforces the constitutional constraints
 */
export interface GovernedAction<Payload = unknown> {
  /** Unique identifier for this action */
  readonly id: string;

  /** Type/kind of action (code_change, run_command, etc.) */
  readonly kind: string;

  /** The actual payload that will be executed */
  readonly payload: Payload;

  /** Current state of this action */
  state: GovernanceState;

  /** Why this action is being proposed (must be human-readable) */
  readonly rationale: string;

  /** Who created this action and when */
  readonly provenance: ActionProvenance;

  /** When was the state last updated */
  updatedAt: number;

  /** Transition from DRAFT to PROPOSED */
  propose(): void;

  /** Transition from PROPOSED to APPROVED (only human can approve) */
  approve(by: ApprovalSource): void;

  /** Transition from any state to REJECTED */
  reject(reason: string): void;

  /** Execute the action (only possible if APPROVED) */
  execute(ctx: ExecutionContext): Promise<ExecutionResult>;

  /** Observe the results of execution (only possible if EXECUTED) */
  observe(): Promise<Observation>;

  /** Verify the observation (only possible if OBSERVED) */
  verify(obs: Observation): boolean;

  /** Get a summary of this action for display */
  summarize(): ActionSummary;
}

/**
 * Human-readable summary of an action
 */
export interface ActionSummary {
  id: string;
  kind: string;
  state: GovernanceState;
  rationale: string;
  filesAffected?: string[];
  changeSize?: number;
}

````

## üìÑ `legacy/governance/actions/CodeChangeAction.ts`

````typescript
import crypto from "crypto";

import {
  GovernedAction,
  GovernanceState,
  ExecutionContext,
  ExecutionResult,
  Observation,
  ActionExecutor,
  ActionSummary,
  ApprovalSource,
  ActionProvenance,
} from "../GovernedAction";

/**
 * Payload for code change actions
 * Contains unified diff and affected files
 */
export interface CodeChangePayload {
  files: string[];
  diff: string;
}

export class CodeChangeAction implements GovernedAction<CodeChangePayload> {
  readonly kind = "code_change";

  state: GovernanceState = "DRAFT";
  updatedAt: number = Date.now();

  constructor(
    public readonly id: string,
    public readonly payload: CodeChangePayload,
    public readonly rationale: string,
    public readonly provenance: ActionProvenance
  ) {
    this.updatedAt = provenance.createdAt;
  }

  propose(): void {
    if (this.state !== "DRAFT") {
      throw new Error(
        `Governance violation: propose() called from ${this.state}, must be DRAFT`
      );
    }
    this.state = "PROPOSED";
    this.updatedAt = Date.now();
  }

  approve(by: ApprovalSource): void {
    if (this.state !== "PROPOSED") {
      throw new Error(
        `Governance violation: approve() called from ${this.state}, must be PROPOSED`
      );
    }
    if (by !== "human") {
      throw new Error(
        `Governance violation: only human can approve, got ${by}`
      );
    }
    this.state = "APPROVED";
    this.updatedAt = Date.now();
  }

  reject(reason: string): void {
    if (this.state === "REJECTED") {
      throw new Error(
        `Governance violation: reject() called from ${this.state}, already rejected`
      );
    }
    this.state = "REJECTED";
    this.updatedAt = Date.now();
  }

  async execute(ctx: ExecutionContext): Promise<ExecutionResult> {
    if (this.state !== "APPROVED") {
      throw new Error(
        `Governance violation: execute() called from ${this.state}, must be APPROVED`
      );
    }

    const startTime = Date.now();

    try {
      await ctx.executor.applyDiff(this.payload.diff);

      this.state = "EXECUTED";
      this.updatedAt = Date.now();

      return {
        ok: true,
        executedAt: Date.now(),
        snapshotAfter: ctx.snapshot,
      };
    } catch (error) {
      this.state = "REJECTED";
      this.updatedAt = Date.now();

      return {
        ok: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  async observe(): Promise<Observation> {
    if (this.state !== "EXECUTED") {
      throw new Error(
        `Governance violation: observe() called from ${this.state}, must be EXECUTED`
      );
    }

    const { execSync } = require("child_process");

    const changedFiles = execSync("git diff --name-only", {
      encoding: "utf-8",
    })
      .trim()
      .split("\n")
      .filter((f: string) => f);

    const gitDiff = execSync("git diff", { encoding: "utf-8" });

    this.state = "OBSERVED";
    this.updatedAt = Date.now();

    return {
      gitDiff,
      changedFiles,
      executionTime: Date.now(),
    };
  }

  verify(obs: Observation): boolean {
    if (this.state !== "OBSERVED") {
      throw new Error(
        `Governance violation: verify() called from ${this.state}, must be OBSERVED`
      );
    }

    const changedFiles = new Set(obs.changedFiles);
    const declaredFiles = new Set(this.payload.files);

    const extraFiles = obs.changedFiles.filter((f) => !declaredFiles.has(f));

    if (extraFiles.length > 0) {
      throw new Error(
        `Governance violation: execution modified undeclared files: ${extraFiles.join(", ")}`
      );
    }

    this.state = "VERIFIED";
    this.updatedAt = Date.now();

    return true;
  }

  summarize(): ActionSummary {
    const changeSize = this.calculateChangeSize();

    return {
      id: this.id,
      kind: this.kind,
      state: this.state,
      rationale: this.rationale,
      filesAffected: this.payload.files,
      changeSize,
    };
  }

  private calculateChangeSize(): number {
    let additions = 0;
    let deletions = 0;

    for (const line of this.payload.diff.split("\n")) {
      if (line.startsWith("+") && !line.startsWith("+++")) additions++;
      if (line.startsWith("-") && !line.startsWith("---")) deletions++;
    }

    return additions + deletions;
  }

  static create(
    payload: CodeChangePayload,
    rationale: string,
    agentId: string,
    planHash: string,
    parentAction?: string
  ): CodeChangeAction {
    const id = crypto.randomUUID();
    const provenance: ActionProvenance = {
      agentId,
      planHash,
      parentAction,
      createdAt: Date.now(),
    };

    return new CodeChangeAction(id, payload, rationale, provenance);
  }
}

````

## üìÑ `legacy/governance/capability/token.ts`

````typescript
import crypto from "crypto";
import { execSync } from "child_process";

const SECRET = process.env.CAP_SECRET || "default-secret-change-in-production";

export type Right =
  | { type: "APPLY_DIFF" }
  | { type: "READ_FILE"; path: string }
  | { type: "EXECUTE_ACTION"; actionId: string };

export type Scope =
  | { type: "ACTION"; id: string }
  | { type: "PATH_PREFIX"; prefix: string }
  | { type: "REPO" };

export interface Capability {
  id: string;
  subject: string;
  rights: Right[];
  scope: Scope;
  issuedAt: number;
  expiresAt: number;
  maxUses: number;
  used: number;
  signature: string;
}

export function sign(data: string): string {
  return crypto
    .createHmac("sha256", SECRET)
    .update(data)
    .digest("hex");
}

export function verify(cap: Capability): boolean {
  const { signature, ...rest } = cap;
  const payload = JSON.stringify(rest);
  const computed = sign(payload);

  return computed === signature;
}

export function issue(input: {
  subject: string;
  rights: Right[];
  scope: Scope;
  ttlMs: number;
  maxUses?: number;
}): Capability {
  const base = {
    id: crypto.randomUUID(),
    subject: input.subject,
    rights: input.rights,
    scope: input.scope,
    issuedAt: Date.now(),
    expiresAt: Date.now() + input.ttlMs,
    maxUses: input.maxUses ?? 1,
    used: 0,
  };

  const payload = JSON.stringify(base);

  return {
    ...base,
    signature: sign(payload),
  };
}

export function checkCapability(
  cap: Capability,
  want: Right,
  context: { actionId?: string; path?: string }
): void {
  if (!verify(cap)) {
    throw new Error("Invalid capability: signature verification failed");
  }

  if (Date.now() > cap.expiresAt) {
    throw new Error("Capability expired");
  }

  if (cap.used >= cap.maxUses) {
    throw new Error("Capability exhausted (max uses reached)");
  }

  const rightMatch = cap.rights.some(
    (r) => JSON.stringify(r) === JSON.stringify(want)
  );

  if (!rightMatch) {
    throw new Error(
      `Capability does not grant right: ${JSON.stringify(want)}`
    );
  }

  if (cap.scope.type === "ACTION" && context.actionId !== cap.scope.id) {
    throw new Error(
      `Scope violation: capability scoped to action ${cap.scope.id}, used on ${context.actionId}`
    );
  }

  if (
    cap.scope.type === "PATH_PREFIX" &&
    context.path &&
    !context.path.startsWith(cap.scope.prefix)
  ) {
    throw new Error(
      `Scope violation: capability scoped to ${cap.scope.prefix}, used on ${context.path}`
    );
  }

  cap.used++;
}

export function attenuate(
  cap: Capability,
  limits: Partial<Pick<Capability, "expiresAt" | "maxUses">>
): Capability {
  if (!verify(cap)) {
    throw new Error("Cannot attenuate invalid capability");
  }

  const reduced = {
    ...cap,
    expiresAt: Math.min(
      cap.expiresAt,
      limits.expiresAt ?? cap.expiresAt
    ),
    maxUses: Math.min(cap.maxUses, limits.maxUses ?? cap.maxUses),
    used: 0,
    signature: "",
  };

  const payload = JSON.stringify({
    id: reduced.id,
    subject: reduced.subject,
    rights: reduced.rights,
    scope: reduced.scope,
    issuedAt: reduced.issuedAt,
    expiresAt: reduced.expiresAt,
    maxUses: reduced.maxUses,
    used: 0,
  });

  return {
    ...reduced,
    signature: sign(payload),
  };
}

const revokedCaps = new Set<string>();

export function revoke(capId: string): void {
  revokedCaps.add(capId);
}

export function checkRevoked(cap: Capability): void {
  if (revokedCaps.has(cap.id)) {
    throw new Error(`Capability ${cap.id} has been revoked`);
  }
}

````

## üìÑ `legacy/governance/commands/diffEdit.ts`

````typescript
import { Command } from "commander";
import chalk from "chalk";
import fs from "fs";
import { execSync } from "child_process";

import { GovernanceEngine } from "../GovernanceEngine";
import { CodeChangeAction, CodeChangePayload } from "../actions/CodeChangeAction";
import { ExecutionContext, ActionExecutor } from "../GovernedAction";
import { parseUnifiedDiff, extractFilesFromDiff, assessRisk } from "../review/diffParser";
import { renderSummary, renderDiffForReview, renderRiskAssessment, promptForApproval } from "../review/render";
import { createSnapshot, rollbackToSnapshot, commitChanges, assertNoExtraChanges, getChangedFiles } from "../execution/sandbox";
import { issue } from "../capability/token";
import { loadActions, saveActions, auditActions } from "../storage/store";

const engine = new GovernanceEngine();
auditActions(loadActions());


function collectGitResult(commitHash: string) {
  try {
    const output = execSync(`git show --stat --oneline ${commitHash}`, {
      encoding: "utf-8",
    });

    const files: string[] = [];
    let insertions = 0;
    let deletions = 0;

    for (const line of output.split("\n")) {
      const fileMatch = line.match(/^\s*(.+?)\s+\|\s+\d+/);
      if (fileMatch) {
        files.push(fileMatch[1].trim());
      }

      const insMatch = line.match(/(\d+)\s+insertions?\(\+\)/);
      const delMatch = line.match(/(\d+)\s+deletions?\(-\)/);
      if (insMatch) insertions = parseInt(insMatch[1], 10);
      if (delMatch) deletions = parseInt(delMatch[1], 10);
    }

    return {
      commits: commitHash ? 1 : 0,
      files,
      insertions,
      deletions,
    };
  } catch {
    return {
      commits: 1,
      files: [],
      insertions: 0,
      deletions: 0,
      warning: "Unable to derive git stats",
    };
  }
}



class GitExecutor implements ActionExecutor {
  async applyDiff(diff: string): Promise<void> {
    // execSync is imported at top level

    try {
      execSync("git apply --index", {
        input: diff,
        stdio: "pipe",
      });
    } catch (error) {
      throw new Error(`Failed to apply diff: ${error}`);
    }
  }

  async readFile(path: string): Promise<string> {
    return fs.promises.readFile(path, "utf-8");
  }

  async writeFile(path: string, content: string): Promise<void> {
    await fs.promises.writeFile(path, content, "utf-8");
  }

  async deleteFile(path: string): Promise<void> {
    await fs.promises.unlink(path);
  }
}

export function createDiffEditCommand(): Command {
  const program = new Command("diff-edit");

  program
    .description("Governed code change CLI - review before executing")
    .version("1.0.0");

  program
    .command("propose <diff-file>")
    .option("-r, --rationale <text>", "Why this change is needed")
    .action(async (diffFile, options) => {
      if (!fs.existsSync(diffFile)) {
        console.error(chalk.red(`Diff file not found: ${diffFile}`));
        process.exit(1);
      }

      const diff = fs.readFileSync(diffFile, "utf-8");
      const rationale = options.rationale || "Manual diff submission";

      const files = extractFilesFromDiff(diff);
      const payload: CodeChangePayload = { files, diff };

      const action = CodeChangeAction.create(
        payload,
        rationale,
        "cli",
        "manual-" + Date.now()
      );

      action.propose();

      const actions = loadActions();
      actions[action.id] = action as any;
      saveActions(actions);

      console.log(chalk.green(`[PROPOSED] ${action.id}`));
      console.log(chalk.cyan("Files:"));
      for (const f of files) {
        console.log(`  - ${chalk.yellow(f)}`);
      }

      console.log(`\n${chalk.bold("Rationale:")} ${rationale}`);
    });

  program
    .command("list")
    .description("List all proposed actions")
    .action(() => {
      const actions = loadActions();

      console.log(chalk.bold("\n" + "=".repeat(60)));
      console.log(chalk.bold("Actions"));
      console.log(chalk.bold("=".repeat(60)) + "\n");

      const table: Array<{
        id: string;
        kind: string;
        state: string;
        rationale: string;
      }> = [];

      for (const [id, a] of Object.entries(actions)) {
        table.push({
          id,
          kind: a.kind,
          state: a.state,
          rationale: a.rationale.substring(0, 50),
        });
      }

      console.table(table);
    });

  program
    .command("approve <id>")
    .description("Review and approve a proposed action")
    .action(async (id) => {
      const actions = loadActions();
      const action = actions[id];

      if (!action) {
        console.error(chalk.red(`Action not found: ${id}`));
        process.exit(1);
      }

      const files = parseUnifiedDiff(action.payload.diff);
      renderDiffForReview(files, action.rationale);

      const { level, warnings } = assessRisk(files);
      renderRiskAssessment(level, warnings);

      const approved = await promptForApproval();

      if (!approved) {
        console.log(chalk.red("\n[REJECTED] Approval aborted"));
        action.state = "REJECTED";
        saveActions(actions);
        return;
      }

      action.state = "APPROVED";
      saveActions(actions);

      console.log(chalk.green(`\n[APPROVED] ${id}`));
    });

  program
    .command("exec <id>")
    .description("Execute an approved action")
    .action(async (id) => {
      const actions = loadActions();
      const action = actions[id];

      if (!action) {
        console.error(chalk.red(`Action not found: ${id}`));
        process.exit(1);
      }

      if (action.state !== "APPROVED") {
        console.error(
          chalk.red(
            `Action not approved (state: ${action.state})`
          )
        );
        process.exit(1);
      }

      console.log(chalk.cyan(`\n[EXECUTING] ${id}...`));

      const snapshot = createSnapshot();
      const executor = new GitExecutor();
      const ctx: ExecutionContext = { executor, snapshot: snapshot.id };

      try {
        // === PRE-EXEC: Snapshot Validation ===
        await executor.applyDiff(action.payload.diff);

        const changedFiles = getChangedFiles();
        assertNoExtraChanges(action.payload.files, changedFiles);

        const snapshotResult = {
          changedFiles,
          unexpectedFiles: changedFiles.filter(
            (f) => !action.payload.files.includes(f)
          ),
          matchedBySandbox: changedFiles.length === action.payload.files.length,
        };

        // === EXEC: Commit ===
        commitChanges(`EXECUTED action ${id}`, snapshot.id);

        const commitHash = execSync("git rev-parse HEAD", {
          encoding: "utf-8",
        }).trim();

        action.state = "EXECUTED";
        action.executedAt = Date.now();
        saveActions(actions);

        // === POST-EXEC: Reporting ===
        const gitResult = collectGitResult(commitHash);

        console.log(chalk.green("\n[EXECUTED]"));
        console.log(chalk.green(`Action ID: ${id}`));

        console.log(chalk.cyan("\nSnapshot Verification (pre-commit):"));
        console.log(
          chalk.cyan(
            `  - Files changed: ${snapshotResult.changedFiles.length}`
          )
        );
        for (const f of snapshotResult.changedFiles) {
          console.log(chalk.cyan(`    - ${f}`));
        }
        if (snapshotResult.unexpectedFiles.length > 0) {
          console.log(chalk.yellow("  - Unexpected files:"));
          for (const f of snapshotResult.unexpectedFiles) {
            console.log(chalk.yellow(`    - ${f}`));
          }
        }
        console.log(
          chalk.cyan(
            `  - Status: ${snapshotResult.matchedBySandbox ? "‚úÖ MATCHED" : "‚ö†Ô∏è DEVIATION"
            }`
          )
        );

        console.log(chalk.cyan("\nGit Result:"));
        console.log(chalk.cyan(`  - Commit: ${commitHash.substring(0, 7)}`));
        console.log(chalk.cyan(`  - Files changed: ${gitResult.files.length}`));
        console.log(chalk.cyan(`  - Insertions: ${gitResult.insertions}`));
        console.log(chalk.cyan(`  - Deletions: ${gitResult.deletions}`));

        console.log(chalk.green("\nStatus:"));
        console.log(chalk.green("  ‚úÖ EXECUTED (validated + committed)"));
      } catch (error) {
        console.error(chalk.red(`\n[FAILED] ${error}`));

        console.log(chalk.yellow("\nRolling back to snapshot..."));
        rollbackToSnapshot(snapshot.id);

        action.state = "REJECTED";
        saveActions(actions);

        console.log(chalk.cyan("\nRolled back successfully"));
        process.exit(1);
      }
    });

  program
    .command("status <id>")
    .description("Show status of an action")
    .action((id) => {
      const actions = loadActions();
      const action = actions[id];

      if (!action) {
        console.error(chalk.red(`Action not found: ${id}`));
        process.exit(1);
      }

      console.log(chalk.bold("\n" + "=".repeat(60)));
      console.log(chalk.bold(`Action: ${id}`));
      console.log(chalk.bold("=".repeat(60)) + "\n");

      console.log(`${chalk.bold("Kind:")} ${action.kind}`);
      console.log(`${chalk.bold("State:")} ${action.state}`);
      console.log(`${chalk.bold("Rationale:")} ${action.rationale}`);
      console.log(
        `${chalk.bold("Updated:")} ${new Date(
          action.updatedAt
        ).toLocaleString()}`
      );

      if (action.state === "EXECUTED" && action.executedAt) {
        console.log(
          `${chalk.bold("Executed:")} ${new Date(
            action.executedAt
          ).toLocaleString()}`
        );
      }
    });

  return program;
}

````

## üìÑ `legacy/governance/execution/sandbox.ts`

````typescript
import { execSync } from "child_process";

export interface ExecutionSnapshot {
  id: string;
  commitHash: string;
  timestamp: number;
  isClean: boolean;
}

export function createSnapshot(): ExecutionSnapshot {
  const statusOutput = execSync("git status --porcelain", {
    encoding: "utf-8",
  }).trim();

  const isClean = statusOutput.length === 0;

  if (!isClean) {
    throw new Error(
      "Cannot create snapshot: working tree is dirty. Commit or stash changes first."
    );
  }

  const commitHash = execSync("git rev-parse HEAD", {
    encoding: "utf-8",
  }).trim();

  return {
    id: commitHash,
    commitHash,
    timestamp: Date.now(),
    isClean,
  };
}

export function verifySnapshot(snapshotId: string): boolean {
  try {
    const current = execSync("git rev-parse HEAD", {
      encoding: "utf-8",
    }).trim();

    return current === snapshotId;
  } catch {
    return false;
  }
}

export function rollbackToSnapshot(snapshotId: string): void {
  try {
    execSync(`git reset --hard ${snapshotId}`, {
      stdio: "inherit",
    });
    console.log(`Rolled back to snapshot ${snapshotId}`);
  } catch (error) {
    throw new Error(
      `Failed to rollback to snapshot ${snapshotId}: ${error}`
    );
  }
}

export function commitChanges(message: string, snapshotId: string): void {
  try {
    execSync(`git commit -am "${message}"`, {
      stdio: "inherit",
    });
  } catch (error) {
    throw new Error(`Failed to commit changes: ${error}`);
  }
}

export function getChangedFiles(): string[] {
  const output = execSync("git diff --name-only HEAD", {
    encoding: "utf-8",
  });

  return output
    .trim()
    .split("\n")
    .filter((f) => f.length > 0);
}

export function assertNoExtraChanges(
  approvedFiles: string[],
  actualFiles: string[]
): void {
  const approvedSet = new Set(approvedFiles);
  const extraFiles = actualFiles.filter((f) => !approvedSet.has(f));

  if (extraFiles.length > 0) {
    throw new Error(
      `Governance violation: execution modified undeclared files:\n${extraFiles.join("\n")}`
    );
  }
}

````

## üìÑ `legacy/governance/fsm/stateMachine.ts`

````typescript
import { GovernanceState } from "../GovernedAction";

/**
 * Only these state transitions are legally permitted
 * Any other transition is a governance violation
 */
const ALLOWED_TRANSITIONS: Record<GovernanceState, GovernanceState[]> = {
  DRAFT: ["PROPOSED"],
  PROPOSED: ["APPROVED", "REJECTED"],
  APPROVED: ["EXECUTED"],
  EXECUTED: ["OBSERVED"],
  OBSERVED: ["VERIFIED"],
  VERIFIED: [],
  REJECTED: [],
};

/**
 * Throw governance violation if transition is not permitted
 */
export function assertTransition(
  from: GovernanceState,
  to: GovernanceState
): void {
  const allowed = ALLOWED_TRANSITIONS[from].includes(to);

  if (!allowed) {
    throw new Error(
      `Governance violation: illegal state transition ${from} ‚Üí ${to}`
    );
  }
}

/**
 * Check if a transition is valid (without throwing)
 */
export function canTransition(
  from: GovernanceState,
  to: GovernanceState
): boolean {
  return ALLOWED_TRANSITIONS[from].includes(to);
}

/**
 * Get all possible next states from current state
 */
export function getNextStates(from: GovernanceState): GovernanceState[] {
  return [...ALLOWED_TRANSITIONS[from]];
}

/**
 * Validate that a state is valid
 */
export function isValidState(state: string): state is GovernanceState {
  return [
    "DRAFT",
    "PROPOSED",
    "APPROVED",
    "EXECUTED",
    "OBSERVED",
    "VERIFIED",
    "REJECTED",
  ].includes(state);
}

/**
 * State machine transition history entry
 */
export interface TransitionHistoryEntry {
  from: GovernanceState;
  to: GovernanceState;
  timestamp: number;
  reason?: string;
}

/**
 * State machine for tracking governance state transitions
 * Enforces constitutional invariants
 */
export class GovernanceStateMachine {
  private currentState: GovernanceState;
  private history: TransitionHistoryEntry[] = [];

  constructor(initialState: GovernanceState) {
    if (!isValidState(initialState)) {
      throw new Error(`Invalid initial state: ${initialState}`);
    }
    this.currentState = initialState;
  }

  get current(): GovernanceState {
    return this.currentState;
  }

  get transitionHistory(): TransitionHistoryEntry[] {
    return [...this.history];
  }

  transition(to: GovernanceState, reason?: string): void {
    assertTransition(this.currentState, to);

    this.history.push({
      from: this.currentState,
      to,
      timestamp: Date.now(),
      reason,
    });

    this.currentState = to;
  }

  isTerminal(): boolean {
    return this.currentState === "VERIFIED" || this.currentState === "REJECTED";
  }

  canProceedTo(state: GovernanceState): boolean {
    return canTransition(this.currentState, state);
  }
}

````

## üìÑ `legacy/governance/index.ts`

````typescript
export * from "./GovernedAction";
export * from "./GovernanceEngine";
export * from "./actions/CodeChangeAction";
export * from "./fsm/stateMachine";
export * from "./review/diffParser";
export * from "./review/render";
export * from "./execution/sandbox";
export * from "./capability/token";
export * from "./storage/store";

````

## üìÑ `legacy/governance/review/diffParser.ts`

````typescript
export interface DiffFile {
  file: string;
  additions: number;
  deletions: number;
  hunks: string[];
}

export function parseUnifiedDiff(diff: string): DiffFile[] {
  const files: DiffFile[] = [];
  let current: DiffFile | null = null;

  for (const line of diff.split("\n")) {
    if (line.startsWith("diff --git")) {
      if (current) {
        files.push(current);
      }
      const match = line.match(/b\/(.+)$/);
      const file = match ? match[1] : "unknown";
      current = { file, additions: 0, deletions: 0, hunks: [] };
    } else if (!current) {
      continue;
    } else if (line.startsWith("+") && !line.startsWith("+++")) {
      current.additions++;
    } else if (line.startsWith("-") && !line.startsWith("---")) {
      current.deletions++;
    } else if (line.startsWith("@@")) {
      current.hunks.push(line);
    }
  }

  if (current) {
    files.push(current);
  }

  return files;
}

export function extractFilesFromDiff(diff: string): string[] {
  const files: string[] = [];
  const filePattern = /^\+\+\+ b\/(.+)$/gm;

  for (const match of diff.matchAll(filePattern)) {
    files.push(match[1]);
  }

  return files;
}

export function assessRisk(files: DiffFile[]): {
  level: "low" | "medium" | "high";
  warnings: string[];
} {
  const warnings: string[] = [];
  const totalLines = files.reduce(
    (sum, f) => sum + f.additions + f.deletions,
    0
  );

  if (totalLines > 300) {
    warnings.push(`Large changeset: ${totalLines} lines`);
  }

  if (files.length > 10) {
    warnings.push(`Many files touched: ${files.length}`);
  }

  if (totalLines > 1000) {
    return { level: "high", warnings };
  }

  if (totalLines > 300 || files.length > 10) {
    return { level: "medium", warnings };
  }

  return { level: "low", warnings };
}

````

## üìÑ `legacy/governance/review/render.ts`

````typescript
import chalk from "chalk";
import { DiffFile } from "./diffParser";

export function renderSummary(files: DiffFile[]): void {
  console.log(chalk.bold("\nDiff Summary\n"));

  for (const f of files) {
    console.log(
      `${chalk.cyan(f.file)}  ` +
      chalk.green(`+${f.additions}`) +
      " " +
      chalk.red(`-${f.deletions}`)
    );
  }
}

export function renderDiffForReview(
  files: DiffFile[],
  rationale: string
): void {
  console.log(
    chalk.bold.cyan("=".repeat(60))
  );
  console.log(chalk.bold.blue("Proposed Code Change"));
  console.log(
    chalk.bold.cyan("=".repeat(60))
  );

  console.log(`${chalk.bold("Rationale:")} ${rationale}\n`);

  for (const f of files) {
    console.log(chalk.yellow(`\nüìÑ ${f.file}`));
    console.log(
      `   ${chalk.green("+")} ${f.additions} lines added`
    );
    console.log(
      `   ${chalk.red("-")} ${f.deletions} lines deleted`
    );
  }

  console.log(
    chalk.bold.cyan("\n" + "=".repeat(60))
  );
}

export function renderRiskAssessment(
  level: "low" | "medium" | "high",
  warnings: string[]
): void {
  const levelColor = {
    low: chalk.green,
    medium: chalk.yellow,
    high: chalk.red,
  };

  console.log(
    chalk.bold(
      `\n${levelColor[level]}(\u26a0\ufe0f  Risk Level: ${level.toUpperCase()})`
    )
  );

  if (warnings.length > 0) {
    for (const w of warnings) {
      console.log(chalk.yellow(`   - ${w}`));
    }
  }
}

export function promptForApproval(): Promise<boolean> {
  const readline = require("readline");
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  return new Promise((resolve) => {
    rl.question(
      chalk.bold.yellow('\nType "YES" to approve, anything else to reject: '),
      (answer: string) => {
        rl.close();
        resolve(answer.trim() === "YES");
      }
    );
  });
}

````

## üìÑ `legacy/governance/storage/store.ts`

````typescript
import fs from "fs";
import path from "path";
import os from "os";

const DATA_DIR = path.join(os.homedir(), ".yuangs");
const STORE_PATH = path.join(DATA_DIR, "actions.json");

export interface SerializedAction {
  id: string;
  kind: string;
  state: string;
  payload: any;
  rationale: string;
  provenance: any;
  updatedAt: number;
  executedAt?: number;
}

export function ensureDataDir(): void {
  if (!fs.existsSync(DATA_DIR)) {
    fs.mkdirSync(DATA_DIR, { recursive: true });
  }
}

export function atomicWrite(filePath: string, data: string): void {
  const tmpPath = `${filePath}.tmp.${Date.now()}`;

  try {
    fs.writeFileSync(tmpPath, data, "utf-8");
    fs.renameSync(tmpPath, filePath);
  } catch (error) {
    if (fs.existsSync(tmpPath)) {
      fs.unlinkSync(tmpPath);
    }
    throw error;
  }
}

export function loadActions(): Record<string, SerializedAction> {
  ensureDataDir();

  if (!fs.existsSync(STORE_PATH)) {
    return {};
  }

  try {
    const content = fs.readFileSync(STORE_PATH, "utf-8");
    const data = JSON.parse(content);
    return deserializeActions(data);
  } catch (error) {
    console.error(`Failed to load actions: ${error}`);
    return {};
  }
}

export function saveActions(actions: Record<string, SerializedAction>): void {
  ensureDataDir();

  try {
    const content = JSON.stringify(actions, null, 2);
    atomicWrite(STORE_PATH, content);
  } catch (error) {
    console.error(`Failed to save actions: ${error}`);
    throw error;
  }
}

export function deserializeActions(
  data: Record<string, any>
): Record<string, SerializedAction> {
  const result: Record<string, SerializedAction> = {};

  for (const [id, raw] of Object.entries(data)) {
    try {
      result[id] = validateAction(raw);
    } catch (error) {
      console.warn(`Invalid action ${id}, skipping: ${error}`);
    }
  }

  return result;
}

function validateAction(raw: any): SerializedAction {
  if (typeof raw.id !== "string" || !raw.id) {
    throw new Error("Action missing valid id");
  }

  const validStates = [
    "DRAFT",
    "PROPOSED",
    "APPROVED",
    "EXECUTED",
    "OBSERVED",
    "VERIFIED",
    "REJECTED",
  ];

  if (!validStates.includes(raw.state)) {
    throw new Error(`Invalid state: ${raw.state}`);
  }

  if (typeof raw.rationale !== "string") {
    throw new Error("Rationale must be a string");
  }

  if (typeof raw.updatedAt !== "number") {
    throw new Error("UpdatedAt must be a number");
  }

  if (raw.state === "EXECUTED" && !raw.executedAt) {
    throw new Error("EXECUTED actions must have executedAt");
  }

  return raw as SerializedAction;
}

export function auditActions(actions: Record<string, SerializedAction>): void {
  for (const [id, action] of Object.entries(actions)) {
    try {
      validateAction(action);
    } catch (error) {
      throw new Error(`Audit failed for action ${id}: ${error}`);
    }
  }
}

````

## üìÑ `legacy/governance/verification/CodeChangeGovernance.tla`

````text
---------------------------- MODULE CodeChangeGovernance --------------------
EXTENDS Naturals

CONSTANTS
  ACTIONS = {a1, a2}
  STATES = {DRAFT, PROPOSED, APPROVED, EXECUTED, OBSERVED, VERIFIED, REJECTED}

VARIABLES
  actionState \in [ACTIONS -> STATES]
  worldState
  snapshot
  caps

----------------------------------------------------------------------------
TYPE DEFINITION
----------------------------------------------------------------------------

ValidState == STATES

LegalTransition(from, to) ==
  /\ (from = DRAFT /\ to = PROPOSED)
  \/ (from = PROPOSED /\ (to = APPROVED \/ to = REJECTED))
  \/ (from = APPROVED /\ to = EXECUTED)
  \/ (from = EXECUTED /\ to = OBSERVED)
  \/ (from = OBSERVED /\ to = VERIFIED)

----------------------------------------------------------------------------
INITIAL STATE
----------------------------------------------------------------------------

Init ==
  /\ actionState = [a \in ACTIONS |-> DRAFT]
  /\ worldState = Empty
  /\ snapshot = 0
  /\ caps = Empty

----------------------------------------------------------------------------
INVARIANTS
----------------------------------------------------------------------------

StateInvariant ==
  /\A a \in ACTIONS : ValidState(actionState[a])

ApprovalInvariant ==
  /\A a \in ACTIONS :
      actionState[a] = APPROVED =>
        \/ \E t \in TIMES :
            /\ actionState[a] # t = PROPOSED
            /\ HumanApproved(t, a)

ExecutionInvariant ==
  /\A a \in ACTIONS :
      actionState[a] = EXECUTED =>
        \/ \E t \in TIMES :
            /\ actionState[a] # t = APPROVED
            /\ SnapshotCreated(t)
            /\ SnapshotValid(t)

NoExtraChangesInvariant ==
  /\A a \in ACTIONS :
      actionState[a] = EXECUTED =>
        WorldChanges \subseteq DeclaredChanges(a)

RevocableInvariant ==
  /\A a \in ACTIONS :
      actionState[a] = REJECTED =>
        /\A t' > t :
            actionState[a] # t' = REJECTED

CapabilityInvariant ==
  /\A a \in ACTIONS :
      actionState[a] = EXECUTED =>
        \/ \E c \in caps :
            CapabilityValid(c) /\
            CapabilitySubject(c) = a /\
            CapabilityGrantExecute(c, a)

----------------------------------------------------------------------------
TRANSITION ACTIONS
----------------------------------------------------------------------------

Propose(a) ==
  /\ actionState[a] = DRAFT
  /\ actionState' = [actionState EXCEPT ![a -> PROPOSED]]

Approve(a) ==
  /\ actionState[a] = PROPOSED
  /\ HumanApprovalPresent(a)
  /\ actionState' = [actionState EXCEPT ![a -> APPROVED]]

Reject(a) ==
  /\ actionState[a] \in {PROPOSED, APPROVED, EXECUTED, OBSERVED}
  /\ actionState' = [actionState EXCEPT ![a -> REJECTED]]

Execute(a, s) ==
  /\ actionState[a] = APPROVED
  /\ SnapshotExists(s)
  /\ snapshot = s
  /\ worldState' = ApplyDiff(worldState, a)
  /\ actionState' = [actionState EXCEPT ![a -> EXECUTED]]

Observe(a) ==
  /\ actionState[a] = EXECUTED
  /\ WorldChanges = GetGitDiff(worldState')
  /\ actionState' = [actionState EXCEPT ![a -> OBSERVED]]

Verify(a) ==
  /\ actionState[a] = OBSERVED
  /\ VerifyNoExtraChanges(a, worldState')
  /\ actionState' = [actionState EXCEPT ![a -> OBSERVED]]

Rollback(a, s) ==
  /\ actionState[a] = EXECUTED
  /\ SnapshotExists(s)
  /\ worldState' = s
  /\ actionState' = [actionState EXCEPT ![a -> REJECTED]]

IssueCap(c, agent, rights, scope) ==
  /\ c \notin caps
  /\ caps' = caps \cup {c}
  /\ CapabilitySignatureValid(c)

RevokeCap(c) ==
  /\ c \in caps
  /\ caps' = caps \ {c}

----------------------------------------------------------------------------
NEXT STATE RELATION
----------------------------------------------------------------------------

Next ==
  \/ \E a \in ACTIONS : Propose(a)
  \/ \E a \in ACTIONS : Approve(a)
  \/ \E a \in ACTIONS : Reject(a)
  \/ \E a \in ACTIONS, s \in Snapshot : Execute(a, s)
  \/ \E a \in ACTIONS : Observe(a)
  \/ \E a \in ACTIONS : Verify(a)
  \/ \E a \in ACTIONS, s \in Snapshot : Rollback(a, s)
  \/ \E c \in Cap, agent \in Agent, rights \in Rights, scope \in Scope : IssueCap(c, agent, rights, scope)
  \/ \E c \in Cap : RevokeCap(c)

----------------------------------------------------------------------------
THEOREMS
----------------------------------------------------------------------------

THEOREM NoSkippedStates ==
  ASSUMING Init /\ [][Next]_actionState
  PROVE  \A a \in ACTIONS :
              actionState[a] = EXECUTED =>
                \/ \E t1, t2, t3 \in TIMES :
                    actionState[a] # t1 = PROPOSED /\
                    actionState[a] # t2 = APPROVED /\
                    actionState[a] # t3 = EXECUTED

THEOREM NoUnauthorizedExecution ==
  ASSUMING Init /\ [][Next]_actionState
  PROVE  \A a \in ACTIONS :
              actionState[a] = EXECUTED =>
                HumanApprovedBeforeExecution(a)

THEOREM RollbackSafety ==
  ASSUMING Init /\ Execute(a, s) /\ Rollback(a, s)
  PROVE  worldState = s

THEOREM CapabilityEnforcement ==
  ASSUMING Init /\ [][Next]_caps
  PROVE  \A a \in ACTIONS, c \in caps :
              (c \in caps /\ CapabilitySubject(c) = a /\ CapabilityGrantExecute(c, a)) =>
                actionState[a] = EXECUTED

=============================================================================

````

## üìÑ `policy/model/ModelRegistry.ts`

````typescript
import { ModelCapabilities } from '../../core/modelMatcher';
import { AtomicCapability } from '../../core/capabilities';
import { ModelSpec } from '../token/types';

/**
 * ModelRegistry - Ê®°ÂûãËßÑÊ†ºÊ≥®ÂÜåË°®
 *
 * Â∞ÜÁé∞ÊúâÁöÑ ModelCapabilities Êâ©Â±ï‰∏∫ ModelSpecÔºå
 * Êèê‰æõÁªü‰∏ÄÁöÑÊ®°Âûã‰ø°ÊÅØÊü•ËØ¢Êé•Âè£„ÄÇ
 */
export class ModelRegistry {
    private models: Map<string, ModelSpec> = new Map();

    constructor(baseCapabilities: ModelCapabilities[]) {
        baseCapabilities.forEach(cap => this.register(cap));
    }

    /**
     * Ê≥®ÂÜåÊ®°ÂûãËßÑÊ†º
     */
    private register(cap: ModelCapabilities): void {
        const spec: ModelSpec = {
            name: cap.name,
            contextWindow: cap.contextWindow ?? 32768,
            costTier: cap.costProfile ?? 'medium',
            longContextCapable: cap.atomicCapabilities.includes(
                AtomicCapability.LONG_CONTEXT
            )
        };
        this.models.set(cap.name, spec);
    }

    /**
     * Ê†πÊçÆÂêçÁß∞Ëé∑ÂèñÊ®°ÂûãËßÑÊ†º
     */
    get(name: string): ModelSpec | undefined {
        return this.models.get(name);
    }

    /**
     * Ëé∑ÂèñÈªòËÆ§Ê®°Âûã
     */
    getDefault(): ModelSpec {
        const defaultModel = this.get('gemini-2.5-flash-lite');
        if (!defaultModel) {
            throw new Error('Default model not found in registry');
        }
        return defaultModel;
    }

    /**
     * Êü•ÊâæÊâÄÊúâÊîØÊåÅÈïøÊñáÊú¨ÁöÑÊ®°Âûã
     * Êåâ‰∏ä‰∏ãÊñáÁ™óÂè£Â§ßÂ∞èÈôçÂ∫èÊéíÂàó
     */
    findLongContextCapable(): ModelSpec[] {
        return Array.from(this.models.values())
            .filter(m => m.longContextCapable)
            .sort((a, b) => b.contextWindow - a.contextWindow);
    }

    /**
     * Êü•ÊâæÊúÄ‰Ω≥ÈïøÊñáÊú¨Ê®°Âûã
     * ËøîÂõû‰∏ä‰∏ãÊñáÁ™óÂè£ÊúÄÂ§ßÁöÑÊ®°Âûã
     */
    findBestLongContextModel(): ModelSpec | undefined {
        const longContextModels = this.findLongContextCapable();
        return longContextModels.length > 0 ? longContextModels[0] : undefined;
    }

    /**
     * ÂàóÂá∫ÊâÄÊúâÂ∑≤Ê≥®ÂÜåÁöÑÊ®°Âûã
     */
    listModels(): ModelSpec[] {
        return Array.from(this.models.values());
    }
}

````

## üìÑ `policy/sampler.ts`

````typescript
import { PendingContextItem, SamplingStrategy } from '../policy/token/types';

/**
 * ContextSampler - ‰∏ä‰∏ãÊñáÈááÊ†∑Âô®
 *
 * ËÅåË¥£Ôºö
 * - ÂÆûÁé∞ head_tail ÈááÊ†∑Á≠ñÁï•
 * - ‰øùÁïôÊñá‰ª∂Â§¥ÈÉ®ÂíåÂ∞æÈÉ®Ôºå‰∏¢ÂºÉ‰∏≠Èó¥ÈÉ®ÂàÜ
 */
export class ContextSampler {
    /**
     * ÂØπ PendingContextItem Â∫îÁî®ÈááÊ†∑Á≠ñÁï•
     */
    static async applySampling(
        item: PendingContextItem,
        strategy: SamplingStrategy
    ): Promise<PendingContextItem> {
        if (strategy === 'none' || item.samplingStrategy === 'none') {
            return item;
        }

        if (strategy === 'head_tail' || item.samplingStrategy === 'head_tail') {
            return this.applyHeadTail(item);
        }

        if (strategy === 'random') {
            return this.applyRandom(item);
        }

        return item;
    }

    /**
     * Head-Tail ÈááÊ†∑Ôºö‰øùÁïôÂ§¥ÈÉ®ÂíåÂ∞æÈÉ®ÂêÑ 30 Ë°å
     */
    private static async applyHeadTail(
        item: PendingContextItem
    ): Promise<PendingContextItem> {
        const resolved = await item.resolve();
        const lines = resolved.content.split('\n');

        const keepLines = 60;
        const headLines = Math.min(30, Math.floor(lines.length / 2));
        const tailLines = Math.min(30, Math.floor(lines.length / 2));

        const sampledLines = [
            ...lines.slice(0, headLines),
            // ...lines.slice(headLines, lines.length - tailLines), // Ë∑≥Ëøá‰∏≠Èó¥ÈÉ®ÂàÜ
            ...lines.slice(-tailLines)
        ];

        return {
            ...item,
            id: `${item.id} (sampled)`,
            resolve: async () => ({
                content: sampledLines.join('\n'),
                byteSize: Buffer.byteLength(sampledLines.join('\n'), 'utf-8'),
                lineCount: sampledLines.length
            })
        };
    }

    /**
     * Random ÈááÊ†∑ÔºöÈöèÊú∫‰øùÁïô 50% ÁöÑË°å
     */
    private static async applyRandom(
        item: PendingContextItem
    ): Promise<PendingContextItem> {
        const resolved = await item.resolve();
        const lines = resolved.content.split('\n');

        const sampledLines = lines.filter((_, index) => Math.random() > 0.5);

        return {
            ...item,
            id: `${item.id} (random)`,
            resolve: async () => ({
                content: sampledLines.join('\n'),
                byteSize: Buffer.byteLength(sampledLines.join('\n'), 'utf-8'),
                lineCount: sampledLines.length
            })
        };
    }
}

````

## üìÑ `policy/syntaxHandler.ts`

````typescript
import fs from 'fs/promises';
import path from 'path';
import { PendingContextItem, SamplingStrategy } from '../policy/token/types';

/**
 * SyntaxHandler - ËØ≠Ê≥ïËß£ÊûêÂô®ÂíåÂª∂ËøüÂä†ËΩΩÁîüÊàêÂô®
 *
 * ËÅåË¥£Ôºö
 * - Ëß£Êûê @file Âíå #dir ËØ≠Ê≥ï
 * - ËøîÂõû PendingContextItem[]Ôºà‰∏çËØªÂèñÂÜÖÂÆπÔºâ
 * - Êèê‰æõ estimate() Âíå resolve() ÊñπÊ≥ï
 */
export class SyntaxHandler {
    static parse(tokens: string[]): PendingContextItem[] {
        const items: PendingContextItem[] = [];

        for (const token of tokens) {
            if (token.startsWith('@')) {
                const item = this.parseFileToken(token);
                if (item) items.push(item);
            } else if (token.startsWith('#')) {
                const item = this.parseDirToken(token);
                if (item) items.push(item);
            }
        }

        return items;
    }

    /**
     * Ëß£ÊûêÊñá‰ª∂ÂºïÁî® @file:path:start-end
     */
    private static parseFileToken(token: string): PendingContextItem | null {
        const raw = token.slice(1);
        const { filePath, range } = this.parsePathAndRange(raw);

        if (!filePath) return null;

        const absPath = path.resolve(filePath);

        return {
            id: absPath,
            type: 'file',
            originalToken: token,
            samplingStrategy: 'head_tail',

            estimate: async () => {
                try {
                    const stat = await fs.stat(absPath);
                    return { byteSize: stat.size };
                } catch (error: any) {
                    throw error;
                }
            },

            resolve: async () => {
                let content = await fs.readFile(absPath, 'utf-8');

                if (range) {
                    content = this.applyRange(content, range);
                }

                return {
                    content,
                    byteSize: Buffer.byteLength(content, 'utf-8'),
                    lineCount: content.split('\n').length
                };
            }
        };
    }

    /**
     * Ëß£ÊûêÁõÆÂΩïÂºïÁî® #dir
     */
    private static parseDirToken(token: string): PendingContextItem | null {
        const dir = token.slice(1);
        const absPath = path.resolve(dir);

        return {
            id: absPath,
            type: 'dir',
            originalToken: token,
            samplingStrategy: 'head_tail',

            estimate: async () => {
                try {
                    const files = await this.scanDir(absPath);
                    let total = 0;
                    for (const f of files) {
                        const stat = await fs.stat(f);
                        total += stat.size;
                    }
                    return { byteSize: total };
                } catch (error: any) {
                    throw error;
                }
            },

            resolve: async () => {
                const files = await this.scanDir(absPath);
                let content = '';
                for (const f of files) {
                    content += `\n// ===== ${f} =====\n`;
                    content += await fs.readFile(f, 'utf-8');
                }
                return {
                    content,
                    byteSize: Buffer.byteLength(content, 'utf-8')
                };
            }
        };
    }

    /**
     * Ëß£ÊûêË∑ØÂæÑÂíåË°åÂè∑ËåÉÂõ¥
     */
    private static parsePathAndRange(raw: string): {
        filePath: string;
        range?: { start: number; end: number };
    } {
        const match = raw.match(/^(.*?)(?::(\d+)-(\d+))?$/);
        if (!match) return { filePath: raw };

        const [, filePath, start, end] = match;
        if (!start || !end) return { filePath };

        return {
            filePath,
            range: { start: Number(start), end: Number(end) }
        };
    }

    /**
     * Â∫îÁî®Ë°åÂè∑ËåÉÂõ¥
     */
    private static applyRange(
        content: string,
        range?: { start: number; end: number }
    ): string {
        if (!range) return content;
        const lines = content.split('\n');
        return lines.slice(range.start - 1, range.end).join('\n');
    }

    /**
     * Êâ´ÊèèÁõÆÂΩïÔºàÈÄíÂΩíÔºâ
     */
    private static async scanDir(dirPath: string): Promise<string[]> {
        const files: string[] = [];

        async function scan(dirPath: string) {
            const entries = await fs.readdir(dirPath, { withFileTypes: true });

            for (const entry of entries) {
                const fullPath = path.join(dirPath, entry.name);

                if (entry.isDirectory()) {
                    await scan(fullPath);
                } else if (entry.isFile()) {
                    files.push(fullPath);
                }
            }
        }

        await scan(dirPath);
        return files;
    }
}

````

## üìÑ `policy/token/DefaultTokenPolicy.ts`

````typescript
import { TokenPolicy, TokenPolicyInput, TokenPolicyResult, TokenAction } from './types';
import { TokenEstimator } from './TokenEstimator';

/**
 * DefaultTokenPolicy - ÈªòËÆ§ÁöÑ 4 Â±Ç Token Ê≤ªÁêÜÁ≠ñÁï•
 *
 * Á≠ñÁï•ÂàÜÂ±ÇÔºö
 * - ÂÆâÂÖ®Âå∫ (‚â§70%): Áõ¥Êé•ÊîæË°å
 * - È¢ÑË≠¶Âå∫ (70-80%): ÊîæË°å‰ΩÜËÆ∞ÂΩïË≠¶Âëä
 * - Ë≠¶ÂëäÂå∫ (80-100%): ÈúÄË¶ÅÁî®Êà∑Á°ÆËÆ§ÔºåÊèê‰æõÂ§öÁßçËß£ÂÜ≥ÊñπÊ°à
 * - ÈòªÊñ≠Âå∫ (>100%): Âº∫Âà∂ÈòªÊñ≠ÔºåÂøÖÈ°ª‰øÆÊîπÂÜÖÂÆπÊàñÂàáÊç¢Ê®°Âûã
 */
export class DefaultTokenPolicy implements TokenPolicy {
    /**
     * ËØÑ‰º∞ Token ‰ΩøÁî®Âπ∂ËøîÂõûÂÜ≥Á≠ñÁªìÊûú
     */
    async evaluate(input: TokenPolicyInput): Promise<TokenPolicyResult> {
        const { model, contextItems, mode } = input;

        // 1. ÂºÇÊ≠•‰º∞ÁÆó Token Ê∂àËÄóÔºàÂÖ≥ÈîÆÔºöÊ≠§Êó∂Êñá‰ª∂Â∞öÊú™ËØªÂÖ•ÂÜÖÂ≠òÔºâ
        const summary = await TokenEstimator.estimate(contextItems);
        const limit = model.contextWindow;
        const ratio = summary.estimatedTokens / limit;

        // 2. Ê£ÄÊü•ÈòªÂ°ûÈîôËØØÔºàÊùÉÈôêÈóÆÈ¢òÁ≠âÔºâ
        if (summary.blockingError) {
            return this.createBlockResult(
                summary.estimatedTokens,
                limit,
                ratio,
                summary.blockingError,
                model
            );
        }

        // 3. ÊâßË°å 4 Â±ÇÁ≠ñÁï•ÂàÜÊîØ
        if (ratio <= 0.7 && summary.warnings.length === 0) {
            return this.createOkResult(
                summary.estimatedTokens,
                limit,
                ratio
            );
        }

        if (ratio <= 0.8) {
            return this.createWarnResult(
                summary.estimatedTokens,
                limit,
                ratio,
                summary.warnings,
                false
            );
        }

        if (ratio <= 1.0) {
            return this.createWarnResult(
                summary.estimatedTokens,
                limit,
                ratio,
                summary.warnings,
                true
            );
        }

        // > 100% - ÈòªÊñ≠
        return this.createBlockResult(
            summary.estimatedTokens,
            limit,
            ratio,
            undefined,
            model
        );
    }

    /**
     * OK ÁªìÊûúÔºàÂÆâÂÖ®Âå∫ÊàñÈ¢ÑË≠¶Âå∫Ôºâ
     */
    private createOkResult(
        estimatedTokens: number,
        limit: number,
        ratio: number,
        message?: string
    ): TokenPolicyResult {
        return {
            status: 'ok',
            estimatedTokens,
            limit,
            ratio,
            message
        };
    }

    /**
     * Warn ÁªìÊûúÔºàË≠¶ÂëäÂå∫ÔºåÊèê‰æõÂ§öÁßçËß£ÂÜ≥ÊñπÊ°àÔºâ
     */
    private createWarnResult(
        estimatedTokens: number,
        limit: number,
        ratio: number,
        warnings: Array<{ item: string; message: string }>,
        isDanger: boolean
    ): TokenPolicyResult {
        const actions: TokenAction[] = [
            {
                type: 'confirm_continue',
                label: 'ÁªßÁª≠ÊâßË°å',
                desc: 'ÂøΩÁï•È£éÈô©ÊåâÂéüÊ†∑ÂèëÈÄÅ'
            }
        ];

        // Â¶ÇÊûúÊ®°Âûã‰∏çÊîØÊåÅÈïøÊñáÊú¨ÔºåÊèê‰æõÂàáÊç¢ÈÄâÈ°π
        if (isDanger) {
            actions.push({
                type: 'suggest_model_switch',
                label: 'ÂàáÊç¢Ëá≥ÈïøÊñáÊú¨Ê®°Âûã',
                desc: '‰ΩøÁî®ÊîØÊåÅÊõ¥Â§ß‰∏ä‰∏ãÊñáÁöÑÊ®°Âûã',
                targetModel: 'gemini-2.0-flash-exp'
            });
        }

        // Pipe Ê®°Âºè‰∏ìÂ±ûÔºöËá™Âä®ÈááÊ†∑
        // Ê≥®ÊÑèÔºöËøôÈáåÂè™ÊòØÂ£∞ÊòéËÉΩÂäõÔºå‰∏çÂÆûÈôÖÈááÊ†∑
        actions.push({
            type: 'auto_sample_pipe',
            label: 'Ëá™Âä®ÈááÊ†∑',
            desc: '‰ªÖ‰øùÁïôÂ§¥ÈÉ®ÂíåÂ∞æÈÉ®‰ø°ÊÅØ',
            strategy: 'head_tail'
        });

        actions.push({
            type: 'abort',
            label: 'ÁªàÊ≠¢‰ªªÂä°',
            desc: 'ÈÄÄÂá∫ÂΩìÂâçÊìç‰Ωú'
        });

        const baseMessage = isDanger
            ? `‚ö†Ô∏è ‰∏ä‰∏ãÊñáÂç†Áî®Áéá ${(ratio * 100).toFixed(1)}%ÔºåÊé•ËøëÊ®°ÂûãÈôêÂà∂„ÄÇ`
            : `‚ÑπÔ∏è  ‰∏ä‰∏ãÊñáÂç†Áî®Áéá ${(ratio * 100).toFixed(1)}%„ÄÇ`;

        const warningMessages = warnings.length > 0
            ? warnings.map(w => `  - ${w.message}`).join('\n')
            : '';

        return {
            status: 'warn',
            estimatedTokens,
            limit,
            ratio,
            message: `${baseMessage}${warningMessages ? '\n\n‚ö†Ô∏è Ë≠¶Âëä:\n' + warningMessages : ''}`,
            actions,
            warnings: warnings.map(w => w.message)
        };
    }

    /**
     * Block ÁªìÊûúÔºàÈòªÊñ≠Âå∫Ôºâ
     */
    private createBlockResult(
        estimatedTokens: number,
        limit: number,
        ratio: number,
        blockingError: string | undefined,
        model: any
    ): TokenPolicyResult {
        const errorMessage = blockingError
            ? `‚õî ${blockingError}`
            : `‚õî ‰∏ä‰∏ãÊñáË∂ÖÈôê (${(ratio * 100).toFixed(1)}% / 100%)`;

        const actions: TokenAction[] = [];

        // Â¶ÇÊûúÊòØÂõ†‰∏∫Ë∂ÖÈôêÔºåÊèê‰æõÊ®°ÂûãÂàáÊç¢ÈÄâÈ°π
        if (!blockingError && model.longContextCapable === false) {
            actions.push({
                type: 'suggest_model_switch',
                label: 'ÂàáÊç¢Ëá≥ÈïøÊñáÊú¨Ê®°Âûã',
                desc: '‰ΩøÁî®ÊîØÊåÅÊõ¥Â§ß‰∏ä‰∏ãÊñáÁöÑÊ®°Âûã',
                targetModel: 'gemini-2.0-flash-exp'
            });
        }

        actions.push({
            type: 'abort',
            label: 'ÁªàÊ≠¢‰ªªÂä°',
            desc: 'ÈÄÄÂá∫ÂΩìÂâçÊìç‰Ωú'
        });

        return {
            status: 'block',
            estimatedTokens,
            limit,
            ratio,
            message: `${errorMessage}\n\nÂøÖÈ°ªÁº©ÂáèÂÜÖÂÆπÊàñÂàáÊç¢Ê®°ÂûãÊâçËÉΩÁªßÁª≠„ÄÇ`,
            actions,
            warnings: blockingError ? [blockingError] : undefined
        };
    }
}

````

## üìÑ `policy/token/TokenEstimator.ts`

````typescript
import { PendingContextItem, EstimateSummary } from './types';

// ÈªòËÆ§Âπ∂ÂèëÈôêÂà∂
const DEFAULT_CONCURRENCY = 50;

/**
 * TokenEstimator - ËΩªÈáèÁ∫ß„ÄÅÈõ∂ÂâØ‰ΩúÁî®ÁöÑ Token È¢Ñ‰º∞
 *
 * ËÆæËÆ°ÂéüÂàôÔºö
 * 1. Âè™Ë∞ÉÁî® estimate()Ôºå‰ªé‰∏çË∞ÉÁî® resolve()
 * 2. ÊîØÊåÅÂπ∂ÂèëÊéßÂà∂ÔºåÈÅøÂÖç EMFILE ÈîôËØØ
 * 3. ÈîôËØØÂàÜÁ±ªÔºöEACCES ‚Üí block, ENOENT ‚Üí warn
 */
export class TokenEstimator {
    /**
     * Âü∫‰∫é Promise.allSettled Âπ∂ÂèëÈ¢Ñ‰º∞ Token Ê∂àËÄó
     *
     * @param items - ÂæÖ‰º∞ÁÆóÁöÑ‰∏ä‰∏ãÊñáÈ°π
     * @param concurrency - ÊúÄÂ§ßÂπ∂ÂèëÊï∞ÔºàÈªòËÆ§ 50Ôºâ
     * @returns ‰º∞ÁÆóÊëòË¶ÅÔºåÂåÖÂê´ token Êï∞„ÄÅË≠¶ÂëäÂíåÈòªÂ°ûÈîôËØØ
     */
    static async estimate(
        items: PendingContextItem[],
        concurrency: number = DEFAULT_CONCURRENCY
    ): Promise<EstimateSummary> {
        const summary: EstimateSummary = {
            totalBytes: 0,
            estimatedTokens: 0,
            warnings: [],
            blockingError: undefined
        };

        if (items.length === 0) {
            return summary;
        }

        // ‰ΩøÁî®Âπ∂ÂèëÊéßÂà∂Êù•ÈÅøÂÖçÊñá‰ª∂ÊèèËø∞Á¨¶ËÄóÂ∞Ω
        const batchResults = await this.batchEstimate(items, concurrency);

        // Â§ÑÁêÜÁªìÊûú
        batchResults.forEach((result, idx) => {
            if (result.success) {
                const value = result.value;
                if (value) {
                    summary.totalBytes += value.byteSize;
                }
            } else {
                this.handleError(items[idx], result.error, summary);
            }
        });

        // ËΩ¨Êç¢Â≠óËäÇÂà∞ TokenÔºàÁªèÈ™åÂÖ¨ÂºèÔºö1 token ‚âà 4 bytesÔºâ
        summary.estimatedTokens = Math.ceil(summary.totalBytes / 4);

        return summary;
    }

    /**
     * ÊâπÈáè‰º∞ÁÆóÔºåÈôêÂà∂Âπ∂ÂèëÊï∞
     */
    private static async batchEstimate(
        items: PendingContextItem[],
        concurrency: number
    ): Promise<Array<{ success: boolean; value?: { byteSize: number }; error?: any }>> {
        const results: Array<{ success: boolean; value?: { byteSize: number }; error?: any }> = [];

        for (let i = 0; i < items.length; i += concurrency) {
            const batch = items.slice(i, i + concurrency);
            const batchPromises = batch.map(async (item, batchIdx) => {
                try {
                    const estimate = await item.estimate?.();
                    return { success: true, value: estimate || { byteSize: 0 } };
                } catch (error: any) {
                    return { success: false, error };
                }
            });

            const batchResults = await Promise.all(batchPromises);
            results.push(...batchResults);
        }

        return results;
    }

    /**
     * ÈîôËØØÂàÜÁ±ªÂ§ÑÁêÜ

    /**
     * ÈîôËØØÂàÜÁ±ªÂ§ÑÁêÜ
     *
     * ËØ≠‰πâÂÆö‰πâÔºö
     * - EACCES (ÊùÉÈôêÊãíÁªù) ‚Üí ÂøÖÈ°ªÈòªÂ°ûÔºåÊó†Ê≥ïÊÅ¢Â§ç
     * - ENOENT (Êñá‰ª∂‰∏çÂ≠òÂú®) ‚Üí Ë≠¶ÂëäÔºåÊñá‰ª∂ÂèØËÉΩË¢´Âà†Èô§
     * - EMFILE (Êñá‰ª∂ÊèèËø∞Á¨¶ËøáÂ§ö) ‚Üí Ë≠¶ÂëäÔºå‰∏¥Êó∂Á≥ªÁªüÁä∂ÊÄÅ
     * - ÂÖ∂‰ªñÈîôËØØ ‚Üí Ë≠¶ÂëäÔºåÈôçÁ∫ßË°å‰∏∫
     */
    private static handleError(
        item: PendingContextItem,
        error: any,
        summary: EstimateSummary
    ): void {
        const errorCode = error?.code || 'UNKNOWN';

        switch (errorCode) {
            case 'EACCES':
                summary.blockingError = `Permission denied: ${item.id}`;
                break;

            case 'ENOENT':
                summary.warnings.push({
                    item: item.id,
                    message: `ENOENT: ${error.message || `File not found: ${item.id}`}`
                });
                break;

            case 'EMFILE':
                summary.warnings.push({
                    item: item.id,
                    message: `Too many open files: ${item.id}`
                });
                break;

            default:
                summary.warnings.push({
                    item: item.id,
                    message: `Estimate failed for ${item.id}: ${error.message || String(error)}`
                });
        }
    }
}

````

## üìÑ `registry/errors.ts`

````typescript
export enum RegistryErrorCode {
  INIT_FAILED = 'INIT_FAILED',
  INVALID_MANIFEST = 'INVALID_MANIFEST',
  CHECKSUM_MISMATCH = 'CHECKSUM_MISMATCH',
  NOT_FOUND = 'NOT_FOUND',
  INVALID_STATE = 'INVALID_STATE',
  CAPABILITY_DENIED = 'CAPABILITY_DENIED',
  DEPENDENCY_CYCLE = 'DEPENDENCY_CYCLE',
  VERSION_CONFLICT = 'VERSION_CONFLICT'
}

export class RegistryError extends Error {
  readonly code: RegistryErrorCode;
  readonly details?: any;

  constructor(code: RegistryErrorCode, message: string, details?: any) {
    super(message);
    this.name = 'RegistryError';
    this.code = code;
    this.details = details;
    Error.captureStackTrace(this, this.constructor);
  }

  toJSON() {
    return {
      name: this.name,
      code: this.code,
      message: this.message,
      details: this.details
    };
  }
}

````

## üìÑ `registry/index.ts`

````typescript
export * from './manifest';
export * from './registry';
export * from './errors';

````

## üìÑ `registry/manifest.ts`

````typescript
import { randomUUID } from 'crypto';
import { createHash } from 'crypto';

export type Capability = 
  | 'read:workspace'
  | 'write:workspace'
  | 'run:shell'
  | 'read:config'
  | 'write:config'
  | 'network:http'
  | 'secret:use'
  | 'secret:read'
  | string;

export type MacroState = 'draft' | 'approved' | 'deprecated';

export interface MacroDependency {
  macro: string;
  version: string;
  mode: 'inline' | 'isolated';
}

export interface MacroManifest {
  id: string;
  version: string;
  description: string;

  author: string;
  createdAt: number;
  updatedAt?: number;

  requires: Capability[];
  inputs?: Record<string, any>;

  checksum: string;
  state: MacroState;

  dependsOn?: MacroDependency[];
  tags?: string[];
  previousChecksum?: string;
}

export interface MacroPublishOptions {
  autoApprove?: boolean;
  skipCapabilityCheck?: boolean;
}

export interface MacroDiffResult {
  hasChanges: boolean;
  capabilityDiff: {
    added: Capability[];
    removed: Capability[];
    unchanged: Capability[];
  };
  requiresApproval: boolean;
  reason?: string;
}

export interface MacroRegistryConfig {
  storagePath: string;
  autoApproveSafe: boolean;
  maxRiskLevel: 'low' | 'medium' | 'high';
}

export function calculateChecksum(manifest: Omit<MacroManifest, 'checksum'>): string {
  const data = JSON.stringify({
    id: manifest.id,
    version: manifest.version,
    requires: manifest.requires.sort(),
    dependsOn: manifest.dependsOn
  });
  return createHash('sha256').update(data).digest('hex');
}

export function validateManifest(manifest: any): manifest is MacroManifest {
  if (!manifest.id || typeof manifest.id !== 'string') return false;
  if (!manifest.version || typeof manifest.version !== 'string') return false;
  if (!manifest.state || !['draft', 'approved', 'deprecated'].includes(manifest.state)) return false;
  if (!Array.isArray(manifest.requires)) return false;
  if (!manifest.checksum || typeof manifest.checksum !== 'string') return false;
  if (!manifest.author || typeof manifest.author !== 'string') return false;
  if (!manifest.createdAt || typeof manifest.createdAt !== 'number') return false;

  return true;
}

````

## üìÑ `registry/registry.ts`

````typescript
import fs from 'fs/promises';
import path from 'path';
import type {
  MacroManifest,
  MacroState,
  MacroPublishOptions,
  MacroDiffResult,
  MacroRegistryConfig,
  Capability
} from './manifest';
import { calculateChecksum, validateManifest } from './manifest';
import { RegistryError, RegistryErrorCode } from './errors';

export class MacroRegistry {
  private config: MacroRegistryConfig;
  private manifests: Map<string, MacroManifest[]> = new Map();

  constructor(config: Partial<MacroRegistryConfig> = {}) {
    this.config = {
      storagePath: config.storagePath || path.join(process.cwd(), '.yuangs_registry'),
      autoApproveSafe: config.autoApproveSafe ?? false,
      maxRiskLevel: config.maxRiskLevel || 'medium'
    };
  }

  async initialize(): Promise<void> {
    try {
      await fs.mkdir(this.config.storagePath, { recursive: true });
      await this.loadFromDisk();
    } catch (error) {
      throw new RegistryError(
        RegistryErrorCode.INIT_FAILED,
        `Failed to initialize registry: ${error}`
      );
    }
  }

  async publish(
    manifest: Omit<MacroManifest, 'checksum'>,
    options: MacroPublishOptions = {}
  ): Promise<MacroManifest> {
    const { autoApprove = this.config.autoApproveSafe, skipCapabilityCheck = false } = options;

    const newManifest: MacroManifest = {
      ...manifest,
      createdAt: manifest.createdAt || Date.now(),
      state: manifest.state || 'draft',
      checksum: calculateChecksum(manifest)
    };

    if (!validateManifest(newManifest)) {
      throw new RegistryError(
        RegistryErrorCode.INVALID_MANIFEST,
        'Invalid manifest structure'
      );
    }

    const existingVersions = this.manifests.get(manifest.id) || [];
    const existing = existingVersions.find(v => v.version === manifest.version);

    if (existing) {
      if (existing.checksum !== newManifest.checksum) {
        throw new RegistryError(
          RegistryErrorCode.CHECKSUM_MISMATCH,
          `Version ${manifest.version} already exists with different checksum`
        );
      }
      return existing;
    }

    if (existingVersions.length > 0) {
      const diff = this.compareCapabilities(existingVersions[existingVersions.length - 1], newManifest);

      if (!skipCapabilityCheck && diff.requiresApproval) {
        newManifest.state = 'draft';
        newManifest.previousChecksum = existingVersions[existingVersions.length - 1].checksum;
      } else if (autoApprove) {
        newManifest.state = 'approved';
      }
    } else if (autoApprove) {
      newManifest.state = 'approved';
    }

    existingVersions.push(newManifest);
    this.manifests.set(manifest.id, existingVersions);

    await this.saveToDisk();

    return newManifest;
  }

  async get(macroId: string, version?: string): Promise<MacroManifest | null> {
    const versions = this.manifests.get(macroId);
    if (!versions || versions.length === 0) {
      return null;
    }

    if (version) {
      return versions.find(v => v.version === version) || null;
    }

    return versions[versions.length - 1];
  }

  async list(filters?: {
    state?: MacroState;
    author?: string;
    tags?: string[];
  }): Promise<MacroManifest[]> {
    let results: MacroManifest[] = [];

    for (const versions of this.manifests.values()) {
      const latest = versions[versions.length - 1];
      results.push(latest);
    }

    if (filters) {
      results = results.filter(m => {
        if (filters.state && m.state !== filters.state) return false;
        if (filters.author && m.author !== filters.author) return false;
        if (filters.tags && filters.tags.length > 0) {
          const hasAllTags = filters.tags.every(tag => m.tags?.includes(tag));
          if (!hasAllTags) return false;
        }
        return true;
      });
    }

    return results.sort((a, b) => b.createdAt - a.createdAt);
  }

  async approve(macroId: string, version: string, approvedBy: string): Promise<MacroManifest> {
    const versions = this.manifests.get(macroId);
    if (!versions) {
      throw new RegistryError(
        RegistryErrorCode.NOT_FOUND,
        `Macro ${macroId} not found`
      );
    }

    const manifest = versions.find(v => v.version === version);
    if (!manifest) {
      throw new RegistryError(
        RegistryErrorCode.NOT_FOUND,
        `Version ${version} of macro ${macroId} not found`
      );
    }

    if (manifest.state !== 'draft') {
      throw new RegistryError(
        RegistryErrorCode.INVALID_STATE,
        `Macro ${macroId}@${version} is not in draft state`
      );
    }

    manifest.state = 'approved';
    manifest.updatedAt = Date.now();

    await this.saveToDisk();

    return manifest;
  }

  async deprecate(macroId: string, version?: string): Promise<MacroManifest> {
    const versions = this.manifests.get(macroId);
    if (!versions) {
      throw new RegistryError(
        RegistryErrorCode.NOT_FOUND,
        `Macro ${macroId} not found`
      );
    }

    if (version) {
      const manifest = versions.find(v => v.version === version);
      if (!manifest) {
        throw new RegistryError(
          RegistryErrorCode.NOT_FOUND,
          `Version ${version} of macro ${macroId} not found`
        );
      }

      if (manifest.state !== 'approved') {
        throw new RegistryError(
          RegistryErrorCode.INVALID_STATE,
          `Cannot deprecate macro in ${manifest.state} state`
        );
      }

      manifest.state = 'deprecated';
      manifest.updatedAt = Date.now();
    } else {
      for (const manifest of versions) {
        if (manifest.state === 'approved') {
          manifest.state = 'deprecated';
          manifest.updatedAt = Date.now();
        }
      }
    }

    await this.saveToDisk();

    return version ? versions.find(v => v.version === version)! : versions[versions.length - 1];
  }

  compareCapabilities(
    oldManifest: MacroManifest,
    newManifest: MacroManifest
  ): MacroDiffResult {
    const oldSet = new Set(oldManifest.requires);
    const newSet = new Set(newManifest.requires);

    const added: string[] = [];
    const removed: string[] = [];
    const unchanged: string[] = [];

    for (const cap of newManifest.requires) {
      if (!oldSet.has(cap)) {
        added.push(cap);
      } else {
        unchanged.push(cap);
      }
    }

    for (const cap of oldManifest.requires) {
      if (!newSet.has(cap)) {
        removed.push(cap);
      }
    }

    const highRiskAdded = added.some(cap => cap.includes('shell') || cap.includes('write') || cap.includes('delete'));
    const hasNewCapabilities = added.length > 0;
    const requiresApproval = highRiskAdded || (hasNewCapabilities && !this.config.autoApproveSafe);

    return {
      hasChanges: added.length > 0 || removed.length > 0,
      capabilityDiff: {
        added,
        removed,
        unchanged
      },
      requiresApproval,
      reason: requiresApproval ? 'New capabilities require approval' : undefined
    };
  }

  async getVersions(macroId: string): Promise<MacroManifest[]> {
    return this.manifests.get(macroId) || [];
  }

  private async loadFromDisk(): Promise<void> {
    try {
      const indexPath = path.join(this.config.storagePath, 'index.json');
      const data = await fs.readFile(indexPath, 'utf-8');
      const loaded = JSON.parse(data) as Record<string, MacroManifest[]>;

      for (const [id, versions] of Object.entries(loaded)) {
        this.manifests.set(id, versions);
      }
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
        console.warn(`Warning: Failed to load registry from disk: ${error}`);
      }
    }
  }

  private async saveToDisk(): Promise<void> {
    const indexPath = path.join(this.config.storagePath, 'index.json');
    const data = Object.fromEntries(this.manifests);
    await fs.writeFile(indexPath, JSON.stringify(data, null, 2), 'utf-8');
  }
}

````

## üìÑ `risk/explainer.ts`

````typescript
import type { Capability, MacroManifest } from '../registry/manifest';

export type RiskLevel = 'low' | 'medium' | 'high';

export interface RiskAssessment {
  overallRisk: RiskLevel;
  score: number;
  factors: RiskFactor[];
  requiresApproval: boolean;
  explanation: string;
}

export interface RiskFactor {
  type: 'capability' | 'destructive' | 'dependency' | 'network' | 'secret';
  severity: RiskLevel;
  description: string;
  capability?: string;
  suggestion?: string;
}

export interface CapabilityNode {
  id: Capability;
  risk: RiskLevel;
  description: string;
  implies?: Capability[];
}

export interface CapabilityGraph {
  nodes: Map<Capability, CapabilityNode>;
  version: string;
}

export function createCapabilityGraph(): CapabilityGraph {
  const nodes = new Map<Capability, CapabilityNode>();

  nodes.set('read:workspace', {
    id: 'read:workspace',
    risk: 'low',
    description: 'Read files from the workspace',
    implies: ['read:config']
  });

  nodes.set('write:workspace', {
    id: 'write:workspace',
    risk: 'high',
    description: 'Write files to the workspace',
    implies: ['read:workspace', 'write:config']
  });

  nodes.set('run:shell', {
    id: 'run:shell',
    risk: 'high',
    description: 'Execute shell commands',
    implies: ['read:workspace', 'write:workspace']
  });

  nodes.set('read:config', {
    id: 'read:config',
    risk: 'low',
    description: 'Read configuration files'
  });

  nodes.set('write:config', {
    id: 'write:config',
    risk: 'medium',
    description: 'Write configuration files'
  });

  nodes.set('network:http', {
    id: 'network:http',
    risk: 'medium',
    description: 'Make HTTP requests'
  });

  nodes.set('secret:use', {
    id: 'secret:use',
    risk: 'high',
    description: 'Access secrets (without reading values)'
  });

  nodes.set('secret:read', {
    id: 'secret:read',
    risk: 'high',
    description: 'Read secret values'
  });

  return {
    nodes,
    version: '1.0.0'
  };
}

export class RiskExplainer {
  private graph: CapabilityGraph;
  private highRiskPatterns: RegExp[];

  constructor(graph?: CapabilityGraph) {
    this.graph = graph || createCapabilityGraph();
    this.highRiskPatterns = [
      /rm\s+-rf/i,
      />\s*\/dev\/null/,
      /dd\s+if=/,
      /sudo\s+rm/
    ];
  }

  explainRisk(manifest: MacroManifest): RiskAssessment {
    const factors: RiskFactor[] = [];

    for (const cap of manifest.requires) {
      const capRisk = this.assessCapability(cap);
      factors.push(...capRisk);
    }

    if (manifest.tags?.includes('destructive')) {
      factors.push({
        type: 'destructive',
        severity: 'high',
        description: 'Macro is tagged as destructive',
        suggestion: 'Requires manual approval from a senior developer'
      });
    }

    if (manifest.dependsOn && manifest.dependsOn.length > 0) {
      factors.push({
        type: 'dependency',
        severity: 'medium',
        description: `Depends on ${manifest.dependsOn.length} external macro(s)`,
        suggestion: 'Review dependency chain for transitive capabilities'
      });
    }

    const overallRisk = this.calculateOverallRisk(factors);
    const score = this.riskToScore(overallRisk);
    const requiresApproval = overallRisk !== 'low';

    return {
      overallRisk,
      score,
      factors,
      requiresApproval,
      explanation: this.generateExplanation(manifest, overallRisk, factors)
    };
  }

  expandCapabilities(capabilities: Capability[]): Capability[] {
    const expanded = new Set<Capability>();

    const stack = [...capabilities];

    while (stack.length > 0) {
      const cap = stack.pop()!;
      if (expanded.has(cap)) continue;

      expanded.add(cap);

      const node = this.graph.nodes.get(cap);
      if (node?.implies) {
        stack.push(...node.implies);
      }
    }

    return Array.from(expanded);
  }

  explainCapability(capability: Capability): string {
    const node = this.graph.nodes.get(capability);

    if (!node) {
      return `Unknown capability: ${capability}`;
    }

    let explanation = `${node.description} (Risk: ${node.risk.toUpperCase()})`;

    if (node.implies && node.implies.length > 0) {
      explanation += `\n  Implies: ${node.implies.join(', ')}`;
    }

    return explanation;
  }

  private assessCapability(capability: Capability): RiskFactor[] {
    const factors: RiskFactor[] = [];
    const node = this.graph.nodes.get(capability);

    if (!node) {
      factors.push({
        type: 'capability',
        severity: 'medium',
        description: `Unknown capability: ${capability}`,
        capability,
        suggestion: 'Define this capability in the graph'
      });
      return factors;
    }

    if (node.risk === 'high') {
      factors.push({
        type: 'capability',
        severity: 'high',
        description: `High-risk capability: ${capability}`,
        capability,
        suggestion: 'Ensure this capability is absolutely necessary'
      });
    }

    if (capability.includes('shell')) {
      factors.push({
        type: 'capability',
        severity: 'high',
        description: 'Shell execution capability - can run arbitrary commands',
        capability,
        suggestion: 'Review all shell commands carefully'
      });
    }

    if (capability.includes('secret')) {
      factors.push({
        type: 'secret',
        severity: 'high',
        description: 'Access to secrets',
        capability,
        suggestion: 'Ensure secrets are scoped properly'
      });
    }

    return factors;
  }

  private calculateOverallRisk(factors: RiskFactor[]): RiskLevel {
    if (factors.some(f => f.severity === 'high')) {
      return 'high';
    }
    if (factors.some(f => f.severity === 'medium')) {
      return 'medium';
    }
    return 'low';
  }

  private riskToScore(risk: RiskLevel): number {
    switch (risk) {
      case 'low': return 1;
      case 'medium': return 5;
      case 'high': return 10;
    }
  }

  private generateExplanation(
    manifest: MacroManifest,
    risk: RiskLevel,
    factors: RiskFactor[]
  ): string {
    let explanation = `Macro "${manifest.id}@${manifest.version}" has ${risk.toUpperCase()} risk.\n\n`;

    explanation += `Required capabilities (${manifest.requires.length}):\n`;
    for (const cap of manifest.requires) {
      explanation += `  - ${this.explainCapability(cap)}\n`;
    }

    if (factors.length > 0) {
      explanation += `\nRisk factors:\n`;
      for (const factor of factors) {
        explanation += `  [${factor.severity.toUpperCase()}] ${factor.description}\n`;
        if (factor.suggestion) {
          explanation += `      ‚Üí ${factor.suggestion}\n`;
        }
      }
    }

    explanation += `\n`;
    if (risk === 'high') {
      explanation += '‚ö†Ô∏è  This macro requires manual approval before execution.\n';
      explanation += 'Review the capabilities and ensure you understand the impact.\n';
    } else if (risk === 'medium') {
      explanation += '‚ö†Ô∏è  This macro has moderate risk. Consider the implications carefully.\n';
    } else {
      explanation += '‚úÖ This macro has low risk and can be auto-approved.\n';
    }

    return explanation;
  }
}

````

## üìÑ `risk/index.ts`

````typescript
export * from './explainer';

````

## üìÑ `types.d.ts`

````typescript
declare module 'marked-terminal' {
    import { Renderer } from 'marked';
    export default class TerminalRenderer extends Renderer {
        constructor(options?: any);
    }
}

````

## üìÑ `utils/confirm.ts`

````typescript
import * as readline from 'node:readline/promises';
import chalk from 'chalk';

export async function confirm(message: string): Promise<boolean> {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
    });

    try {
        const answer = await rl.question(chalk.yellow(`\n‚ö†Ô∏è  ${message} (y/N) `));
        return answer.toLowerCase() === 'y';
    } finally {
        rl.close();
    }
}


````

## üìÑ `utils/history.ts`

````typescript
import fs from 'fs';
import path from 'path';
import os from 'os';
import { parseCommandHistory, type HistoryEntry } from '../core/validation';

const HISTORY_FILE = path.join(os.homedir(), '.yuangs_cmd_history.json');

export type { HistoryEntry };

export function getCommandHistory(): HistoryEntry[] {
    if (fs.existsSync(HISTORY_FILE)) {
        try {
            return parseCommandHistory(fs.readFileSync(HISTORY_FILE, 'utf8'));
        } catch (e) { }
    }
    return [];
}

export function saveHistory(entry: { question: string; command: string }) {
    let history = getCommandHistory();
    const newEntry: HistoryEntry = {
        ...entry,
        time: new Date().toLocaleString()
    };
    // Keep last 1000, unique commands
    history = [newEntry, ...history.filter(item => item.command !== entry.command)].slice(0, 1000);
    fs.writeFileSync(HISTORY_FILE, JSON.stringify(history, null, 2));
}

````

## üìÑ `utils/renderer.ts`

````typescript
import chalk from 'chalk';
import * as marked from 'marked';
import TerminalRenderer from 'marked-terminal';
import ora, { Ora } from 'ora';

// ÂàùÂßãÂåñ marked ÈÖçÁΩÆ
marked.setOptions({
    renderer: new TerminalRenderer({
        tab: 2,
        width: process.stdout.columns || 80,
        showSectionPrefix: false
    }) as any
});

export class StreamMarkdownRenderer {
    private fullResponse: string = '';
    private prefix: string;
    private isFirstOutput: boolean = true;
    private spinner: Ora | null = null;
    private startTime: number;

    constructor(prefix: string = chalk.bold.blue('ü§ñ AIÔºö'), spinner?: Ora) {
        this.prefix = prefix;
        this.spinner = spinner || null;
        this.startTime = Date.now();
    }

    /**
     * Â§ÑÁêÜÊµÅÂºèÊï∞ÊçÆÂùó
     */
    public onChunk(chunk: string) {
        if (this.spinner && this.spinner.isSpinning) {
            this.spinner.stop();
        }

        if (this.isFirstOutput) {
            process.stdout.write(this.prefix);
            this.isFirstOutput = false;
        }

        this.fullResponse += chunk;
        process.stdout.write(chunk);
    }

    /**
     * ÊµÅÁªìÊùüÔºåÊâßË°åÂõûÊªöÂπ∂Ê∏≤Êüì Markdown
     */
    public finish(): string {
        // Â¶ÇÊûú Spinner ËøòÂú®ËΩ¨ÔºàËØ¥ÊòéÊ≤°Êúâ‰ªª‰ΩïËæìÂá∫ÔºâÔºåÂÖàÂÅúÊéâ
        if (this.spinner && this.spinner.isSpinning) {
            this.spinner.stop();
        }

        const formatted = (marked.parse(this.fullResponse, { async: false }) as string).trim();

        if (process.stdout.isTTY && this.fullResponse.trim()) {
            const screenWidth = process.stdout.columns || 80;
            const totalContent = this.prefix + this.fullResponse;
            
            // ËÆ°ÁÆóÂéüÂßãÊñáÊú¨Âç†Áî®ÁöÑÂèØËßÜË°åÊï∞
            const lineCount = this.getVisualLineCount(totalContent, screenWidth);

            // 1. Ê∏ÖÈô§ÂΩìÂâçË°åÂâ©‰ΩôÂÜÖÂÆπ
            process.stdout.write('\r\x1b[K');
            // 2. Âêë‰∏äÂõûÊªöÂπ∂Ê∏ÖÈô§‰πãÂâçÁöÑË°å
            for (let i = 0; i < lineCount - 1; i++) {
                process.stdout.write('\x1b[A\x1b[K');
            }

            // 3. ËæìÂá∫Ê†ºÂºèÂåñÂêéÁöÑ Markdown
            process.stdout.write(this.prefix + formatted + '\n');
        } else {
            // Èùû TTY Ê®°ÂºèÊàñÊó†ÂÜÖÂÆπÔºåÁõ¥Êé•Ë°•ÂÖÖÊç¢Ë°åÔºàÂ¶ÇÊûú‰πãÂâçËæìÂá∫‰∫ÜÂÜÖÂÆπÔºâ
            if (this.fullResponse.trim()) {
                process.stdout.write('\n'); 
            }
        }

        // ËæìÂá∫ËÄóÊó∂ÁªüËÆ°
        const elapsed = (Date.now() - this.startTime) / 1000;
        process.stdout.write('\n' + chalk.gray(`‚îÄ`.repeat(20) + ` (ËÄóÊó∂: ${elapsed.toFixed(2)}s) ` + `‚îÄ`.repeat(20) + '\n\n'));

        return this.fullResponse;
    }

    /**
     * ËÆ°ÁÆóÊñáÊú¨Âú®ÁªàÁ´ØÁöÑÂèØËßÜË°åÊï∞
     */
    private getVisualLineCount(text: string, screenWidth: number): number {
        const stripAnsi = (str: string) => str.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, '');

        const lines = text.split('\n');
        let totalLines = 0;

        for (const line of lines) {
            // Expand tabs
            const expandedLine = line.replace(/\t/g, '        ');
            const cleanLine = stripAnsi(expandedLine);

            let lineWidth = 0;
            for (const char of cleanLine) {
                const code = char.codePointAt(0) || 0;
                // Â§ßÈÉ®ÂàÜÂÆΩÂ≠óÁ¨¶ÔºàÂ¶Ç‰∏≠ÊñáÔºâÂç† 2 Ê†º
                lineWidth += code > 255 ? 2 : 1;
            }

            if (lineWidth === 0) {
                totalLines += 1;
            } else {
                totalLines += Math.ceil(lineWidth / screenWidth);
            }
        }

        return totalLines;
    }
}

````

## üìÑ `utils/syntaxHandler.ts`

````typescript
import fs from 'fs';
import chalk from 'chalk';
import path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';
import { buildPromptWithFileContent, readFilesContent } from '../core/fileReader';
import { ContextBuffer } from '../commands/contextBuffer';
import { loadContext, saveContext } from '../commands/contextStorage';

const execAsync = promisify(exec);

/**
 * Ëß£ÊûêÂπ∂Â§ÑÁêÜÁâπÊÆäËØ≠Ê≥ïÔºà@„ÄÅ#„ÄÅ:ls Á≠âÔºâ
 */
export async function handleSpecialSyntax(input: string, stdinData?: string): Promise<{ processed: boolean; result?: string }> {
    const trimmed = input.trim();

    // Â§ÑÁêÜ @ Êñá‰ª∂ÂºïÁî®ËØ≠Ê≥ï
    if (trimmed.startsWith('@')) {
        // Ê£ÄÊü•ÊòØÂê¶ÊòØ @! Á´ãÂç≥ÊâßË°åËØ≠Ê≥ï
        const immediateExecMatch = trimmed.match(/^@\s*!\s*(.+?)$/);
        if (immediateExecMatch) {
            const filePath = immediateExecMatch[1].trim();
            return await handleImmediateExec(filePath);
        }

        // Ê£ÄÊü•ÊòØÂê¶ÊòØÂ∏¶Ë°åÂè∑ÁöÑËØ≠Ê≥ï @file:start-end
        const lineRangeMatch = trimmed.match(/^@\s*(.+?)(?::(\d+)(?:-(\d+))?)?\s*(?:\n(.*))?$/s);
        if (lineRangeMatch) {
            const filePath = lineRangeMatch[1];
            const startLine = lineRangeMatch[2] ? parseInt(lineRangeMatch[2]) : null;
            const endLine = lineRangeMatch[3] ? parseInt(lineRangeMatch[3]) : null;
            const question = lineRangeMatch[4] || (stdinData ? `ÂàÜÊûê‰ª•‰∏ãÊñá‰ª∂ÂÜÖÂÆπÔºö\n\n${stdinData}` : 'ËØ∑ÂàÜÊûêËøô‰∏™Êñá‰ª∂');

            return await handleFileReference(filePath.trim(), startLine, endLine, question);
        }
    }

    // Â§ÑÁêÜ # ÁõÆÂΩïÂºïÁî®ËØ≠Ê≥ï
    if (trimmed.startsWith('#')) {
        const dirMatch = trimmed.match(/^#\s*(.+?)\s*(?:\n(.*))?$/s);
        if (dirMatch) {
            const dirPath = dirMatch[1].trim();
            const question = dirMatch[2] || (stdinData ? `ÂàÜÊûê‰ª•‰∏ãÁõÆÂΩïÂÜÖÂÆπÔºö\n\n${stdinData}` : 'ËØ∑ÂàÜÊûêËøô‰∏™ÁõÆÂΩï');
            return await handleDirectoryReference(dirPath, question);
        }
    }

    // Â§ÑÁêÜ :ls ÂëΩ‰ª§
    if (trimmed === ':ls') {
        return await handleListContext();
    }

    // Âú∫ÊôØ 5.1: :exec ÂéüÂ≠êÊâßË°å
    if (trimmed.startsWith(':exec ')) {
        const command = trimmed.slice(6).trim();
        return await handleAtomicExec(command);
    }

    // Â§ÑÁêÜ :cat [index] ÂëΩ‰ª§
    if (trimmed === ':cat' || trimmed.startsWith(':cat ')) {
        const parts = trimmed.split(' ');
        const index = parts.length > 1 ? parseInt(parts[1]) : null;
        return await handleCatContext(index);
    }

    // Â§ÑÁêÜ :clear ÂëΩ‰ª§
    if (trimmed === ':clear') {
        return await handleClearContext();
    }

    // Â¶ÇÊûú‰∏çÊòØÁâπÊÆäËØ≠Ê≥ïÔºåËøîÂõûÊú™Â§ÑÁêÜ
    return { processed: false };
}

async function handleFileReference(filePath: string, startLine: number | null = null, endLine: number | null = null, question?: string): Promise<{ processed: boolean; result: string }> {
    const fullPath = path.resolve(filePath);

    if (!fs.existsSync(fullPath) || !fs.statSync(fullPath).isFile()) {
        return { 
            processed: true, 
            result: `ÈîôËØØ: Êñá‰ª∂ "${filePath}" ‰∏çÂ≠òÂú®Êàñ‰∏çÊòØ‰∏Ä‰∏™Êñá‰ª∂` 
        };
    }

    try {
        let content = fs.readFileSync(fullPath, 'utf-8');
        
        // Â¶ÇÊûúÊåáÂÆö‰∫ÜË°åÂè∑ËåÉÂõ¥ÔºåÂàôÊèêÂèñÁõ∏Â∫îË°å
        if (startLine !== null) {
            const lines = content.split('\n');
            
            // È™åËØÅË°åÂè∑ËåÉÂõ¥
            if (startLine < 1 || startLine > lines.length) {
                return { 
                    processed: true, 
                    result: `ÈîôËØØ: Ëµ∑ÂßãË°åÂè∑ ${startLine} Ë∂ÖÂá∫Êñá‰ª∂ËåÉÂõ¥ (Êñá‰ª∂ÂÖ±Êúâ ${lines.length} Ë°å)` 
                };
            }

            const startIdx = startLine - 1; // ËΩ¨Êç¢‰∏∫Êï∞ÁªÑÁ¥¢ÂºïÔºà‰ªé0ÂºÄÂßãÔºâ
            let endIdx = endLine ? Math.min(endLine, lines.length) : lines.length; // Â¶ÇÊûúÊú™ÊåáÂÆöÁªìÊùüË°åÔºåÂàôÂà∞Êñá‰ª∂Êú´Â∞æ

            if (endLine && (endLine < startLine || endLine > lines.length)) {
                return { 
                    processed: true, 
                    result: `ÈîôËØØ: ÁªìÊùüË°åÂè∑ ${endLine} Ë∂ÖÂá∫ÊúâÊïàËåÉÂõ¥ (Â∫îÂú® ${startLine}-${lines.length} ‰πãÈó¥)` 
                };
            }

            // ÊèêÂèñÊåáÂÆöËåÉÂõ¥ÁöÑË°å
            content = lines.slice(startIdx, endIdx).join('\n');
        }

        const contentMap = new Map<string, string>();
        contentMap.set(filePath, content);

        // ÊåÅ‰πÖÂåñÂà∞‰∏ä‰∏ãÊñá
        const contextBuffer = new ContextBuffer();
        const persisted = await loadContext();
        contextBuffer.import(persisted);

        contextBuffer.add({
            type: 'file',
            path: filePath + (startLine !== null ? `:${startLine}${endLine ? `-${endLine}` : ''}` : ''),
            content: content
        });

        await saveContext(contextBuffer.export());

        const prompt = buildPromptWithFileContent(
            `Êñá‰ª∂: ${filePath}${startLine !== null ? `:${startLine}${endLine ? `-${endLine}` : ''}` : ''}`,
            [filePath],
            contentMap,
            question || `ËØ∑ÂàÜÊûêÊñá‰ª∂: ${filePath}`
        );

        return { processed: true, result: prompt };
    } catch (error) {
        return { 
            processed: true, 
            result: `ËØªÂèñÊñá‰ª∂Â§±Ë¥•: ${error}` 
        };
    }
}

async function handleDirectoryReference(dirPath: string, question?: string): Promise<{ processed: boolean; result: string }> {
    const fullPath = path.resolve(dirPath);

    if (!fs.existsSync(fullPath) || !fs.statSync(fullPath).isDirectory()) {
        return { 
            processed: true, 
            result: `ÈîôËØØ: ÁõÆÂΩï "${dirPath}" ‰∏çÂ≠òÂú®Êàñ‰∏çÊòØ‰∏Ä‰∏™ÁõÆÂΩï` 
        };
    }

    try {
        const findCommand = process.platform === 'darwin' || process.platform === 'linux'
            ? `find "${fullPath}" -type f`
            : `dir /s /b "${fullPath}"`;

        const { stdout } = await execAsync(findCommand);
        const filePaths = stdout.trim().split('\n').filter(f => f);

        if (filePaths.length === 0) {
            return { 
                processed: true, 
                result: `ÁõÆÂΩï "${dirPath}" ‰∏ãÊ≤°ÊúâÊñá‰ª∂` 
            };
        }

        const contentMap = readFilesContent(filePaths);

        // ÊåÅ‰πÖÂåñÂà∞‰∏ä‰∏ãÊñá
        const contextBuffer = new ContextBuffer();
        const persisted = await loadContext();
        contextBuffer.import(persisted);

        contextBuffer.add({
            type: 'directory',
            path: dirPath,
            content: Array.from(contentMap.entries()).map(([p, c]) => `--- ${p} ---\n${c}`).join('\n\n')
        });

        await saveContext(contextBuffer.export());

        const prompt = buildPromptWithFileContent(
            `ÁõÆÂΩï: ${dirPath}\nÊâæÂà∞ ${filePaths.length} ‰∏™Êñá‰ª∂`,
            filePaths.map(p => path.relative(process.cwd(), p)),
            contentMap,
            question
        );

        return { processed: true, result: prompt };
    } catch (error) {
        return { 
            processed: true, 
            result: `ËØªÂèñÁõÆÂΩïÂ§±Ë¥•: ${error}` 
        };
    }
}

async function handleImmediateExec(filePath: string): Promise<{ processed: boolean; result: string }> {
    const fullPath = path.resolve(filePath);

    if (!fs.existsSync(fullPath)) {
        return { 
            processed: true, 
            result: `ÈîôËØØ: Êñá‰ª∂ "${filePath}" ‰∏çÂ≠òÂú®` 
        };
    }

    try {
        // 1. ËØªÂèñËÑöÊú¨ÂÜÖÂÆπ
        const content = fs.readFileSync(fullPath, 'utf-8');
        
        console.log(chalk.gray(`Ê≠£Âú®ÊâßË°å ${filePath} Âπ∂ÊçïËé∑ËæìÂá∫...`));
        
        // 2. ÊâßË°åËÑöÊú¨
        // Ê≥®ÊÑèÔºöËøôÈáå‰ΩøÁî® execAsync ÊçïËé∑ËæìÂá∫
        const { stdout, stderr } = await execAsync(`chmod +x "${fullPath}" && "${fullPath}"`, { cwd: process.cwd() });
        
        // 3. ÊûÑÈÄ†ÁªÑÂêà‰∏ä‰∏ãÊñá (Â•ëÁ∫¶Ë¶ÅÊ±ÇÔºöÂëΩ‰ª§ÂÜÖÂÆπ + ÂÆûÈôÖËæìÂá∫)
        const combinedContext = `
=== ËÑöÊú¨ÂÜÖÂÆπ (${filePath}) ===
\`\`\`bash
${content}
\`\`\`

=== ÊâßË°åÊ†áÂáÜËæìÂá∫ (stdout) ===
\`\`\`
${stdout}
\`\`\`

=== ÊâßË°åÊ†áÂáÜÈîôËØØ (stderr) ===
\`\`\`
${stderr}
\`\`\`
`;

        // ÊåÅ‰πÖÂåñÂà∞‰∏ä‰∏ãÊñá
        const contextBuffer = new ContextBuffer();
        const persisted = await loadContext();
        contextBuffer.import(persisted);

        contextBuffer.add({
            type: 'file',
            path: `${filePath} (Runtime Log)`,
            content: combinedContext,
            summary: 'ÂåÖÂê´ËÑöÊú¨Ê∫êÁ†ÅÂíåÊâßË°åÂêéÁöÑËæìÂá∫Êó•Âøó'
        });

        await saveContext(contextBuffer.export());

        // ËøîÂõûÁªô AI ÁöÑ Prompt
        const result = `ÊàëÊâßË°å‰∫ÜËÑöÊú¨ ${filePath}„ÄÇ\n‰ª•‰∏ãÊòØËÑöÊú¨Ê∫êÁ†ÅÂíåÊâßË°åËæìÂá∫Ôºö\n${combinedContext}\n\nËØ∑ÂàÜÊûê‰∏∫‰Ωï‰ºöÂá∫Áé∞‰∏äËø∞ËæìÂá∫ÔºàÁâπÂà´ÊòØÈîôËØØ‰ø°ÊÅØÔºâÔºü`;
        return { processed: true, result };
    } catch (error: any) {
        const errorMsg = error.message || String(error);
        const result = `ÊâßË°åËÑöÊú¨ ${filePath} Êó∂ÂèëÁîüÈîôËØØÔºö\n${errorMsg}\n\nËØ∑ÂàÜÊûêÂéüÂõ†„ÄÇ`;
        return { processed: true, result };
    }
}

async function handleAtomicExec(command: string): Promise<{ processed: boolean; result: string }> {
    console.log(chalk.cyan(`\n‚ö°Ô∏è [Atomic Exec] ÊâßË°åÂëΩ‰ª§: ${command}\n`));
    
    try {
        // ÂØπ‰∫éÂéüÂ≠êÊâßË°åÔºåÊàë‰ª¨Â∏åÊúõÁî®Êà∑ËÉΩÂÆûÊó∂ÁúãÂà∞ËæìÂá∫ÔºåÊâÄ‰ª•Áî® inherit
        const { spawn } = require('child_process');
        const child = spawn(command, { 
            shell: true, 
            stdio: 'inherit' 
        });

        await new Promise<void>((resolve, reject) => {
            child.on('close', (code: number) => {
                if (code === 0) resolve();
                else reject(new Error(`Exit code ${code}`));
            });
            child.on('error', reject);
        });
        
        // ÂéüÂ≠êÊâßË°å‰∏çÂ∞ÜÁªìÊûú‰º†Áªô AIÔºåÁõ¥Êé•ËøîÂõûÁ©∫ÁªìÊûúË°®Á§∫Â§ÑÁêÜÂÆåÊàê
        return { processed: true, result: '' }; 
    } catch (error) {
        console.error(chalk.red(`ÊâßË°åÂ§±Ë¥•: ${error}`));
        return { processed: true, result: '' };
    }
}

async function handleListContext(): Promise<{ processed: boolean; result: string }> {
    try {
        const persisted = await loadContext();
        const contextBuffer = new ContextBuffer();
        contextBuffer.import(persisted);

        if (contextBuffer.isEmpty()) {
            return { processed: true, result: 'ÂΩìÂâçÊ≤°Êúâ‰∏ä‰∏ãÊñá' };
        }

        const list = contextBuffer.list();
        let result = 'ÂΩìÂâç‰∏ä‰∏ãÊñáÂàóË°®Ôºö\n';
        list.forEach((item, index) => {
            result += `${index + 1}. ${item.type}: ${item.path} (${item.tokens} tokens)\n`;
        });

        return { processed: true, result };
    } catch (error) {
        return { 
            processed: true, 
            result: `ËØªÂèñ‰∏ä‰∏ãÊñáÂ§±Ë¥•: ${error}` 
        };
    }
}

async function handleCatContext(index: number | null): Promise<{ processed: boolean; result: string }> {
    try {
        const persisted = await loadContext();
        const contextBuffer = new ContextBuffer();
        contextBuffer.import(persisted);

        if (contextBuffer.isEmpty()) {
            return { processed: true, result: 'ÂΩìÂâçÊ≤°Êúâ‰∏ä‰∏ãÊñá' };
        }

        const items = contextBuffer.export();

        if (index !== null) {
            // Êü•ÁúãÊåáÂÆöÁ¥¢Âºï
            if (index < 1 || index > items.length) {
                return { processed: true, result: `ÈîôËØØ: Á¥¢Âºï ${index} Ë∂ÖÂá∫ËåÉÂõ¥ (ÂÖ±Êúâ ${items.length} ‰∏™È°πÁõÆ)` };
            }
            const item = items[index - 1];
            return { 
                processed: true, 
                result: `--- [${index}] ${item.type}: ${item.path} ---\n${item.content}\n--- End ---` 
            };
        } else {
            // Êü•ÁúãÂÖ®ÈÉ®
            let result = '=== ÂΩìÂâçÂÆåÊï¥‰∏ä‰∏ãÊñáÂÜÖÂÆπ ===\n\n';
            items.forEach((item, i) => {
                result += `--- [${i + 1}] ${item.type}: ${item.path} ---\n${item.content}\n\n`;
            });
            result += '==========================';
            return { processed: true, result };
        }
    } catch (error) {
        return { 
            processed: true, 
            result: `ËØªÂèñ‰∏ä‰∏ãÊñáÂ§±Ë¥•: ${error}` 
        };
    }
}

async function handleClearContext(): Promise<{ processed: boolean; result: string }> {
    try {
        // Ê∏ÖÈô§ÊåÅ‰πÖÂåñÂ≠òÂÇ®
        await saveContext([]);
        
        return { processed: true, result: '‰∏ä‰∏ãÊñáÂ∑≤Ê∏ÖÁ©∫ÔºàÂê´ÊåÅ‰πÖÂåñÔºâ' };
    } catch (error) {
        return { 
            processed: true, 
            result: `Ê∏ÖÈô§‰∏ä‰∏ãÊñáÂ§±Ë¥•: ${error}` 
        };
    }
}

````
