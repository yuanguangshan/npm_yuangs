```code
/**
 * @fileoverview A script to validate the GitHub Flavored Markdown (GFM) compatibility of markdown files.
 * It uses the 'marked' library to parse markdown and can be extended with GFM-specific checks.
 */

const fs = require('fs');
const path = require('path');
const marked = require('marked');
const { markedHighlight } = require('marked-highlight');
const hljs = require('highlight.js'); // Assuming highlight.js is used for code highlighting

// --- Configuration ---
// Directories to scan for markdown files. Adjust as needed.
const MARKDOWN_DIRS = [
    '.', // Root directory
    'docs', // Example: if you have a docs folder
    // Add other directories containing markdown files
];

// File extensions to consider as markdown.
const MARKDOWN_EXTENSIONS = ['.md', '.markdown'];

// --- GFM Compatibility Rules (Conceptual) ---
// This section outlines potential checks for GFM compatibility.
// Currently, 'marked' itself handles much of the GFM parsing.
// For stricter validation, custom rules can be implemented here.

/**
 * Checks if a given markdown string adheres to GFM compatibility.
 * This is a conceptual function that can be expanded.
 * @param {string} markdownContent The markdown content to validate.
 * @returns {{isValid: boolean, errors: string[]}} Validation result.
 */
function checkGfmCompatibility(markdownContent) {
    const errors = [];
    let isValid = true;

    // --- Example GFM Checks ---
    // 1. Table Syntax: GFM has specific table syntax. 'marked' generally handles this.
    //    You could add checks for malformed tables if needed.
    // 2. Task Lists: GFM supports task lists like "- [ ] task".
    //    You might want to check for correct formatting if 'marked' doesn't flag it.
    // 3. Strikethrough: GFM supports `~~strikethrough~~`.
    // 4. Autolinks: GFM auto-links URLs.
    // 5. Footnotes: GFM supports footnotes (though this might be less common in project READMEs).

    // For now, we rely on 'marked' parsing to implicitly validate.
    // If 'marked' throws an error during parsing, it would be caught below.

    // Example: Check for common markdown pitfalls that might render differently
    // For instance, excessive use of raw HTML that might not be allowed or escaped.
    if (markdownContent.includes('<script>')) {
        errors.push("Potentially unsafe raw HTML: <script> tag detected. GFM might sanitize or disallow this.");
        isValid = false;
    }

    // Add more specific GFM checks here.
    // For example, check for correct usage of code block delimiters with language specifiers.
    // Or ensure emoji shortcodes are correctly formatted if they are used.

    return { isValid, errors };
}

// --- Marked Renderer Configuration ---
// Configure marked for GFM features.
// The 'gfm: true' option enables GFM features like tables, strikethrough, etc.
const markedRenderer = new marked.Renderer();

// Configure code highlighting
markedRenderer.code = (code, language) => {
    const highlighted = language ? hljs.highlight(code, { language }).value : code;
    return `<pre><code class="language-${language || 'plaintext'}">${highlighted}</code></pre>`;
};

marked.use({
    renderer: markedRenderer,
    pedantic: false, // Set to true for stricter parsing, but GFM is more lenient
    gfm: true,       // Enable GitHub Flavored Markdown
    breaks: false,   // Set to true if you want newline characters to create line breaks
});

// --- File Discovery and Validation ---

/**
 * Recursively finds all markdown files in a given directory.
 * @param {string} dirPath The directory to start searching from.
 * @returns {string[]} An array of absolute paths to markdown files.
 */
function findMarkdownFiles(dirPath) {
    let markdownFiles = [];
    const files = fs.readdirSync(dirPath);

    for (const file of files) {
        const filePath = path.join(dirPath, file);
        const stat = fs.statSync(filePath);

        if (stat.isDirectory()) {
            markdownFiles = markdownFiles.concat(findMarkdownFiles(filePath));
        } else if (MARKDOWN_EXTENSIONS.some(ext => filePath.endsWith(ext))) {
            markdownFiles.push(path.resolve(filePath));
        }
    }
    return markdownFiles;
}

/**
 * Main function to discover and validate markdown files.
 */
async function validateMarkdownFiles() {
    let allMarkdownFiles = [];
    for (const dir of MARKDOWN_DIRS) {
        const absolutePath = path.resolve(dir);
        if (fs.existsSync(absolutePath) && fs.statSync(absolutePath).isDirectory()) {
            allMarkdownFiles = allMarkdownFiles.concat(findMarkdownFiles(absolutePath));
        } else {
            console.warn(`Warning: Directory "${absolutePath}" does not exist or is not a directory. Skipping.`);
        }
    }

    if (allMarkdownFiles.length === 0) {
        console.log("No markdown files found to validate.");
        return;
    }

    console.log(`Found ${allMarkdownFiles.length} markdown files. Validating GFM compatibility...`);

    let overallValid = true;
    const results = [];

    for (const filePath of allMarkdownFiles) {
        try {
            const content = fs.readFileSync(filePath, 'utf-8');
            const { isValid, errors } = checkGfmCompatibility(content);

            // Attempt to parse to catch potential rendering issues marked might encounter
            try {
                marked.parse(content);
            } catch (parseError) {
                errors.push(`Markdown parsing error: ${parseError.message}`);
                overallValid = false;
            }

            if (!isValid || errors.length > 0) {
                overallValid = false;
                results.push({
                    file: path.relative(process.cwd(), filePath),
                    isValid: false,
                    errors: errors.length > 0 ? errors : ["GFM compatibility check failed (details pending)."]
                });
            } else {
                results.push({
                    file: path.relative(process.cwd(), filePath),
                    isValid: true,
                    errors: []
                });
            }
        } catch (error) {
            overallValid = false;
            results.push({
                file: path.relative(process.cwd(), filePath),
                isValid: false,
                errors: [`Error reading or processing file: ${error.message}`]
            });
        }
    }

    console.log("\n--- GFM Compatibility Validation Summary ---");
    results.forEach(({ file, isValid, errors }) => {
        if (isValid) {
            console.log(`âœ… ${file}: OK`);
        } else {
            console.error(`âŒ ${file}: FAILED`);
            errors.forEach(err => console.error(`  - ${err}`));
        }
    });

    if (overallValid) {
        console.log("\nðŸŽ‰ All markdown files appear to be GFM compatible.");
        process.exit(0);
    } else {
        console.error("\nðŸš¨ Some markdown files failed GFM compatibility checks.");
        process.exit(1);
    }
}

// Execute the validation
validateMarkdownFiles().catch(err => {
    console.error("An unexpected error occurred during validation:", err);
    process.exit(1);
});