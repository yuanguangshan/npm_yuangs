import chalk from 'chalk';
import ora from 'ora';
import readline from 'readline';
import { callAI_Stream, getConversationHistory, addToConversationHistory, clearConversationHistory } from '../ai/client';
import * as marked from 'marked';
import TerminalRenderer from 'marked-terminal';
import fs from 'fs';
import path from 'path';
import { buildPromptWithFileContent, readFilesContent } from '../core/fileReader';
import { exec } from 'child_process';
import { promisify } from 'util';
import { ContextBuffer } from './contextBuffer';
import { loadContext, saveContext, clearContextStorage } from './contextStorage';
import { getGitContext } from './gitContext';
const execAsync = promisify(exec);

async function showFileSelector(rl: readline.Interface): Promise<string | null> {
    return new Promise((resolve) => {
        try {
            const currentDir = process.cwd();
            const files = fs.readdirSync(currentDir);

            if (files.length === 0) {
                console.log(chalk.yellow('å½“å‰ç›®å½•ä¸ºç©º\n'));
                resolve(null);
                return;
            }

            console.log(chalk.bold.cyan('ğŸ“ å½“å‰ç›®å½•æ–‡ä»¶åˆ—è¡¨:\n'));

            files.forEach((file, index) => {
                const fullPath = path.join(currentDir, file);
                const isDir = fs.statSync(fullPath).isDirectory();
                const icon = isDir ? chalk.cyan('ğŸ“') : chalk.green('ğŸ“„');
                const padding = (index + 1).toString().padStart(2);
                console.log(`  [${padding}] ${icon} ${file}`);
            });
            console.log();

            rl.question(chalk.cyan('è¯·é€‰æ‹©æ–‡ä»¶ (è¾“å…¥åºå·ï¼Œæˆ–æŒ‰ Enter è¿”å›): '), (choice) => {
                if (choice.trim() === '') {
                    console.log(chalk.gray('å·²å–æ¶ˆé€‰æ‹©\n'));
                    resolve(null);
                    return;
                }

                const index = parseInt(choice) - 1;
                if (isNaN(index) || index < 0 || index >= files.length) {
                    console.log(chalk.red('æ— æ•ˆçš„åºå·\n'));
                    resolve(null);
                    return;
                }

                const selectedFile = files[index];
                console.log(chalk.green(`âœ“ å·²é€‰æ‹©: ${selectedFile}\n`));
                resolve(selectedFile);
            });
        } catch (error) {
            console.error(chalk.red(`è¯»å–ç›®å½•å¤±è´¥: ${error}\n`));
            resolve(null);
        }
    });
}

async function handleFileReference(filePath: string, question?: string): Promise<string> {
    const fullPath = path.resolve(filePath);

    if (!fs.existsSync(fullPath) || !fs.statSync(fullPath).isFile()) {
        console.log(chalk.red(`é”™è¯¯: æ–‡ä»¶ "${filePath}" ä¸å­˜åœ¨æˆ–ä¸æ˜¯ä¸€ä¸ªæ–‡ä»¶\n`));
        return question || '';
    }

    const spinner = ora(chalk.cyan('æ­£åœ¨è¯»å–æ–‡ä»¶...')).start();

    try {
        const content = fs.readFileSync(fullPath, 'utf-8');
        const relativePath = path.relative(process.cwd(), fullPath);

        const contentMap = new Map<string, string>();
        contentMap.set(relativePath, content);

        const prompt = buildPromptWithFileContent(
            `æ–‡ä»¶: ${relativePath}`,
            [relativePath],
            contentMap,
            question || `è¯·åˆ†ææ–‡ä»¶: ${relativePath}`
        );

        spinner.stop();
        console.log(chalk.green(`âœ“ å·²è¯»å–æ–‡ä»¶: ${relativePath}\n`));
        return prompt;
    } catch (error) {
        spinner.stop();
        console.error(chalk.red(`è¯»å–æ–‡ä»¶å¤±è´¥: ${error}\n`));
        return question || '';
    }
}

async function handleFileReferenceInput(input: string): Promise<string> {
    const match = input.match(/^@\s*(.+?)\s*(?:\n(.*))?$/s);
    if (!match) {
        console.log(chalk.yellow('æ ¼å¼é”™è¯¯ï¼Œæ­£ç¡®ç”¨æ³•: @æ–‡ä»¶è·¯å¾„ [é—®é¢˜]\n'));
        return '';
    }

    const filePath = match[1].trim();
    const question = match[2] ? match[2].trim() : '';
    return handleFileReference(filePath, question);
}

async function handleDirectoryReference(input: string): Promise<string> {
    const match = input.match(/^#\s*(.+?)\s*(?:\n(.*))?$/s);
    if (!match) {
        console.log(chalk.yellow('æ ¼å¼é”™è¯¯ï¼Œæ­£ç¡®ç”¨æ³•: # ç›®å½•è·¯å¾„ [é—®é¢˜]\n'));
        return input;
    }

    const dirPath = match[1].trim();
    const question = match[2] ? match[2].trim() : 'è¯·åˆ†æè¿™ä¸ªç›®å½•ä¸‹çš„æ–‡ä»¶';

    const fullPath = path.resolve(dirPath);

    if (!fs.existsSync(fullPath) || !fs.statSync(fullPath).isDirectory()) {
        console.log(chalk.red(`é”™è¯¯: ç›®å½• "${dirPath}" ä¸å­˜åœ¨æˆ–ä¸æ˜¯ä¸€ä¸ªç›®å½•\n`));
        return question;
    }

    const spinner = ora(chalk.cyan('æ­£åœ¨è¯»å–æ–‡ä»¶...')).start();

    try {
        const findCommand = process.platform === 'darwin' || process.platform === 'linux'
            ? `find "${fullPath}" -type f`
            : `dir /s /b "${fullPath}"`;

        const { stdout } = await execAsync(findCommand);
        const filePaths = stdout.trim().split('\n').filter(f => f);

        spinner.stop();

        if (filePaths.length === 0) {
            console.log(chalk.yellow(`ç›®å½• "${dirPath}" ä¸‹æ²¡æœ‰æ–‡ä»¶\n`));
            return question;
        }

        const contentMap = readFilesContent(filePaths);

        const prompt = buildPromptWithFileContent(
            `ç›®å½•: ${dirPath}\næ‰¾åˆ° ${filePaths.length} ä¸ªæ–‡ä»¶`,
            filePaths.map(p => path.relative(process.cwd(), p)),
            contentMap,
            question
        );

        console.log(chalk.green(`âœ“ å·²è¯»å– ${contentMap.size} ä¸ªæ–‡ä»¶\n`));
        return prompt;
    } catch (error) {
        spinner.stop();
        console.error(chalk.red(`è¯»å–ç›®å½•å¤±è´¥: ${error}\n`));
        return question;
    }
}

export async function handleAIChat(initialQuestion: string | null, model?: string) {
    if (initialQuestion) {
        await askOnceStream(initialQuestion, model);
        return;
    }

    console.log(chalk.bold.cyan('\nğŸ¤– è¿›å…¥ AI äº¤äº’æ¨¡å¼ (è¾“å…¥ exit é€€å‡º)\n'));

    const contextBuffer = new ContextBuffer();
    const persisted = await loadContext();
    contextBuffer.import(persisted);

    if (persisted.length > 0) {
        console.log(chalk.yellow(`ğŸ“¦ å·²æ¢å¤ ${persisted.length} æ¡ä¸Šä¸‹æ–‡\n`));
    }

    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
        terminal: true
    });

    // Helper to wrap rl.question in a Promise
    const ask = (query: string): Promise<string> => {
        return new Promise((resolve) => {
            rl.question(query, (answer) => {
                resolve(answer);
            });
        });
    };

    try {
        while (true) {
            const input = await ask(chalk.green('ä½ ï¼š'));
            const trimmed = input.trim();

            if (trimmed.startsWith('@')) {
                rl.pause();
                try {
                    // å¢å¼ºçš„åŒ¹é…æ¨¡å¼ï¼Œæ”¯æŒè¡Œå·æŒ‡å®š: @ filepath:startLine-endLine as alias
                    const match = trimmed.match(/^@\s*(.+?)(?::(\d+)(?:-(\d+))?)?(?:\s+as\s+(.+))?$/);
                    const filePath = match?.[1] ?? (await showFileSelector(rl));
                    const lineStart = match?.[2] ? parseInt(match[2]) : null;
                    const lineEnd = match?.[3] ? parseInt(match[3]) : null;
                    const alias = match?.[4];

                    if (!filePath) continue;

                    const absolutePath = path.resolve(filePath);
                    let content = await fs.promises.readFile(absolutePath, 'utf-8');

                    // å¦‚æœæŒ‡å®šäº†è¡Œå·èŒƒå›´ï¼Œåˆ™æå–ç›¸åº”è¡Œ
                    if (lineStart !== null) {
                        const lines = content.split('\n');

                        // éªŒè¯è¡Œå·èŒƒå›´
                        if (lineStart < 1 || lineStart > lines.length) {
                            console.log(chalk.red(`\né”™è¯¯: èµ·å§‹è¡Œå· ${lineStart} è¶…å‡ºæ–‡ä»¶èŒƒå›´ (æ–‡ä»¶å…±æœ‰ ${lines.length} è¡Œ)\n`));
                            rl.resume();
                            continue;
                        }

                        const startIdx = lineStart - 1; // è½¬æ¢ä¸ºæ•°ç»„ç´¢å¼•ï¼ˆä»0å¼€å§‹ï¼‰
                        let endIdx = lineEnd ? Math.min(lineEnd, lines.length) : lines.length; // å¦‚æœæœªæŒ‡å®šç»“æŸè¡Œï¼Œåˆ™åˆ°æ–‡ä»¶æœ«å°¾

                        if (lineEnd && (lineEnd < lineStart || lineEnd > lines.length)) {
                            console.log(chalk.red(`\né”™è¯¯: ç»“æŸè¡Œå· ${lineEnd} è¶…å‡ºæœ‰æ•ˆèŒƒå›´ (åº”åœ¨ ${lineStart}-${lines.length} ä¹‹é—´)\n`));
                            rl.resume();
                            continue;
                        }

                        // æå–æŒ‡å®šèŒƒå›´çš„è¡Œ
                        content = lines.slice(startIdx, endIdx).join('\n');

                        // æ›´æ–°è·¯å¾„æ˜¾ç¤ºï¼ŒåŒ…å«è¡Œå·ä¿¡æ¯
                        const rangeInfo = lineEnd ? `${lineStart}-${lineEnd}` : `${lineStart}`;
                        const pathWithRange = `${filePath}:${rangeInfo}`;

                        contextBuffer.add({
                            type: 'file',
                            path: pathWithRange,
                            alias,
                            content
                        }, true); // bypassTokenLimit = true
                    } else {
                        // åŸå§‹è¡Œä¸ºï¼šæ·»åŠ æ•´ä¸ªæ–‡ä»¶
                        contextBuffer.add({
                            type: 'file',
                            path: filePath,
                            alias,
                            content
                        });
                    }

                    await saveContext(contextBuffer.export());
                    const displayName = alias ? `${alias} (${filePath}${lineStart !== null ? `:${lineStart}${lineEnd ? `-${lineEnd}` : ''}` : ''})` :
                        (filePath + (lineStart !== null ? `:${lineStart}${lineEnd ? `-${lineEnd}` : ''}` : ''));
                    console.log(chalk.green(`âœ… å·²åŠ å…¥æ–‡ä»¶ä¸Šä¸‹æ–‡: ${displayName}\n`));
                } catch (err: unknown) {
                    const message = err instanceof Error ? err.message : String(err);
                    console.error(chalk.red(`\n[å¤„ç†é”™è¯¯]: ${message}\n`));
                } finally {
                    rl.resume();
                }
                continue;
            }

            if (trimmed.startsWith('#')) {
                rl.pause();
                try {
                    const match = trimmed.match(/^#\s*(.+?)\s*(?:\n(.*))?$/s);
                    if (!match) {
                        console.log(chalk.yellow('æ ¼å¼é”™è¯¯ï¼Œæ­£ç¡®ç”¨æ³•: # ç›®å½•è·¯å¾„\n'));
                        rl.resume();
                        continue;
                    }

                    const dirPath = match[1].trim();
                    const fullPath = path.resolve(dirPath);

                    if (!fs.existsSync(fullPath) || !fs.statSync(fullPath).isDirectory()) {
                        console.log(chalk.red(`é”™è¯¯: ç›®å½• "${dirPath}" ä¸å­˜åœ¨æˆ–ä¸æ˜¯ä¸€ä¸ªç›®å½•\n`));
                        rl.resume();
                        continue;
                    }

                    const findCommand = process.platform === 'darwin' || process.platform === 'linux'
                        ? `find "${fullPath}" -type f`
                        : `dir /s /b "${fullPath}"`;

                    const { stdout } = await execAsync(findCommand);
                    const filePaths = stdout.trim().split('\n').filter(f => f);

                    if (filePaths.length === 0) {
                        console.log(chalk.yellow(`ç›®å½• "${dirPath}" ä¸‹æ²¡æœ‰æ–‡ä»¶\n`));
                        rl.resume();
                        continue;
                    }

                    const contentMap = readFilesContent(filePaths);
                    const prompt = buildPromptWithFileContent(
                        `ç›®å½•: ${dirPath}\næ‰¾åˆ° ${filePaths.length} ä¸ªæ–‡ä»¶`,
                        filePaths.map(p => path.relative(process.cwd(), p)),
                        contentMap,
                        ''
                    );

                    contextBuffer.add({
                        type: 'directory',
                        path: dirPath,
                        content: prompt
                    });

                    await saveContext(contextBuffer.export());
                    console.log(chalk.green(`âœ… å·²åŠ å…¥ç›®å½•ä¸Šä¸‹æ–‡: ${dirPath}\n`));
                } catch (err: unknown) {
                    const message = err instanceof Error ? err.message : String(err);
                    console.error(chalk.red(`\n[å¤„ç†é”™è¯¯]: ${message}\n`));
                } finally {
                    rl.resume();
                }
                continue;
            }

            if (['exit', 'quit', 'bye'].includes(trimmed.toLowerCase())) {
                console.log(chalk.cyan('ğŸ‘‹ å†è§ï¼'));
                break;
            }

            if (trimmed === '/clear') {
                clearConversationHistory();
                console.log(chalk.yellow('âœ“ å¯¹è¯å†å²å·²æ¸…ç©º\n'));
                continue;
            }

            if (trimmed === '/history') {
                const history = getConversationHistory();
                if (history.length === 0) {
                    console.log(chalk.gray('æš‚æ— å¯¹è¯å†å²\n'));
                } else {
                    history.forEach((msg) => {
                        const prefix = msg.role === 'user' ? chalk.green('ä½ : ') : chalk.blue('AI: ');
                        console.log(prefix + msg.content);
                    });
                }
                continue;
            }

            if (trimmed === ':ls') {
                const list = contextBuffer.list();
                if (list.length === 0) {
                    console.log(chalk.gray('ğŸ“­ å½“å‰æ²¡æœ‰ä¸Šä¸‹æ–‡\n'));
                } else {
                    console.table(list);
                }
                continue;
            }

            if (trimmed === ':clear') {
                contextBuffer.clear();
                await clearContextStorage();
                console.log(chalk.yellow('ğŸ§¹ ä¸Šä¸‹æ–‡å·²æ¸…ç©ºï¼ˆå«æŒä¹…åŒ–ï¼‰\n'));
                continue;
            }

            if (!trimmed) continue;

            let finalPrompt = contextBuffer.isEmpty()
                ? trimmed
                : contextBuffer.buildPrompt(trimmed);

            const gitContext = await getGitContext();

            if (gitContext) {
                finalPrompt = `
${gitContext}

${finalPrompt}
`;
            }

            try {
                rl.pause();
                await askOnceStream(finalPrompt, model);

                contextBuffer.clear();
                await saveContext([]);
            } catch (err: unknown) {
                const message = err instanceof Error ? err.message : String(err);
                console.error(chalk.red(`\n[AI execution error]: ${message}`));
            } finally {
                rl.resume();
            }
        }
    } catch (criticalErr: unknown) {
        const message = criticalErr instanceof Error ? criticalErr.message : String(criticalErr);
        console.error(chalk.red(`\n[Critical Loop Error]: ${message}`));
    } finally {
        rl.close();
    }
}

// é…ç½® marked ä½¿ç”¨ TerminalRenderer
marked.setOptions({
    renderer: new TerminalRenderer({
        // è‡ªå®šä¹‰ç»ˆç«¯æ¸²æŸ“é€‰é¡¹
        tab: 2,
        width: process.stdout.columns || 80,
        showSectionPrefix: false,
        // æŠ‘åˆ¶ç€è‰²é”™è¯¯ï¼Œé˜²æ­¢å…¶åœ¨æµå¼è¾“å‡ºä¸­æ‰“ç ´è¡Œæ•°è®¡ç®—
        highlight: (code: string, lang: string) => {
            return code; // é»˜è®¤è¿”å›åŸæ ·ï¼Œé¿å…æŸäº›è§£æå™¨å‘ stdout/stderr æ‰“å°è­¦å‘Š
        }
    }) as any
});

async function askOnceStream(question: string, model?: string) {
    const startTime = Date.now();
    const messages = [...getConversationHistory()];
    messages.push({ role: 'user', content: question });

    const spinner = ora(chalk.cyan('AI æ­£åœ¨æ€è€ƒ...')).start();
    let fullResponse = '';
    const BOT_PREFIX = chalk.bold.blue('ğŸ¤– AIï¼š');

    // Helper function to calculate visual lines in terminal (including wrapping)
    const getVisualLineCount = (text: string): number => {
        if (!text) return 0;
        const columns = process.stdout.columns || 80;
        const lines = text.split('\n');
        let totalLines = 0;
        for (const line of lines) {
            // Strip all ANSI escape sequences more thoroughly
            const cleanLine = line.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, '');
            let visualWidth = 0;
            for (const char of cleanLine) {
                const code = char.codePointAt(0) || 0;
                // Threshold 255 is more accurate for CJK/Emoji detection in most terminal fonts
                visualWidth += code > 255 ? 2 : 1;
            }
            // Standard terminal wrap logic: a line of length 'columns' occupies 2 rows (cursor on next row)
            totalLines += Math.floor(visualWidth / columns) + 1;
        }
        return totalLines;
    };

    try {
        // Hide cursor to prevent flickering
        process.stdout.write('\x1b[?25l');

        await callAI_Stream(messages, model, (chunk) => {
            if (spinner.isSpinning) {
                spinner.stop();
                process.stdout.write(BOT_PREFIX);
            }
            process.stdout.write(chunk);
            fullResponse += chunk;
        });

        // After stream is complete, we replace with Markdown
        const plainOutput = BOT_PREFIX + fullResponse;
        const plainLines = getVisualLineCount(plainOutput);

        if (plainLines > 0) {
            readline.moveCursor(process.stdout, 0, -(plainLines - 1));
            readline.cursorTo(process.stdout, 0);
            readline.clearScreenDown(process.stdout);
        }

        // 3. Render and print the full Markdown version
        const formatted = (marked.parse(fullResponse, { async: false }) as string).trimEnd();
        process.stdout.write(BOT_PREFIX + formatted);

        // Show cursor back
        process.stdout.write('\n\x1b[?25h');

        addToConversationHistory('user', question);
        addToConversationHistory('assistant', fullResponse);

        const elapsed = (Date.now() - startTime) / 1000;
        process.stdout.write('\n' + chalk.gray(`â”€`.repeat(20) + ` (è€—æ—¶: ${elapsed.toFixed(2)}s) ` + `â”€`.repeat(20) + '\n\n'));
    } catch (error: any) {
        if (spinner.isSpinning) {
            spinner.stop();
        }
        process.stdout.write('\x1b[?25h'); // Ensure cursor is shown even on error
        throw error;
    }
}
