import { Command } from 'commander';
import chalk from 'chalk';
import ora from 'ora';
import fs from 'fs';
import path from 'path';
import { GitService } from '../../core/git/GitService';
import { AIError } from '../../agent/llm';
import {
  PlanWorkflow,
  GitWorkflowSession,
  WorkflowConfig
} from '../../core/workflows';
import { CapabilityLevel } from '../../core/capability/CapabilityLevel';
import { getCapabilityLevelDisplay } from './utils';

const DEFAULT_PLAN_PROMPT = 'åˆ†æé¡¹ç›®ç°çŠ¶å¹¶è§„åˆ’ä¸‹ä¸€æ­¥å¼€å‘ä»»åŠ¡';
const METADATA_PREFIX = '>';

async function resolveUserPrompt(cliPrompt: string, todoPath: string): Promise<{ prompt: string; fromFile: boolean }> {
    if (cliPrompt) {
        return { prompt: cliPrompt, fromFile: false };
    }

    try {
        await fs.promises.access(todoPath, fs.constants.F_OK);
        const content = await fs.promises.readFile(todoPath, 'utf8');

        const lines = content.split('\n');
        let startIndex = 0;

        while (startIndex < lines.length && lines[startIndex].trim().startsWith(METADATA_PREFIX)) {
            startIndex++;
        }

        while (startIndex < lines.length && lines[startIndex].trim() === '') {
            startIndex++;
        }

        const filePrompt = lines.slice(startIndex).join('\n').trim();

        if (filePrompt) {
            return { prompt: filePrompt, fromFile: true };
        }
    } catch (e: unknown) {
        if (e instanceof Error && (e as NodeJS.ErrnoException).code !== 'ENOENT') {
            console.warn(chalk.yellow(`âš ï¸  è¯»å– todo.md å¤±è´¥: ${e.message}`));
        }
    }

    return { prompt: DEFAULT_PLAN_PROMPT, fromFile: false };
}

export function registerPlanCommand(gitCmd: Command) {
    gitCmd
        .command('plan [prompt...]')
        .description('è‡ªåŠ¨è¯»å–æœ€è¿‘ 10 æ¬¡æäº¤ï¼Œç”±ä¸¤ä¸ª AI (æ¶æ„å¸ˆ & å®¡æŸ¥å‘˜) åä½œç”Ÿæˆ todo.md')
        .option('-r, --rounds <number>', 'å¯¹è¯è½®æ•°', '2')
        .option('-m, --model <model>', 'æ¶æ„å¸ˆæ¨¡å‹', 'Assistant')
        .option('--reviewer-model <model>', 'å®¡æŸ¥å‘˜æ¨¡å‹', 'gemini-2.5-flash-lite')
        .action(async (promptParts, options) => {
            const cliPrompt = promptParts.join(' ').trim();
            const maxRounds = parseInt(options.rounds) || 2;
            const todoPath = path.join(process.cwd(), 'todo.md');

            const { prompt: userPrompt, fromFile } = await resolveUserPrompt(cliPrompt, todoPath);

            const spinner = ora(fromFile ? 'æ­£åœ¨ä» todo.md è¯»å–å¹¶åˆå§‹åŒ–åˆ†æè§„åˆ’...' : 'æ­£åœ¨åˆå§‹åŒ–åˆ†æè§„åˆ’...').start();

            try {
                const gitService = new GitService();

                if (!(await gitService.isGitRepository())) {
                    spinner.fail('å½“å‰ç›®å½•ä¸æ˜¯ Git ä»“åº“');
                    return;
                }

                spinner.succeed('Git ä»“åº“éªŒè¯é€šè¿‡');

                const workflowConfig: WorkflowConfig = {
                    sessionId: Date.now().toString(36) + Math.random().toString(36).substring(2, 11),
                    model: options.model || 'Assistant',
                    capability: CapabilityLevel.SEMANTIC
                };

                const session = new GitWorkflowSession(workflowConfig);
                const planWorkflow = new PlanWorkflow(gitService);

                console.log(chalk.bold.cyan('\nğŸš€ å¯åŠ¨å·¥ä½œæµä¼šè¯...\n'));

                spinner.start('[å·¥ä½œæµ] æ­£åœ¨æ‰§è¡Œè®¡åˆ’é˜¶æ®µ...');

                const result = await session.runPlan(
                    async (input) => planWorkflow.run(input, session.getConfig()),
                    {
                        userPrompt,
                        maxRounds,
                        architectModel: options.model,
                        reviewerModel: options.reviewerModel
                    }
                );

                if (result.success && result.data) {
                    spinner.succeed('è®¡åˆ’æ‰§è¡ŒæˆåŠŸ');

                    const filePath = path.join(process.cwd(), 'todo.md');

                    const metadataLines = [
                        `> ğŸ“… Generated by Yuangs Git Plan at ${new Date().toLocaleString()}`,
                        `> ğŸ¯ Context: ${userPrompt}`,
                        `> ğŸ”§ Capability Level: ${getCapabilityLevelDisplay(result.data.capability.minCapability)}`,
                        `> âš™ï¸  Estimated Time: ${result.data.estimatedTime}ms`,
                        `> ğŸ“Š Estimated Tokens: ${result.data.estimatedTokens}`,
                        '',
                    ];

                    const fileOutput = metadataLines.join('\n') + result.data.todoMarkdown;

                    fs.writeFileSync(filePath, fileOutput);

                    console.log('');
                    console.log(chalk.green(`âœ… è§„åˆ’å®Œæˆï¼æ–‡ä»¶å·²ç”Ÿæˆ: ${chalk.bold('todo.md')}`));
                    console.log(chalk.gray(`ğŸ‘‰ ä½ å¯ä»¥ä½¿ç”¨ 'code todo.md' æ‰“å¼€æŸ¥çœ‹`));
                    console.log('');
                    console.log(chalk.bold.cyan('ğŸ“Š ä¼šè¯æ‘˜è¦:'));
                    console.log(chalk.gray(session.getSummary()));

                    session.complete();
                } else {
                    spinner.fail('è®¡åˆ’æ‰§è¡Œå¤±è´¥');

                    if (result.errors && result.errors.length > 0) {
                        console.log('');
                        console.log(chalk.bold.red('âŒ é”™è¯¯è¯¦æƒ…:'));
                        result.errors.forEach((error, index) => {
                            console.log(chalk.red(`  ${index + 1}. [${error.kind}] ${error.message}`));
                            if (error.suggestions && error.suggestions.length > 0) {
                                error.suggestions.forEach(suggestion => {
                                    console.log(chalk.yellow(`     ğŸ’¡ ${suggestion}`));
                                });
                            }
                        });
                    }

                    if (result.summary) {
                        console.log('');
                        console.log(chalk.gray(`ğŸ“ ${result.summary}`));
                    }
                }
            } catch (error: any) {
                spinner.fail(chalk.red(`æ‰§è¡Œè¿‡ç¨‹ä¸­å‡ºé”™: ${error.message}`));

                if (error instanceof AIError) {
                    console.error(chalk.red(`Status: ${error.statusCode}`));
                }

                process.exit(1);
            }
        });
}
