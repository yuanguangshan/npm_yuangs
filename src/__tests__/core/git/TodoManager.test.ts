import { describe, it, expect, beforeEach, afterEach } from '@jest/globals';
import fs from 'fs';
import path from 'path';
import {
    parseTodoFile,
    updateTaskStatus,
    updateMetadata,
    getNextTask,
    calculateProgress,
    validateDependencies,
    getExecutionOrder
} from '../../../core/git/TodoManager';

describe('TodoManager', () => {
    let testDir: string;
    let todoPath: string;

    beforeEach(() => {
        testDir = path.join(__dirname, 'test-todos');
        fs.mkdirSync(testDir, { recursive: true });
        todoPath = path.join(testDir, 'todo.md');
    });

    afterEach(() => {
        if (fs.existsSync(testDir)) {
            fs.rmSync(testDir, { recursive: true, force: true });
        }
    });

    describe('parseTodoFile', () => {
        it('should parse simple todo file', async () => {
            const content = `> Generated by Yuangs
> Progress: 1/3

# Task List

- [ ] First task
- [x] Second task
- [ ] Third task
`;
            fs.writeFileSync(todoPath, content, 'utf8');

            const result = await parseTodoFile(todoPath);
            expect(result.tasks).toHaveLength(3);
            expect(result.tasks[0].completed).toBe(false);
            expect(result.tasks[1].completed).toBe(true);
            expect(result.tasks[2].completed).toBe(false);
        });

        it('should parse metadata', async () => {
            const content = `> Generated by Yuangs Git Plan at 2024-01-28T10:00:00.000Z
> Context: Add new feature
> ğŸ“Š Progress: 2/5 tasks completed
> ğŸ”„ Current Task: 3

- [ ] Task 1
- [x] Task 2
`;
            fs.writeFileSync(todoPath, content, 'utf8');

            const result = await parseTodoFile(todoPath);
            expect(result.metadata.generatedAt).toBe('2024-01-28T10:00:00.000Z');
            expect(result.metadata.context).toBe('Add new feature');
            expect(result.metadata.progress).toEqual({ completed: 2, total: 5 });
            expect(result.metadata.currentTask).toBe(3);
        });

        it('should parse task dependencies', async () => {
            const content = `# Tasks

- [ ] Task 1
- [ ] Task 2 [depends: 1]
- [ ] Task 3 [depends: 1,2]
`;
            fs.writeFileSync(todoPath, content, 'utf8');

            const result = await parseTodoFile(todoPath);
            expect(result.tasks[0].dependsOn).toBeUndefined();
            expect(result.tasks[1].dependsOn).toEqual([0]);
            expect(result.tasks[2].dependsOn).toEqual([0, 1]);
        });

        it('should parse task priorities', async () => {
            const content = `# Tasks

- [ ] Task 1 [priority: high]
- [ ] Task 2 [priority: low]
`;
            fs.writeFileSync(todoPath, content, 'utf8');

            const result = await parseTodoFile(todoPath);
            expect(result.tasks[0].priority).toBe('high');
            expect(result.tasks[1].priority).toBe('low');
        });

        it('should parse task status from comments', async () => {
            const content = `# Tasks

- [ ] Task 1 <!-- exec:in_progress, attempts:2 -->
`;
            fs.writeFileSync(todoPath, content, 'utf8');

            const result = await parseTodoFile(todoPath);
            expect(result.tasks[0].execStatus).toBe('in_progress');
            expect(result.tasks[0].attempts).toBe(2);
        });
    });

    describe('updateTaskStatus', () => {
        it('should update task completion status', async () => {
            const content = `> Context: Test

- [ ] Task 1
- [ ] Task 2
`;
            fs.writeFileSync(todoPath, content, 'utf8');

            await updateTaskStatus(todoPath, 0, { completed: true });
            const result = await fs.promises.readFile(todoPath, 'utf8');
            
            expect(result).toContain('- [x] Task 1');
            expect(result).toContain('- [ ] Task 2');
        });

        it('should update task status comment', async () => {
            const content = `> Context: Test

- [ ] Task 1
`;
            fs.writeFileSync(todoPath, content, 'utf8');

            await updateTaskStatus(todoPath, 0, {
                execStatus: 'in_progress',
                attempts: 2
            });
            const result = await fs.promises.readFile(todoPath, 'utf8');
            
            expect(result).toContain('<!-- exec:in_progress, attempts:2 -->');
        });
    });

    describe('updateMetadata', () => {
        it('should update progress metadata', async () => {
            const content = `> Context: Test

- [ ] Task 1
`;
            fs.writeFileSync(todoPath, content, 'utf8');

            await updateMetadata(todoPath, {
                progress: { completed: 1, total: 5 },
                currentTask: 2
            });
            const result = await fs.promises.readFile(todoPath, 'utf8');
            
            expect(result).toContain('> ğŸ“Š Progress: 1/5 tasks completed');
            expect(result).toContain('> ğŸ”„ Current Task: 2');
        });
    });

    describe('getNextTask', () => {
        it('should return first pending task', () => {
            const tasks = [
                { index: 0, description: 'Task 1', completed: true },
                { index: 1, description: 'Task 2', completed: false },
                { index: 2, description: 'Task 3', completed: false }
            ];
            
            const next = getNextTask(tasks);
            expect(next?.description).toBe('Task 2');
        });

        it('should respect dependencies', () => {
            const tasks = [
                { index: 0, description: 'Task 1', completed: false, dependsOn: [] },
                { index: 1, description: 'Task 2', completed: false, dependsOn: [0] }
            ];
            
            const next = getNextTask(tasks);
            expect(next?.description).toBe('Task 1');
        });

        it('should return task with completed dependencies', () => {
            const tasks = [
                { index: 0, description: 'Task 1', completed: true, dependsOn: [] },
                { index: 1, description: 'Task 2', completed: false, dependsOn: [0] }
            ];
            
            const next = getNextTask(tasks);
            expect(next?.description).toBe('Task 2');
        });

        it('should respect priority', () => {
            const tasks = [
                { index: 0, description: 'Task 1', completed: false, priority: 'low' as const },
                { index: 1, description: 'Task 2', completed: false, priority: 'high' as const },
                { index: 2, description: 'Task 3', completed: false, priority: 'medium' as const }
            ];
            
            const next = getNextTask(tasks);
            expect(next?.description).toBe('Task 2');
        });

        it('should return null if no tasks', () => {
            const tasks: any[] = [];
            expect(getNextTask(tasks)).toBeNull();
        });
    });

    describe('validateDependencies', () => {
        it('should detect circular dependencies', () => {
            const tasks = [
                { index: 0, description: 'Task 1', completed: false, dependsOn: [1] },
                { index: 1, description: 'Task 2', completed: false, dependsOn: [0] }
            ];
            
            const result = validateDependencies(tasks);
            expect(result.valid).toBe(false);
            expect(result.errors).toContain('æ£€æµ‹åˆ°å¾ªç¯ä¾èµ–: ä»»åŠ¡ #1 <-> #2');
        });

        it('should detect self-dependencies', () => {
            const tasks = [
                { index: 0, description: 'Task 1', completed: false, dependsOn: [0] }
            ];
            
            const result = validateDependencies(tasks);
            expect(result.valid).toBe(false);
            expect(result.errors).toContain('ä»»åŠ¡ #1 ä¸èƒ½ä¾èµ–è‡ªå·±');
        });

        it('should detect invalid dependency indices', () => {
            const tasks = [
                { index: 0, description: 'Task 1', completed: false, dependsOn: [99] }
            ];
            
            const result = validateDependencies(tasks);
            expect(result.valid).toBe(false);
            expect(result.errors).toContain('ä»»åŠ¡ #1 ä¾èµ–äº†æ— æ•ˆçš„ä»»åŠ¡ç´¢å¼•: 100');
        });

        it('should validate correct dependencies', () => {
            const tasks = [
                { index: 0, description: 'Task 1', completed: false, dependsOn: [] },
                { index: 1, description: 'Task 2', completed: false, dependsOn: [0] }
            ];
            
            const result = validateDependencies(tasks);
            expect(result.valid).toBe(true);
            expect(result.errors).toHaveLength(0);
        });
    });

    describe('getExecutionOrder', () => {
        it('should return correct topological order', () => {
            const tasks = [
                { index: 0, description: 'Task 1', completed: false },
                { index: 1, description: 'Task 2', completed: false, dependsOn: [0] },
                { index: 2, description: 'Task 3', completed: false, dependsOn: [1] }
            ];
            
            const order = getExecutionOrder(tasks);
            expect(order).toEqual([0, 1, 2]);
        });

        it('should handle multiple dependencies', () => {
            const tasks = [
                { index: 0, description: 'Task 1', completed: false },
                { index: 1, description: 'Task 2', completed: false },
                { index: 2, description: 'Task 3', completed: false, dependsOn: [0, 1] }
            ];
            
            const order = getExecutionOrder(tasks);
            expect(order.indexOf(2)).toBeGreaterThan(order.indexOf(0));
            expect(order.indexOf(2)).toBeGreaterThan(order.indexOf(1));
        });
    });
});
