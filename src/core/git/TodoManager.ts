import fs from 'fs';
import path from 'path';

export interface TaskStatus {
    index: number;
    description: string;
    completed: boolean;
    execStatus?: 'pending' | 'in_progress' | 'done' | 'failed';
    reviewScore?: number;
    reviewIssues?: string[];
    attempts?: number;
    backupId?: string;
    dependsOn?: number[];
    priority?: 'high' | 'medium' | 'low';
}

export interface TodoMetadata {
    generatedAt?: string;
    context?: string;
    progress?: { completed: number; total: number };
    currentTask?: number;
}

const METADATA_PREFIX = '>';
const TASK_REGEX = /^[\s]*-\s*\[([x\s])\]\s*(.+?)(?:\s*<!--\s*(.+?)\s*-->)?$/;
const DEPENDENCY_REGEX = /\[depends:\s*(.+?)\]/i;
const PRIORITY_REGEX = /\[priority:\s*(high|medium|low)\]/i;

/**
 * è§£æ todo.md æ–‡ä»¶
 */
export async function parseTodoFile(filePath: string): Promise<{
    metadata: TodoMetadata;
    tasks: TaskStatus[];
    rawContent: string;
}> {
    const content = await fs.promises.readFile(filePath, 'utf8');
    const lines = content.split('\n');
    
    // è§£æå…ƒæ•°æ®
    const metadata: TodoMetadata = {};
    let contentStartIndex = 0;
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line.startsWith(METADATA_PREFIX)) {
            contentStartIndex = i;
            break;
        }
        
        // è§£æç‰¹å®šå…ƒæ•°æ®
        if (line.includes('Generated by Yuangs Git Plan at')) {
            const match = line.match(/at (.+)$/);
            if (match) {
                metadata.generatedAt = match[1].trim();
            }
        } else if (line.includes('Context:')) {
            metadata.context = line.split('Context:')[1]?.trim();
        } else if (line.includes('Progress:')) {
            const match = line.match(/(\d+)\/(\d+)/);
            if (match) {
                metadata.progress = {
                    completed: parseInt(match[1]),
                    total: parseInt(match[2])
                };
            }
        } else if (line.includes('Current Task:')) {
            metadata.currentTask = parseInt(line.split('Current Task:')[1]?.trim() || '0');
        }
    }
    
    // è§£æä»»åŠ¡
    const tasks: TaskStatus[] = [];
    const mainContent = lines.slice(contentStartIndex).join('\n');
    
    let taskIndex = 0;
    for (const line of lines.slice(contentStartIndex)) {
        const match = line.match(TASK_REGEX);
        if (match) {
            const [, checkbox, description, comment] = match;
            const task: TaskStatus = {
                index: taskIndex++,
                description: description.trim(),
                completed: checkbox.toLowerCase() === 'x',
                attempts: 0
            };
            
            // è§£ææè¿°ä¸­çš„ä¾èµ–å…³ç³»
            const depMatch = description.match(DEPENDENCY_REGEX);
            if (depMatch) {
                const depIndices = depMatch[1].split(',')
                    .map(s => parseInt(s.trim()) - 1)
                    .filter(n => !isNaN(n) && n >= 0);
                if (depIndices.length > 0) {
                    task.dependsOn = depIndices;
                }
            }
            
            // è§£ææè¿°ä¸­çš„ä¼˜å…ˆçº§
            const priorityMatch = description.match(PRIORITY_REGEX);
            if (priorityMatch) {
                task.priority = priorityMatch[1] as 'high' | 'medium' | 'low';
            }
            
            // è§£ææ³¨é‡Šä¸­çš„çŠ¶æ€
            if (comment) {
                const execMatch = comment.match(/exec:(\w+)/);
                const reviewMatch = comment.match(/review:(\d+)/);
                const attemptsMatch = comment.match(/attempts:(\d+)/);
                const backupMatch = comment.match(/backup:([a-f0-9]+)/);
                
                if (execMatch) task.execStatus = execMatch[1] as any;
                if (reviewMatch) task.reviewScore = parseInt(reviewMatch[1]);
                if (attemptsMatch) task.attempts = parseInt(attemptsMatch[1]);
                if (backupMatch) task.backupId = backupMatch[1];
            }
            
            tasks.push(task);
        }
    }
    
    return { metadata, tasks, rawContent: content };
}

/**
 * æ›´æ–°ä»»åŠ¡çŠ¶æ€
 */
export async function updateTaskStatus(
    filePath: string,
    taskIndex: number,
    updates: Partial<TaskStatus>
): Promise<void> {
    const content = await fs.promises.readFile(filePath, 'utf8');
    const lines = content.split('\n');
    
    let currentTaskIndex = 0;
    for (let i = 0; i < lines.length; i++) {
        const match = lines[i].match(TASK_REGEX);
        if (match && currentTaskIndex === taskIndex) {
            const [, checkbox, description] = match;
            
            // æ„å»ºæ–°çš„æ³¨é‡Š
            const comments: string[] = [];
            if (updates.execStatus) comments.push(`exec:${updates.execStatus}`);
            if (updates.reviewScore !== undefined) comments.push(`review:${updates.reviewScore}`);
            if (updates.attempts !== undefined) comments.push(`attempts:${updates.attempts}`);
            
            const newCheckbox = updates.completed ? 'x' : ' ';
            const commentStr = comments.length > 0 ? ` <!-- ${comments.join(', ')} -->` : '';
            
            lines[i] = `- [${newCheckbox}] ${description}${commentStr}`;
            break;
        }
        if (match) currentTaskIndex++;
    }
    
    await fs.promises.writeFile(filePath, lines.join('\n'), 'utf8');
}

/**
 * æ›´æ–°å…ƒæ•°æ®
 */
export async function updateMetadata(
    filePath: string,
    updates: Partial<TodoMetadata>
): Promise<void> {
    const content = await fs.promises.readFile(filePath, 'utf8');
    const lines = content.split('\n');
    
    // æ‰¾åˆ°å…ƒæ•°æ®ç»“æŸä½ç½®
    let metadataEndIndex = 0;
    for (let i = 0; i < lines.length; i++) {
        if (!lines[i].trim().startsWith(METADATA_PREFIX)) {
            metadataEndIndex = i;
            break;
        }
    }
    
    // æ›´æ–°æˆ–æ·»åŠ è¿›åº¦ä¿¡æ¯
    if (updates.progress) {
        let progressLineIndex = -1;
        for (let i = 0; i < metadataEndIndex; i++) {
            if (lines[i].includes('Progress:')) {
                progressLineIndex = i;
                break;
            }
        }
        
        const progressLine = `> ğŸ“Š Progress: ${updates.progress.completed}/${updates.progress.total} tasks completed`;
        if (progressLineIndex >= 0) {
            lines[progressLineIndex] = progressLine;
        } else {
            lines.splice(metadataEndIndex, 0, progressLine);
        }
    }
    
    if (updates.currentTask !== undefined) {
        let currentTaskLineIndex = -1;
        for (let i = 0; i < metadataEndIndex; i++) {
            if (lines[i].includes('Current Task:')) {
                currentTaskLineIndex = i;
                break;
            }
        }
        
        const currentTaskLine = `> ğŸ”„ Current Task: ${updates.currentTask}`;
        if (currentTaskLineIndex >= 0) {
            lines[currentTaskLineIndex] = currentTaskLine;
        } else {
            lines.splice(metadataEndIndex, 0, currentTaskLine);
        }
    }
    
    await fs.promises.writeFile(filePath, lines.join('\n'), 'utf8');
}

/**
 * è·å–ä¸‹ä¸€ä¸ªå¾…æ‰§è¡Œçš„ä»»åŠ¡ï¼ˆè€ƒè™‘ä¾èµ–å…³ç³»ï¼‰
 */
export function getNextTask(tasks: TaskStatus[]): TaskStatus | null {
    const pendingTasks = tasks.filter(t => !t.completed && t.execStatus !== 'failed');
    
    if (pendingTasks.length === 0) {
        return null;
    }
    
    // æ£€æŸ¥å“ªäº›ä»»åŠ¡å¯ä»¥æ‰§è¡Œï¼ˆæ‰€æœ‰ä¾èµ–éƒ½å·²å®Œæˆï¼‰
    const availableTasks = pendingTasks.filter(task => {
        if (!task.dependsOn || task.dependsOn.length === 0) {
            return true;
        }
        
        return task.dependsOn.every(depIndex => {
            const depTask = tasks[depIndex];
            return depTask && depTask.completed;
        });
    });
    
    if (availableTasks.length === 0) {
        // å¦‚æœæ²¡æœ‰å¯æ‰§è¡Œçš„ä»»åŠ¡ï¼Œè¿”å›ç¬¬ä¸€ä¸ªå¤±è´¥çš„ä»»åŠ¡ï¼ˆå¦‚æœæœ‰ï¼‰
        const firstFailed = tasks.find(t => t.execStatus === 'failed');
        return firstFailed || null;
    }
    
    // æŒ‰ä¼˜å…ˆçº§æ’åºï¼šhigh > medium > low
    const priorityOrder = { high: 0, medium: 1, low: 2 };
    availableTasks.sort((a, b) => {
        const priorityA = a.priority ? priorityOrder[a.priority] : 1;
        const priorityB = b.priority ? priorityOrder[b.priority] : 1;
        return priorityA - priorityB;
    });
    
    // è¿”å›ä¼˜å…ˆçº§æœ€é«˜çš„å¯æ‰§è¡Œä»»åŠ¡
    return availableTasks[0];
}

/**
 * éªŒè¯ä»»åŠ¡çš„ä¾èµ–å…³ç³»
 */
export function validateDependencies(tasks: TaskStatus[]): { valid: boolean; errors: string[] } {
    const errors: string[] = [];
    
    for (const task of tasks) {
        if (task.dependsOn && task.dependsOn.length > 0) {
            for (const depIndex of task.dependsOn) {
                // æ£€æŸ¥ä¾èµ–ç´¢å¼•æ˜¯å¦æœ‰æ•ˆ
                if (depIndex < 0 || depIndex >= tasks.length) {
                    errors.push(`ä»»åŠ¡ #${task.index + 1} ä¾èµ–äº†æ— æ•ˆçš„ä»»åŠ¡ç´¢å¼•: ${depIndex + 1}`);
                    continue;
                }
                
                // æ£€æŸ¥å¾ªç¯ä¾èµ–
                if (hasCircularDependency(tasks, task.index, depIndex, new Set())) {
                    errors.push(`æ£€æµ‹åˆ°å¾ªç¯ä¾èµ–: ä»»åŠ¡ #${task.index + 1} <-> #${depIndex + 1}`);
                }
                
                // æ£€æŸ¥è‡ªä¾èµ–
                if (depIndex === task.index) {
                    errors.push(`ä»»åŠ¡ #${task.index + 1} ä¸èƒ½ä¾èµ–è‡ªå·±`);
                }
            }
        }
    }
    
    return { valid: errors.length === 0, errors };
}

/**
 * æ£€æŸ¥å¾ªç¯ä¾èµ–
 */
function hasCircularDependency(
    tasks: TaskStatus[],
    from: number,
    to: number,
    visited: Set<number>
): boolean {
    if (visited.has(to)) {
        return true;
    }
    
    visited.add(to);
    const toTask = tasks[to];
    
    if (!toTask || !toTask.dependsOn) {
        return false;
    }
    
    for (const dep of toTask.dependsOn) {
        if (dep === from || hasCircularDependency(tasks, from, dep, new Set(visited))) {
            return true;
        }
    }
    
    return false;
}

/**
 * è·å–ä»»åŠ¡çš„æ‰§è¡Œé¡ºåº
 */
export function getExecutionOrder(tasks: TaskStatus[]): number[] {
    const order: number[] = [];
    const visited = new Set<number>();
    
    function visit(index: number) {
        if (visited.has(index)) {
            return;
        }
        
        visited.add(index);
        const task = tasks[index];
        
        // å…ˆè®¿é—®ä¾èµ–çš„ä»»åŠ¡
        if (task.dependsOn) {
            for (const depIndex of task.dependsOn) {
                visit(depIndex);
            }
        }
        
        order.push(index);
    }
    
    for (let i = 0; i < tasks.length; i++) {
        visit(i);
    }
    
    return order;
}

/**
 * è®¡ç®—è¿›åº¦
 */
export function calculateProgress(tasks: TaskStatus[]): { completed: number; total: number } {
    return {
        completed: tasks.filter(t => t.completed).length,
        total: tasks.length
    };
}
