import fs from 'fs';
import path from 'path';

export interface TaskStatus {
    index: number;
    description: string;
    completed: boolean;
    execStatus?: 'pending' | 'in_progress' | 'done' | 'failed';
    reviewScore?: number;
    reviewIssues?: string[];
    attempts?: number;
}

export interface TodoMetadata {
    generatedAt?: string;
    context?: string;
    progress?: { completed: number; total: number };
    currentTask?: number;
}

const METADATA_PREFIX = '>';
const TASK_REGEX = /^[\s]*-\s*\[([x\s])\]\s*(.+?)(?:\s*<!--\s*(.+?)\s*-->)?$/;

/**
 * è§£æ todo.md æ–‡ä»¶
 */
export async function parseTodoFile(filePath: string): Promise<{
    metadata: TodoMetadata;
    tasks: TaskStatus[];
    rawContent: string;
}> {
    const content = await fs.promises.readFile(filePath, 'utf8');
    const lines = content.split('\n');
    
    // è§£æå…ƒæ•°æ®
    const metadata: TodoMetadata = {};
    let contentStartIndex = 0;
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line.startsWith(METADATA_PREFIX)) {
            contentStartIndex = i;
            break;
        }
        
        // è§£æç‰¹å®šå…ƒæ•°æ®
        if (line.includes('Generated by Yuangs Git Plan at')) {
            metadata.generatedAt = line.split('at')[1]?.trim();
        } else if (line.includes('Context:')) {
            metadata.context = line.split('Context:')[1]?.trim();
        } else if (line.includes('Progress:')) {
            const match = line.match(/(\d+)\/(\d+)/);
            if (match) {
                metadata.progress = {
                    completed: parseInt(match[1]),
                    total: parseInt(match[2])
                };
            }
        } else if (line.includes('Current Task:')) {
            metadata.currentTask = parseInt(line.split('Current Task:')[1]?.trim() || '0');
        }
    }
    
    // è§£æä»»åŠ¡
    const tasks: TaskStatus[] = [];
    const mainContent = lines.slice(contentStartIndex).join('\n');
    
    let taskIndex = 0;
    for (const line of lines.slice(contentStartIndex)) {
        const match = line.match(TASK_REGEX);
        if (match) {
            const [, checkbox, description, comment] = match;
            const task: TaskStatus = {
                index: taskIndex++,
                description: description.trim(),
                completed: checkbox.toLowerCase() === 'x',
                attempts: 0
            };
            
            // è§£ææ³¨é‡Šä¸­çš„çŠ¶æ€
            if (comment) {
                const execMatch = comment.match(/exec:(\w+)/);
                const reviewMatch = comment.match(/review:(\d+)/);
                const attemptsMatch = comment.match(/attempts:(\d+)/);
                
                if (execMatch) task.execStatus = execMatch[1] as any;
                if (reviewMatch) task.reviewScore = parseInt(reviewMatch[1]);
                if (attemptsMatch) task.attempts = parseInt(attemptsMatch[1]);
            }
            
            tasks.push(task);
        }
    }
    
    return { metadata, tasks, rawContent: content };
}

/**
 * æ›´æ–°ä»»åŠ¡çŠ¶æ€
 */
export async function updateTaskStatus(
    filePath: string,
    taskIndex: number,
    updates: Partial<TaskStatus>
): Promise<void> {
    const content = await fs.promises.readFile(filePath, 'utf8');
    const lines = content.split('\n');
    
    let currentTaskIndex = 0;
    for (let i = 0; i < lines.length; i++) {
        const match = lines[i].match(TASK_REGEX);
        if (match && currentTaskIndex === taskIndex) {
            const [, checkbox, description] = match;
            
            // æ„å»ºæ–°çš„æ³¨é‡Š
            const comments: string[] = [];
            if (updates.execStatus) comments.push(`exec:${updates.execStatus}`);
            if (updates.reviewScore !== undefined) comments.push(`review:${updates.reviewScore}`);
            if (updates.attempts !== undefined) comments.push(`attempts:${updates.attempts}`);
            
            const newCheckbox = updates.completed ? 'x' : ' ';
            const commentStr = comments.length > 0 ? ` <!-- ${comments.join(', ')} -->` : '';
            
            lines[i] = `- [${newCheckbox}] ${description}${commentStr}`;
            break;
        }
        if (match) currentTaskIndex++;
    }
    
    await fs.promises.writeFile(filePath, lines.join('\n'), 'utf8');
}

/**
 * æ›´æ–°å…ƒæ•°æ®
 */
export async function updateMetadata(
    filePath: string,
    updates: Partial<TodoMetadata>
): Promise<void> {
    const content = await fs.promises.readFile(filePath, 'utf8');
    const lines = content.split('\n');
    
    // æ‰¾åˆ°å…ƒæ•°æ®ç»“æŸä½ç½®
    let metadataEndIndex = 0;
    for (let i = 0; i < lines.length; i++) {
        if (!lines[i].trim().startsWith(METADATA_PREFIX)) {
            metadataEndIndex = i;
            break;
        }
    }
    
    // æ›´æ–°æˆ–æ·»åŠ è¿›åº¦ä¿¡æ¯
    if (updates.progress) {
        let progressLineIndex = -1;
        for (let i = 0; i < metadataEndIndex; i++) {
            if (lines[i].includes('Progress:')) {
                progressLineIndex = i;
                break;
            }
        }
        
        const progressLine = `> ğŸ“Š Progress: ${updates.progress.completed}/${updates.progress.total} tasks completed`;
        if (progressLineIndex >= 0) {
            lines[progressLineIndex] = progressLine;
        } else {
            lines.splice(metadataEndIndex, 0, progressLine);
        }
    }
    
    if (updates.currentTask !== undefined) {
        let currentTaskLineIndex = -1;
        for (let i = 0; i < metadataEndIndex; i++) {
            if (lines[i].includes('Current Task:')) {
                currentTaskLineIndex = i;
                break;
            }
        }
        
        const currentTaskLine = `> ğŸ”„ Current Task: ${updates.currentTask}`;
        if (currentTaskLineIndex >= 0) {
            lines[currentTaskLineIndex] = currentTaskLine;
        } else {
            lines.splice(metadataEndIndex, 0, currentTaskLine);
        }
    }
    
    await fs.promises.writeFile(filePath, lines.join('\n'), 'utf8');
}

/**
 * è·å–ä¸‹ä¸€ä¸ªå¾…æ‰§è¡Œçš„ä»»åŠ¡
 */
export function getNextTask(tasks: TaskStatus[]): TaskStatus | null {
    return tasks.find(t => !t.completed) || null;
}

/**
 * è®¡ç®—è¿›åº¦
 */
export function calculateProgress(tasks: TaskStatus[]): { completed: number; total: number } {
    return {
        completed: tasks.filter(t => t.completed).length,
        total: tasks.length
    };
}
