# Project Documentation

- **Generated at:** 2026-01-27 18:27:11
- **Root Dir:** `.`
- **File Count:** 152
- **Total Size:** 617.83 KB

<a name="toc"></a>
## ğŸ“‚ æ‰«æç›®å½•
- [__tests__/core/kernel/XResolver.test.ts](#ğŸ“„-__tests__corekernelxresolvertestts) (216 lines, 7.31 KB)
- [agent/AgentRuntime.ts](#ğŸ“„-agentagentruntimets) (326 lines, 11.01 KB)
- [agent/DualAgentRuntime.ts](#ğŸ“„-agentdualagentruntimets) (333 lines, 10.23 KB)
- [agent/ReflectionAgent.ts](#ğŸ“„-agentreflectionagentts) (49 lines, 1.37 KB)
- [agent/actions.ts](#ğŸ“„-agentactionsts) (53 lines, 1.58 KB)
- [agent/astParser.ts](#ğŸ“„-agentastparserts) (238 lines, 7.19 KB)
- [agent/codeSummary.js](#ğŸ“„-agentcodesummaryjs) (335 lines, 11.81 KB)
- [agent/context.ts](#ğŸ“„-agentcontextts) (39 lines, 1.30 KB)
- [agent/contextManager.ts](#ğŸ“„-agentcontextmanagerts) (96 lines, 2.53 KB)
- [agent/dynamicPrompt.ts](#ğŸ“„-agentdynamicpromptts) (236 lines, 5.60 KB)
- [agent/errorHandling.ts](#ğŸ“„-agenterrorhandlingts) (262 lines, 7.07 KB)
- [agent/executor.ts](#ğŸ“„-agentexecutorts) (248 lines, 6.28 KB)
- [agent/governance.ts](#ğŸ“„-agentgovernancets) (97 lines, 3.52 KB)
- [agent/governance/bridge.ts](#ğŸ“„-agentgovernancebridgets) (36 lines, 1.13 KB)
- [agent/governance/core.ts](#ğŸ“„-agentgovernancecorets) (35 lines, 1.22 KB)
- [agent/governance/index.ts](#ğŸ“„-agentgovernanceindexts) (7 lines, 0.26 KB)
- [agent/governance/ledger.ts](#ğŸ“„-agentgovernanceledgerts) (22 lines, 0.48 KB)
- [agent/governance/sandbox/core.as.ts](#ğŸ“„-agentgovernancesandboxcoreasts) (33 lines, 1.35 KB)
- [agent/index.ts](#ğŸ“„-agentindexts) (11 lines, 0.45 KB)
- [agent/llm.ts](#ğŸ“„-agentllmts) (216 lines, 7.06 KB)
- [agent/llmAdapter.ts](#ğŸ“„-agentllmadapterts) (117 lines, 3.90 KB)
- [agent/policy/engine.ts](#ğŸ“„-agentpolicyenginets) (91 lines, 2.26 KB)
- [agent/policy/index.ts](#ğŸ“„-agentpolicyindexts) (3 lines, 0.09 KB)
- [agent/policy/policies/noDangerousShell.ts](#ğŸ“„-agentpolicypoliciesnodangerousshellts) (49 lines, 1.79 KB)
- [agent/policy/types.ts](#ğŸ“„-agentpolicytypests) (27 lines, 0.49 KB)
- [agent/preferences.ts](#ğŸ“„-agentpreferencests) (162 lines, 4.77 KB)
- [agent/prompt.ts](#ğŸ“„-agentpromptts) (110 lines, 2.76 KB)
- [agent/relevance.ts](#ğŸ“„-agentrelevancets) (180 lines, 4.33 KB)
- [agent/replay/events.ts](#ğŸ“„-agentreplayeventsts) (30 lines, 0.59 KB)
- [agent/replay/index.ts](#ğŸ“„-agentreplayindexts) (3 lines, 0.08 KB)
- [agent/replay/recorder.ts](#ğŸ“„-agentreplayrecorderts) (58 lines, 1.38 KB)
- [agent/replay/replayer.ts](#ğŸ“„-agentreplayreplayerts) (84 lines, 1.88 KB)
- [agent/riskDisclosure.ts](#ğŸ“„-agentriskdisclosurets) (383 lines, 9.41 KB)
- [agent/selectModel.ts](#ğŸ“„-agentselectmodelts) (14 lines, 0.33 KB)
- [agent/skills.ts](#ğŸ“„-agentskillsts) (188 lines, 5.36 KB)
- [agent/smartContextManager.ts](#ğŸ“„-agentsmartcontextmanagerts) (120 lines, 3.42 KB)
- [agent/state.ts](#ğŸ“„-agentstatets) (99 lines, 2.32 KB)
- [agent/types.ts](#ğŸ“„-agenttypests) (79 lines, 1.68 KB)
- [ai/client.ts](#ğŸ“„-aiclientts) (143 lines, 5.02 KB)
- [ai/prompt.ts](#ğŸ“„-aipromptts) (86 lines, 2.29 KB)
- [ai/types.ts](#ğŸ“„-aitypests) (1 lines, 0.09 KB)
- [api/index.ts](#ğŸ“„-apiindexts) (1 lines, 0.03 KB)
- [api/registryAPI.ts](#ğŸ“„-apiregistryapits) (91 lines, 2.69 KB)
- [audit/Replayer.ts](#ğŸ“„-auditreplayerts) (115 lines, 3.22 KB)
- [audit/index.ts](#ğŸ“„-auditindexts) (1 lines, 0.03 KB)
- [audit/timeline.ts](#ğŸ“„-audittimelinets) (353 lines, 9.21 KB)
- [cli.ts](#ğŸ“„-clits) (619 lines, 26.11 KB)
- [commands/capabilityCommands.ts](#ğŸ“„-commandscapabilitycommandsts) (141 lines, 4.84 KB)
- [commands/config/index.ts](#ğŸ“„-commandsconfigindexts) (45 lines, 1.28 KB)
- [commands/config/model.ts](#ğŸ“„-commandsconfigmodelts) (171 lines, 5.26 KB)
- [commands/config/modelRegistry.ts](#ğŸ“„-commandsconfigmodelregistryts) (155 lines, 3.88 KB)
- [commands/context/ContextAssembler.ts](#ğŸ“„-commandscontextcontextassemblerts) (179 lines, 5.10 KB)
- [commands/context/ContextStore.ts](#ğŸ“„-commandscontextcontextstorets) (200 lines, 5.39 KB)
- [commands/context/ContextTypes.ts](#ğŸ“„-commandscontextcontexttypests) (40 lines, 0.75 KB)
- [commands/context/index.ts](#ğŸ“„-commandscontextindexts) (9 lines, 0.23 KB)
- [commands/contextBuffer.ts](#ğŸ“„-commandscontextbufferts) (222 lines, 5.92 KB)
- [commands/contextStorage.ts](#ğŸ“„-commandscontextstoragets) (24 lines, 0.68 KB)
- [commands/explainCommands.ts](#ğŸ“„-commandsexplaincommandsts) (32 lines, 1.01 KB)
- [commands/gitContext.ts](#ğŸ“„-commandsgitcontextts) (32 lines, 0.77 KB)
- [commands/handleAIChat.ts](#ğŸ“„-commandshandleaichatts) (901 lines, 36.67 KB)
- [commands/handleAICommand.ts](#ğŸ“„-commandshandleaicommandts) (298 lines, 10.59 KB)
- [commands/handleConfig.ts](#ğŸ“„-commandshandleconfigts) (72 lines, 2.28 KB)
- [commands/preferencesCommands.ts](#ğŸ“„-commandspreferencescommandsts) (246 lines, 7.58 KB)
- [commands/replayCommands.ts](#ğŸ“„-commandsreplaycommandsts) (100 lines, 3.53 KB)
- [commands/routerCommands.ts](#ğŸ“„-commandsroutercommandsts) (497 lines, 16.46 KB)
- [commands/shellCompletions.ts](#ğŸ“„-commandsshellcompletionsts) (504 lines, 13.64 KB)
- [commands/skillsCommands.ts](#ğŸ“„-commandsskillscommandsts) (126 lines, 4.64 KB)
- [commands/ssh/index.ts](#ğŸ“„-commandssshindexts) (303 lines, 8.16 KB)
- [commands/ssh/server.ts](#ğŸ“„-commandssshserverts) (243 lines, 10.04 KB)
- [core/apps.ts](#ğŸ“„-coreappsts) (49 lines, 1.63 KB)
- [core/autofix.ts](#ğŸ“„-coreautofixts) (22 lines, 0.61 KB)
- [core/capabilities.ts](#ğŸ“„-corecapabilitiests) (69 lines, 1.90 KB)
- [core/capabilityInference.ts](#ğŸ“„-corecapabilityinferencets) (25 lines, 0.93 KB)
- [core/capabilitySystem.ts](#ğŸ“„-corecapabilitysystemts) (118 lines, 3.22 KB)
- [core/completion.legacy.ts](#ğŸ“„-corecompletionlegacyts) (225 lines, 5.89 KB)
- [core/completion/builtin.ts](#ğŸ“„-corecompletionbuiltints) (18 lines, 0.84 KB)
- [core/completion/cache.ts](#ğŸ“„-corecompletioncachets) (47 lines, 1.07 KB)
- [core/completion/index.ts](#ğŸ“„-corecompletionindexts) (30 lines, 0.69 KB)
- [core/completion/path.ts](#ğŸ“„-corecompletionpathts) (39 lines, 1.04 KB)
- [core/completion/resolver.ts](#ğŸ“„-corecompletionresolverts) (106 lines, 2.62 KB)
- [core/completion/types.ts](#ğŸ“„-corecompletiontypests) (30 lines, 0.50 KB)
- [core/completion/utils.ts](#ğŸ“„-corecompletionutilsts) (10 lines, 0.26 KB)
- [core/configMerge.ts](#ğŸ“„-coreconfigmergets) (122 lines, 3.09 KB)
- [core/db.ts](#ğŸ“„-coredbts) (56 lines, 1.80 KB)
- [core/executionRecord.ts](#ğŸ“„-coreexecutionrecordts) (105 lines, 2.60 KB)
- [core/executionStore.ts](#ğŸ“„-coreexecutionstorets) (100 lines, 2.44 KB)
- [core/executor.ts](#ğŸ“„-coreexecutorts) (37 lines, 0.97 KB)
- [core/explain.ts](#ğŸ“„-coreexplaints) (106 lines, 2.99 KB)
- [core/fileReader.ts](#ğŸ“„-corefilereaderts) (72 lines, 2.03 KB)
- [core/kernel/ASTParser.ts](#ğŸ“„-corekernelastparserts) (221 lines, 5.87 KB)
- [core/kernel/AtomicTransactionManager.ts](#ğŸ“„-corekernelatomictransactionmanagerts) (298 lines, 7.56 KB)
- [core/kernel/FastScanner.ts](#ğŸ“„-corekernelfastscannerts) (318 lines, 9.00 KB)
- [core/kernel/PostCheckVerifier.ts](#ğŸ“„-corekernelpostcheckverifierts) (241 lines, 5.58 KB)
- [core/kernel/XResolver.ts](#ğŸ“„-corekernelxresolverts) (251 lines, 6.92 KB)
- [core/macros.ts](#ğŸ“„-coremacrosts) (83 lines, 2.36 KB)
- [core/metrics/MetricsCollector.ts](#ğŸ“„-coremetricsmetricscollectorts) (131 lines, 4.16 KB)
- [core/modelMatcher.ts](#ğŸ“„-coremodelmatcherts) (102 lines, 2.65 KB)
- [core/modelRouter/BaseAdapter.ts](#ğŸ“„-coremodelrouterbaseadapterts) (266 lines, 6.68 KB)
- [core/modelRouter/ModelRouter.ts](#ğŸ“„-coremodelroutermodelrouterts) (378 lines, 13.55 KB)
- [core/modelRouter/adapters/CodebuddyAdapter.ts](#ğŸ“„-coremodelrouteradapterscodebuddyadapterts) (141 lines, 3.55 KB)
- [core/modelRouter/adapters/GoogleAdapter.ts](#ğŸ“„-coremodelrouteradaptersgoogleadapterts) (184 lines, 4.85 KB)
- [core/modelRouter/adapters/QwenAdapter.ts](#ğŸ“„-coremodelrouteradaptersqwenadapterts) (167 lines, 4.36 KB)
- [core/modelRouter/config.ts](#ğŸ“„-coremodelrouterconfigts) (151 lines, 3.47 KB)
- [core/modelRouter/index.ts](#ğŸ“„-coremodelrouterindexts) (138 lines, 3.52 KB)
- [core/modelRouter/policies/BasePolicy.ts](#ğŸ“„-coremodelrouterpoliciesbasepolicyts) (104 lines, 3.32 KB)
- [core/modelRouter/policies/DslPolicy.ts](#ğŸ“„-coremodelrouterpoliciesdslpolicyts) (133 lines, 4.86 KB)
- [core/modelRouter/policies/types.ts](#ğŸ“„-coremodelrouterpoliciestypests) (25 lines, 0.65 KB)
- [core/modelRouter/types.ts](#ğŸ“„-coremodelroutertypests) (310 lines, 6.53 KB)
- [core/observability/SupervisorActionLog.ts](#ğŸ“„-coreobservabilitysupervisoractionlogts) (64 lines, 1.46 KB)
- [core/os.ts](#ğŸ“„-coreosts) (39 lines, 1.00 KB)
- [core/replayDiff.ts](#ğŸ“„-corereplaydiffts) (284 lines, 8.07 KB)
- [core/replayEngine.ts](#ğŸ“„-corereplayenginets) (161 lines, 4.54 KB)
- [core/risk.ts](#ğŸ“„-coreriskts) (18 lines, 0.48 KB)
- [core/validation.ts](#ğŸ“„-corevalidationts) (160 lines, 4.73 KB)
- [engine/agent/governance/CausalTracker.ts](#ğŸ“„-engineagentgovernancecausaltrackerts) (37 lines, 0.91 KB)
- [engine/agent/governance/ObservationRegistry.ts](#ğŸ“„-engineagentgovernanceobservationregistryts) (39 lines, 0.90 KB)
- [engine/agent/governance/errors.ts](#ğŸ“„-engineagentgovernanceerrorsts) (7 lines, 0.19 KB)
- [engine/agent/knowledgeGraph/index.ts](#ğŸ“„-engineagentknowledgegraphindexts) (76 lines, 1.83 KB)
- [engine/agent/knowledgeGraph/types.ts](#ğŸ“„-engineagentknowledgegraphtypests) (36 lines, 0.78 KB)
- [index.ts](#ğŸ“„-indexts) (3 lines, 0.14 KB)
- [legacy/governance/GovernanceEngine.ts](#ğŸ“„-legacygovernancegovernanceenginets) (131 lines, 3.08 KB)
- [legacy/governance/GovernedAction.ts](#ğŸ“„-legacygovernancegovernedactionts) (142 lines, 3.23 KB)
- [legacy/governance/actions/CodeChangeAction.ts](#ğŸ“„-legacygovernanceactionscodechangeactionts) (199 lines, 4.61 KB)
- [legacy/governance/capability/token.ts](#ğŸ“„-legacygovernancecapabilitytokents) (161 lines, 3.47 KB)
- [legacy/governance/commands/diffEdit.ts](#ğŸ“„-legacygovernancecommandsdiffeditts) (331 lines, 9.38 KB)
- [legacy/governance/execution/sandbox.ts](#ğŸ“„-legacygovernanceexecutionsandboxts) (93 lines, 2.03 KB)
- [legacy/governance/fsm/stateMachine.ts](#ğŸ“„-legacygovernancefsmstatemachinets) (118 lines, 2.59 KB)
- [legacy/governance/index.ts](#ğŸ“„-legacygovernanceindexts) (9 lines, 0.32 KB)
- [legacy/governance/review/diffParser.ts](#ğŸ“„-legacygovernancereviewdiffparserts) (76 lines, 1.74 KB)
- [legacy/governance/review/render.ts](#ğŸ“„-legacygovernancereviewrenderts) (85 lines, 1.83 KB)
- [legacy/governance/storage/store.ts](#ğŸ“„-legacygovernancestoragestorets) (126 lines, 2.83 KB)
- [legacy/governance/verification/CodeChangeGovernance.tla](#ğŸ“„-legacygovernanceverificationcodechangegovernancetla) (171 lines, 5.11 KB)
- [policy/model/ModelRegistry.ts](#ğŸ“„-policymodelmodelregistryts) (76 lines, 2.11 KB)
- [policy/sampler.ts](#ğŸ“„-policysamplerts) (84 lines, 2.43 KB)
- [policy/syntaxHandler.ts](#ğŸ“„-policysyntaxhandlerts) (168 lines, 4.74 KB)
- [policy/token/DefaultTokenPolicy.ts](#ğŸ“„-policytokendefaulttokenpolicyts) (197 lines, 5.67 KB)
- [policy/token/TokenEstimator.ts](#ğŸ“„-policytokentokenestimatorts) (130 lines, 4.00 KB)
- [registry/errors.ts](#ğŸ“„-registryerrorsts) (32 lines, 0.80 KB)
- [registry/index.ts](#ğŸ“„-registryindexts) (3 lines, 0.08 KB)
- [registry/manifest.ts](#ğŸ“„-registrymanifestts) (85 lines, 2.12 KB)
- [registry/registry.ts](#ğŸ“„-registryregistryts) (271 lines, 7.72 KB)
- [risk/explainer.ts](#ğŸ“„-riskexplainerts) (282 lines, 7.04 KB)
- [risk/index.ts](#ğŸ“„-riskindexts) (1 lines, 0.03 KB)
- [ssh/GovernedExecutor.ts](#ğŸ“„-sshgovernedexecutorts) (317 lines, 8.20 KB)
- [ssh/InputBuffer.ts](#ğŸ“„-sshinputbufferts) (76 lines, 1.58 KB)
- [ssh/SSHSession.ts](#ğŸ“„-sshsshsessionts) (189 lines, 4.01 KB)
- [types.d.ts](#ğŸ“„-typesdts) (6 lines, 0.17 KB)
- [utils/confirm.ts](#ğŸ“„-utilsconfirmts) (17 lines, 0.44 KB)
- [utils/globDetector.ts](#ğŸ“„-utilsglobdetectorts) (116 lines, 3.89 KB)
- [utils/history.ts](#ğŸ“„-utilshistoryts) (28 lines, 0.89 KB)
- [utils/renderer.ts](#ğŸ“„-utilsrendererts) (538 lines, 14.55 KB)
- [utils/syntaxHandler.ts](#ğŸ“„-utilssyntaxhandlerts) (368 lines, 12.54 KB)

---

## ğŸ“„ __tests__/core/kernel/XResolver.test.ts

````typescript
/**
 * X-Resolver è·¨æ–‡ä»¶ä¾èµ–æ¢æµ‹æµ‹è¯•
 *
 * éªŒè¯ X-Resolver çš„è·¨æ–‡ä»¶ç¬¦å·å‘ç°èƒ½åŠ›
 */

import { XResolver } from '../../../core/kernel/XResolver';
import { EnhancedASTParser } from '../../../core/kernel/ASTParser';
import * as fs from 'fs/promises';
import * as path from 'path';

describe('X-Resolver è·¨æ–‡ä»¶ä¾èµ–æ¢æµ‹æµ‹è¯•', () => {
  const testWorkspace = path.join(__dirname, 'temp_workspace');
  let resolver: XResolver;

  beforeAll(async () => {
    await fs.mkdir(testWorkspace, { recursive: true });
    resolver = new XResolver();

    const providerCode = `
/**
 * è®¡ç®—æ€»ä»·ï¼ˆå«ç¨ï¼‰
 * @param {number} price å•†å“ä»·æ ¼
 * @param {number} tax ç¨ç‡ï¼ˆå¦‚ 0.05 è¡¨ç¤º 5%ï¼‰
 * @returns {number} å«ç¨æ€»ä»·
 */
export function calculateTotal(price: number, tax: number): number {
  return price * (1 + tax);
}

/**
 * ç‰ˆæœ¬å·å¸¸é‡
 */
export const VERSION = '1.0.0';

/**
 * å•†å“æ¥å£
 */
export interface Product {
  name: string;
  price: number;
}
`;

    const consumerCode = `
import { calculateTotal } from './Provider';
import { Product } from './Provider';

/**
 * ç»“è´¦å‡½æ•°
 */
function checkout(product: Product) {
  console.log("Starting checkout...");
  const total = calculateTotal(product.price, 0.05);
  return total;
}

export { checkout };
`;

    await fs.writeFile(path.join(testWorkspace, 'Provider.ts'), providerCode);
    await fs.writeFile(path.join(testWorkspace, 'Consumer.ts'), consumerCode);
  });

  afterAll(async () => {
    await fs.rm(testWorkspace, { recursive: true, force: true });
  });

  describe('AST Parser ç¬¦å·æå–', () => {
    it('åº”è¯¥èƒ½ç²¾å‡†æå– Provider.ts å¯¼å‡ºçš„ç¬¦å·', async () => {
      const parser = new EnhancedASTParser();
      const result = await parser.parseFile(path.join(testWorkspace, 'Provider.ts'));

      expect(result.success).toBe(true);
      expect(result.symbols.length).toBeGreaterThan(0);

      const calcTotal = result.symbols.find(s => s.name === 'calculateTotal');
      expect(calcTotal).toBeDefined();
      expect(calcTotal?.kind).toBe('Function');
      expect(calcTotal?.isExported).toBe(true);
      expect(calcTotal?.jsDoc).toContain('@param price');
      expect(calcTotal?.jsDoc).toContain('@param tax');
      expect(calcTotal?.jsDoc).toContain('@returns');
    });

    it('åº”è¯¥æå–æ¥å£ç±»å‹ç¬¦å·', async () => {
      const parser = new EnhancedASTParser();
      const result = await parser.parseFile(path.join(testWorkspace, 'Provider.ts'));

      const productInterface = result.symbols.find(s => s.name === 'Product');
      expect(productInterface).toBeDefined();
      expect(productInterface?.kind).toBe('Interface');
      expect(productInterface?.isExported).toBe(true);
    });

    it('åº”è¯¥æå–å¸¸é‡ç¬¦å·', async () => {
      const parser = new EnhancedASTParser();
      const result = await parser.parseFile(path.join(testWorkspace, 'Provider.ts'));

      const version = result.symbols.find(s => s.name === 'VERSION');
      expect(version).toBeDefined();
      expect(version?.kind).toBe('Variable');
      expect(version?.isExported).toBe(true);
    });
  });

  describe('X-Resolver è·¨æ–‡ä»¶åˆ†æ', () => {
    it('åº”è¯¥èƒ½å‘ç° Consumer.ts å¼•ç”¨äº† Provider.ts', async () => {
      const result = await resolver.getImpactAnalysis(path.join(testWorkspace, 'Provider.ts'));

      expect(result.exportedSymbols.length).toBe(3);
      expect(result.impacts.length).toBeGreaterThan(0);

      const consumerImpact = result.impacts.find(i =>
        i.filePath.includes('Consumer.ts')
      );

      expect(consumerImpact).toBeDefined();
      expect(consumerImpact?.symbols).toContain('calculateTotal');
      expect(consumerImpact?.symbols).toContain('Product');
    });

    it('åº”è¯¥åªåˆ‡å–åŒ…å«ç¬¦å·è°ƒç”¨çš„ç›¸å…³ä»£ç å—', async () => {
      const result = await resolver.getImpactAnalysis(path.join(testWorkspace, 'Provider.ts'));

      const consumerImpact = result.impacts.find(i =>
        i.filePath.includes('Consumer.ts')
      );

      expect(consumerImpact?.snippet).toContain('calculateTotal(product.price, 0.05)');
      expect(consumerImpact?.snippet).toContain('import { calculateTotal }');
    });

    it('åº”è¯¥åŒ…å«å¯¼å‡ºç¬¦å·çš„ JSDoc', async () => {
      const result = await resolver.getImpactAnalysis(path.join(testWorkspace, 'Provider.ts'));

      const consumerImpact = result.impacts.find(i =>
        i.filePath.includes('Consumer.ts')
      );

      expect(consumerImpact?.jsDoc).toBeDefined();
      expect(consumerImpact?.jsDoc).toContain('calculateTotal');
      expect(consumerImpact?.jsDoc).toContain('@param price');
      expect(consumerImpact?.jsDoc).toContain('@param tax');
    });

    it('åº”è¯¥è¿”å›å®Œæ•´çš„åˆ†æç»“æœ', async () => {
      const result = await resolver.getImpactAnalysis(path.join(testWorkspace, 'Provider.ts'));

      expect(result).toHaveProperty('targetFile');
      expect(result).toHaveProperty('exportedSymbols');
      expect(result).toHaveProperty('impacts');
      expect(result).toHaveProperty('duration');
      expect(typeof result.duration).toBe('number');
      expect(result.duration).toBeGreaterThanOrEqual(0);
    });
  });

  describe('AI ä¸Šä¸‹æ–‡æ¸²æŸ“', () => {
    it('åº”è¯¥æ¸²æŸ“ä¸º AI å‹å¥½çš„æ ¼å¼', async () => {
      const result = await resolver.getImpactAnalysis(path.join(testWorkspace, 'Provider.ts'));
      const context = resolver.renderAsAIContext(result);

      expect(context).toContain('X-RESOLVER: CROSS-FILE DEPENDENCY CONTEXT');
      expect(context).toContain('[EXPORTED SYMBOLS]');
      expect(context).toContain('[AFFECTED FILES]');
      expect(context).toContain('EXTERNAL DEPENDENCY REFERENCE');
      expect(context).toContain('READ-ONLY');
      expect(context).toContain('USAGE SNIPPET');
    });

    it('åº”è¯¥åŒ…å«å¯¼å‡ºç¬¦å·åˆ—è¡¨', async () => {
      const result = await resolver.getImpactAnalysis(path.join(testWorkspace, 'Provider.ts'));
      const context = resolver.renderAsAIContext(result);

      expect(context).toContain('calculateTotal');
      expect(context).toContain('VERSION');
      expect(context).toContain('Product');
    });

    it('åº”è¯¥åŒ…å«å—å½±å“æ–‡ä»¶çš„è·¯å¾„', async () => {
      const result = await resolver.getImpactAnalysis(path.join(testWorkspace, 'Provider.ts'));
      const context = resolver.renderAsAIContext(result);

      expect(context).toContain('Consumer.ts');
    });

    it('åº”è¯¥åŒ…å« JSDoc æ–‡æ¡£', async () => {
      const result = await resolver.getImpactAnalysis(path.join(testWorkspace, 'Provider.ts'));
      const context = resolver.renderAsAIContext(result);

      expect(context).toContain('SYMBOL CONTRACT');
      expect(context).toContain('@param price');
      expect(context).toContain('@param tax');
    });
  });

  describe('é”™è¯¯å¤„ç†', () => {
    it('åº”è¯¥æ­£ç¡®å¤„ç†ä¸å­˜åœ¨çš„æ–‡ä»¶', async () => {
      const result = await resolver.getImpactAnalysis('/nonexistent/file.ts');

      expect(result.exportedSymbols).toHaveLength(0);
      expect(result.impacts).toHaveLength(0);
    });

    it('åº”è¯¥æ­£ç¡®å¤„ç†æ²¡æœ‰å¯¼å‡ºçš„æ–‡ä»¶', async () => {
      const noExportFile = path.join(testWorkspace, 'NoExport.ts');
      await fs.writeFile(noExportFile, 'const x = 42;');

      const result = await resolver.getImpactAnalysis(noExportFile);

      expect(result.exportedSymbols).toHaveLength(0);
      expect(result.impacts).toHaveLength(0);
    });
  });
});

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/AgentRuntime.ts

````typescript
import chalk from "chalk";
import { randomUUID } from "crypto";
import * as marked from "marked";
import TerminalRenderer from "marked-terminal";

// Configure marked with TerminalRenderer
const terminalRenderer = new TerminalRenderer();
marked.setOptions({ renderer: terminalRenderer });

import { LLMAdapter } from "./llmAdapter";
import { GovernanceService } from "./governance";
import { ToolExecutor } from "./executor";
import { ContextManager } from "./contextManager";
import { SmartContextManager } from "./smartContextManager";
import { evaluateProposal } from "./governance/core";
import { ProposedAction } from "./state";
import {
  buildDynamicContext,
  injectDynamicContext,
  DynamicContext
} from "./dynamicPrompt";
import { StreamMarkdownRenderer } from '../utils/renderer';

export class AgentRuntime {
  private context: SmartContextManager;
  private executionId: string;

  constructor(initialContext: any) {
    this.context = new SmartContextManager(initialContext);
    this.executionId = randomUUID();
  }

  async run(
    userInput: string,
    mode: "chat" | "command" = "chat",
    onChunk?: (chunk: string) => void,
    model?: string,
    renderer?: StreamMarkdownRenderer
  ) {
    let turnCount = 0;
    const maxTurns = 10;
    let lastError: string | undefined;

    // æ„å»ºåˆå§‹åŠ¨æ€ä¸Šä¸‹æ–‡
    const initialDynamicContext = await buildDynamicContext();

    if (userInput) {
      this.context.addMessage("user", userInput);
    }

    while (turnCount < maxTurns) {
      const currentTurn = ++turnCount;
      if (currentTurn > 1) {
        console.log(chalk.blue(`\n--- Turn ${currentTurn} ---`));
      }

      // Use smart context manager to get relevance-ranked context
      const enhancedContext = await this.context.getEnhancedContext({
        query: userInput,
        minRelevance: 0.3,
        maxTokens: 8000,
        enableSmartSummary: true
      });

      const messages: any[] = [];

      // Add context overview as system message
      if (enhancedContext.summary) {
        messages.push({
          role: 'system',
          content: enhancedContext.summary
        });
      }

      // Add ranked context files
      for (const item of enhancedContext.rankedItems) {
        messages.push({
          role: 'user',
          content: `@${item.path} (ç›¸å…³åº¦: ${(item.relevance * 100).toFixed(0)}%)\n${item.summary || item.content || ''}`
        });
      }

      // Add user input
      if (userInput) {
        messages.push({
          role: 'user',
          content: userInput
        });
      }

      // Build dynamic context (if previous step had error)
      const dynamicContext = await buildDynamicContext(lastError);

      // æ„å»ºåŸºç¡€promptï¼ˆåŒ…æ‹¬æ²»ç†ç­–ç•¥ï¼‰
      const basePrompt = GovernanceService.getPolicyManual();

      // æ³¨å…¥åŠ¨æ€ä¸Šä¸‹æ–‡
      const enhancedPrompt = injectDynamicContext(basePrompt, dynamicContext);

      // Create renderer if not provided but onChunk is available
      let agentRenderer = renderer;
      let agentOnChunk = onChunk;

      if (!agentRenderer && agentOnChunk) {
        agentRenderer = new StreamMarkdownRenderer(
          chalk.bgHex('#3b82f6').white.bold(' ğŸ¤– Agent ') + ' ',
          undefined,
          { autoFinish: false }
        );
        agentOnChunk = agentRenderer.startChunking();
      }

      const thought = await LLMAdapter.think(
        messages,
        mode as any,
        agentOnChunk,
        model,
        enhancedPrompt,
        this.context,
      );

      const action: ProposedAction = {
        id: randomUUID(),
        type: (thought.type as any) || "answer",
        payload: thought.payload || { text: thought.raw },
        riskLevel: "low",
        reasoning: thought.reasoning || "",
      };

      if (action.reasoning && !onChunk) {
        console.log(chalk.gray(`\nğŸ¤” Reasoning: ${action.reasoning}`));
      }

      // å¦‚æœ LLM è®¤ä¸ºå·²ç»å®Œæˆæˆ–è€…å½“å‰çš„åŠ¨ä½œå°±æ˜¯å›ç­”
      if (thought.isDone || action.type === "answer") {
        const result = await ToolExecutor.execute(action as any);

        // å¦‚æœæ²¡æœ‰ rendererï¼Œä½¿ç”¨å†…éƒ¨åˆ›å»ºçš„
        if (!renderer && agentRenderer) {
          // Stream final answer through internal renderer
          for (let i = 0; i < result.output.length; i += 10) {
            const chunk = result.output.slice(i, i + 10);
            agentRenderer.onChunk(chunk);
          }
          agentRenderer.finish();
        } else if (!renderer) {
          // Fallback to marked if no renderer
          const rendered = marked.parse(result.output);
          console.log(chalk.green(`\nğŸ¤– AIï¼š\n`) + rendered);
        }
        // å¦‚æœå¤–éƒ¨ä¼ å…¥äº† rendererï¼Œç”±å¤–éƒ¨è°ƒç”¨ finish()

        this.context.addMessage("assistant", result.output);

        // Learn from successful chat
        try {
          const { createExecutionRecord } = await import('../core/executionRecord');
          const { inferCapabilityRequirement } = await import('../core/capabilityInference');
          const { saveExecutionRecord } = await import('../core/executionStore');

          const record = createExecutionRecord(
            'agent-chat',
            { required: [], preferred: [] } as any,
            {
              aiProxyUrl: { value: '', source: 'built-in' },
              defaultModel: { value: '', source: 'built-in' },
              accountType: { value: 'free', source: 'built-in' }
            } as any,
            { selected: null, candidates: [], fallbackOccurred: false },
            { success: true },
            undefined,
            userInput,
            'chat'
          );

          (record as any).llmResult = { plan: thought.parsedPlan };
          (record as any).input = { rawInput: userInput };

          const savedRecordId = saveExecutionRecord(record);
          const { loadExecutionRecord } = await import('../core/executionStore');
          const savedRecord = loadExecutionRecord(savedRecordId);

          if (savedRecord) {
            const { learnSkillFromRecord } = await import('./skills');
            learnSkillFromRecord(savedRecord, true);
          }
        } catch (error) {
          console.warn(chalk.yellow(`[Skill Learning] Failed: ${error}`));
        }

        break;
      }

      // === å¼ºåˆ¶ ACK æ ¡éªŒï¼ˆCausal Lockï¼‰ ===
      const lastObs = this.context.getLastAckableObservation();
      const ackText = thought.parsedPlan?.acknowledged_observation;

      if (lastObs && ackText && ackText !== 'NONE') {
        const actualContent = lastObs.content.trim();
        const ackedContent = ackText.trim();

        if (actualContent !== ackedContent) {
          console.log(
            chalk.red(`[CAUSAL BREAK] âŒ ACK mismatch!`),
          );
          console.log(chalk.red(`  Expected: ${actualContent.substring(0, 100)}...`));
          console.log(chalk.red(`  Received: ${ackedContent.substring(0, 100)}...`));
          this.context.addMessage(
            "system",
            `CAUSAL BREAK: ACK does not match physical Observation. Cannot proceed without acknowledging reality.`,
          );
          continue;
        }

        console.log(chalk.green(`[CAUSAL LOCK] âœ… ACK verified`));
      }

      // === é¢„æ£€ (Pre-flight) ===
      const preCheck = evaluateProposal(
        action,
        GovernanceService.getRules(),
        GovernanceService.getLedgerSnapshot(),
      );
      if (preCheck.effect === "deny") {
        console.log(
          chalk.red(`[PRE-FLIGHT] ğŸ›¡ï¸ Policy Blocked: ${preCheck.reason}`),
        );
        this.context.addMessage(
          "system",
          `POLICY DENIED: ${preCheck.reason}. Find a different way.`,
        );
        continue;
      }

      // === æ­£å¼æ²»ç† (WASM + äººå·¥/è‡ªåŠ¨) ===
      const decision = await GovernanceService.adjudicate(action);
      if (decision.status === "rejected") {
        console.log(chalk.red(`[GOVERNANCE] âŒ Rejected: ${decision.reason}`));
        this.context.addMessage(
          "system",
          `Rejected by Governance: ${decision.reason}`,
        );
        continue;
      }

      // === è®°å½•å› æœè¾¹åˆ° KG ===
      if (lastObs && lastObs.metadata?.obsId && ackText && ackText !== 'NONE') {
        try {
          const { recordEdge } = await import('../engine/agent/knowledgeGraph');
          recordEdge({
            from: lastObs.metadata.obsId,
            to: action.id,
            type: 'ACKNOWLEDGED_BY' as any,
            metadata: {
              verified: true,
              timestamp: Date.now()
            }
          });
          console.log(chalk.gray(`[KG] âš“ Causal edge recorded`));
        } catch (error: any) {
          console.warn(chalk.yellow(`[KG] Warning: Failed to record causal edge: ${error.message}`));
        }
      }

      // === æ‰§è¡Œ ===
      console.log(chalk.yellow(`[EXECUTING] âš™ï¸ ${action.type}...`));
      const result = await ToolExecutor.execute(action as any);

      if (result.success) {
        // æˆåŠŸæ—¶æ¸…é™¤é”™è¯¯çŠ¶æ€
        lastError = undefined;
        this.context.addToolResult(action.type, result.output);
        const preview = result.output.length > 300
          ? result.output.substring(0, 300) + '...'
          : result.output;
        console.log(chalk.green(`[SUCCESS] Result:\n${preview}`));

        // Learn from this successful execution
        try {
          const { createExecutionRecord } = await import('../core/executionRecord');
          const { inferCapabilityRequirement } = await import('../core/capabilityInference');
          const { saveExecutionRecord } = await import('../core/executionStore');

          const record = createExecutionRecord(
            `agent-${mode}`,
            { required: [], preferred: [] } as any,
            {
              aiProxyUrl: { value: '', source: 'built-in' },
              defaultModel: { value: '', source: 'built-in' },
              accountType: { value: 'free', source: 'built-in' }
            } as any,
            { selected: null, candidates: [], fallbackOccurred: false },
            { success: true },
            undefined,
            userInput,
            mode
          );

          // Attach thought/plan data for skill learning
          (record as any).llmResult = { plan: thought.parsedPlan };
          (record as any).input = { rawInput: userInput };

          const savedRecordId = saveExecutionRecord(record);
          const { loadExecutionRecord } = await import('../core/executionStore');
          const savedRecord = loadExecutionRecord(savedRecordId);

          if (savedRecord) {
            const { learnSkillFromRecord } = await import('./skills');
            learnSkillFromRecord(savedRecord, true);
          }
        } catch (error) {
          console.warn(chalk.yellow(`[Skill Learning] Failed: ${error}`));
        }
      } else {
        // å¤±è´¥æ—¶è®°å½•é”™è¯¯ï¼Œä¸‹æ¬¡å¾ªç¯ä¼šæ³¨å…¥é”™è¯¯æ¢å¤æŒ‡å¯¼
        lastError = result.error;
        this.context.addToolResult(action.type, `Error: ${result.error}`);
        console.log(chalk.red(`[ERROR] ${result.error}`));
      }
    }

    if (turnCount >= maxTurns) {
      console.log(chalk.red(`\nâš ï¸ Max turns (${maxTurns}) reached.`));
    }
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/DualAgentRuntime.ts

````typescript
import chalk from 'chalk';
import { randomUUID } from 'crypto';
import { LLMAdapter } from './llmAdapter';
import { GovernanceService } from './governance';
import { ToolExecutor } from './executor';
import { ContextManager } from './contextManager';
import { ProposedAction } from './state';
import { TaskStep, TaskPlan } from './types';
import { ToolExecutionResult } from './state';
import { askAI, getUserConfig } from '../ai/client';

export class DualAgentRuntime {
  private context: ContextManager;
  private executionId: string;
  private steps: TaskStep[] = [];
  private currentIndex = 0;

  constructor(initialContext: any) {
    this.context = new ContextManager(initialContext);
    this.executionId = randomUUID();
  }

  async run(
    userInput: string,
    onChunk?: (chunk: string) => void,
    model?: string
  ): Promise<void> {
    const needsPlanner = await this.shouldUsePlanner(userInput);

    if (!needsPlanner) {
      await this.runFastPath(userInput, onChunk, model);
    } else {
      await this.runPlannedPath(userInput, onChunk, model);
    }
  }

  private async shouldUsePlanner(userInput: string): Promise<boolean> {
    const config = getUserConfig();

    if (config.disablePlanner) {
      return false;
    }

    const plannerKeywords = ['é‡æ„', 'ä¼˜åŒ–æ•´ä¸ª', 'æ‰¹é‡', 'å¤šæ­¥éª¤', 'é€ä¸ª', 'ä¾æ¬¡', 'è®¡åˆ’', 'refactor', 'optimize all', 'batch', 'multiple steps', 'sequentially'];

    if (!plannerKeywords.some(kw => userInput.toLowerCase().includes(kw.toLowerCase()))) {
      return false;
    }

    const complexityScore = await this.assessComplexity(userInput);
    return complexityScore > 0.7;
  }

  private async assessComplexity(input: string): Promise<number> {
    const simpleIndicators = [
      /åˆ—å‡º|list|ls/,
      /æŸ¥çœ‹|show|cat|less/,
      /æŸ¥æ‰¾|find|grep/,
      /åˆ›å»º|create|mkdir|touch/
    ];

    const hasSimpleIndicator = simpleIndicators.some(pattern => pattern.test(input));

    const plannerKeywords = ['é‡æ„', 'ä¼˜åŒ–æ•´ä¸ª', 'æ‰¹é‡', 'å¤šæ­¥éª¤', 'é€ä¸ª', 'ä¾æ¬¡', 'è®¡åˆ’', 'refactor', 'optimize all', 'batch', 'multiple steps', 'sequentially'];
    const hasPlannerKeyword = plannerKeywords.some(kw => input.toLowerCase().includes(kw.toLowerCase()));

    // If input has planner keywords, treat as high complexity
    if (hasPlannerKeyword) {
      return 0.8;
    }

    if (input.length < 30 || hasSimpleIndicator) {
      return 0.3;
    }

    return 0.8;
  }

  private async runFastPath(userInput: string, onChunk?: (chunk: string) => void, model?: string): Promise<void> {
    console.log(chalk.gray('ğŸš€ Quick path: Direct execution'));

    const runtime = await this.importAgentRuntime();

    this.context.addMessage('user', userInput);
    await runtime.run(userInput, 'command', onChunk, model);
  }

  private async runPlannedPath(userInput: string, onChunk?: (chunk: string) => void, model?: string): Promise<void> {
    console.log(chalk.blue('ğŸ“‹ Planning task...'));

    const plan = await this.callPlanner(userInput, model);
    this.steps = plan.steps;

    console.log(chalk.cyan(`\nPlan created with ${this.steps.length} steps:\n`));
    this.steps.forEach((step, i) => {
      const icon = step.risk_level === 'high' ? 'âš ï¸' : 'âœ…';
      console.log(`  ${i + 1}. ${icon} ${step.description}`);
    });

    console.log(chalk.gray(`\n${plan.plan}`));
    console.log(chalk.gray(`Estimated time: ${plan.estimated_time}\n`));

    const shouldProceed = await this.askUser('Proceed with this plan? (y/N): ');
    if (!shouldProceed) {
      console.log(chalk.yellow('Execution cancelled by user.'));
      return;
    }

    for (let i = 0; i < this.steps.length; i++) {
      this.currentIndex = i;
      const step = this.steps[i];

      console.log(chalk.yellow(`\nâ–¶ï¸  Step ${i + 1}/${this.steps.length}: ${step.description}`));

      const result = await this.executeStep(step, onChunk, model, userInput);

      if (!result.success) {
        console.log(chalk.red(`âŒ Step failed: ${result.error}`));

        const shouldContinue = await this.askUser('Step failed. Continue with remaining steps? (y/N): ');

        if (!shouldContinue) {
          console.log(chalk.yellow('Execution stopped by user.'));
          break;
        }
      } else {
        console.log(chalk.green(`âœ… Step completed`));

        if (result.output && result.output.length > 0) {
          const preview = result.output.length > 300 ? result.output.substring(0, 300) + '...' : result.output;
          console.log(chalk.gray(`   Output: ${preview}`));
        }
      }
    }

    console.log(chalk.blue('\nğŸ‰ All tasks completed!'));
  }

  private async callPlanner(input: string, model?: string): Promise<TaskPlan> {
    const config = getUserConfig();
    const finalModel = model || config.defaultModel || 'Assistant';

    const prompt = this.buildPlannerPrompt(input);

    const messages = [{ role: 'user', content: prompt }];

    try {
      const response = await askAI(prompt, finalModel);

      const jsonMatch = response.match(/```json\n([\s\S]*?)\n```/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[1]);
      }

      const braceMatch = response.match(/\{[\s\S]*\}/);
      if (braceMatch) {
        return JSON.parse(braceMatch[0]);
      }

      return {
        plan: 'No plan generated',
        steps: [],
        estimated_time: 'Unknown'
      };
    } catch (error) {
      console.error(chalk.red(`Planner error: ${error}`));
      return {
        plan: 'Plan generation failed',
        steps: [],
        estimated_time: 'Unknown'
      };
    }
  }

  private buildPlannerPrompt(input: string): string {
    const context = this.getContextSummary();

    return `# ROLE: Task Planner

You are a strategic planner. Break down complex tasks into executable steps.

# INPUT
User Request: ${input}

${context ? `Context:\n${context}\n` : ''}

# OUTPUT FORMAT
\`\`\`json
{
  "plan": "Brief overview of the approach",
  "steps": [
    {
      "id": "step_1",
      "description": "What to do",
      "type": "shell_cmd | tool_call | analysis | code_diff",
      "command": "Command if shell_cmd",
      "tool_name": "Tool name if tool_call",
      "parameters": {},
      "risk_level": "low | medium | high",
      "dependencies": []
    }
  ],
  "estimated_time": "2 minutes"
}
\`\`\`

# GUIDELINES
- Keep steps granular and verifiable
- Mark destructive operations (rm, dd, format) as high risk
- Include validation steps when appropriate
- Consider error handling in each step
- For shell commands, use exact commands that can be executed directly
- For tool calls, specify tool_name and parameters
- Dependencies are step IDs that must complete before this step`;
  }

  private getContextSummary(): string {
    const files = this.context.getMessages()
      .filter(m => m.role === 'user')
      .map(m => m.content)
      .join('\n');

    return files ? `Files/Context:\n${files}` : '';
  }

  private async executeStep(
    step: TaskStep,
    onChunk?: (chunk: string) => void,
    model?: string,
    originalInput: string = ''
  ): Promise<ToolExecutionResult> {
    const action: ProposedAction = {
      id: randomUUID(),
      type: step.type,
      payload: {
        tool_name: step.tool_name || '',
        parameters: step.parameters || {},
        command: step.command || '',
        risk_level: step.risk_level
      },
      riskLevel: step.risk_level,
      reasoning: `Executing planned step: ${step.description}`
    };

    const result = await ToolExecutor.execute(action);

    if (result.success) {
      this.context.addToolResult(step.type, result.output);

      try {
        const { createExecutionRecord } = await import('../core/executionRecord');
        const { saveExecutionRecord } = await import('../core/executionStore');

        const record = createExecutionRecord(
          `agent-planner-${step.type}`,
          { required: [], preferred: [] } as any,
          {
            aiProxyUrl: { value: '', source: 'built-in' },
            defaultModel: { value: '', source: 'built-in' },
            accountType: { value: 'free', source: 'built-in' }
          } as any,
          { selected: null, candidates: [], fallbackOccurred: false },
          { success: true },
          step.command || JSON.stringify(step.parameters),
          this.executionId,
          'agent'
        );

        (record as any).llmResult = { plan: { goal: step.description, command: step.command, parameters: step.parameters, risk_level: step.risk_level } };
        (record as any).input = { rawInput: originalInput };

        const savedRecordId = saveExecutionRecord(record);
        const { loadExecutionRecord } = await import('../core/executionStore');
        const savedRecord = loadExecutionRecord(savedRecordId);

        if (savedRecord) {
          const { learnSkillFromRecord } = await import('./skills');
          learnSkillFromRecord(savedRecord, true);
        }
      } catch (error) {
        console.warn(chalk.yellow(`[Skill Learning] Failed: ${error}`));
      }
    } else {
      this.context.addToolResult(step.type, `Error: ${result.error}`);

      try {
        const { getAllSkills, updateSkillStatus } = await import('./skills');
        const skills = getAllSkills();
        const existingSkill = skills.find(s => s.name === step.description);

        if (existingSkill) {
          updateSkillStatus(existingSkill.id, false);
        }
      } catch (error) {
        console.warn(chalk.yellow(`[Skill Learning] Failed to update status: ${error}`));
      }
    }

    return {
      success: result.success,
      output: result.output,
      error: result.error
    };
  }

  private async importAgentRuntime(): Promise<any> {
    const module = await import('./AgentRuntime');
    const AgentRuntime = module.AgentRuntime;
    return new AgentRuntime({});
  }

  private async askUser(question: string): Promise<boolean> {
    const readline = await import('readline');
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });

    return new Promise((resolve) => {
      rl.question(question, (answer) => {
        rl.close();
        resolve(answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes');
      });
    });
  }

  getExecutionState(): { steps: TaskStep[]; currentIndex: number } {
    return {
      steps: this.steps,
      currentIndex: this.currentIndex
    };
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/ReflectionAgent.ts

````typescript
import { listExecutionRecords } from '../core/executionStore';
import { saveContext } from '../commands/contextStorage';
import { ContextItem } from '../commands/contextBuffer';

export class ReflectionAgent {
  static async run(limit: number = 20) {
    const records = listExecutionRecords(limit);
    if (records.length === 0) return;

    const failures = records.filter(r => !r.outcome.success);
    const successes = records.filter(r => r.outcome.success);

    const memories: ContextItem[] = [];

    if (failures.length > 0) {
      memories.push({
        type: 'memory',
        path: 'reflection:failures',
        summary: 'Recent high-risk failures',
        content: failures.slice(0, 5)
          .map(f => `âŒ ${f.meta.commandName}`)
          .join('\n'),
        importance: 0.8,
        lastUsedAt: Date.now(),
        id: `reflection:failures:${Date.now()}`,
        tokens: 0
      });
    }

    if (successes.length > 0) {
      memories.push({
        type: 'memory',
        path: 'reflection:success',
        summary: 'Recent stable successes',
        content: successes.slice(0, 5)
          .map(s => `âœ… ${s.meta.commandName}`)
          .join('\n'),
        importance: 0.5,
        lastUsedAt: Date.now(),
        id: `reflection:success:${Date.now()}`,
        tokens: 0
      });
    }

    if (memories.length > 0) {
      await saveContext(memories);
    }
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/actions.ts

````typescript
import { AgentAction } from './types';
import { exec } from 'child_process';
import { promisify } from 'util';
import chalk from 'chalk';
import readline from 'readline';

const execAsync = promisify(exec);

export async function executeAction(
    action: AgentAction,
    options?: { autoYes?: boolean }
): Promise<void> {
    if (action.type === 'print') {
        console.log(action.content);
        return;
    }

    if (action.type === 'confirm') {
        const ok = options?.autoYes || await confirm('Execute this action?');
        if (ok) {
            await executeAction(action.next, options);
        }
        return;
    }

    if (action.type === 'execute') {
        try {
            console.log(chalk.cyan(`\nExecuting: ${action.command}\n`));
            const { stdout, stderr } = await execAsync(action.command, {
                shell: typeof process.env.SHELL === 'string' ? process.env.SHELL : undefined
            });
            if (stdout) console.log(stdout);
            if (stderr) console.error(chalk.yellow(stderr));
        } catch (error: any) {
            console.error(chalk.red(`Execution failed: ${error.message}`));
            throw error;
        }
    }
}

async function confirm(message: string): Promise<boolean> {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
    });

    return new Promise((resolve) => {
        rl.question(chalk.cyan(`${message} (y/N): `), (answer) => {
            rl.close();
            resolve(answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes');
        });
    });
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/astParser.ts

````typescript
/**
 * AST Parser for TypeScript/JavaScript
 *
 * ä½¿ç”¨ TypeScript Compiler API è¿›è¡ŒçœŸæ­£çš„ AST çº§åˆ«ç¬¦å·æå–
 * æ›¿ä»£æ­£åˆ™è¡¨è¾¾å¼ï¼Œæä¾›æ›´å‡†ç¡®çš„ç»“æ„åŒ–æ‘˜è¦
 */

import * as ts from 'typescript';
import * as fs from 'fs/promises';
import * as path from 'path';
import { Symbol } from './codeSummary';

export interface ASTParseResult {
  symbols: Symbol[];
  success: boolean;
  error?: string;
}

/**
 * TypeScript/JavaScript AST è§£æå™¨
 */
export class TypeScriptASTParser {
  /**
   * ä»æºä»£ç æå–ç¬¦å·
   */
  static parse(code: string, filePath: string): ASTParseResult {
    try {
      const sourceFile = ts.createSourceFile(
        filePath,
        code,
        ts.ScriptTarget.Latest,
        true,
        ts.ScriptKind.TS
      );

      const symbols: Symbol[] = [];
      this.extractSymbols(sourceFile, symbols);

      return {
        symbols,
        success: true
      };
    } catch (error) {
      return {
        symbols: [],
        success: false,
        error: error instanceof Error ? error.message : 'Unknown parsing error'
      };
    }
  }

  /**
   * é€’å½’éå† AST æå–ç¬¦å·
   */
  private static extractSymbols(node: ts.Node, symbols: Symbol[]): void {
    if (!node) return;

    const isExported = this.hasExportModifier(node);

    // æå–å¯¼å…¥è¯­å¥
    if (ts.isImportDeclaration(node)) {
      const moduleSpecifier = node.moduleSpecifier.getText();
      this.addSymbol(symbols, moduleSpecifier, 'import', node);
    }
    else if (ts.isImportEqualsDeclaration(node)) {
      this.addSymbol(symbols, node.name.getText(), 'import', node);
    }

    // æå–å¯¼å‡ºè¯­å¥
    else if (ts.isExportDeclaration(node)) {
      const moduleSpecifier = node.moduleSpecifier?.getText();
      if (moduleSpecifier) {
        this.addSymbol(symbols, `export ${moduleSpecifier}`, 'export', node);
      }
    }

    // æå–ç±»å®šä¹‰
    else if (ts.isClassDeclaration(node) && node.name) {
      this.addSymbol(symbols, node.name.getText(), isExported ? 'export' : 'class', node, this.getSignature(node));
    }

    // æå–æ¥å£å®šä¹‰
    else if (ts.isInterfaceDeclaration(node) && node.name) {
      this.addSymbol(symbols, node.name.getText(), isExported ? 'export' : 'interface', node, this.getSignature(node));
    }

    // æå–ç±»å‹åˆ«å
    else if (ts.isTypeAliasDeclaration(node) && node.name) {
      this.addSymbol(symbols, node.name.getText(), isExported ? 'export' : 'type', node, this.getSignature(node));
    }

    // æå–æšä¸¾å®šä¹‰
    else if (ts.isEnumDeclaration(node) && node.name) {
      this.addSymbol(symbols, node.name.getText(), isExported ? 'export' : 'enum', node, this.getSignature(node));
    }

    // æå–å‡½æ•°å£°æ˜
    else if (ts.isFunctionDeclaration(node) && node.name) {
      this.addSymbol(symbols, node.name.getText(), isExported ? 'export' : 'function', node, this.getSignature(node));
    }

    // æå–æ–¹æ³•å£°æ˜
    else if (ts.isMethodDeclaration(node) && node.name) {
      this.addSymbol(symbols, node.name.getText(), 'function', node, this.getSignature(node));
    }

    // æå–ç®­å¤´å‡½æ•°èµ‹å€¼
    else if (ts.isVariableStatement(node)) {
      const exported = this.hasExportModifier(node);
      const declaration = node.declarationList.declarations[0];
      if (declaration && ts.isIdentifier(declaration.name)) {
        const init = declaration.initializer;
        if (init && (ts.isArrowFunction(init) || ts.isFunctionExpression(init))) {
          this.addSymbol(symbols, declaration.name.getText(), exported ? 'export' : 'function', node, this.getSignature(node));
        } else {
          this.addSymbol(symbols, declaration.name.getText(), exported ? 'export' : 'variable', node, this.getSignature(node));
        }
      }
    }

    // é€’å½’å¤„ç†å­èŠ‚ç‚¹
    ts.forEachChild(node, (child) => this.extractSymbols(child, symbols));
  }

  /**
   * æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦æœ‰å¯¼å‡ºä¿®é¥°ç¬¦
   */
  private static hasExportModifier(node: ts.Node): boolean {
    if ('modifiers' in node) {
      const modifiers = (node as any).modifiers;
      return modifiers && modifiers.some((m: any) => m.kind === ts.SyntaxKind.ExportKeyword);
    }
    return false;
  }

  /**
   * æ·»åŠ ç¬¦å·åˆ°åˆ—è¡¨
   */
  private static addSymbol(
    symbols: Symbol[],
    name: string,
    type: 'function' | 'class' | 'variable' | 'import' | 'export' | 'interface' | 'type' | 'enum',
    node: ts.Node,
    signature?: string
  ): void {
    const sourceFile = node.getSourceFile();
    const { line } = sourceFile.getLineAndCharacterOfPosition(node.getStart());

    symbols.push({
      name: name.replace(/['"]/g, ''),
      type,
      line: line + 1,
      signature: signature || node.getText().split('\n')[0].slice(0, 200)
    });
  }

  /**
   * è·å–èŠ‚ç‚¹ç­¾åå­—ç¬¦ä¸²
   */
  private static getSignature(node: ts.Node): string {
    let signature = '';
    const nodeText = node.getText();

    // æå–ç¬¬ä¸€è¡Œæˆ–ç­¾åéƒ¨åˆ†
    const firstLine = nodeText.split('\n')[0];
    if (firstLine.length < 200) {
      signature = firstLine;
    } else {
      // å°è¯•æå–ç­¾åéƒ¨åˆ†
      const signatureMatch = firstLine.match(/^(.*?)[{;]/);
      if (signatureMatch) {
        signature = signatureMatch[1];
      } else {
        signature = firstLine.slice(0, 200);
      }
    }

    return signature;
  }

  /**
   * ä»æ–‡ä»¶è·¯å¾„è§£æå¹¶è¿”å›ç¬¦å·
   */
  static async parseFile(filePath: string): Promise<ASTParseResult> {
    try {
      const code = await fs.readFile(filePath, 'utf-8');
      return this.parse(code, filePath);
    } catch (error) {
      return {
        symbols: [],
        success: false,
        error: error instanceof Error ? error.message : 'File read error'
      };
    }
  }

  /**
   * ç”Ÿæˆç´§å‡‘çš„ç¬¦å·æ‘˜è¦æ–‡æœ¬
   */
  static generateCompactSummary(symbols: Symbol[], filePath: string): string {
    const imports = symbols.filter(s => s.type === 'import');
    const exports = symbols.filter(s => s.type === 'export');
    const types = symbols.filter(s => ['interface', 'type', 'enum'].includes(s.type));
    const classes = symbols.filter(s => s.type === 'class');
    const functions = symbols.filter(s => s.type === 'function');
    const variables = symbols.filter(s => s.type === 'variable');

    let summary = `æ–‡ä»¶: ${path.basename(filePath)}\n`;
    summary += `ç»Ÿè®¡: ${imports.length}ä¸ªå¯¼å…¥, ${exports.length}ä¸ªå¯¼å‡º, ${types.length}ä¸ªç±»å‹, ${classes.length}ä¸ªç±», ${functions.length}ä¸ªå‡½æ•°\n`;

    if (symbols.length > 0) {
      summary += '\nä¸»è¦ç¬¦å·:\n';

      if (classes.length > 0) {
        summary += '  ç±»: ' + classes.map(s => s.name).join(', ') + '\n';
      }

      if (functions.length > 0) {
        const displayFunctions = functions.slice(0, 10);
        summary += '  å‡½æ•°: ' + displayFunctions.map(fn => fn.name).join(', ');
        if (functions.length > 10) {
          summary += ` (è¿˜æœ‰${functions.length - 10}ä¸ª)`;
        }
        summary += '\n';
      }

      if (imports.length > 0 && imports.length <= 5) {
        summary += '  å¯¼å…¥: ' + imports.map(s => s.name).join(', ') + '\n';
      }

      if (exports.length > 0 && exports.length <= 5) {
        summary += '  å¯¼å‡º: ' + exports.map(s => s.name).join(', ') + '\n';
      }
    }

    return summary;
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/codeSummary.js

````javascript
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractSymbols = extractSymbols;
exports.generateFileSummary = generateFileSummary;
exports.generateMultipleFileSummaries = generateMultipleFileSummaries;
exports.generateSummaryReport = generateSummaryReport;
var path = require("path");
/**
 * ä»ä»£ç ä¸­æå–ç¬¦å·ï¼ˆç®€å•æ­£åˆ™å®ç°ï¼Œæ”¯æŒå¤šè¯­è¨€ï¼‰
 */
function extractSymbols(code, filename) {
    var symbols = [];
    var lines = code.split('\n');
    // æ ¹æ®æ–‡ä»¶æ‰©å±•åé€‰æ‹©æå–ç­–ç•¥
    var ext = path.extname(filename).toLowerCase();
    if (['.ts', '.js', '.tsx', '.jsx'].includes(ext)) {
        extractJavaScriptSymbols(lines, symbols);
    }
    else if (['.py'].includes(ext)) {
        extractPythonSymbols(lines, symbols);
    }
    else if (['.go'].includes(ext)) {
        extractGoSymbols(lines, symbols);
    }
    else if (['.rs'].includes(ext)) {
        extractRustSymbols(lines, symbols);
    }
    else if (['.java'].includes(ext)) {
        extractJavaSymbols(lines, symbols);
    }
}
// Classes
var classMatch = trimmed.match(/^class\s+(\w+)/);
if (classMatch) {
    symbols.push({
        name: classMatch[1],
        type: 'class',
        line: lineNum,
        signature: trimmed
    });
}
// Functions
var funcMatch = trimmed.match(/^function\s+(\w+)/);
if (funcMatch) {
    symbols.push({
        name: funcMatch[1],
        type: 'function',
        line: lineNum,
        signature: trimmed
    });
}
// Methods
var methodMatch = trimmed.match(/^\s*(async\s+)?(public|private|protected)?\s*(static)?\s*(\w+)\s*\(/);
if (methodMatch && !trimmed.includes('function ')) {
    symbols.push({
        name: methodMatch[4],
        type: 'function',
        line: lineNum,
        signature: trimmed
    });
}
// Arrow functions
var arrowMatch = trimmed.match(/^const\s+(\w+)\s*=\s*(async\s+)?\(/);
if (arrowMatch) {
    symbols.push({
        name: arrowMatch[1],
        type: 'function',
        line: lineNum,
        signature: trimmed
    });
}
;
/**
 * æå–Pythonç¬¦å·
 */
function extractPythonSymbols(lines, symbols) {
    lines.forEach(function (line, index) {
        var lineNum = index + 1;
        var trimmed = line.trim();
        // Imports
        if (trimmed.startsWith('import ') || trimmed.startsWith('from ')) {
            symbols.push({
                name: trimmed,
                type: 'import',
                line: lineNum
            });
        }
        // Classes
        var classMatch = trimmed.match(/^class\s+(\w+)/);
        if (classMatch) {
            symbols.push({
                name: classMatch[1],
                type: 'class',
                line: lineNum,
                signature: trimmed
            });
        }
        // Functions
        var funcMatch = trimmed.match(/^def\s+(\w+)/);
        if (funcMatch) {
            symbols.push({
                name: funcMatch[1],
                type: 'function',
                line: lineNum,
                signature: trimmed
            });
        }
    });
}
/**
 * æå–Goç¬¦å·
 */
function extractGoSymbols(lines, symbols) {
    lines.forEach(function (line, index) {
        var lineNum = index + 1;
        var trimmed = line.trim();
        // Imports
        if (trimmed.startsWith('import ')) {
            symbols.push({
                name: trimmed,
                type: 'import',
                line: lineNum
            });
        }
        // Types/Interfaces
        var typeMatch = trimmed.match(/^(type|interface)\s+(\w+)/);
        if (typeMatch) {
            symbols.push({
                name: typeMatch[2],
                type: 'class',
                line: lineNum,
                signature: trimmed
            });
        }
        // Functions
        var funcMatch = trimmed.match(/^func\s+(\w+)/);
        if (funcMatch) {
            symbols.push({
                name: funcMatch[1],
                type: 'function',
                line: lineNum,
                signature: trimmed
            });
        }
    });
}
/**
 * æå–Rustç¬¦å·
 */
function extractRustSymbols(lines, symbols) {
    lines.forEach(function (line, index) {
        var lineNum = index + 1;
        var trimmed = line.trim();
        // Uses
        if (trimmed.startsWith('use ')) {
            symbols.push({
                name: trimmed,
                type: 'import',
                line: lineNum
            });
        }
        // Structs
        var structMatch = trimmed.match(/^struct\s+(\w+)/);
        if (structMatch) {
            symbols.push({
                name: structMatch[1],
                type: 'class',
                line: lineNum,
                signature: trimmed
            });
        }
        // Functions
        var funcMatch = trimmed.match(/^fn\s+(\w+)/);
        if (funcMatch) {
            symbols.push({
                name: funcMatch[1],
                type: 'function',
                line: lineNum,
                signature: trimmed
            });
        }
    });
}
/**
 * æå–Javaç¬¦å·
 */
function extractJavaSymbols(lines, symbols) {
    lines.forEach(function (line, index) {
        var lineNum = index + 1;
        var trimmed = line.trim();
        // Imports
        if (trimmed.startsWith('import ')) {
            symbols.push({
                name: trimmed,
                type: 'import',
                line: lineNum
            });
        }
        // Classes
        var classMatch = trimmed.match(/^class\s+(\w+)/);
        if (classMatch) {
            symbols.push({
                name: classMatch[1],
                type: 'class',
                line: lineNum,
                signature: trimmed
            });
        }
        // Methods
        var methodMatch = trimmed.match(/^\s*(public|private|protected)?\s*(static)?\s*\w+\s+(\w+)\s*\(/);
        if (methodMatch) {
            symbols.push({
                name: methodMatch[2],
                type: 'function',
                line: lineNum,
                signature: trimmed
            });
        }
    });
}
/**
 * ç”Ÿæˆæ–‡ä»¶æ‘˜è¦
 */
function generateFileSummary(filePath, content) {
    var symbols = extractSymbols(content, filePath);
    // ç»Ÿè®¡ç¬¦å·ç±»å‹
    var stats = {
        imports: symbols.filter(function (s) { return s.type === 'import'; }).length,
        exports: symbols.filter(function (s) { return s.type === 'export'; }).length,
        classes: symbols.filter(function (s) { return s.type === 'class'; }).length,
        functions: symbols.filter(function (s) { return s.type === 'function'; }).length,
    };
    // ç”Ÿæˆæ‘˜è¦æ–‡æœ¬
    var summary = "\u6587\u4EF6: ".concat(path.basename(filePath), "\n");
    summary += "\u7EDF\u8BA1: ".concat(stats.imports, "\u4E2A\u5BFC\u5165, ").concat(stats.exports, "\u4E2A\u5BFC\u51FA, ").concat(stats.classes, "\u4E2A\u7C7B, ").concat(stats.functions, "\u4E2A\u51FD\u6570\n");
    if (symbols.length > 0) {
        summary += '\nä¸»è¦ç¬¦å·:\n';
        // æŒ‰ç±»å‹åˆ†ç»„
        var classes = symbols.filter(function (s) { return s.type === 'class'; });
        var functions = symbols.filter(function (s) { return s.type === 'function'; });
        var imports = symbols.filter(function (s) { return s.type === 'import'; });
        var exports_1 = symbols.filter(function (s) { return s.type === 'export'; });
        if (classes.length > 0) {
            summary += '  ç±»: ' + classes.map(function (s) { return s.name; }).join(', ') + '\n';
        }
        if (functions.length > 0) {
            summary += '  å‡½æ•°: ' + functions.slice(0, 10).map(function (s) { return s.name; }).join(', ');
            if (functions.length > 10) {
                summary += " (\u8FD8\u6709".concat(functions.length - 10, "\u4E2A)");
            }
            summary += '\n';
        }
        if (imports.length > 0 && imports.length <= 5) {
            summary += '  å¯¼å…¥: ' + imports.map(function (s) { return s.name; }).join(', ') + '\n';
        }
    }
    return {
        path: filePath,
        summary: summary,
        symbols: symbols
    };
}
/**
 * ç”Ÿæˆå¤šæ–‡ä»¶æ‘˜è¦
 */
function generateMultipleFileSummaries(files) {
    return __awaiter(this, void 0, void 0, function () {
        var summaries, _i, files_1, file, summary;
        return __generator(this, function (_a) {
            summaries = [];
            for (_i = 0, files_1 = files; _i < files_1.length; _i++) {
                file = files_1[_i];
                summary = generateFileSummary(file.path, file.content);
                summaries.push(summary);
            }
            return [2 /*return*/, summaries];
        });
    });
}
/**
 * ç”Ÿæˆæ‘˜è¦æŠ¥å‘Šï¼ˆç”¨äºæ³¨å…¥åˆ°Promptï¼‰
 */
function generateSummaryReport(summaries, maxLength) {
    if (maxLength === void 0) { maxLength = 2000; }
    var report = '[CODE STRUCTURE SUMMARY]\n';
    for (var _i = 0, summaries_1 = summaries; _i < summaries_1.length; _i++) {
        var summary = summaries_1[_i];
        // å¦‚æœè¶…è¿‡æœ€å¤§é•¿åº¦ï¼Œæˆªæ–­
        if (report.length + summary.summary.length > maxLength) {
            var remaining = maxLength - report.length - 20;
            if (remaining > 0) {
                report += "\n... (\u8FD8\u6709".concat(summaries.length - summaries.indexOf(summary), "\u4E2A\u6587\u4EF6\u672A\u663E\u793A\uFF0C\u53EF\u6309\u9700\u67E5\u770B\u8BE6\u60C5)");
            }
            break;
        }
        report += '\n' + summary.summary;
    }
    return report;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/context.ts

````typescript
import { AgentInput, AgentContext } from './types';
import { ContextBuffer } from '../commands/contextBuffer';
import { generateFileSummary, generateSummaryReport } from './codeSummary';

/**
 * Build context for agent execution
 * Implements intelligent token optimization by using AST summaries for large files
 * instead of sending full file contents
 */
export function buildContext(input: AgentInput, contextBuffer: ContextBuffer): AgentContext {
    const items = contextBuffer.export();

    const files = items.map(item => {
        const content = item.content ?? item.summary ?? '';

        // Token optimization: Use summary instead of full content if file is large (> 500 lines or > 20KB)
        const lines = content.split('\n').length;
        const sizeKb = content.length / 1024;

        if (lines > 500 || sizeKb > 20) {
            const summary = generateFileSummary(item.path, content);
            return {
                path: item.path,
                content: summary.summary, // Use AST summary instead of full content
            };
        }

        return {
            path: item.path,
            content: content,
        };
    });

    return {
        files,
        gitDiff: undefined, // Will be enhanced later
        history: [], // Will be populated from conversation history
    };
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/contextManager.ts

````typescript
import crypto from 'crypto';
import { GovernanceContext } from './state';

export interface MessageMetadata {
  kind?: string;
  obsId?: string;
}

export class ContextManager {
  private messages: Array<{ role: string; content: string; timestamp: number; metadata?: MessageMetadata }> = [];
  private maxHistorySize = 50;

  constructor(initialContext?: GovernanceContext) {
    if (initialContext?.history) {
      this.messages = initialContext.history.map(msg => ({
        ...msg,
        timestamp: Date.now()
      }));
    }

    if (initialContext?.input) {
      this.addMessage('user', initialContext.input);
    }
  }

  addMessage(role: string, content: string): void {
    this.messages.push({
      role,
      content,
      timestamp: Date.now()
    });

    if (this.messages.length > this.maxHistorySize) {
      this.messages = this.messages.slice(-this.maxHistorySize);
    }
  }

  addToolResult(toolName: string, result: string): void {
    const content = `Tool ${toolName} returned:\n${result}`;
    this.addMessage('tool', content);
  }

  addObservation(
    observation: string,
    kind: 'tool_result' | 'system_note' | 'manual_input' = 'system_note',
    originatingActionId?: string
  ): string {
    const obsId = `obs_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`;

    this.addMessage('system', observation);
    this.messages[this.messages.length - 1].metadata = { kind, obsId };
    return obsId;
  }

  getLastAckableObservation(): { content: string; metadata?: MessageMetadata } | null {
    for (let i = this.messages.length - 1; i >= 0; i--) {
      const msg = this.messages[i];
      if (msg.role === 'system' && msg.metadata?.obsId) {
        return {
          content: msg.content,
          metadata: msg.metadata
        };
      }
    }
    return null;
  }

  getMessages(): Array<{ role: 'system' | 'user' | 'assistant' | 'tool'; content: string }> {
    return this.messages.map(({ role, content }) => ({
      role: role as 'system' | 'user' | 'assistant' | 'tool',
      content
    }));
  }

  getRecentMessages(count: number): Array<{ role: string; content: string; timestamp: number }> {
    return this.messages.slice(-count);
  }

  getHash(): string {
    const content = JSON.stringify(this.messages);
    return crypto.createHash('sha256').update(content).digest('hex');
  }

  getSnapshot() {
    return {
      inputHash: this.getHash(),
      systemPromptVersion: 'v1.0.0',
      toolSetVersion: 'v1.0.0',
      recentMessages: this.getRecentMessages(10)
    };
  }

  clear(): void {
    this.messages = [];
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/dynamicPrompt.ts

````typescript
import * as fs from 'fs/promises';
import * as path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

/**
 * ç¼“å­˜æ£€æµ‹ç»“æœï¼Œé¿å…é‡å¤IOæ“ä½œ
 */
let cachedGitContext: string | null = null;
let cachedTechStack: string[] | null = null;
let lastCheckTimestamp = 0;
const CACHE_TTL = 5000; // 5ç§’ç¼“å­˜

/**
 * åŠ¨æ€Promptç”Ÿæˆå™¨
 * æ ¹æ®è¿è¡Œæ—¶çŠ¶æ€åŠ¨æ€æ³¨å…¥Promptç‰‡æ®µ
 */

export interface DynamicContext {
  gitContext?: string;
  techStack?: string[];
  lastError?: string;
  errorRecovery?: string;
}

/**
 * æ£€æµ‹Gitä¸Šä¸‹æ–‡ï¼ˆå¢å¼ºç‰ˆï¼Œæ”¯æŒå­ç›®å½•æ£€æµ‹ï¼‰
 */
export async function detectGitContext(): Promise<string | null> {
  // ä½¿ç”¨gitå‘½ä»¤æ£€æµ‹ï¼Œæ”¯æŒåœ¨é¡¹ç›®å­ç›®å½•ä¸­è¿è¡Œ
  try {
    const { stdout } = await execAsync('git rev-parse --is-inside-work-tree', {
      cwd: process.cwd(),
      timeout: 2000
    });
    
    if (stdout.trim() === 'true') {
      return `
[GIT CONTEXT]
å½“å‰ç›®å½•åœ¨ä¸€ä¸ªGitä»“åº“ä¸­ã€‚
- ä¼˜å…ˆä½¿ç”¨ \`git ls-files\` åˆ—å‡ºæ–‡ä»¶ï¼ˆéµå®ˆ.gitignoreï¼‰
- ä½¿ç”¨ \`git diff\` æŸ¥çœ‹æœªæäº¤çš„æ›´æ”¹
- ä½¿ç”¨ \`git log\` æŸ¥çœ‹æœ€è¿‘å†å²
- è°¨æ…æ“ä½œç‰ˆæœ¬æ§åˆ¶æ–‡ä»¶
`;
    }
  } catch {
    // gitå‘½ä»¤å¤±è´¥ï¼Œå›é€€åˆ°æ–‡ä»¶ç³»ç»Ÿæ£€æµ‹
    try {
      await fs.access('.git');
      return `
[GIT CONTEXT]
å½“å‰ç›®å½•æ˜¯ä¸€ä¸ªGitä»“åº“ã€‚
- ä¼˜å…ˆä½¿ç”¨ \`git ls-files\` åˆ—å‡ºæ–‡ä»¶ï¼ˆéµå®ˆ.gitignoreï¼‰
- ä½¿ç”¨ \`git diff\` æŸ¥çœ‹æœªæäº¤çš„æ›´æ”¹
- ä½¿ç”¨ \`git log\` æŸ¥çœ‹æœ€è¿‘å†å²
- è°¨æ…æ“ä½œç‰ˆæœ¬æ§åˆ¶æ–‡ä»¶
`;
    } catch {
      return null;
    }
  }
  
  return null;
}

/**
 * æ£€æµ‹æŠ€æœ¯æ ˆï¼ˆä½¿ç”¨Promise.allå¹¶å‘æ£€æµ‹ï¼Œæå‡æ€§èƒ½ï¼‰
 */
export async function detectTechStack(): Promise<string[]> {
  const filesToCheck = [
    { file: 'package.json', stack: 'Node.js' },
    { file: 'Cargo.toml', stack: 'Rust' },
    { file: 'go.mod', stack: 'Go' },
    { file: 'requirements.txt', stack: 'Python' },
    { file: 'pom.xml', stack: 'Java/Maven' },
    { file: 'build.gradle', stack: 'Java/Gradle' },
    { file: 'Gemfile', stack: 'Ruby' },
    { file: 'composer.json', stack: 'PHP' },
    { file: 'Dockerfile', stack: 'Docker' },
  ];

  // å¹¶å‘æ£€æµ‹æ‰€æœ‰æ–‡ä»¶ï¼Œæå‡æ€§èƒ½
  const results = await Promise.all(
    filesToCheck.map(async ({ file, stack }) => {
      try {
        await fs.access(file);
        return stack;
      } catch {
        return null;
      }
    })
  );

  // è¿‡æ»¤æ‰nullå€¼å¹¶å»é‡
  return results.filter((stack): stack is string => stack !== null);
}

/**
 * ç”ŸæˆæŠ€æœ¯æ ˆæŒ‡å¯¼
 */
export function generateTechStackGuidance(stacks: string[]): string {
  if (stacks.length === 0) {
    return '';
  }

  const guidance: string[] = [];

  if (stacks.includes('Node.js')) {
    guidance.push(`
[TECH STACK: Node.js]
- ä½¿ç”¨ \`npm\` æˆ– \`yarn\` è¿›è¡ŒåŒ…ç®¡ç†
- æ£€æŸ¥ package.json å¯ç”¨çš„è„šæœ¬å‘½ä»¤
- ç”Ÿæˆä»£ç æ—¶ä½¿ç”¨TypeScriptä¸¥æ ¼æ¨¡å¼
- ä½¿ç”¨ESLintå’ŒPrettierè¿›è¡Œä»£ç æ ¼å¼åŒ–`);
  }

  if (stacks.includes('Python')) {
    guidance.push(`
[TECH STACK: Python]
- ä½¿ç”¨ \`pip\` æˆ– \`poetry\` è¿›è¡ŒåŒ…ç®¡ç†
- æ£€æŸ¥ requirements.txt æˆ– pyproject.toml
- éµå¾ªPEP 8ä»£ç é£æ ¼æŒ‡å—
- ä½¿ç”¨è™šæ‹Ÿç¯å¢ƒéš”ç¦»ä¾èµ–`);
  }

  if (stacks.includes('Go')) {
    guidance.push(`
[TECH STACK: Go]
- ä½¿ç”¨ \`go mod\` è¿›è¡Œæ¨¡å—ç®¡ç†
- æ£€æŸ¥ go.mod æ–‡ä»¶äº†è§£ä¾èµ–
- éµå¾ªGoæƒ¯ç”¨æ¨¡å¼å’Œé”™è¯¯å¤„ç†
- ä½¿ç”¨ \`go test\` è¿è¡Œæµ‹è¯•`);
  }

  if (stacks.includes('Rust')) {
    guidance.push(`
[TECH STACK: Rust]
- ä½¿ç”¨ \`cargo\` è¿›è¡ŒåŒ…ç®¡ç†
- æ£€æŸ¥ Cargo.toml äº†è§£ä¾èµ–
- éµå¾ªRustæ‰€æœ‰æƒå’Œå€Ÿç”¨è§„åˆ™
- ä½¿ç”¨ \`cargo clippy\` è¿›è¡Œä»£ç æ£€æŸ¥`);
  }

  if (stacks.includes('Docker')) {
    guidance.push(`
[TECH STACK: Docker]
- æ£€æŸ¥ Dockerfile å’Œ docker-compose.yml
- å®¹å™¨åŒ–è¿è¡Œå’Œæµ‹è¯•å‘½ä»¤
- æ³¨æ„å¤šé˜¶æ®µæ„å»ºä¼˜åŒ–
- ç®¡ç†å®¹å™¨ç½‘ç»œå’Œå·`);
  }

  return guidance.join('\n');
}

/**
 * ç”Ÿæˆé”™è¯¯æ¢å¤æŒ‡å¯¼
 */
export function generateErrorRecovery(lastError: string): string {
  return `
[ERROR RECOVERY]
ä¸Šä¸€æ­¥æ“ä½œå¤±è´¥: ${lastError}
ä½ å¿…é¡»å°è¯•ä¸åŒçš„æ–¹æ³•æˆ–éªŒè¯å‰ç½®æ¡ä»¶ã€‚

è€ƒè™‘ä»¥ä¸‹é€‰é¡¹:
- æ£€æŸ¥å‘½ä»¤è¯­æ³•æ˜¯å¦æ­£ç¡®
- éªŒè¯æ–‡ä»¶/è·¯å¾„æ˜¯å¦å­˜åœ¨
- ä½¿ç”¨ä¸åŒçš„æ ‡å¿—æˆ–å·¥å…·
- æ£€æŸ¥ä¾èµ–æ˜¯å¦å·²å®‰è£…
- æŸ¥çœ‹é”™è¯¯æ—¥å¿—è·å–æ›´å¤šä¿¡æ¯

å¦‚æœä»ç„¶å¤±è´¥ï¼Œåˆ‡æ¢åˆ° "answer" æ¨¡å¼å‘ç”¨æˆ·è¯´æ˜é—®é¢˜`;
}

/**
 * æ„å»ºåŠ¨æ€ä¸Šä¸‹æ–‡
 */
export async function buildDynamicContext(
  lastError?: string,
  includeTechStack: boolean = true
): Promise<DynamicContext> {
  const context: DynamicContext = {};

  // æ£€æµ‹Gitä¸Šä¸‹æ–‡
  const gitContext = await detectGitContext();
  if (gitContext) {
    context.gitContext = gitContext;
  }

  // æ£€æµ‹æŠ€æœ¯æ ˆ
  if (includeTechStack) {
    const techStack = await detectTechStack();
    if (techStack.length > 0) {
      context.techStack = techStack;
    }
  }

  // é”™è¯¯æ¢å¤
  if (lastError) {
    context.lastError = lastError;
    context.errorRecovery = generateErrorRecovery(lastError);
  }

  return context;
}

/**
 * å°†åŠ¨æ€ä¸Šä¸‹æ–‡æ³¨å…¥åˆ°Prompt
 */
export function injectDynamicContext(
  basePrompt: string,
  context: DynamicContext
): string {
  let prompt = basePrompt;

  // æ³¨å…¥Gitä¸Šä¸‹æ–‡
  if (context.gitContext) {
    prompt += `\n${context.gitContext}`;
  }

  // æ³¨å…¥æŠ€æœ¯æ ˆæŒ‡å¯¼
  if (context.techStack && context.techStack.length > 0) {
    const guidance = generateTechStackGuidance(context.techStack);
    prompt += `\n${guidance}`;
  }

  // æ³¨å…¥é”™è¯¯æ¢å¤
  if (context.errorRecovery) {
    prompt += `\n${context.errorRecovery}`;
  }

  return prompt;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/errorHandling.ts

````typescript
/**
 * é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶
 * æ™ºèƒ½å¤„ç†LLMè°ƒç”¨å¤±è´¥ï¼Œæä¾›è‡ªåŠ¨é‡è¯•å’Œæ›¿ä»£æ–¹æ¡ˆ
 */

export interface RetryConfig {
  maxAttempts: number;
  initialDelay: number; // æ¯«ç§’
  maxDelay: number; // æ¯«ç§’
  backoffMultiplier: number;
  retryableErrors: string[];
}

export interface RetryResult<T> {
  success: boolean;
  data?: T;
  error?: Error;
  attempts: number;
  totalDuration: number;
  lastError?: Error;
  fallbackUsed?: boolean;
}

export interface AlternativeStrategy<T> {
  name: string;
  description: string;
  execute: () => Promise<T>;
}

const DEFAULT_RETRY_CONFIG: RetryConfig = {
  maxAttempts: 3,
  initialDelay: 1000,
  maxDelay: 10000,
  backoffMultiplier: 2,
  retryableErrors: [
    'network',
    'timeout',
    'rate limit',
    'ECONNRESET',
    'ETIMEDOUT',
    '503',
    '502',
    '429',
    'ENOTFOUND',
  ],
};

/**
 * æŒ‡æ•°é€€é¿å»¶è¿Ÿè®¡ç®—
 */
function calculateBackoffDelay(
  attempt: number,
  config: RetryConfig
): number {
  const delay = Math.min(
    config.initialDelay * Math.pow(config.backoffMultiplier, attempt - 1),
    config.maxDelay
  );
  // æ·»åŠ éšæœºæŠ–åŠ¨ï¼ˆÂ±25%ï¼‰
  const jitter = delay * 0.25 * (Math.random() * 2 - 1);
  return Math.max(0, delay + jitter);
}

/**
 * åˆ¤æ–­é”™è¯¯æ˜¯å¦å¯é‡è¯•
 */
function isRetryableError(error: Error, config: RetryConfig): boolean {
  // Safely extract error message
  let errorMessage = '';
  if (typeof error.message === 'string') {
    errorMessage = error.message;
  } else if (typeof error === 'string') {
    errorMessage = error;
  }
  
  const lowerMessage = errorMessage.toLowerCase();
  return config.retryableErrors.some(
    (pattern) => lowerMessage.includes(pattern.toLowerCase())
  );
}

/**
 * è‡ªåŠ¨é‡è¯•æ‰§è¡Œå™¨
 */
export async function withRetry<T>(
  operation: () => Promise<T>,
  config: Partial<RetryConfig> = {}
): Promise<RetryResult<T>> {
  const finalConfig = { ...DEFAULT_RETRY_CONFIG, ...config };
  let lastError: Error | undefined;
  let attempts = 0;
  const startTime = Date.now();

  while (attempts < finalConfig.maxAttempts) {
    attempts++;

    try {
      const result = await operation();
      const totalDuration = Date.now() - startTime;

      return {
        success: true,
        data: result,
        attempts,
        totalDuration,
      };
    } catch (error) {
      lastError = error as Error;

      // å¦‚æœä¸å¯é‡è¯•æˆ–è¾¾åˆ°æœ€å¤§å°è¯•æ¬¡æ•°ï¼Œç›´æ¥å¤±è´¥
      if (
        !isRetryableError(lastError, finalConfig) ||
        attempts >= finalConfig.maxAttempts
      ) {
        break;
      }

      // è®¡ç®—å»¶è¿Ÿå¹¶ç­‰å¾…
      const delay = calculateBackoffDelay(attempts, finalConfig);
      // Safely extract error message for logging
      const errorMsg = typeof lastError.message === 'string' ? lastError.message : String(lastError);
      console.log(
        `[é‡è¯•] ç¬¬${attempts}æ¬¡å°è¯•å¤±è´¥: ${errorMsg}, ${delay.toFixed(0)}msåé‡è¯•...`
      );
      await sleep(delay);
    }
  }

  const totalDuration = Date.now() - startTime;
  return {
    success: false,
    error: lastError,
    attempts,
    totalDuration,
    lastError,
  };
}

/**
 * å¸¦æ›¿ä»£æ–¹æ¡ˆçš„æ‰§è¡Œå™¨
 */
export async function withAlternatives<T>(
  primary: () => Promise<T>,
  alternatives: AlternativeStrategy<T>[],
  config: Partial<RetryConfig> = {}
): Promise<RetryResult<T>> {
  // å…ˆå°è¯•ä¸»è¦ç­–ç•¥ï¼ˆå¸¦é‡è¯•ï¼‰
  const primaryResult = await withRetry(primary, config);

  if (primaryResult.success) {
    return primaryResult;
  }

  // ä¸»ç­–ç•¥å¤±è´¥ï¼Œå°è¯•æ›¿ä»£æ–¹æ¡ˆ
  console.log(`[æ›¿ä»£æ–¹æ¡ˆ] ä¸»ç­–ç•¥å¤±è´¥ï¼Œå°è¯•${alternatives.length}ä¸ªæ›¿ä»£æ–¹æ¡ˆ...`);

  for (const alternative of alternatives) {
    console.log(`[æ›¿ä»£æ–¹æ¡ˆ] å°è¯•: ${alternative.name} - ${alternative.description}`);

    try {
      const data = await alternative.execute();
      return {
        success: true,
        data,
        attempts: primaryResult.attempts + 1,
        totalDuration: primaryResult.totalDuration,
        fallbackUsed: true,
      };
    } catch (error) {
      const errorMsg = error instanceof Error && typeof error.message === 'string' 
        ? error.message 
        : String(error);
      console.log(`[æ›¿ä»£æ–¹æ¡ˆ] ${alternative.name} å¤±è´¥: ${errorMsg}`);
    }
  }

  // æ‰€æœ‰æ–¹æ¡ˆéƒ½å¤±è´¥
  return {
    success: false,
    error: new Error('æ‰€æœ‰æ‰§è¡Œæ–¹æ¡ˆå‡å¤±è´¥'),
    attempts: primaryResult.attempts + alternatives.length,
    totalDuration: primaryResult.totalDuration,
    lastError: primaryResult.lastError,
    fallbackUsed: true,
  };
}

/**
 * ç”Ÿæˆé”™è¯¯è§£é‡Š
 */
export function generateErrorExplanation(error: Error, context: string = ''): string {
  const explanations: Record<string, string> = {
    network:
      'ç½‘ç»œè¿æ¥å¤±è´¥ã€‚è¯·æ£€æŸ¥ï¼š1. ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸ 2. é˜²ç«å¢™è®¾ç½® 3. ä»£ç†é…ç½®',
    timeout:
      'è¯·æ±‚è¶…æ—¶ã€‚å¯èƒ½åŸå› ï¼š1. ç½‘ç»œå»¶è¿Ÿ 2. æœåŠ¡å™¨å“åº”æ…¢ 3. è¯·æ±‚å¤„ç†æ—¶é—´è¿‡é•¿',
    'rate limit':
      'APIè°ƒç”¨é¢‘ç‡è¶…é™ã€‚è¯·ç¨åé‡è¯•ï¼Œæˆ–è€ƒè™‘å‡çº§APIè®¡åˆ’ä»¥è·å¾—æ›´é«˜çš„é€Ÿç‡é™åˆ¶',
    'econnreset':
      'è¿æ¥è¢«é‡ç½®ã€‚å¯èƒ½æ˜¯ç½‘ç»œä¸ç¨³å®šæˆ–æœåŠ¡å™¨æš‚æ—¶ä¸å¯ç”¨',
    'etimedout':
      'è¿æ¥è¶…æ—¶ã€‚è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥å’ŒæœåŠ¡å™¨çŠ¶æ€',
    '503':
      'æœåŠ¡æš‚æ—¶ä¸å¯ç”¨ã€‚æœåŠ¡å™¨å¯èƒ½æ­£åœ¨ç»´æŠ¤æˆ–è¿‡è½½ï¼Œè¯·ç¨åé‡è¯•',
    '502':
      'ç½‘å…³é”™è¯¯ã€‚æœåŠ¡å™¨è¿”å›äº†æ— æ•ˆçš„å“åº”ï¼Œè¯·ç¨åé‡è¯•',
    '429':
      'è¯·æ±‚è¿‡å¤šã€‚è¶…è¿‡äº†APIçš„é€Ÿç‡é™åˆ¶ï¼Œè¯·ç­‰å¾…ä¸€æ®µæ—¶é—´åé‡è¯•',
    'enotfound':
      'ä¸»æœºæœªæ‰¾åˆ°ã€‚è¯·æ£€æŸ¥ï¼š1. åŸŸåæ‹¼å†™ 2. DNSé…ç½® 3. ç½‘ç»œè¿æ¥',
    'authentication':
      'è®¤è¯å¤±è´¥ã€‚è¯·æ£€æŸ¥APIå¯†é’¥æˆ–è®¤è¯å‡­è¯',
    'authorization':
      'æˆæƒå¤±è´¥ã€‚æ‚¨å¯èƒ½æ²¡æœ‰æ‰§è¡Œæ­¤æ“ä½œçš„æƒé™',
    'invalid request':
      'è¯·æ±‚æ— æ•ˆã€‚è¯·æ£€æŸ¥è¯·æ±‚æ ¼å¼å’Œå‚æ•°',
    'context length':
      'ä¸Šä¸‹æ–‡é•¿åº¦è¶…é™ã€‚è¯·å‡å°‘è¾“å…¥å†…å®¹æˆ–ä½¿ç”¨æ›´çŸ­çš„Prompt',
  };

  // Safely extract error message
  let errorMessage = '';
  if (typeof error.message === 'string') {
    errorMessage = error.message;
  } else if (typeof error === 'string') {
    errorMessage = error;
  }
  
  const lowerMessage = errorMessage.toLowerCase();
  
  // æŸ¥æ‰¾åŒ¹é…çš„é”™è¯¯è§£é‡Š
  for (const [key, explanation] of Object.entries(explanations)) {
    if (errorMessage.includes(key.toLowerCase())) {
      return `âŒ é”™è¯¯ç±»å‹: ${key}\n${explanation}${context ? '\n\nä¸Šä¸‹æ–‡: ' + context : ''}`;
    }
  }

  // é»˜è®¤è§£é‡Š
  return `âŒ é”™è¯¯: ${errorMessage}\n\nå¯èƒ½åŸå› ï¼š\n1. ç½‘ç»œè¿æ¥é—®é¢˜\n2. APIæœåŠ¡å¼‚å¸¸\n3. è¯·æ±‚æ ¼å¼é”™è¯¯\n4. è®¤è¯æˆæƒé—®é¢˜\n\nå»ºè®®ï¼š\n1. æ£€æŸ¥ç½‘ç»œè¿æ¥\n2. æŸ¥çœ‹APIæ–‡æ¡£\n3. ç¡®è®¤APIå¯†é’¥æ­£ç¡®\n4. ç¨åé‡è¯•${context ? '\n\nä¸Šä¸‹æ–‡: ' + context : ''}`;
}

/**
 * ç¡çœ å‡½æ•°
 */
function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * åˆ›å»ºæ›¿ä»£ç­–ç•¥
 */
export function createAlternativeStrategy<T>(
  name: string,
  description: string,
  execute: () => Promise<T>
): AlternativeStrategy<T> {
  return {
    name,
    description,
    execute
  };
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/executor.ts

````typescript
import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs/promises';
import path from 'path';
import { ProposedAction, ToolExecutionResult } from './state';

const execAsync = promisify(exec);

export class ToolExecutor {
  private static readonly MAX_OUTPUT_LENGTH = 2000; // Maximum output length in characters

  /**
   * Truncates output if too long and adds helpful suggestions
   */
  private static maybeTruncate(output: string): string {
    if (output.length <= this.MAX_OUTPUT_LENGTH) {
      return output;
    }

    const truncated = output.slice(0, this.MAX_OUTPUT_LENGTH);
    const suggestion = `

[âš ï¸ OUTPUT TRUNCATED]
The output was too long (${output.length} chars). Here are some ways to get what you need:

1. Use \`head\` to see the first lines:
   head -n 50 filename

2. Use \`tail\` to see the last lines:
   tail -n 50 filename

3. Use \`grep\` to filter relevant content:
   grep "keyword" filename

4. Use specific line ranges with read_file
`;

    return truncated + suggestion;
  }

  static async execute(action: ProposedAction): Promise<ToolExecutionResult> {
    const { type, payload } = action;

    try {
      const result = await this.executeAction(type, payload);
      const truncated = this.maybeTruncate(result.output);

      return {
        ...result,
        output: truncated
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.message || String(error),
        output: ''
      };
    }
  }

  private static async executeAction(type: string, payload: any): Promise<ToolExecutionResult> {
    switch (type) {
      case 'tool_call':
        return await this.executeTool(payload);

      case 'shell_cmd':
        return await this.executeShell(payload.command);

      case 'code_diff':
        return await this.executeDiff(payload.diff);

      case 'answer':
        return {
          success: true,
          output: payload.content || payload.text || '',
          artifacts: []
        };

      default:
        return {
          success: false,
          error: `Unknown action type: ${type}`,
          output: ''
        };
    }
  }

  private static async executeTool(payload: any): Promise<ToolExecutionResult> {
    const toolName = payload.tool_name;

    switch (toolName) {
      case 'read_file':
        return await this.toolReadFile(payload.parameters);
      
      case 'write_file':
        return await this.toolWriteFile(payload.parameters);
      
      case 'list_files':
        return await this.toolListFiles(payload.parameters);
      
      case 'web_search':
        return {
          success: false,
          error: 'web_search not implemented yet',
          output: ''
        };
      
      default:
        return {
          success: false,
          error: `Unknown tool: ${toolName}`,
          output: ''
        };
    }
  }

  private static async toolReadFile(params: any): Promise<ToolExecutionResult> {
    const filePath = params.path;
    try {
      const content = await fs.readFile(filePath, 'utf-8');
      return {
        success: true,
        output: content,
        artifacts: [filePath]
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.message,
        output: ''
      };
    }
  }

  private static async toolWriteFile(params: any): Promise<ToolExecutionResult> {
    const filePath = params.path;
    const content = params.content;
    
    try {
      await fs.mkdir(path.dirname(filePath), { recursive: true });
      await fs.writeFile(filePath, content, 'utf-8');
      return {
        success: true,
        output: `Successfully wrote ${filePath}`,
        artifacts: [filePath]
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.message,
        output: ''
      };
    }
  }

  private static async toolListFiles(params: any): Promise<ToolExecutionResult> {
    const dirPath = params.path || '.';
    const recursive = params.recursive || false;
    
    try {
      const files = await this.getFiles(dirPath, recursive);
      return {
        success: true,
        output: JSON.stringify(files, null, 2),
        artifacts: files.map(f => f.path)
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.message,
        output: ''
      };
    }
  }

  private static async getFiles(dir: string, recursive: boolean): Promise<Array<{ path: string; type: string }>> {
    const entries = await fs.readdir(dir, { withFileTypes: true });
    const files: Array<{ path: string; type: string }> = [];

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      
      if (entry.isDirectory()) {
        files.push({ path: fullPath, type: 'directory' });
        if (recursive) {
          const subFiles = await this.getFiles(fullPath, recursive);
          files.push(...subFiles);
        }
      } else {
        files.push({ path: fullPath, type: 'file' });
      }
    }

    return files;
  }

  private static async executeShell(command: string): Promise<ToolExecutionResult> {
    try {
      const { stdout, stderr } = await execAsync(command, {
        maxBuffer: 10 * 1024 * 1024,
        cwd: process.cwd()
      });

      const output = stdout || stderr || '';
      
      return {
        success: true,
        output,
        artifacts: []
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.message,
        output: error.stdout || error.stderr || ''
      };
    }
  }

  private static async executeDiff(diff: string): Promise<ToolExecutionResult> {
    try {
      const tempFile = path.join(process.cwd(), '.yuangs_temp.patch');
      await fs.writeFile(tempFile, diff, 'utf-8');

      const { stdout, stderr } = await execAsync(`git apply --check ${tempFile}`, {
        cwd: process.cwd()
      });

      const { stdout: applyOutput } = await execAsync(`git apply ${tempFile}`, {
        cwd: process.cwd()
      });

      await fs.unlink(tempFile);

      return {
        success: true,
        output: applyOutput || 'Diff applied successfully',
        artifacts: ['.yuangs_temp.patch']
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.message,
        output: error.stdout || error.stderr || 'Failed to apply diff'
      };
    }
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/governance.ts

````typescript
import chalk from 'chalk';
import { ProposedAction, GovernanceDecision } from './state';
import { evaluateProposal, PolicyRule, RiskEntry } from './governance/core';
import { RiskLedger } from './governance/ledger';
import { WasmGovernanceBridge } from './governance/bridge';
import { generateRiskDisclosure, formatRiskDisclosureCLI, extractRiskFactorsFromThought, RiskFactors } from './riskDisclosure';
import jsyaml from 'js-yaml';
import fs from 'fs';
import path from 'path';

export class GovernanceService {
  private static rules: PolicyRule[] = [];
  private static ledger = new RiskLedger();
  private static initialized = false;

  static async init() {
    if (this.initialized) return;
    this.loadPolicy();
    await WasmGovernanceBridge.init();
    this.initialized = true;
  }

  private static loadPolicy() {
    try {
      const policyPath = path.join(process.cwd(), 'policy.yaml');
      if (fs.existsSync(policyPath)) {
        const content = fs.readFileSync(policyPath, 'utf8');
        const config = jsyaml.load(content) as any;
        this.rules = config.rules || [];
      }
    } catch (e) {
      this.rules = [];
    }
  }

  static getRules(): PolicyRule[] {
    return this.rules;
  }

  static getLedgerSnapshot(): RiskEntry[] {
    return this.ledger.getSnapshot();
  }

  static getPolicyManual(): string {
    return this.rules.map(r => `- ${r.id}: ${r.reason} (${r.effect})`).join('\n');
  }

  static async adjudicate(action: ProposedAction): Promise<GovernanceDecision> {
    await this.init();

    // 1. WASM ç‰©ç†å±‚æ ¸éªŒ
    const wasmResult = WasmGovernanceBridge.evaluate(action, this.rules, this.ledger.getSnapshot());
    if (wasmResult.effect === 'deny') {
      return { status: 'rejected', by: 'policy', reason: wasmResult.reason || 'WASM Denied', timestamp: Date.now() };
    }

    // 2. é€»è¾‘å±‚æ ¸éªŒ
    const logicResult = evaluateProposal(action, this.rules, this.ledger.getSnapshot());
    if (logicResult.effect === 'deny') {
      return { status: 'rejected', by: 'policy', reason: logicResult.reason || 'Policy Denied', timestamp: Date.now() };
    }

    if (logicResult.effect === 'allow') {
      this.ledger.record(action.type);
      return { status: 'approved', by: 'policy', timestamp: Date.now() };
    }

    // 3. äººå·¥å¹²é¢„å…œåº•
    console.log(chalk.yellow(`\nâš ï¸  Governance: Explicit approval required for ${action.type}`));
    if (action.type === 'shell_cmd') {
      console.log(chalk.bold.green('ğŸ’» Proposed Command: ') + chalk.yellow(action.payload.command));
    } else if (action.type === 'tool_call') {
      console.log(chalk.bold.green('ğŸ› ï¸  Tool: ') + chalk.cyan(`${action.payload.tool_name}(${JSON.stringify(action.payload.parameters)})`));
    }

    // Generate and display risk disclosure
    const riskFactors: RiskFactors = extractRiskFactorsFromThought(action.reasoning || '');
    riskFactors.commandType = action.type;
    if (action.type === 'shell_cmd') {
      riskFactors.command = action.payload.command;
    }
    riskFactors.isDestructive = action.payload.risk_level === 'high';

    const disclosure = generateRiskDisclosure(riskFactors);
    console.log(formatRiskDisclosureCLI(disclosure));

    const { confirm } = await import('../utils/confirm');
    const ok = await confirm(`Do you want to proceed with this action?`);

    if (ok) {
      this.ledger.record(action.type);
      return { status: 'approved', by: 'human', timestamp: Date.now() };
    } else {
      return { status: 'rejected', by: 'human', reason: 'User declined execution', timestamp: Date.now() };
    }
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/governance/bridge.ts

````typescript
import fs from 'fs';
import path from 'path';

export class WasmGovernanceBridge {
    private static instance: any = null;

    static async init(): Promise<boolean> {
        try {
            const loader = require('@assemblyscript/loader');
            const wasmPath = path.join(process.cwd(), 'build', 'release.wasm');

            if (!fs.existsSync(wasmPath)) {
                return false;
            }

            const wasmModule = await loader.instantiate(fs.readFileSync(wasmPath));
            this.instance = wasmModule.exports;
            return true;
        } catch (e) {
            return false;
        }
    }

    static evaluate(proposal: any, rules: any, ledger: any): any {
        if (!this.instance) return { effect: 'error', reason: 'WASM not initialized' };

        const { __newString, __getString, evaluate } = this.instance;

        const pPtr = __newString(JSON.stringify(proposal));
        const rPtr = __newString(JSON.stringify(rules));
        const lPtr = __newString(JSON.stringify(ledger));

        const resultPtr = evaluate(pPtr, rPtr, lPtr);
        return JSON.parse(__getString(resultPtr));
    }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/governance/core.ts

````typescript
import { ProposedAction } from '../state';

export interface PolicyRule {
    id: string;
    when: { type?: string; pattern?: string; max_per_minute?: number };
    effect: 'allow' | 'deny' | 'require_approval';
    reason?: string;
}

export interface RiskEntry {
    ts: number;
    actionType: string;
}

export function evaluateProposal(
    action: ProposedAction,
    rules: PolicyRule[],
    ledger: RiskEntry[]
): { effect: string; reason?: string } {
    const now = Date.now();
    for (const rule of rules) {
        const typeMatch = !rule.when.type || rule.when.type === action.type;
        const payloadStr = JSON.stringify(action.payload);
        const patternMatch = !rule.when.pattern || new RegExp(rule.when.pattern, 'i').test(payloadStr);

        if (typeMatch && patternMatch) {
            if (rule.when.max_per_minute) {
                const count = ledger.filter(e => e.ts > now - 60000 && e.actionType === action.type).length;
                if (count >= rule.when.max_per_minute) return { effect: 'deny', reason: `Rate limit: ${rule.id}` };
            }
            return { effect: rule.effect, reason: rule.reason };
        }
    }
    return { effect: 'require_approval', reason: 'Default human review required' };
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/governance/index.ts

````typescript
// Original governance module exports
export * from './bridge';
export * from './core';
export * from './ledger';

// Note: New causal tracking modules are in src/engine/agent/governance/
// These are imported directly when needed to avoid circular dependencies

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/governance/ledger.ts

````typescript
import { RiskEntry } from './core';

export class RiskLedger {
    private entries: RiskEntry[] = [];

    record(actionType: string): void {
        this.entries.push({
            ts: Date.now(),
            actionType
        });
        this.cleanup();
    }

    getSnapshot(): RiskEntry[] {
        return [...this.entries];
    }

    private cleanup(): void {
        const oneHourAgo = Date.now() - 3600000;
        this.entries = this.entries.filter(e => e.ts > oneHourAgo);
    }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/governance/sandbox/core.as.ts

````typescript
/**
 * yuangs Governance WASM Sandbox
 * è¿™é‡Œçš„ä»£ç åœ¨æ‰§è¡Œæ—¶ä¸ Node.js å†…å­˜å®Œå…¨éš”ç¦»
 */

// ç®€å•çš„è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥å­—ç¬¦ä¸²åŒ…å«ï¼ˆWASM å†…éƒ¨å®ç°ï¼‰
function includes(source: string, target: string): boolean {
    return source.indexOf(target) != -1;
}

/**
 * æ ¸å¿ƒè£å†³å¯¼å‡ºå‡½æ•°
 * @param proposal ææ¡ˆå­—ç¬¦ä¸²
 * @param rules è§„åˆ™å­—ç¬¦ä¸²ï¼ˆYAML è½¬æ¢åçš„ JSONï¼‰
 * @param ledger è´¦æœ¬å­—ç¬¦ä¸²
 */
export function evaluate(proposal: string, rules: string, ledger: string): string {
    // 1. æš´åŠ›é˜»æ–­ï¼šæœ€åº•å±‚çš„ç‰©ç†é˜²çº¿ï¼ˆå³ä¾¿å¤–éƒ¨é€»è¾‘è¢«æ±¡æŸ“ï¼Œè¿™é‡Œä¹Ÿæ˜¯æ­»çš„ï¼‰
    if (proposal.includes("rm -rf /") || proposal.includes("sudo rm")) {
        return '{"effect": "deny", "reason": "WASM_SANDBOX: æ£€æµ‹åˆ°æ¯ç­æ€§å‘½ä»¤ï¼Œå¼ºåˆ¶é˜»æ–­"}';
    }

    // 2. æ£€æŸ¥é€Ÿç‡ï¼ˆåŸºäºè´¦æœ¬é•¿åº¦ï¼‰
    // å‡è®¾æˆ‘ä»¬ä¸æƒ³è®© AI åœ¨çŸ­æ—¶é—´å†…è¿ç»­æè®®è¶…è¿‡ 50 æ¬¡
    if (ledger.length > 5000) { // ç®€å•é€šè¿‡å­—ç¬¦ä¸²é•¿åº¦æ¨¡æ‹Ÿå¼‚å¸¸è´¦æœ¬
        return '{"effect": "deny", "reason": "WASM_SANDBOX: è´¦æœ¬å¼‚å¸¸è†¨èƒ€ï¼Œå¯èƒ½é­å—æ‹’ç»æœåŠ¡æ”»å‡»"}';
    }

    // 3. é€»è¾‘é€ä¼ 
    // åœ¨å®é™…ç”Ÿäº§ä¸­ï¼Œæˆ‘ä»¬ä¼šåœ¨è¿™é‡Œè§£æ JSON rulesã€‚
    // ç›®å‰ç‰ˆæœ¬æˆ‘ä»¬å…ˆç¡®ä¿ç‰©ç†é“¾è·¯æ‰“é€šã€‚
    return '{"effect": "allow", "reason": "WASM_SANDBOX: ç‰©ç†éš”ç¦»å±‚éªŒè¯é€šè¿‡"}';
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/index.ts

````typescript
export { AgentRuntime } from './AgentRuntime';
export { DualAgentRuntime } from './DualAgentRuntime';
export { SmartContextManager } from './smartContextManager';
export * from './state';
export { LLMAdapter } from './llmAdapter';
export { GovernanceService } from './governance';
export { ToolExecutor } from './executor';
export { ContextManager } from './contextManager';
export * from './skills';
export * from './relevance';
export * from './preferences';

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/llm.ts

````typescript
import { AgentPrompt, LLMResult } from './types';
import { callAI_Stream } from '../ai/client';
import axios from 'axios';
import { DEFAULT_AI_PROXY_URL, DEFAULT_MODEL, DEFAULT_ACCOUNT_TYPE, type AIRequestMessage } from '../core/validation';
import fs from 'fs';
import path from 'path';
import os from 'os';
import { safeParseJSON } from '../core/validation';
import { z } from 'zod';
import { withRetry, RetryConfig } from './errorHandling';

const CONFIG_FILE = path.join(os.homedir(), '.yuangs.json');

// Agent Action Schema for Native Structured Output
export { supportsStructuredOutput };

export const AgentActionSchema = z.object({
  action_type: z.enum(['tool_call', 'shell_cmd', 'answer', 'code_diff']),
  tool_name: z.string().optional(),
  parameters: z.record(z.string(), z.any()).optional(),
  command: z.string().optional(),
  diff: z.string().optional(),
  risk_level: z.enum(['low', 'medium', 'high']),
  risk_explanation: z.string().optional(),
  content: z.string().optional(),
  is_done: z.boolean().optional()
});

export type AgentAction = z.infer<typeof AgentActionSchema>;

// Models that support native structured output
const STRUCTURED_OUTPUT_MODELS = [
  'gpt-4o',
  'gpt-4o-mini',
  'gpt-4-turbo',
  'claude-3.5-sonnet',
  'claude-3.5-haiku',
  'gemini-2.5-flash',
  'gemini-2.5-flash-lite',
  'gemini-3-flash-preview',
  'Assistant',
  'gemini-2.5-pro'
];

/**
 * Check if a model supports native structured output
 */
function supportsStructuredOutput(model: string): boolean {
  const modelName = model.toLowerCase();
  return STRUCTURED_OUTPUT_MODELS.some(supported => 
    modelName.includes(supported.toLowerCase())
  );
}

function getUserConfig(): any {
    if (fs.existsSync(CONFIG_FILE)) {
        try {
            const content = fs.readFileSync(CONFIG_FILE, 'utf8');
            return JSON.parse(content);
        } catch (e) { }
    }
    return {};
}

export async function runLLM({
    prompt,
    model,
    stream,
    onChunk,
  }: {
    prompt: AgentPrompt;
    model: string;
    stream: boolean;
    onChunk?: (s: string, type?: 'thought' | 'json') => void;
  }): Promise<LLMResult> {
    const start = Date.now();

    if (stream) {
        let raw = '';
        const messages = prompt.system ? [{ role: 'system', content: prompt.system } as any, ...prompt.messages] : prompt.messages;

        // Track current block type for streaming
        let currentBlockType: 'thought' | 'json' | 'none' = 'none';
        let buffer = '';

        await callAI_Stream(messages, model, (chunk) => {
            raw += chunk;
            onChunk?.(chunk, 'thought');
        });

        return {
            rawText: raw,
            latencyMs: Date.now() - start,
        };
    }

    // Non-streaming mode with optional schema
    const config = getUserConfig();
    const url = config.aiProxyUrl || DEFAULT_AI_PROXY_URL;

    const headers = {
        'Content-Type': 'application/json',
        'X-Client-ID': 'npm_yuangs',
        'Origin': 'https://cli.want.biz',
        'Referer': 'https://cli.want.biz/',
        'account': config.accountType || DEFAULT_ACCOUNT_TYPE,
        'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Mobile/15E148 Safari/604.1',
        'Accept': 'application/json'
    };

    // Native Structured Output: Check if model supports it and we're in Agent mode
    const modelUsed = model || config.defaultModel || DEFAULT_MODEL;
    const useStructuredOutput = supportsStructuredOutput(modelUsed) && !stream;

    let responseData: any = {
        model: modelUsed,
        messages: prompt.system ? [{ role: 'system', content: prompt.system }, ...prompt.messages] : prompt.messages,
        stream: false
    };

    if (useStructuredOutput && prompt.system?.includes('SYSTEM PROTOCOL')) {
        responseData.response_format = {
            type: 'json_schema',
            json_schema: {
                name: 'agent_action',
                description: 'Agent action following REACT protocol',
                strict: true,
                schema: {
                    type: 'object',
                    properties: {
                        action_type: {
                            type: 'string',
                            enum: ['tool_call', 'shell_cmd', 'answer', 'code_diff']
                        },
                        tool_name: {
                            type: 'string'
                        },
                        parameters: {
                            type: 'object',
                            additionalProperties: true
                        },
                        command: {
                            type: 'string'
                        },
                        diff: {
                            type: 'string'
                        },
                        risk_level: {
                            type: 'string',
                            enum: ['low', 'medium', 'high']
                        },
                        risk_explanation: {
                            type: 'string'
                        },
                        content: {
                            type: 'string'
                        },
                        is_done: {
                            type: 'boolean'
                        }
                    },
                    required: ['action_type', 'risk_level']
                }
            }
        };
    }

    try {
        const response = await axios.post(url, responseData, { headers }) as any;

        // Safely extract content from response
        let rawText = '';
        if (response.data && typeof response.data === 'object') {
          if (response.data.choices && Array.isArray(response.data.choices) && response.data.choices.length > 0) {
            rawText = response.data.choices[0]?.message?.content || '';
          } else {
            // Handle cases where response format is different
            rawText = response.data.content || response.data.text || JSON.stringify(response.data);
          }
        } else {
          rawText = String(response.data || '');
        }

        let parsed = undefined;
        if (prompt.outputSchema) {
            const parseResult = safeParseJSON(rawText, prompt.outputSchema, {});
            if (parseResult.success) {
                parsed = parseResult.data;
            }
        }

        return {
            rawText,
            parsed,
            latencyMs: Date.now() - start,
        };
    } catch (error: any) {
        // Safely extract error message without accessing circular references
        let errorMsg = 'æœªçŸ¥é”™è¯¯';
        
        // Only access the basic message property to avoid circular reference issues
        try {
            if (error && typeof error.message === 'string') {
                errorMsg = error.message;
            } else if (typeof error === 'string') {
                errorMsg = error;
            } else {
                errorMsg = String(error);
            }
        } catch (e) {
            errorMsg = 'æœªçŸ¥é”™è¯¯ï¼ˆæ— æ³•è§£æé”™è¯¯ä¿¡æ¯ï¼‰';
        }
        
        throw new Error(`AI è¯·æ±‚å¤±è´¥: ${errorMsg}`);
    }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/llmAdapter.ts

````typescript
import { AgentThought } from './state';
import { runLLM } from './llm';
import { AgentPrompt } from './types';
import type { AIRequestMessage } from '../core/validation';
import { getUserConfig } from '../ai/client';
import JSON5 from 'json5';
import { ContextManager } from './contextManager';
import { buildV2_2ProtocolPrompt, ProtocolV2_2Config } from './protocolV2_2';

export class LLMAdapter {
  static async think(
    messages: AIRequestMessage[],
    mode: 'chat' | 'command' | 'command+exec' = 'chat',
    onChunk?: (chunk: string, type?: 'thought' | 'json') => void,
    model?: string,
    customSystemPrompt?: string,
    contextManager?: ContextManager
  ): Promise<AgentThought> {
    const v2Config: ProtocolV2_2Config = {
        mode: mode === 'chat' ? 'chat' : 'command',
        enableStrictOutput: mode !== 'chat',
        enableReasoningTrace: true
    };

    let protocol = buildV2_2ProtocolPrompt(v2Config);

    if (mode === 'command' || mode === 'command+exec') {
      protocol += `\n\nCOMMAND MODE ACTIVE:
- Prioritize "shell_cmd" for any terminal-based task.
- Minimize "answer" type unless task is purely conversational.
- Direct execution is expected.`;
    }

    const prompt: AgentPrompt = {
      system: customSystemPrompt ? `${protocol}\n\nGOVERNANCE POLICY:\n${customSystemPrompt}` : protocol,
      messages,
    };

    const config = getUserConfig();
    const finalModel = model || config.defaultModel || 'Assistant';

    const result = await runLLM({
      prompt,
      model: finalModel,
      stream: !!onChunk,
      onChunk
    });

    return this.parseThought(result.rawText);
  }

  static parseThought(raw: string): AgentThought {
    try {
      // CoT V2.2: åˆ†åˆ«æå– [THOUGHT] å—å’Œ JSON å—
      const thoughtMatch = raw.match(/\[THOUGHT\]([\s\S]*?)\[\/THOUGHT\]/);
      const jsonMatch = raw.match(/```json\n([\s\S]*?)\n```/) || raw.match(/\{[\s\S]*\}/);
      
      if (jsonMatch) {
        const parsed = JSON5.parse(jsonMatch[1] || jsonMatch[0]);
        
        // ä» THOUGHT å—æå–æ€è€ƒå†…å®¹
        const thoughtContent = thoughtMatch ? thoughtMatch[1].trim() : '';

        // å¦‚æœæ˜ç¡®æ ‡è®°ä¸º doneï¼Œæˆ–è€…åŠ¨ä½œä¸º answerï¼Œåˆ™è§†ä¸ºä»»åŠ¡ç»“æŸ
        if (parsed.is_done === true || parsed.action_type === 'answer') {
          return {
            raw,
            parsedPlan: parsed,
            isDone: true,
            type: 'answer',
            payload: {
              content: parsed.final_answer || parsed.content || parsed.text || raw
            },
            reasoning: thoughtContent
          };
        }

        // æ™ºèƒ½æ¨æ–­åŠ¨ä½œç±»å‹ï¼šå¦‚æœ AI æ²¡ç»™ action_typeï¼Œæˆ‘ä»¬æ ¹æ®å­—æ®µçŒœæµ‹
        let inferredType = parsed.action_type;
        if (!inferredType) {
          if (parsed.tool_name || parsed.tool) inferredType = 'tool_call';
          else if (parsed.command || parsed.cmd) inferredType = 'shell_cmd';
          else if (parsed.diff || parsed.patch) inferredType = 'code_diff';
          else inferredType = 'answer';
        }

        return {
          raw,
          parsedPlan: parsed,
          isDone: inferredType === 'answer' || parsed.is_done === true,
          type: inferredType,
          payload: {
            tool_name: parsed.tool_name || parsed.tool || '',
            parameters: parsed.parameters || parsed.params || {},
            command: parsed.command || parsed.cmd || '',
            diff: parsed.diff || parsed.patch || '',
            content: parsed.content || parsed.text || '',
            risk_level: parsed.risk_level || 'low',
            risk_explanation: parsed.risk_explanation || ''
          },
          reasoning: thoughtContent // ä» THOUGHT å—æå–
        };
      }
    } catch (e) {
      // è§£æå¤±è´¥æ—¶ï¼Œå›é€€åˆ°å°†åŸå§‹å†…å®¹ä½œä¸ºå›ç­”
    }

    return {
      raw,
      parsedPlan: {},
      isDone: true,
      type: 'answer',
      payload: { content: raw },
      reasoning: ''
    };
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/policy/engine.ts

````typescript
import { Policy, PolicyContext, PolicyResult } from './types';
import { RiskLevel } from '../state';

export class PolicyEngine {
  private policies: Map<string, Policy> = new Map();

  registerPolicy(policy: Policy): void {
    this.policies.set(policy.name, policy);
  }

  unregisterPolicy(name: string): void {
    this.policies.delete(name);
  }

  async evaluate(context: PolicyContext): Promise<PolicyResult> {
    let finalResult: PolicyResult = {
      allowed: true,
      reason: 'All policies passed'
    };

    for (const [name, policy] of this.policies) {
      const result = await policy.evaluate(context);
      
      if (!result.allowed) {
        return {
          allowed: false,
          reason: `Policy "${name}" blocked: ${result.reason}`,
          requiresEscalation: result.requiresEscalation || false,
          suggestedActions: result.suggestedActions
        };
      }

      if (result.requiresEscalation) {
        finalResult.requiresEscalation = true;
        finalResult.suggestedActions = result.suggestedActions;
      }
    }

    return finalResult;
  }

  evaluateRisk(action: { type: string; payload: any }): RiskLevel {
    const { type, payload } = action;

    if (type === 'tool_call') {
      const toolName = payload.tool_name;
      
      const lowRiskTools = ['read_file', 'list_files', 'web_search'];
      if (lowRiskTools.includes(toolName)) {
        return 'low';
      }

      const mediumRiskTools = ['write_file', 'shell'];
      if (mediumRiskTools.includes(toolName)) {
        const cmd = payload.parameters?.command || payload.command || '';
        if (this.containsDangerousCommand(cmd)) {
          return 'high';
        }
        return 'medium';
      }

      return 'medium';
    }

    if (type === 'shell_cmd') {
      const cmd = payload.command || '';
      if (this.containsDangerousCommand(cmd)) {
        return 'high';
      }
      return 'medium';
    }

    return 'low';
  }

  private containsDangerousCommand(cmd: string): boolean {
    const dangerousPatterns = [
      /rm\s+-rf\s+\//,
      /rm\s+-rf\s+~/,
      />\s*\/dev\/null/,
      /dd\s+if=/,
      /mkfs/,
      /format/,
      /sudo\s+rm/
    ];

    return dangerousPatterns.some(pattern => pattern.test(cmd));
  }
}

export const policyEngine = new PolicyEngine();

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/policy/index.ts

````typescript
export * from './types';
export * from './engine';
export * from './policies/noDangerousShell';

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/policy/policies/noDangerousShell.ts

````typescript
import { Policy, PolicyContext, PolicyResult } from '../types';
import { RiskLevel } from '../../state';

export class NoDangerousShellPolicy implements Policy {
  name = 'no-dangerous-shell';
  description = 'Prevents execution of dangerous shell commands';

  evaluate(context: PolicyContext): PolicyResult {
    const { action } = context;

    if (action.type === 'shell_cmd') {
      const command = action.payload?.command || '';
      
      const dangerousPatterns = [
        { pattern: /rm\s+-rf\s+\//, name: 'rm -rf /', risk: 'high' },
        { pattern: /rm\s+-rf\s+~/, name: 'rm -rf ~', risk: 'high' },
        { pattern: />\s*\/dev\/null/, name: 'Redirect to /dev/null', risk: 'medium' },
        { pattern: /dd\s+if=/, name: 'dd command', risk: 'high' },
        { pattern: /mkfs/, name: 'mkfs (filesystem creation)', risk: 'high' },
        { pattern: /format/, name: 'format command', risk: 'high' },
        { pattern: /sudo\s+rm/, name: 'sudo rm', risk: 'high' },
        { pattern: /chmod\s+777\s+\/(?!dev)/, name: 'chmod 777 on system', risk: 'high' },
        { pattern: /:\s*~\(\)/, name: 'fork bomb', risk: 'high' }
      ];

      for (const { pattern, name, risk } of dangerousPatterns) {
        if (pattern.test(command)) {
          return {
            allowed: false,
            reason: `Dangerous command detected: ${name} (${risk} risk)`,
            requiresEscalation: risk === 'high',
            suggestedActions: [
              `Review the command: "${command}"`,
              'Consider using safer alternatives',
              'Break down the operation into smaller, safer steps'
            ]
          };
        }
      }
    }

    return {
      allowed: true,
      reason: 'No dangerous patterns detected'
    };
  }
}

export const noDangerousShellPolicy = new NoDangerousShellPolicy();

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/policy/types.ts

````typescript
import { RiskLevel } from '../state';

export interface PolicyContext {
  action: {
    type: string;
    payload: any;
  };
  user?: {
    permissions: string[];
  };
  environment?: {
    isProduction: boolean;
  };
}

export interface PolicyResult {
  allowed: boolean;
  reason?: string;
  requiresEscalation?: boolean;
  suggestedActions?: string[];
}

export interface Policy {
  name: string;
  description: string;
  evaluate(context: PolicyContext): PolicyResult | Promise<PolicyResult>;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/preferences.ts

````typescript
export interface ChatPreferences {
  verbosity: 'concise' | 'normal' | 'detailed';
  language: 'zh-CN' | 'en-US' | 'auto';
  codeStyle: 'functional' | 'imperative' | 'any';
  explanation: 'technical' | 'beginner' | 'adaptive';
  outputFormat: 'markdown' | 'plain' | 'structured';
  autoConfirm: boolean;
  contextStrategy: 'smart' | 'minimal' | 'full';
}

const DEFAULT_PREFERENCES: ChatPreferences = {
  verbosity: 'normal',
  language: 'auto',
  codeStyle: 'any',
  explanation: 'adaptive',
  outputFormat: 'markdown',
  autoConfirm: false,
  contextStrategy: 'smart'
};

export class PreferencesManager {
  private static preferences: ChatPreferences = DEFAULT_PREFERENCES;

  static getPreferences(): ChatPreferences {
    return { ...this.preferences };
  }

  static setPreferences(updates: Partial<ChatPreferences>): void {
    this.preferences = { ...this.preferences, ...updates };
    this.savePreferences();
  }

  static getPreference<K extends keyof ChatPreferences>(key: K): ChatPreferences[K] {
    return this.preferences[key];
  }

  private static savePreferences(): void {
    try {
      const fs = require('fs');
      const path = require('path');
      const os = require('os');

      const configPath = path.join(os.homedir(), '.yuangs_preferences.json');
      fs.writeFileSync(configPath, JSON.stringify(this.preferences, null, 2), 'utf8');
    } catch (error) {
      console.warn('Failed to save preferences:', error);
    }
  }

  static loadPreferences(): void {
    try {
      const fs = require('fs');
      const path = require('path');
      const os = require('os');

      const configPath = path.join(os.homedir(), '.yuangs_preferences.json');

      if (fs.existsSync(configPath)) {
        const content = fs.readFileSync(configPath, 'utf8');
        this.preferences = { ...DEFAULT_PREFERENCES, ...JSON.parse(content) };
      }
    } catch (error) {
      console.warn('Failed to load preferences, using defaults:', error);
    }
  }

  static resetPreferences(): void {
    this.preferences = { ...DEFAULT_PREFERENCES };
    this.savePreferences();
  }
}

export function buildPersonalizedPrompt(
  basePrompt: string,
  preferences?: Partial<ChatPreferences>
): string {
  const prefs = { ...DEFAULT_PREFERENCES, ...preferences };
  let personalized = basePrompt;

  if (prefs.verbosity === 'concise') {
    personalized += '\n\nã€ç®€æ´æ¨¡å¼ã€‘\n- åªæä¾›ç›´æ¥ç­”æ¡ˆ\n- çœç•¥è¯¦ç»†è§£é‡Š\n- é™¤éæ˜ç¡®è¦æ±‚';
  } else if (prefs.verbosity === 'detailed') {
    personalized += '\n\nã€è¯¦ç»†æ¨¡å¼ã€‘\n- æä¾›å…¨é¢çš„è§£é‡Š\n- åŒ…å«ç¤ºä¾‹å’ŒèƒŒæ™¯\n- è¯´æ˜æŠ€æœ¯ç»†èŠ‚';
  }

  if (prefs.language !== 'auto') {
    personalized += `\n\nã€è¯­è¨€è®¾ç½®ã€‘\nè¯·ä½¿ç”¨ ${prefs.language} å›ç­”`;
  }

  if (prefs.explanation === 'beginner') {
    personalized += '\n\nã€æ–°æ‰‹å‹å¥½ã€‘\n- é¿å…ä¸“ä¸šæœ¯è¯­\n- é€æ­¥è§£é‡Šæ¦‚å¿µ\n- æä¾›æ›´å¤šç¤ºä¾‹';
  } else if (prefs.explanation === 'technical') {
    personalized += '\n\nã€æŠ€æœ¯æ¨¡å¼ã€‘\n- ä½¿ç”¨æ ‡å‡†æœ¯è¯­\n- ç›´æ¥åˆ‡å…¥æŠ€æœ¯ç»†èŠ‚\n- çœç•¥åŸºç¡€æ¦‚å¿µè§£é‡Š';
  }

  if (prefs.codeStyle === 'functional') {
    personalized += '\n\nã€å‡½æ•°å¼ä»£ç é£æ ¼ã€‘\n- ä¼˜å…ˆä½¿ç”¨çº¯å‡½æ•°\n- é¿å…å‰¯ä½œç”¨\n- å¼ºè°ƒä¸å¯å˜æ€§';
  } else if (prefs.codeStyle === 'imperative') {
    personalized += '\n\nã€å‘½ä»¤å¼ä»£ç é£æ ¼ã€‘\n- ä¼˜å…ˆä½¿ç”¨å¾ªç¯å’Œæ¡ä»¶\n- æ˜ç¡®çš„çŠ¶æ€å˜æ›´\n- è¿‡ç¨‹åŒ–æ€ç»´';
  }

  return personalized;
}

export function applyOutputFormat(
  content: string,
  format: 'markdown' | 'plain' | 'structured'
): string {
  switch (format) {
    case 'plain':
      return content
        .replace(/#{1,6}\s/g, '')
        .replace(/\*\*/g, '')
        .replace(/`[^`]+`/g, '$1')
        .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
        .trim();

    case 'structured':
      const sections = content.split(/\n#{2,6}\s+/).filter(s => s.trim());
      if (sections.length > 1) {
        return JSON.stringify({
          sections: sections.map(s => ({
            content: s.trim(),
            length: s.length
          }))
        }, null, 2);
      }
      return content;

    case 'markdown':
    default:
      return content;
  }
}

export function buildContextStrategyPrompt(strategy: 'smart' | 'minimal' | 'full'): string {
  switch (strategy) {
    case 'minimal':
      return `
ã€ä¸Šä¸‹æ–‡ç­–ç•¥ï¼šæœ€å°åŒ–ã€‘
- åªä½¿ç”¨æ˜ç¡®å¼•ç”¨çš„æ–‡ä»¶å’Œç›®å½•
- ä¸è¿›è¡Œéšå¼æ–‡ä»¶ç³»ç»Ÿæ‰«æ
- æœ€å°åŒ–Tokenä½¿ç”¨`;

    case 'full':
      return `
ã€ä¸Šä¸‹æ–‡ç­–ç•¥ï¼šå®Œå…¨åŒ…å«ã€‘
- ä½¿ç”¨æ‰€æœ‰å¯ç”¨çš„ä¸Šä¸‹æ–‡
- ä¸è¿›è¡ŒTokené™åˆ¶
- åŒ…å«æ‰€æœ‰ç›¸å…³ä¿¡æ¯`;

    case 'smart':
    default:
      return `
ã€ä¸Šä¸‹æ–‡ç­–ç•¥ï¼šæ™ºèƒ½ç­›é€‰ã€‘
- ä¼˜å…ˆä½¿ç”¨æ˜ç¡®å¼•ç”¨çš„æ–‡ä»¶ (@, #è¯­æ³•)
- å…¶æ¬¡ä½¿ç”¨é«˜åº¦ç›¸å…³çš„æ–‡ä»¶
- æ ¹æ®Tokené¢„ç®—åŠ¨æ€è°ƒæ•´`;
  }
}

PreferencesManager.loadPreferences();

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/prompt.ts

````typescript
import {
    AgentIntent,
    AgentContext,
    AgentMode,
    AgentPrompt,
} from './types';
import { buildCommandPrompt as buildCommandPromptString } from '../ai/prompt';
import { getOSProfile } from '../core/os';
import { getMacros } from '../core/macros';
import { aiCommandPlanSchema } from '../core/validation';
import { getRelevantSkills } from './skills';
import {
    buildDynamicContext,
    injectDynamicContext,
    DynamicContext
} from './dynamicPrompt';
import {
    buildV2_2ProtocolPrompt,
    buildOutputConstraints,
    ProtocolV2_2Config
} from './protocolV2_2';

export function buildPrompt(
    intent: AgentIntent,
    context: AgentContext,
    mode: AgentMode,
    input: string
): AgentPrompt {
    if (mode === 'chat') {
        return buildChatPrompt(context, input);
    }

    return buildCommandPromptObject(input, context);
}

function buildChatPrompt(
    context: AgentContext,
    input: string
): AgentPrompt {
    const messages: any[] = [
        ...(context.history ?? []),
    ];

    // Add context files if available
    let contextDesc = '';
    if (context.files && context.files.length > 0) {
        contextDesc = context.files.map(f =>
            `File: ${f.path}\n\`\`\`\n${f.content}\n\`\`\``
        ).join('\n\n');
    }

    messages.push({
        role: 'user',
        content: input,
    });

    const v2Config: ProtocolV2_2Config = {
        mode: 'chat',
        enableStrictOutput: false,
        enableReasoningTrace: true
    };

    const baseSystemPrompt = buildV2_2ProtocolPrompt(v2Config);
    const outputConstraints = buildOutputConstraints();

    const dynamicContext: DynamicContext = {};
    const systemPrompt = injectDynamicContext(
        `${baseSystemPrompt}\n${outputConstraints}`,
        dynamicContext
    );

    return {
        system: systemPrompt,
        messages,
    };
}

function buildCommandPromptObject(
    input: string,
    context: AgentContext
): AgentPrompt {
    const os = getOSProfile();
    const macros = getMacros();
    const skills = getRelevantSkills(input);
    let promptText = buildCommandPromptString(input, os, macros);

    if (skills.length > 0) {
        const skillList = skills.map(s => `- ${s.name}: å½“é‡åˆ° "${s.whenToUse}" æ—¶ï¼Œä½ å¯ä»¥å‚è€ƒè®¡åˆ’: ${s.planTemplate.goal}`).join('\n');
        promptText = `ã€å‚è€ƒæŠ€èƒ½åº“ã€‘\n${skillList}\n\n${promptText}`;
    }

    const v2Config: ProtocolV2_2Config = {
        mode: 'command',
        enableStrictOutput: true,
        enableReasoningTrace: true
    };

    const systemPrompt = buildV2_2ProtocolPrompt(v2Config);

    return {
        system: systemPrompt,
        messages: [
            {
                role: 'user',
                content: promptText,
            },
        ],
        outputSchema: aiCommandPlanSchema,
    };
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/relevance.ts

````typescript
export interface ContextItem {
  path: string;
  content?: string;
  summary?: string;
}

export interface RankedContextItem extends ContextItem {
  relevance: number;
  matchReasons: string[];
}

export interface RelevanceConfig {
  keywordsWeight: number;
  pathWeight: number;
  extensionWeight: number;
  recencyWeight: number;
}

const DEFAULT_CONFIG: RelevanceConfig = {
  keywordsWeight: 0.4,
  pathWeight: 0.3,
  extensionWeight: 0.2,
  recencyWeight: 0.1
};

function extractKeywords(query: string): string[] {
  const cleaned = query
    .toLowerCase()
    .replace(/[^\w\s\u4e00-\u9fa5]/g, '')
    .trim();

  const words = cleaned.split(/\s+/).filter(w => w.length > 1);

  const keywords = new Set<string>();

  for (const word of words) {
    if (word.length > 2) {
      keywords.add(word);
    }

    if (word.length > 4) {
      for (let i = 3; i < word.length; i++) {
        keywords.add(word.substring(0, i));
      }
    }
  }

  return Array.from(keywords);
}

function calculateKeywordMatchScore(
  content: string,
  summary: string,
  keywords: string[]
): number {
  const textToMatch = (summary || content).toLowerCase();
  let matches = 0;
  let totalMatches = 0;

  for (const keyword of keywords) {
    const regex = new RegExp(keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
    const keywordMatches = textToMatch.match(regex);

    if (keywordMatches) {
      matches += keywordMatches.length;
    }

    totalMatches++;
  }

  return totalMatches > 0 ? matches / (totalMatches * Math.max(keywords.length, 1)) : 0;
}

function calculatePathScore(path: string, keywords: string[]): number {
  const pathLower = path.toLowerCase();
  let score = 0;

  for (const keyword of keywords) {
    if (pathLower.includes(keyword)) {
      score += 1;

      const parts = path.split(/[/\\]/);
      const fileName = parts[parts.length - 1].toLowerCase();

      if (fileName.includes(keyword)) {
        score += 1;
      }
    }
  }

  const maxScore = Math.max(keywords.length, 1);
  return Math.min(score / maxScore, 1);
}

function calculateExtensionScore(path: string, query: string): number {
  const pathLower = path.toLowerCase();
  const queryLower = query.toLowerCase();

  const ext = pathLower.split('.').pop() || '';
  const queryExts = ['.ts', '.js', '.py', '.go', '.rs', '.java', '.json', '.md'];

  if (!ext) return 0;

  if (queryLower.includes(ext)) {
    return 1;
  }

  if (queryExts.some(e => queryLower.includes(e)) && queryExts.includes(`.${ext}`)) {
    return 0.8;
  }

  return 0;
}

function calculateRecencyScore(item: ContextItem): number {
  return 0.5;
}

export function rankByRelevance(
  items: ContextItem[],
  query: string,
  config?: Partial<RelevanceConfig>
): RankedContextItem[] {
  const finalConfig = { ...DEFAULT_CONFIG, ...config };
  const keywords = extractKeywords(query);

  return items
    .map(item => {
      const keywordScore = calculateKeywordMatchScore(
        item.content || '',
        item.summary || '',
        keywords
      );

      const pathScore = calculatePathScore(item.path, keywords);
      const extensionScore = calculateExtensionScore(item.path, query);
      const recencyScore = calculateRecencyScore(item);

      const relevance =
        (keywordScore * finalConfig.keywordsWeight) +
        (pathScore * finalConfig.pathWeight) +
        (extensionScore * finalConfig.extensionWeight) +
        (recencyScore * finalConfig.recencyWeight);

      const matchReasons: string[] = [];

      if (keywordScore > 0.5) matchReasons.push('Keywords match');
      if (pathScore > 0.5) matchReasons.push('Path match');
      if (extensionScore > 0.5) matchReasons.push('Relevant extension');

      return {
        ...item,
        relevance: Math.min(relevance, 1),
        matchReasons
      };
    })
    .filter(item => item.relevance > 0.1)
    .sort((a, b) => b.relevance - a.relevance);
}

export function calculateTotalTokens(items: ContextItem[]): number {
  let total = 0;

  for (const item of items) {
    const text = item.content || item.summary || '';
    total += text.length;
  }

  return Math.ceil(total / 4);
}

export function filterContextByRelevance(
  items: ContextItem[],
  query: string,
  minRelevance: number = 0.3,
  config?: Partial<RelevanceConfig>
): RankedContextItem[] {
  const ranked = rankByRelevance(items, query, config);
  return ranked.filter(item => item.relevance >= minRelevance);
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/replay/events.ts

````typescript
export type EventType = 
  | 'state_transition'
  | 'llm_call'
  | 'tool_execution'
  | 'governance_decision'
  | 'observation_recorded'
  | 'evaluation_result'
  | 'error_occurred';

export interface RuntimeEvent {
  id: string;
  timestamp: number;
  executionId: string;
  type: EventType;
  data: {
    from?: string;
    to?: string;
    action?: any;
    decision?: any;
    result?: any;
    error?: string;
  };
  metadata?: Record<string, any>;
}

export interface EventRecorder {
  record(event: RuntimeEvent): void;
  flush(): Promise<void>;
  getEvents(executionId?: string): RuntimeEvent[];
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/replay/index.ts

````typescript
export * from './events';
export * from './recorder';
export * from './replayer';

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/replay/recorder.ts

````typescript
import { RuntimeEvent, EventRecorder } from './events';
import fs from 'fs/promises';
import path from 'path';
import { randomUUID } from 'crypto';

export class FileEventRecorder implements EventRecorder {
  private events: RuntimeEvent[] = [];
  private logFile: string;
  private flushInterval: number = 1000;

  constructor(logDir: string = '.yuangs_events') {
    this.logFile = path.join(logDir, `events_${Date.now()}.jsonl`);
  }

  async record(event: RuntimeEvent): Promise<void> {
    this.events.push(event);

    if (this.events.length >= this.flushInterval) {
      await this.flush();
    }
  }

  async flush(): Promise<void> {
    if (this.events.length === 0) return;

    const logDir = path.dirname(this.logFile);
    await fs.mkdir(logDir, { recursive: true });

    const content = this.events
      .map(e => JSON.stringify(e))
      .join('\n') + '\n';

    await fs.appendFile(this.logFile, content, 'utf8');
    this.events = [];
  }

  getEvents(executionId?: string): RuntimeEvent[] {
    if (!executionId) {
      return [...this.events];
    }

    return this.events.filter(e => e.executionId === executionId);
  }
}

export const createEvent = (
  executionId: string,
  type: RuntimeEvent['type'],
  data: RuntimeEvent['data'],
  metadata?: RuntimeEvent['metadata']
): RuntimeEvent => ({
  id: randomUUID(),
  timestamp: Date.now(),
  executionId,
  type,
  data,
  metadata
});

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/replay/replayer.ts

````typescript
import { RuntimeEvent } from './events';

export interface ReplayerOptions {
  speed?: number;
  stopOnError?: boolean;
  dryRun?: boolean;
}

export class EventReplayer {
  private events: RuntimeEvent[] = [];
  private currentIndex: number = 0;
  private options: Required<ReplayerOptions>;

  constructor(events: RuntimeEvent[], options: ReplayerOptions = {}) {
    this.events = events;
    this.options = {
      speed: options.speed || 1,
      stopOnError: options.stopOnError !== undefined ? options.stopOnError : true,
      dryRun: options.dryRun || false
    };
  }

  hasNext(): boolean {
    return this.currentIndex < this.events.length;
  }

  next(): RuntimeEvent | null {
    if (!this.hasNext()) {
      return null;
    }

    return this.events[this.currentIndex++];
  }

  reset(): void {
    this.currentIndex = 0;
  }

  async replay(onEvent: (event: RuntimeEvent, options: Required<ReplayerOptions>) => Promise<void>): Promise<void> {
    this.reset();
    let hasError = false;

    while (this.hasNext() && !hasError) {
      const event = this.next();

      if (!event) break;

      try {
        await onEvent(event, this.options);

        if (event.type === 'error_occurred') {
          hasError = true;
          if (this.options.stopOnError) {
            break;
          }
        }

        if (this.options.speed > 1) {
          const delay = 100 / this.options.speed;
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      } catch (error: any) {
        console.error(`[Replay] Error at event ${event.id}:`, error.message);
        hasError = true;
      }
    }

    return;
  }

  getSummary(): {
    total: number;
    completed: number;
    errors: number;
  } {
    const errors = this.events.filter(e => e.type === 'error_occurred').length;
    
    return {
      total: this.events.length,
      completed: this.currentIndex,
      errors
    };
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/riskDisclosure.ts

````typescript
/**
 * é£é™©å‘ŠçŸ¥ç”Ÿæˆå™¨
 * ä¸ºé«˜é£é™©æ“ä½œç”Ÿæˆè¯¦ç»†çš„é£é™©å‘ŠçŸ¥ä¹¦ï¼Œå¢å¼ºHuman-in-the-loopå®‰å…¨æ€§
 */

export interface RiskLevel {
  level: 'low' | 'medium' | 'high';
  score: number; // 0-100
}

export interface RiskFactors {
  commandType: string; // shell_cmd, file_write, file_delete, etc.
  command?: string;
  filePath?: string;
  fileCount?: number;
  isDestructive: boolean;
  modifiesSystem: boolean;
  requiresNetwork: boolean;
  modifiesGit: boolean;
}

export interface RiskDisclosure {
  riskLevel: RiskLevel;
  factors: RiskFactors;
  description: string;
  potentialIssues: string[];
  recommendedActions: string[];
  requireConfirmation: boolean;
  checkpoint?: string;
}

/**
 * åˆ†ææ“ä½œé£é™©ç­‰çº§
 */
export function analyzeRiskLevel(factors: RiskFactors): RiskLevel {
  let score = 0;

  // å‘½ä»¤ç±»å‹é£é™©
  const commandTypeScores: Record<string, number> = {
    'shell_cmd': 50,
    'file_write': 40,
    'file_delete': 70,
    'file_read': 10,
    'git_operation': 40,
    'npm_install': 30,
    'docker_operation': 50,
    'system_config': 80,
  };
  score += commandTypeScores[factors.commandType] || 30;

  // ç ´åæ€§æ“ä½œ
  if (factors.isDestructive) {
    score += 30;
  }

  // ç³»ç»Ÿä¿®æ”¹
  if (factors.modifiesSystem) {
    score += 20;
  }

  // ç½‘ç»œæ“ä½œ
  if (factors.requiresNetwork) {
    score += 15;
  }

  // Gitæ“ä½œ
  if (factors.modifiesGit) {
    score += 10;
  }

  // ç‰¹å®šå‘½ä»¤é£é™©
  if (factors.command) {
    const highRiskPatterns = [
      /rm\s+-rf/,
      /rm\s+-r/,
      /del\s+\//,
      /format/,
      /mkfs/,
      /dd\s+if=/,
      /chmod\s+777/,
      /chmod\s+-R/,
      /chown\s+-R/,
      /wget.*\|/,
      /curl.*\|/,
      /:>.*\//,
      /eval/,
      /exec/,
    ];

    for (const pattern of highRiskPatterns) {
      if (pattern.test(factors.command)) {
        score += 30;
        break;
      }
    }
  }

  // æ–‡ä»¶æ•°é‡é£é™©
  if (factors.fileCount && factors.fileCount > 10) {
    score += 20;
  }

  // é™åˆ¶åˆ†æ•°èŒƒå›´
  score = Math.min(100, Math.max(0, score));

  // ç¡®å®šé£é™©ç­‰çº§
  let level: 'low' | 'medium' | 'high';
  if (score >= 70) {
    level = 'high';
  } else if (score >= 40) {
    level = 'medium';
  } else {
    level = 'low';
  }

  return { level, score };
}

/**
 * ç”Ÿæˆé£é™©æè¿°
 */
function generateRiskDescription(factors: RiskFactors, riskLevel: RiskLevel): string {
  let description = '';

  switch (factors.commandType) {
    case 'shell_cmd':
      description = `å³å°†æ‰§è¡Œå‘½ä»¤è¡Œæ“ä½œã€‚`;
      break;
    case 'file_write':
      description = `å³å°†å†™å…¥${factors.fileCount || 1}ä¸ªæ–‡ä»¶ã€‚`;
      break;
    case 'file_delete':
      description = `å³å°†åˆ é™¤${factors.fileCount || 1}ä¸ªæ–‡ä»¶ã€‚`;
      break;
    case 'git_operation':
      description = `å³å°†æ‰§è¡ŒGitç‰ˆæœ¬æ§åˆ¶æ“ä½œã€‚`;
      break;
    case 'npm_install':
      description = `å³å°†å®‰è£…npmä¾èµ–åŒ…ã€‚`;
      break;
    case 'docker_operation':
      description = `å³å°†æ‰§è¡ŒDockerå®¹å™¨æ“ä½œã€‚`;
      break;
    case 'system_config':
      description = `å³å°†ä¿®æ”¹ç³»ç»Ÿé…ç½®ã€‚`;
      break;
    default:
      description = `å³å°†æ‰§è¡Œæ½œåœ¨é£é™©æ“ä½œã€‚`;
  }

  // å§‹ç»ˆæ·»åŠ é£é™©ç­‰çº§æè¿°
  if (riskLevel.level === 'high') {
    description += ` æ­¤æ“ä½œé£é™©ç­‰çº§ä¸ºã€é«˜ã€‘ï¼Œå¯èƒ½å¯¼è‡´æ•°æ®ä¸¢å¤±æˆ–ç³»ç»Ÿä¸å¯ç”¨ã€‚`;
  } else if (riskLevel.level === 'medium') {
    description += ` æ­¤æ“ä½œé£é™©ç­‰çº§ä¸ºã€ä¸­ã€‘ï¼Œè¯·ä»”ç»†æ£€æŸ¥æ“ä½œå†…å®¹ã€‚`;
  } else {
    description += ` æ­¤æ“ä½œé£é™©ç­‰çº§ä¸ºã€ä½ã€‘ï¼Œé£é™©ç›¸å¯¹å¯æ§ã€‚`;
  }

  return description;
}

/**
 * ç”Ÿæˆæ½œåœ¨é—®é¢˜åˆ—è¡¨
 */
function generatePotentialIssues(factors: RiskFactors, riskLevel: RiskLevel): string[] {
  const issues: string[] = [];

  if (factors.isDestructive) {
    issues.push('æ•°æ®å¯èƒ½æ— æ³•æ¢å¤');
    issues.push('é‡è¦æ–‡ä»¶å¯èƒ½è¢«æ°¸ä¹…åˆ é™¤');
  }

  if (factors.modifiesSystem) {
    issues.push('ç³»ç»Ÿé…ç½®å¯èƒ½è¢«ä¿®æ”¹');
    issues.push('å¯èƒ½å½±å“å…¶ä»–åº”ç”¨ç¨‹åº');
  }

  if (factors.requiresNetwork) {
    issues.push('éœ€è¦ç½‘ç»œè¿æ¥');
    issues.push('å¯èƒ½ä¸‹è½½ä¸å®‰å…¨çš„è½¯ä»¶');
    issues.push('å¯èƒ½æ³„éœ²æ•æ„Ÿä¿¡æ¯');
  }

  if (factors.modifiesGit) {
    issues.push('Gitå†å²å¯èƒ½è¢«ä¿®æ”¹');
    issues.push('å¯èƒ½å¯¼è‡´åä½œå†²çª');
  }

  if (factors.command) {
    if (factors.command.includes('rm') || factors.command.includes('del')) {
      issues.push('æ–‡ä»¶åˆ é™¤æ“ä½œä¸å¯é€†');
    }
    if (factors.command.includes('sudo')) {
      issues.push('éœ€è¦ç®¡ç†å‘˜æƒé™');
      issues.push('å¯èƒ½å½±å“ç³»ç»Ÿç¨³å®šæ€§');
    }
    if (factors.command.includes('chmod')) {
      issues.push('æ–‡ä»¶æƒé™å¯èƒ½è¢«ä¿®æ”¹');
    }
  }

  // é«˜é£é™©ç‰¹æ®Šé—®é¢˜
  if (riskLevel.level === 'high') {
    issues.push('å¯èƒ½å¯¼è‡´ç³»ç»Ÿå´©æºƒ');
    issues.push('å¯èƒ½éœ€è¦é‡æ–°å®‰è£…ç³»ç»Ÿ');
  }

  return issues.length > 0 ? issues : ['å¯èƒ½å¯¼è‡´ä¸å¯é¢„æœŸçš„å‰¯ä½œç”¨'];
}

/**
 * ç”Ÿæˆæ¨èè¡ŒåŠ¨
 */
function generateRecommendedActions(factors: RiskFactors, riskLevel: RiskLevel): string[] {
  const actions: string[] = [];

  if (factors.isDestructive) {
    actions.push('å¤‡ä»½é‡è¦æ•°æ®');
    actions.push('ç¡®è®¤åˆ é™¤åˆ—è¡¨');
    actions.push('ä½¿ç”¨--dry-runå‚æ•°æµ‹è¯•');
  }

  if (factors.modifiesSystem) {
    actions.push('è®°å½•å½“å‰é…ç½®');
    actions.push('åœ¨æµ‹è¯•ç¯å¢ƒå…ˆå°è¯•');
    actions.push('å‡†å¤‡å›æ»šæ–¹æ¡ˆ');
  }

  if (factors.requiresNetwork) {
    actions.push('éªŒè¯è½¯ä»¶æ¥æº');
    actions.push('æ£€æŸ¥æ•°å­—ç­¾å');
    actions.push('ä½¿ç”¨ç½‘ç»œéš”ç¦»ç¯å¢ƒ');
  }

  if (factors.modifiesGit) {
    actions.push('åˆ›å»ºå¤‡ä»½åˆ†æ”¯');
    actions.push('ä¸å›¢é˜Ÿæˆå‘˜æ²Ÿé€š');
    actions.push('æ£€æŸ¥æœªæäº¤çš„æ›´æ”¹');
  }

  if (factors.command) {
    if (factors.command.includes('rm') || factors.command.includes('del')) {
      actions.push('ä½¿ç”¨é€šé…ç¬¦å‰å…ˆéªŒè¯');
      actions.push('ç¡®è®¤å½“å‰å·¥ä½œç›®å½•');
    }
    if (factors.command.includes('sudo')) {
      actions.push('ç¡®è®¤å‘½ä»¤æ¥æº');
      actions.push('æ£€æŸ¥ä¾èµ–è½¯ä»¶');
    }
  }

  // é€šç”¨å»ºè®®
  actions.push('ä»”ç»†å®¡æŸ¥å‘½ä»¤å‚æ•°');
  actions.push('ç¡®è®¤æ–‡ä»¶è·¯å¾„æ­£ç¡®');
  actions.push('è€ƒè™‘åˆ›å»ºç³»ç»Ÿå¿«ç…§');

  if (riskLevel.level === 'high') {
    actions.unshift('âš ï¸ å¼ºçƒˆå»ºè®®å…ˆåœ¨æµ‹è¯•ç¯å¢ƒéªŒè¯');
  }

  return actions;
}

/**
 * ç”Ÿæˆæ£€æŸ¥ç‚¹
 */
function generateCheckpoint(factors: RiskFactors, riskLevel: RiskLevel): string {
  const timestamp = new Date().toISOString();
  const actions: string[] = [];

  if (factors.isDestructive) {
    actions.push('å·²ç¡®è®¤é‡è¦æ•°æ®å·²å¤‡ä»½');
  }

  if (factors.modifiesSystem) {
    actions.push('å·²è®°å½•å½“å‰ç³»ç»Ÿé…ç½®');
  }

  if (factors.modifiesGit) {
    actions.push('å·²åˆ›å»ºå¤‡ä»½åˆ†æ”¯');
  }

  return `Checkpoint [${timestamp}]
- ${actions.join('\n- ') || 'å·²ç¡®è®¤æ“ä½œé£é™©'}`;
}

/**
 * ç”Ÿæˆé£é™©å‘ŠçŸ¥ä¹¦
 */
export function generateRiskDisclosure(factors: RiskFactors): RiskDisclosure {
  const riskLevel = analyzeRiskLevel(factors);
  const description = generateRiskDescription(factors, riskLevel);
  const potentialIssues = generatePotentialIssues(factors, riskLevel);
  const recommendedActions = generateRecommendedActions(factors, riskLevel);
  const requireConfirmation = riskLevel.level === 'high';
  const checkpoint = riskLevel.level === 'high' ? generateCheckpoint(factors, riskLevel) : undefined;

  return {
    riskLevel,
    factors,
    description,
    potentialIssues,
    recommendedActions,
    requireConfirmation,
    checkpoint,
  };
}

/**
 * æ ¼å¼åŒ–é£é™©å‘ŠçŸ¥ä¹¦ä¸ºCLIå‹å¥½çš„æ ¼å¼
 */
export function formatRiskDisclosureCLI(disclosure: RiskDisclosure): string {
  const { riskLevel, description, potentialIssues, recommendedActions, checkpoint } = disclosure;

  // é£é™©ç­‰çº§å›¾æ ‡
  const riskIcons = {
    low: 'ğŸŸ¢',
    medium: 'ğŸŸ¡',
    high: 'ğŸ”´',
  };

  const riskLabels = {
    low: 'ä½é£é™©',
    medium: 'ä¸­é£é™©',
    high: 'é«˜é£é™©',
  };

  let output = '';

  output += `\n${'='.repeat(60)}\n`;
  output += `${riskIcons[riskLevel.level]} é£é™©å‘ŠçŸ¥ä¹¦ [é£é™©ç­‰çº§: ${riskLabels[riskLevel.level]} (${riskLevel.score}/100)]\n`;
  output += `${'='.repeat(60)}\n\n`;

  output += `ğŸ“‹ æ“ä½œæè¿°\n${description}\n\n`;

  if (potentialIssues.length > 0) {
    output += `âš ï¸  æ½œåœ¨é—®é¢˜\n`;
    potentialIssues.forEach(issue => {
      output += `   â€¢ ${issue}\n`;
    });
    output += `\n`;
  }

  if (recommendedActions.length > 0) {
    output += `ğŸ’¡ æ¨èè¡ŒåŠ¨\n`;
    recommendedActions.forEach(action => {
      output += `   ${action}\n`;
    });
    output += `\n`;
  }

  if (checkpoint) {
    output += `ğŸ“ æ“ä½œå‰æ£€æŸ¥ç‚¹\n${checkpoint}\n\n`;
  }

  if (riskLevel.level === 'high') {
    output += `ğŸ” éœ€è¦ç¡®è®¤\n`;
    output += `   æ­¤æ“ä½œé£é™©è¾ƒé«˜ï¼Œè¯·ç¡®è®¤ï¼š\n`;
    output += `   [y] ç»§ç»­æ‰§è¡Œ\n`;
    output += `   [n] å–æ¶ˆæ“ä½œ\n`;
    output += `   [v] æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯\n\n`;
  }

  output += `${'='.repeat(60)}\n`;

  return output;
}

/**
 * ä»è§£æçš„thoughtç”Ÿæˆé£é™©å› ç´ 
 */
export function extractRiskFactorsFromThought(thought: string): RiskFactors {
  // è¿™é‡Œå¯ä»¥è§£æthoughtä¸­çš„action_typeã€commandç­‰ä¿¡æ¯
  // æš‚æ—¶è¿”å›é»˜è®¤å€¼ï¼Œå®é™…ä½¿ç”¨æ—¶éœ€è¦æ ¹æ®å…·ä½“çš„thoughtæ ¼å¼è°ƒæ•´
  return {
    commandType: 'shell_cmd',
    isDestructive: false,
    modifiesSystem: false,
    requiresNetwork: false,
    modifiesGit: false,
  };
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/selectModel.ts

````typescript
import { AgentIntent } from './types';
import { getUserConfig } from '../ai/client';

export function selectModel(
    intent: AgentIntent,
    override?: string
): string {
    if (override) return override;

    const config = getUserConfig();
    const defaultModel = config.defaultModel || 'Assistant';

    return defaultModel;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/skills.ts

````typescript
import fs from 'fs';
import path from 'path';
import os from 'os';
import chalk from 'chalk';

export interface Skill {
    id: string;
    name: string;
    description: string;
    whenToUse: string; // è§¦å‘åœºæ™¯æè¿°
    planTemplate: any;

    // è¯„ä»·æŒ‡æ ‡
    successCount: number;
    failureCount: number;
    confidence: number; // 0 ~ 1, åˆå§‹ 0.5

    // æ—¶é—´æˆ³
    lastUsed: number;
    createdAt: number;

    // æ˜¯å¦å¯ç”¨
    enabled: boolean;
}

const SKILLS_FILE = path.join(os.homedir(), '.yuangs_skills.json');
let skillLibrary: Skill[] = [];

// === Persistence Logic ===

function loadSkills() {
    if (fs.existsSync(SKILLS_FILE)) {
        try {
            const data = fs.readFileSync(SKILLS_FILE, 'utf-8');
            skillLibrary = JSON.parse(data);
        } catch (e) {
            console.error(chalk.yellow(`Failed to load skills from ${SKILLS_FILE}, starting empty.`));
            skillLibrary = [];
        }
    }
}

function saveSkills() {
    try {
        fs.writeFileSync(SKILLS_FILE, JSON.stringify(skillLibrary, null, 2));
    } catch (e) {
        console.error(chalk.red(`Failed to save skills to ${SKILLS_FILE}`));
    }
}

// Initialize on load
loadSkills();

// === Existing Logic with Save Hooks ===

/**
 * è®¡ç®—æŠ€èƒ½åˆ† (0 ~ 1)
 */
export function computeSkillScore(skill: Skill, now: number = Date.now()): number {
    const totalUses = skill.successCount + skill.failureCount;
    const successRate = totalUses === 0 ? 0.5 : skill.successCount / totalUses;

    // æ—¶é—´è¡°å‡ (Freshness): åŠè¡°æœŸçº¦ 14 å¤©
    const idleDays = (now - skill.lastUsed) / (1000 * 60 * 60 * 24);
    const freshness = Math.exp(-idleDays / 14);

    // ç»¼åˆå¾—åˆ†: 45% æˆåŠŸç‡ + 35% æ–°é²œåº¦ + 20% ç½®ä¿¡åº¦
    return (0.45 * successRate) + (0.35 * freshness) + (0.20 * skill.confidence);
}

/**
 * æ›´æ–°æŠ€èƒ½çŠ¶æ€ (æ‰§è¡Œåè°ƒç”¨)
 */
export function updateSkillStatus(skillId: string, success: boolean) {
    const skill = skillLibrary.find(s => s.id === skillId);
    if (!skill) return;

    skill.lastUsed = Date.now();
    if (success) {
        skill.successCount++;
        // æˆåŠŸå¥–åŠ±: ç½®ä¿¡åº¦ç¼“æ…¢æå‡
        skill.confidence = Math.min(1, skill.confidence + 0.05);
    } else {
        skill.failureCount++;
        // å¤±è´¥æƒ©ç½š: æƒ©ç½šåŠ›åº¦å¤§äºå¥–åŠ±ï¼Œé˜²æ­¢ç³»ç»Ÿâ€œè‡ªå—¨â€
        skill.confidence = Math.max(0, skill.confidence - 0.1);
    }

    saveSkills(); // Persist changes
}

/**
 * è‡ªåŠ¨å­¦ä¹ æ–°æŠ€èƒ½
 */
export function learnSkillFromRecord(record: any, success: boolean = true) {
    // Handle both old and new record structures
    const mode = record.mode || record.meta?.mode || 'chat';
    const plan = record.llmResult?.plan || record.decision?.llmResult?.plan;
    const input = record.input?.rawInput || record.meta?.rawInput;

    // Only learn from agent/chat mode with plans
    if (mode !== 'chat' && mode !== 'agent') return;
    if (!plan) return;

    const skillName = plan.goal || plan.command || 'unnamed';
    const existingSkill = skillLibrary.find(s => s.name === skillName);

    if (existingSkill) {
        updateSkillStatus(existingSkill.id, success);
        return;
    }

    // åªæœ‰æˆåŠŸçš„è®°å½•æ‰è¢«å­¦ä¸ºæ–°æŠ€èƒ½
    if (!success) return;

    const now = Date.now();
    skillLibrary.push({
        id: record.id,
        name: skillName,
        description: `Auto-learned skill: ${skillName}`,
        whenToUse: input || 'Agent execution',
        planTemplate: plan,
        successCount: 1,
        failureCount: 0,
        confidence: 0.5,
        lastUsed: now,
        createdAt: now,
        enabled: true
    });

    // æ¯å­¦ä¹ ä¸€æ¬¡ï¼Œå°è¯•æ¸…ç†ä¸€æ¬¡â€œå†·â€æŠ€èƒ½
    reapColdSkills();

    saveSkills(); // Persist changes
}

/**
 * ç­›é€‰å¹¶æ’åºæŠ€èƒ½ (ç”¨äºæ³¨å…¥ Prompt)
 */
export function getRelevantSkills(input: string, limit: number = 3): Skill[] {
    const now = Date.now();

    return skillLibrary
        // 1. åŸºç¡€ç­›é€‰: å‰”é™¤è¯„åˆ†è¿‡ä½çš„æŠ€èƒ½ (ç¡¬æ·˜æ±°é˜ˆå€¼ 0.3)
        .filter(s => computeSkillScore(s, now) >= 0.3)
        // 2. è¿‡æ»¤å·²ç¦ç”¨çš„æŠ€èƒ½
        .filter(s => s.enabled !== false)
        // 3. æ’åº: æŒ‰ç»¼åˆåˆ†æ’åº
        .sort((a, b) => computeSkillScore(b, now) - computeSkillScore(a, now))
        // 4. å–ä¸Šé™
        .slice(0, limit);
}

/**
 * æ¸…ç†è¿‡æœŸæˆ–ä½è´¨æŠ€èƒ½ (Reaper)
 */
export function reapColdSkills() {
    const now = Date.now();
    const initialCount = skillLibrary.length;

    skillLibrary = skillLibrary.filter(skill => {
        const score = computeSkillScore(skill, now);
        const idleDays = (now - skill.lastUsed) / (1000 * 60 * 60 * 24);

        // æ»¡è¶³ä»¥ä¸‹ä»»ä¸€æ¡ä»¶åˆ™æ·˜æ±°:
        // 1. å¾—åˆ†æä½ä¸”é•¿æœŸä¸ç”¨
        if (score < 0.25 && idleDays > 30) return false;
        // 2. å¤±è´¥ç‡æé«˜ä¸”å°è¯•è¿‡ä¸€å®šæ¬¡æ•°
        if (skill.failureCount > 5 && (skill.successCount / (skill.successCount + skill.failureCount)) < 0.2) return false;

        return true;
    });

    // å¼ºåˆ¶ä¿æŒå®¹é‡
    if (skillLibrary.length > 100) {
        // å¦‚æœè¿˜è¶…æ ‡ï¼Œç§»é™¤å¾—åˆ†æœ€ä½çš„é‚£ä¸ª
        skillLibrary.sort((a, b) => computeSkillScore(a, now) - computeSkillScore(b, now));
        skillLibrary.shift();
    }

    if (skillLibrary.length !== initialCount) {
        saveSkills(); // Persist if changes happened
    }
}

export function getAllSkills(): Skill[] {
    return [...skillLibrary];
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/smartContextManager.ts

````typescript
import { ContextManager } from './contextManager';
import { rankByRelevance, filterContextByRelevance, calculateTotalTokens, RankedContextItem } from './relevance';

export interface EnhancedContextOptions {
  query: string;
  minRelevance?: number;
  maxTokens?: number;
  enableSmartSummary?: boolean;
}

export class SmartContextManager extends ContextManager {
  private cachedRankedItems: RankedContextItem[] = [];
  private cachedQuery: string = '';

  async getEnhancedContext(options: EnhancedContextOptions): Promise<{
    rankedItems: RankedContextItem[];
    summary: string;
    filteredCount: number;
    totalCount: number;
  }> {
    const { query, minRelevance = 0.3, maxTokens = 10000, enableSmartSummary = true } = options;

    const messages = this.getMessages();

    const contextItems = messages
      .filter(m => m.role === 'user')
      .map(m => ({
        path: this.extractPathFromMessage(m.content) || '',
        content: m.content
      }))
      .filter(item => item.path && item.path.length > 0);

    const rankedItems = await rankByRelevance(contextItems, query);
    this.cachedRankedItems = rankedItems;
    this.cachedQuery = query;

    const filteredItems = filterContextByRelevance(
      contextItems,
      query,
      minRelevance
    );

    let finalItems = filteredItems;

    if (maxTokens > 0) {
      const totalTokens = calculateTotalTokens(finalItems);

      if (totalTokens > maxTokens) {
        const ratio = maxTokens / totalTokens;
        finalItems = finalItems.slice(0, Math.ceil(finalItems.length * ratio));
      }
    }

    const summary = enableSmartSummary ? this.buildSmartSummary(query, finalItems, contextItems) : '';

    return {
      rankedItems,
      summary,
      filteredCount: finalItems.length,
      totalCount: contextItems.length
    };
  }

  private extractPathFromMessage(content: string): string | undefined {
    const pathMatch = content.match(/@([^\s]+)/);
    return pathMatch ? pathMatch[1] : undefined;
  }

  private buildSmartSummary(
    query: string,
    items: RankedContextItem[],
    allItems: any[]
  ): string {
    if (items.length === 0) {
      return '';
    }

    const highRelevance = items.filter(i => i.relevance > 0.8);
    const mediumRelevance = items.filter(i => i.relevance > 0.5 && i.relevance <= 0.8);

    let summary = 'ã€ä¸Šä¸‹æ–‡æ¦‚è§ˆã€‘\n';
    summary += `- æ€»æ–‡ä»¶: ${allItems.length}\n`;
    summary += `- å·²ç­›é€‰: ${items.length}\n`;
    summary += `- é«˜åº¦ç›¸å…³ (>0.8): ${highRelevance.length}\n`;
    summary += `- ä¸­åº¦ç›¸å…³ (0.5-0.8): ${mediumRelevance.length}\n\n`;

    if (highRelevance.length > 0) {
      summary += 'ã€é«˜åº¦ç›¸å…³æ–‡ä»¶ã€‘\n';
      highRelevance.slice(0, 5).forEach(item => {
        summary += `  - ${item.path} (ç›¸å…³åº¦: ${(item.relevance * 100).toFixed(0)}%)\n`;
      });

      if (highRelevance.length > 5) {
        summary += `  ... è¿˜æœ‰ ${highRelevance.length - 5} ä¸ª\n`;
      }
    }

    if (mediumRelevance.length > 0 && mediumRelevance.length <= 3) {
      summary += '\nã€ä¸­åº¦ç›¸å…³æ–‡ä»¶ã€‘\n';
      mediumRelevance.forEach(item => {
        summary += `  - ${item.path} (ç›¸å…³åº¦: ${(item.relevance * 100).toFixed(0)}%)\n`;
      });
    }

    return summary;
  }

  getCachedRankedItems(): RankedContextItem[] {
    return this.cachedRankedItems;
  }

  getCachedQuery(): string {
    return this.cachedQuery;
  }

  clearCache(): void {
    this.cachedRankedItems = [];
    this.cachedQuery = '';
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/state.ts

````typescript
import { randomUUID } from 'crypto';

export type AgentState = 
  | 'IDLE' 
  | 'THINKING' 
  | 'PROPOSING' 
  | 'GOVERNING' 
  | 'EXECUTING' 
  | 'OBSERVING' 
  | 'EVALUATING' 
  | 'TERMINAL';

export type RiskLevel = 'low' | 'medium' | 'high';

export interface ProposedAction {
  id: string;
  type: 'tool_call' | 'code_diff' | 'shell_cmd' | 'answer';
  payload: any;
  riskLevel: RiskLevel;
  reasoning: string;
}

export type GovernanceDecision = 
  | { status: 'approved'; by: 'policy' | 'human'; timestamp: number }
  | { status: 'rejected'; by: 'policy' | 'human'; reason: string; timestamp: number }
  | { 
      status: 'modified'; 
      by: 'human'; 
      originalActionId: string;
      modifiedAction: ProposedAction;
      modificationReason: string;
      timestamp: number;
    };

export type EvaluationOutcome = 
  | { kind: 'continue'; reason: 'incomplete' | 'failure_retry' }
  | { kind: 'terminate'; reason: 'goal_satisfied' | 'user_abort' | 'max_turns_exceeded' }
  | { kind: 'pause'; reason: 'await_human_input' };

export interface AgentThought {
  raw: string;
  parsedPlan: any;
  isDone: boolean;
  type?: 'tool_call' | 'code_diff' | 'shell_cmd' | 'answer';
  payload?: any;
  reasoning?: string;
}

export interface ExecutionTurn {
  turnId: number;
  startTime: number;
  endTime?: number;
  contextSnapshot: {
    inputHash: string;
    systemPromptVersion: string;
    toolSetVersion: string;
    recentMessages: Array<{ role: string; content: string; timestamp: number }>;
  };
  thought?: AgentThought;
  proposedAction?: ProposedAction;
  governance?: GovernanceDecision;
  executionResult?: {
    success: boolean;
    output: string;
    error?: string;
    artifacts?: string[];
  };
  observation?: {
    summary: string;
    artifacts: string[];
    truncated?: boolean;
  };
  evaluation?: EvaluationOutcome;
}

export interface GovernanceLoopConfig {
  maxTurns: number;
  autoApproveLowRisk: boolean;
  verbose: boolean;
}

export interface ToolExecutionResult {
  success: boolean;
  output: string;
  error?: string;
  artifacts?: string[];
}

export interface GovernanceContext {
  input: string;
  mode: 'chat' | 'command' | 'command+exec';
  history: AIRequestMessage[];
  files?: Array<{ path: string; content: string }>;
}

interface AIRequestMessage {
  role: 'user' | 'assistant' | 'system' | 'tool';
  content: string;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ agent/types.ts

````typescript
import type { AIRequestMessage } from '../core/validation';

export type AgentMode = 'chat' | 'command' | 'command+exec';

export type ObservationKind =
  | 'tool_result'
  | 'system_note'
  | 'manual_input'
  | 'error'
  | 'none';

export interface AgentInput {
    rawInput: string;
    stdin?: string;
    context?: AgentContext;
    options?: {
        model?: string;
        stream?: boolean;
        autoYes?: boolean;
        verbose?: boolean;
    };
}

export interface AgentContext {
    files?: Array<{ path: string; content: string }>;
    gitDiff?: string;
    history?: AIRequestMessage[];
}

export interface AgentIntent {
    type: 'chat' | 'shell' | 'analysis';
    capabilities: {
        reasoning?: boolean;
        code?: boolean;
        longContext?: boolean;
        streaming?: boolean;
    };
}

export interface AgentPrompt {
    system?: string;
    messages: AIRequestMessage[];
    outputSchema?: any;
}

export interface LLMResult {
    rawText: string;
    parsed?: any;
    plan?: any;
    latencyMs: number;
    tokens?: {
        prompt: number;
        completion: number;
        total: number;
    };
    costUsd?: number;
}

export type AgentAction =
    | { type: 'print'; content: string }
    | { type: 'confirm'; next: AgentAction }
    | { type: 'execute'; command: string; risk: 'low' | 'medium' | 'high' };

export interface TaskStep {
  id: string;
  description: string;
  type: 'shell_cmd' | 'tool_call' | 'code_diff' | 'answer';
  command?: string;
  tool_name?: string;
  parameters?: Record<string, any>;
  risk_level: 'low' | 'medium' | 'high';
  dependencies: string[];
}

export interface TaskPlan {
  plan: string;
  steps: TaskStep[];
  estimated_time: string;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ ai/client.ts

````typescript
import axios from 'axios';
import fs from 'fs';
import path from 'path';
import os from 'os';
import { DEFAULT_AI_PROXY_URL, DEFAULT_MODEL, DEFAULT_ACCOUNT_TYPE, type UserConfig, type AIRequestMessage } from '../core/validation';
import { appendMessageToDB, getRecentMessagesFromDB, clearMessagesInDB } from '../core/db';

const CONFIG_FILE = path.join(os.homedir(), '.yuangs.json');

let conversationHistory: AIRequestMessage[] = getRecentMessagesFromDB(20);

export function addToConversationHistory(role: 'system' | 'user' | 'assistant', content: string) {
    conversationHistory.push({ role, content });
    if (conversationHistory.length > 20) {
        conversationHistory = conversationHistory.slice(-20);
    }
    // Deep persist
    appendMessageToDB(role, content);
}

export function clearConversationHistory() {
    conversationHistory = [];
    clearMessagesInDB();
}

export function getConversationHistory() {
    return conversationHistory;
}

export function getUserConfig(): UserConfig {
    if (fs.existsSync(CONFIG_FILE)) {
        try {
            const content = fs.readFileSync(CONFIG_FILE, 'utf8');
            return JSON.parse(content) as UserConfig;
        } catch (e) { }
    }
    return {};
}

export async function askAI(prompt: string, model?: string): Promise<string> {
    const config = getUserConfig();
    const url = config.aiProxyUrl || DEFAULT_AI_PROXY_URL;

    const headers = {
        'Content-Type': 'application/json',
        'X-Client-ID': 'npm_yuangs',
        'Origin': 'https://cli.want.biz',
        'Referer': 'https://cli.want.biz/',
        'account': config.accountType || DEFAULT_ACCOUNT_TYPE,
        'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Mobile/15E148 Safari/604.1',
        'Accept': 'application/json'
    };

    const data = {
        model: model || config.defaultModel || DEFAULT_MODEL,
        messages: [{ role: 'user', content: prompt }],
        stream: false
    };

    try {
        const response = await axios.post(url, data, { headers });
        const content = response.data?.choices?.[0]?.message?.content;
        return content || '';
    } catch (error: any) {
        // Safely extract error message without accessing circular references
        let errorMsg = 'æœªçŸ¥é”™è¯¯';
        
        if (typeof error.message === 'string') {
            errorMsg = error.message;
        } else if (typeof error === 'string') {
            errorMsg = error;
        }
        
        // Try to get response data error message (safely)
        if (error.response && typeof error.response.data === 'object') {
            const responseData = error.response.data;
            if (typeof responseData.error?.message === 'string') {
                errorMsg = responseData.error.message;
            } else if (typeof responseData.message === 'string') {
                errorMsg = responseData.message;
            }
        }
        
        throw new Error(`AI è¯·æ±‚å¤±è´¥: ${errorMsg}`);
    }
}

export async function callAI_Stream(messages: AIRequestMessage[], model: string | undefined, onChunk: (content: string) => void): Promise<void> {
    const config = getUserConfig();
    const url = config.aiProxyUrl || DEFAULT_AI_PROXY_URL;

    const response = await axios({
        method: 'post',
        url: url,
        data: {
            model: model || config.defaultModel || DEFAULT_MODEL,
            messages: messages,
            stream: true
        },
        responseType: 'stream',
        headers: {
            'Content-Type': 'application/json',
            'X-Client-ID': 'npm_yuangs',
            'Origin': 'https://cli.want.biz',
            'Referer': 'https://cli.want.biz/',
            'account': config.accountType || DEFAULT_ACCOUNT_TYPE,
            'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Mobile/15E148 Safari/604.1',
            'Accept': 'application/json'
        }
    });

    return new Promise((resolve, reject) => {
        let buffer = '';
        
        response.data.on('data', (chunk: Buffer) => {
            buffer += chunk.toString();
            let lines = buffer.split('\n');
            buffer = lines.pop() || '';

            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine.startsWith('data: ')) {
                    const data = trimmedLine.slice(6);
                    if (data === '[DONE]') {
                        resolve();
                        return;
                    }
                    try {
                        const parsed = JSON.parse(data);
                        const content = parsed.choices?.[0]?.delta?.content || '';
                        if (content) {
                            onChunk(content);
                        }
                    } catch (e) { }
                }
            }
        });
        response.data.on('error', reject);
        response.data.on('end', () => {
            resolve();
        });
    });
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ ai/prompt.ts

````typescript
import { OSProfile } from '../core/os';
import type { Macro } from '../core/validation';

export function buildCommandPrompt(
    userInput: string,
    os: OSProfile,
    macros?: Record<string, Macro>,
    context?: string
): string {
    const macroContext = macros && Object.keys(macros).length > 0
        ? `
ã€å¯å¤ç”¨çš„å¿«æ·æŒ‡ä»¤ (Macros)ã€‘
ä»¥ä¸‹æ˜¯å¯ä»¥ç›´æ¥å¤ç”¨çš„å·²éªŒè¯å‘½ä»¤ã€‚ä¼˜å…ˆå¤ç”¨è¿™äº›æŒ‡ä»¤ï¼Œè€Œä¸æ˜¯ç”Ÿæˆæ–°å‘½ä»¤ï¼š

${Object.entries(macros).map(([name, macro]) => `  - ${name}: ${macro.description || '(æ— æè¿°)'}`).join('\n')}

å½“ç”¨æˆ·çš„éœ€æ±‚ä¸æŸä¸ª Macro åŒ¹é…æˆ–ç›¸ä¼¼æ—¶ï¼š
1. ä¼˜å…ˆä½¿ç”¨è¯¥ Macro
2. åœ¨ JSON è¾“å‡ºä¸­ä½¿ç”¨ "macro" å­—æ®µæŒ‡å®š Macro åç§°ï¼Œè€Œä¸æ˜¯ "command" å­—æ®µ
3. ä»…åœ¨æ²¡æœ‰åˆé€‚ Macro æ—¶æ‰ç”Ÿæˆæ–°å‘½ä»¤
`
        : '';

    return `
ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å‘½ä»¤è¡Œä¸“å®¶ã€‚

ã€ç³»ç»Ÿç¯å¢ƒã€‘
- æ“ä½œç³»ç»Ÿ: ${os.name}
- Shell: ${os.shell}
- find å®ç°: ${os.find}
- stat å®ç°: ${os.stat}

ã€è§„åˆ™ã€‘
- å‘½ä»¤å¿…é¡»ä¸å½“å‰ç³»ç»Ÿå…¼å®¹ã€‚
- å¦‚æœæ˜¯ macOS (BSD):
  - ä¸å…è®¸ä½¿ç”¨ find -printf
  - ä¼˜å…ˆä½¿ç”¨ stat -f
- å¦‚æœæ˜¯ Linux (GNU):
  - å¯ä½¿ç”¨ find -printf
- é»˜è®¤ä¸ä½¿ç”¨ sudoã€‚
- ç¡®ä¿è¾“å‡ºçš„å‘½ä»¤æ˜¯å•è¡Œæˆ–è€…ä½¿ç”¨ && è¿æ¥ã€‚
- ä¸è¦è§£é‡Šï¼Œåªè¾“å‡ºç¬¦åˆä»¥ä¸‹ JSON ç»“æ„çš„æ–‡æœ¬ã€‚
- ä¼˜å…ˆå¤ç”¨å·²éªŒè¯çš„å¿«æ·æŒ‡ä»¤ï¼ˆMacrosï¼‰ï¼Œæ¯ä¸ª Macro éƒ½æ˜¯ç»è¿‡äººå·¥éªŒè¯çš„å¯é å‘½ä»¤ã€‚åœ¨ç”Ÿæˆæ–°å‘½ä»¤å‰ï¼Œæ£€æŸ¥æ˜¯å¦å·²æœ‰ Macro å¯ä»¥å®Œæˆä»»åŠ¡ã€‚

${macroContext}

ã€è¾“å‡º JSON ç»“æ„ã€‘
{
  "plan": "ç®€è¦è¯´æ˜ä½ å‡†å¤‡æ‰§è¡Œçš„æ­¥éª¤",
  "command": "å¯ç›´æ¥æ‰§è¡Œçš„ shell å‘½ä»¤ï¼ˆä»…å½“æ²¡æœ‰åˆé€‚ Macro æ—¶æä¾›ï¼‰",
  "macro": "è¦å¤ç”¨çš„ Macro åç§°ï¼ˆä¼˜å…ˆä½¿ç”¨ï¼Œä¸ command äºŒé€‰ä¸€ï¼‰",
  "risk": "low | medium | high"
}

ã€ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‘
${context || 'æ— '}

ã€ç”¨æˆ·éœ€æ±‚ã€‘
${userInput}
`;
}

export function buildFixPrompt(
    originalCmd: string,
    stderr: string,
    os: OSProfile
): string {
    return `
è¯¥å‘½ä»¤åœ¨ ${os.name} ä¸Šæ‰§è¡Œå¤±è´¥ï¼š

å‘½ä»¤ï¼š
${originalCmd}

é”™è¯¯ä¿¡æ¯ï¼š
${stderr}

è¯·ç”Ÿæˆä¸€ä¸ª **${os.name} å…¼å®¹** çš„ç­‰ä»·å‘½ä»¤ã€‚
ä¾ç„¶åªè¾“å‡º JSON æ ¼å¼ã€‚æ³¨æ„ï¼šè¿™æ˜¯ä¿®å¤å‘½ä»¤ï¼Œä¸éœ€è¦æ£€æŸ¥ Macroã€‚

{
  "plan": "ä¿®å¤è¯´æ˜",
  "command": "ä¿®å¤åçš„å‘½ä»¤",
  "risk": "low | medium | high"
}
`;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ ai/types.ts

````typescript
export { AICommandPlan, type AICommandPlan as AICommandPlanType } from '../core/validation';

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ api/index.ts

````typescript
export * from './registryAPI';

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ api/registryAPI.ts

````typescript
import { MacroRegistry } from '../registry/registry';
import { RiskExplainer, createCapabilityGraph } from '../risk/explainer';
import type { MacroManifest, MacroPublishOptions, Capability } from '../registry/manifest';
import type { RiskAssessment } from '../risk/explainer';

export class RegistryAPI {
  private registry: MacroRegistry;
  private riskExplainer: RiskExplainer;

  constructor(storagePath?: string) {
    this.registry = new MacroRegistry({ storagePath });
    this.riskExplainer = new RiskExplainer(createCapabilityGraph());
  }

  async initialize(): Promise<void> {
    await this.registry.initialize();
  }

  async publishMacro(
    id: string,
    version: string,
    description: string,
    requires: Capability[],
    author: string,
    options: MacroPublishOptions = {}
  ): Promise<MacroManifest> {
    const manifest: Omit<MacroManifest, 'checksum'> = {
      id,
      version,
      description,
      author,
      createdAt: Date.now(),
      state: 'draft',
      requires
    };

    return await this.registry.publish(manifest, options);
  }

  async getMacro(id: string, version?: string): Promise<MacroManifest | null> {
    return await this.registry.get(id, version);
  }

  async listMacros(filters?: {
    state?: 'draft' | 'approved' | 'deprecated';
    author?: string;
    tags?: string[];
  }): Promise<MacroManifest[]> {
    return await this.registry.list(filters);
  }

  async approveMacro(id: string, version: string, approvedBy: string): Promise<MacroManifest> {
    return await this.registry.approve(id, version, approvedBy);
  }

  async deprecateMacro(id: string, version?: string): Promise<MacroManifest> {
    return await this.registry.deprecate(id, version);
  }

  async assessMacroRisk(id: string, version?: string): Promise<RiskAssessment | null> {
    const manifest = await this.registry.get(id, version);
    if (!manifest) {
      return null;
    }

    return this.riskExplainer.explainRisk(manifest);
  }

  async compareMacroVersions(id: string, oldVersion: string, newVersion: string) {
    const oldManifest = await this.registry.get(id, oldVersion);
    const newManifest = await this.registry.get(id, newVersion);

    if (!oldManifest || !newManifest) {
      throw new Error('One or both versions not found');
    }

    return this.registry.compareCapabilities(oldManifest, newManifest);
  }

  async getMacroVersions(id: string) {
    return await this.registry.getVersions(id);
  }

  async explainCapability(capability: Capability): Promise<string> {
    return this.riskExplainer.explainCapability(capability);
  }

  async expandCapabilities(capabilities: Capability[]): Promise<Capability[]> {
    return this.riskExplainer.expandCapabilities(capabilities);
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ audit/Replayer.ts

````typescript
import * as fs from 'fs';
import * as readline from 'readline';
import { CastHeader, Frame } from './Recorder';

/**
 * å›æ”¾å™¨
 */
export class Replayer {
  private frames: Frame[] = [];
  private header?: CastHeader;
  private speed = 1.0;

  constructor(private filePath: string) {}

  /**
   * åŠ è½½å½•åƒæ–‡ä»¶
   */
  async load(): Promise<void> {
    const fileStream = fs.createReadStream(this.filePath);
    const rl = readline.createInterface({
      input: fileStream,
      crlfDelay: Infinity
    });

    let isFirstLine = true;

    for await (const line of rl) {
      if (!line.trim()) continue;

      if (isFirstLine) {
        try {
          this.header = JSON.parse(line) as CastHeader;
          isFirstLine = false;
        } catch (e) {
            console.error('Invalid header format');
            throw e;
        }
      } else {
        try {
          const frame = JSON.parse(line) as Frame;
          this.frames.push(frame);
        } catch (e) {
          // ignore corrupted lines
        }
      }
    }
  }

  /**
   * æ’­æ”¾
   */
  async play(speed: number = 1.0): Promise<void> {
    this.speed = speed;
    
    if (!this.header || this.frames.length === 0) {
      console.log('ğŸ“¼ Empty or invalid recording.');
      return;
    }

    console.log(`\nğŸ“¼ Playing: ${this.header.title}`);
    console.log(`â±ï¸  Duration: ${this.frames[this.frames.length - 1][0].toFixed(2)}s`);
    console.log(`â© Speed: ${this.speed}x`);
    console.log('--------------------------------------------------\n');

    // è¿™ç§ç®€å•çš„ sleep å®ç°å¯èƒ½ä¼šæœ‰æ¼‚ç§»ï¼Œä½†å¯¹äº MVP è¶³å¤Ÿäº†
    // æ›´ç²¾å‡†çš„å®ç°åº”è¯¥åŸºäº Date.now() åŠ¨æ€è®¡ç®—ä¸‹ä¸€æ¬¡ sleep æ—¶é—´
    
    let lastTime = 0;

    for (const frame of this.frames) {
      const [time, type, data, meta] = frame;
      
      // è®¡ç®—éœ€è¦ç­‰å¾…çš„æ—¶é—´ (ms)
      const delay = (time - lastTime) * 1000 / this.speed;
      
      if (delay > 10) {
        await this.sleep(delay);
      }
      
      this.renderFrame(frame);
      lastTime = time;
    }

    console.log('\n\n--------------------------------------------------');
    console.log('âœ… End of playback');
  }

  private renderFrame(frame: Frame) {
    const [_, type, data, meta] = frame;

    if (type === 'o') {
      // æ ¸å¿ƒ: å°†æ•è·çš„ PTY è¾“å‡ºåŸæ ·å†™å…¥ stdout
      process.stdout.write(data);
    } else if (type === 'g') {
      // æ²»ç†äº‹ä»¶å¯è§†åŒ–
      // ä½¿ç”¨ ANSI é¢œè‰²åœ¨è¾“å‡ºæµä¸­æ’å…¥é†’ç›®çš„æç¤ºï¼Œæˆ–è€…ä»…ä»…æ‰“å°åœ¨ stderr ä»¥å…ç ´åå¸ƒå±€
      // ä¸ºäº†ä¸ç ´å terminal UI (æ¯”å¦‚ vim ç•Œé¢)ï¼Œæœ€å¥½ä¸è¦ç›´æ¥æ’å…¥ stdout
      // è¿™é‡Œä½œä¸º MVPï¼Œæˆ‘ä»¬ç®€å•åœ°ç”¨ä¸€ç§ç‰¹æ®Šçš„é¢œè‰²æ‰“å°
      /*
      console.log(`\n\x1b[33m[GOVERNANCE EVENT]: ${data} ${JSON.stringify(meta)}\x1b[0m`);
      */
      // å®é™…ä¸Šï¼Œå¦‚æœåœ¨ running app (vim/htop) ä¸­æ’å…¥ log ä¼šå¯¼è‡´èŠ±å±
      // æ›´å¥½çš„åšæ³•æ˜¯ overlayï¼Œä½† CLI åšä¸åˆ°
      // æš‚æ—¶ç­–ç•¥: åª log åˆ° stderrï¼Œæˆ–è€…å¿½ç•¥
    } else if (type === 'r') {
        // Resize event
        // å°è¯• resize ç»ˆç«¯? é€šå¸¸ä¸è¡Œã€‚
        // å¯ä»¥æ˜¾ç¤ºæç¤º
    }
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ audit/index.ts

````typescript
export * from './timeline';

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ audit/timeline.ts

````typescript
import type { ExecutionTurn } from '../agent/state';

export type AuditEventType =
  | 'macro_started'
  | 'macro_finished'
  | 'state_transition'
  | 'capability_requested'
  | 'capability_granted'
  | 'capability_denied'
  | 'human_approval_requested'
  | 'human_approved'
  | 'human_rejected'
  | 'tool_executed'
  | 'error_occurred';

export interface AuditEvent {
  id: string;
  timestamp: number;
  executionId: string;
  type: AuditEventType;
  data: {
    macroId?: string;
    macroVersion?: string;
    turnId?: number;
    fromState?: string;
    toState?: string;
    capability?: string;
    reason?: string;
    toolName?: string;
    toolParams?: any;
    success?: boolean;
    error?: string;
    approver?: string;
    duration?: number;
  };
  metadata?: Record<string, any>;
}

export interface ExecutionTimeline {
  executionId: string;
  startTime: number;
  endTime?: number;
  events: AuditEvent[];
  summary: ExecutionSummary;
}

export interface ExecutionSummary {
  totalDuration?: number;
  totalTurns: number;
  successfulTurns: number;
  failedTurns: number;
  capabilitiesRequested: Set<string>;
  capabilitiesGranted: Set<string>;
  capabilitiesDenied: Set<string>;
  toolsUsed: Map<string, number>;
  errors: Array<{ turn: number; message: string }>;
  humanApprovals: number;
  humanRejections: number;
}

export interface EffectsSummary {
  filesRead: string[];
  filesWritten: string[];
  filesModified: string[];
  commandsExecuted: Array<{ command: string; success: boolean }>;
  networkRequests: Array<{ url: string; method?: string }>;
  secretsAccessed: string[];
}

export class AuditTimeline {
  private events: AuditEvent[] = [];
  private executionId: string;
  private startTime: number;

  constructor(executionId: string) {
    this.executionId = executionId;
    this.startTime = Date.now();
  }

  record(event: Omit<AuditEvent, 'id' | 'timestamp' | 'executionId'>): void {
    this.events.push({
      id: this.generateEventId(),
      timestamp: Date.now(),
      executionId: this.executionId,
      ...event
    });
  }

  recordTurn(turn: ExecutionTurn): void {
    const startTime = Date.now();

    this.record({
      type: 'macro_started',
      data: {
        turnId: turn.turnId
      }
    });

    if (turn.proposedAction) {
      this.record({
        type: 'capability_requested',
        data: {
          capability: turn.proposedAction.type
        }
      });
    }

    if (turn.governance) {
      if (turn.governance.status === 'approved' && turn.governance.by === 'human') {
        this.record({
          type: 'human_approval_requested',
          data: {
            approver: turn.governance.by
          }
        });

        this.record({
          type: 'human_approved',
          data: {
            approver: turn.governance.by
          }
        });
      } else if (turn.governance.status === 'rejected') {
        this.record({
          type: 'human_approval_requested',
          data: {}
        });

        this.record({
          type: 'human_rejected',
          data: {
            reason: (turn.governance as any).reason
          }
        });
      }
    }

    if (turn.executionResult) {
      if (turn.proposedAction?.type === 'tool_call') {
        this.record({
          type: 'tool_executed',
          data: {
            toolName: turn.proposedAction.payload?.tool_name,
            toolParams: turn.proposedAction.payload?.parameters,
            success: turn.executionResult.success
          }
        });
      }

      if (!turn.executionResult.success) {
        this.record({
          type: 'error_occurred',
          data: {
            error: turn.executionResult.error
          }
        });
      }
    }

    const duration = Date.now() - startTime;
    this.record({
      type: 'macro_finished',
      data: {
        duration
      }
    });
  }

  generateTimeline(): ExecutionTimeline {
    const summary = this.generateSummary();

    return {
      executionId: this.executionId,
      startTime: this.startTime,
      endTime: this.events.length > 0 ? this.events[this.events.length - 1].timestamp : undefined,
      events: this.events,
      summary
    };
  }

  generateEffectsSummary(turns: ExecutionTurn[]): EffectsSummary {
    const effects: EffectsSummary = {
      filesRead: [],
      filesWritten: [],
      filesModified: [],
      commandsExecuted: [],
      networkRequests: [],
      secretsAccessed: []
    };

    for (const turn of turns) {
      if (turn.proposedAction?.type === 'tool_call') {
        const toolName = turn.proposedAction.payload?.tool_name;
        const params = turn.proposedAction.payload?.parameters;

        switch (toolName) {
          case 'read_file':
            if (params?.path && turn.executionResult?.success) {
              effects.filesRead.push(params.path);
            }
            break;

          case 'write_file':
            if (params?.path && turn.executionResult?.success) {
              effects.filesWritten.push(params.path);
            }
            break;

          case 'list_files':
            if (params?.path && turn.executionResult?.success) {
              effects.filesModified.push(params.path);
            }
            break;
        }
      }

      if (turn.proposedAction?.type === 'shell_cmd' && turn.executionResult) {
        effects.commandsExecuted.push({
          command: turn.proposedAction.payload?.command,
          success: turn.executionResult.success
        });
      }
    }

    return effects;
  }

  toJSON(): string {
    return JSON.stringify(this.generateTimeline(), null, 2);
  }

  toMarkdown(): string {
    const timeline = this.generateTimeline();
    let markdown = `# Execution Timeline\n\n`;
    markdown += `**Execution ID:** ${timeline.executionId}\n`;
    markdown += `**Start Time:** ${new Date(timeline.startTime).toISOString()}\n`;
    if (timeline.endTime) {
      markdown += `**End Time:** ${new Date(timeline.endTime).toISOString()}\n`;
      markdown += `**Duration:** ${((timeline.endTime - timeline.startTime) / 1000).toFixed(2)}s\n`;
    }
    markdown += `\n`;

    markdown += `## Summary\n\n`;
    markdown += `- Total Turns: ${timeline.summary.totalTurns}\n`;
    markdown += `- Successful: ${timeline.summary.successfulTurns}\n`;
    markdown += `- Failed: ${timeline.summary.failedTurns}\n`;
    markdown += `- Human Approvals: ${timeline.summary.humanApprovals}\n`;
    markdown += `- Human Rejections: ${timeline.summary.humanRejections}\n`;
    markdown += `\n`;

    markdown += `## Events\n\n`;
    for (const event of timeline.events) {
      markdown += `### ${event.type}\n`;
      markdown += `- **Time:** ${new Date(event.timestamp).toISOString()}\n`;
      if (event.data.capability) {
        markdown += `- **Capability:** ${event.data.capability}\n`;
      }
      if (event.data.toolName) {
        markdown += `- **Tool:** ${event.data.toolName}\n`;
      }
      if (event.data.reason) {
        markdown += `- **Reason:** ${event.data.reason}\n`;
      }
      if (event.data.error) {
        markdown += `- **Error:** ${event.data.error}\n`;
      }
      markdown += `\n`;
    }

    return markdown;
  }

  private generateSummary(): ExecutionSummary {
    const capabilitiesRequested = new Set<string>();
    const capabilitiesGranted = new Set<string>();
    const capabilitiesDenied = new Set<string>();
    const toolsUsed = new Map<string, number>();
    const errors: Array<{ turn: number; message: string }> = [];
    let humanApprovals = 0;
    let humanRejections = 0;
    let successfulTurns = 0;
    let failedTurns = 0;

    for (const event of this.events) {
      switch (event.type) {
        case 'capability_requested':
          if (event.data.capability) {
            capabilitiesRequested.add(event.data.capability);
          }
          break;

        case 'capability_granted':
          if (event.data.capability) {
            capabilitiesGranted.add(event.data.capability);
          }
          break;

        case 'capability_denied':
          if (event.data.capability) {
            capabilitiesDenied.add(event.data.capability);
          }
          break;

        case 'tool_executed':
          if (event.data.toolName) {
            const count = toolsUsed.get(event.data.toolName) || 0;
            toolsUsed.set(event.data.toolName, count + 1);
          }
          break;

        case 'human_approved':
          humanApprovals++;
          successfulTurns++;
          break;

        case 'human_rejected':
          humanRejections++;
          failedTurns++;
          break;

        case 'error_occurred':
          if (event.data.error) {
            errors.push({
              turn: event.data.turnId || 0,
              message: event.data.error
            });
            failedTurns++;
          }
          break;
      }
    }

    const endTime = this.events.length > 0 ? this.events[this.events.length - 1].timestamp : Date.now();

    return {
      totalDuration: endTime - this.startTime,
      totalTurns: successfulTurns + failedTurns,
      successfulTurns,
      failedTurns,
      capabilitiesRequested,
      capabilitiesGranted,
      capabilitiesDenied,
      toolsUsed,
      errors,
      humanApprovals,
      humanRejections
    };
  }

  private generateEventId(): string {
    return `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ cli.ts

````typescript
#!/usr/bin/env node
import chalk from 'chalk';
import path from 'path';
import fs from 'fs';
import os from 'os';
import { Command } from 'commander';
import { handleAICommand } from './commands/handleAICommand';
import { handleAIChat } from './commands/handleAIChat';
import { registerCapabilityCommands } from './commands/capabilityCommands';
import { getAllCommands, getCommandSubcommands, getCommandDescription, installBashCompletion, installZshCompletion, complete, setProgramInstance } from './core/completion';
import { loadAppsConfig, openUrl, DEFAULT_APPS } from './core/apps';
import { getMacros, saveMacro, runMacro } from './core/macros';
import { getCommandHistory } from './utils/history';
import { handleSpecialSyntax } from './utils/syntaxHandler';
import { registerRegistryCommands } from './commands/registryCommands';
import { registerExplainCommands } from './commands/explainCommands';
import { registerReplayCommands } from './commands/replayCommands';
import { registerSkillsCommands } from './commands/skillsCommands';
import { registerPreferencesCommands } from './commands/preferencesCommands';
import { registerConfigCommands } from './commands/config';
import { registerSSHCommand } from './commands/ssh';
import { registerRouterCommands } from './commands/routerCommands';
import { wouldExpandAsGlob } from './utils/globDetector';
// import { createDiffEditCommand } from './governance/commands/diffEdit';

// Mandatory Node.js version check
const majorVersion = Number(process.versions.node.split('.')[0]);
if (majorVersion < 18) {
    console.error(chalk.red(`Error: yuangs requires Node.js >= 18. Current version: ${process.version}`));
    process.exit(1);
}

const packageJson = JSON.parse(fs.readFileSync(path.join(__dirname, '../package.json'), 'utf8'));
const version = packageJson.version;

const program = new Command();

program
    .name('yuangs')
    .description('è‹‘å¹¿å±±çš„ä¸ªäººå‘½ä»¤è¡Œå·¥å…·')
    .version(version, '-V, --version');

setProgramInstance(program);

async function readStdin(): Promise<string> {
    if (process.stdin.isTTY) return '';
    return new Promise((resolve) => {
        let data = '';
        process.stdin.setEncoding('utf8');
        process.stdin.on('data', chunk => data += chunk);
        process.stdin.on('end', () => resolve(data));
        // Simple timeout to avoid hanging if no input
        setTimeout(() => resolve(data), 2000);
    });
}

function parseOptionsFromArgs(args: string[]): {
    exec: boolean;
    model?: string;
    withContent: boolean;
} {
    return {
        exec: args.includes('-e') || args.includes('--exec'),
        model: getArgValue(args, ['-m', '--model']) || getModelFromShortcuts(args),
        withContent: args.includes('-w') || args.includes('--with-content')
    };
}

function getModelFromShortcuts(args: string[]): string | undefined {
    if (args.includes('-p')) return 'Assistant';
    if (args.includes('-f')) return 'Assistant';
    if (args.includes('-l')) return 'Assistant';
    return undefined;
}

function getArgValue(args: string[], flags: string[]): string | undefined {
    for (let i = 0; i < args.length; i++) {
        for (const flag of flags) {
            if (args[i] === flag && i + 1 < args.length && !args[i + 1].startsWith('-')) {
                return args[i + 1];
            }
        }
    }
    return undefined;
}

program
    .command('ai [question...]')
    .description('å‘ AI æé—®')
    .option('-e, --exec', 'ç”Ÿæˆå¹¶æ‰§è¡Œ Linux å‘½ä»¤')
    .option('-m, --model <model>', 'æŒ‡å®š AI æ¨¡å‹')
    .option('-p', 'ä½¿ç”¨ Pro æ¨¡å‹')
    .option('-f', 'ä½¿ç”¨ Flash æ¨¡å‹')
    .option('-l', 'ä½¿ç”¨ Lite æ¨¡å‹')
    .option('-w, --with-content', 'åœ¨ç®¡é“æ¨¡å¼ä¸‹è¯»å–æ–‡ä»¶å†…å®¹')
    .option('--verbose', 'è¯¦ç»†è¾“å‡ºï¼ˆæ˜¾ç¤º Capability åŒ¹é…è¯¦æƒ…ï¼‰')
    .option('--planner', 'å¯ç”¨åŒAgentæ¨¡å¼ï¼ˆPlanner + Executorï¼‰')
    .option('--no-planner', 'ç¦ç”¨åŒAgentæ¨¡å¼')
    .option('--show-context-relevance', 'æ˜¾ç¤ºä¸Šä¸‹æ–‡ç›¸å…³æ€§è¯„åˆ†')
    .option('--context-strategy <strategy>', 'ä¸Šä¸‹æ–‡ç­–ç•¥: smart/minimal/full')
    .action(async (questionArgs, options) => {
        const stdinData = await readStdin();
        let question = Array.isArray(questionArgs) ? questionArgs.join(' ').trim() : questionArgs || '';

        if (stdinData) {
            if (options.withContent) {
                const { parseFilePathsFromLsOutput, readFilesContent, buildPromptWithFileContent } = await import('./core/fileReader');
                const filePaths = parseFilePathsFromLsOutput(stdinData);
                const contentMap = readFilesContent(filePaths);
                question = buildPromptWithFileContent(stdinData, filePaths, contentMap, question || undefined);
            } else {
                question = `ä»¥ä¸‹æ˜¯è¾“å…¥å†…å®¹ï¼š\n\n${stdinData}\n\næˆ‘çš„é—®é¢˜æ˜¯ï¼š${question || 'åˆ†æä»¥ä¸Šå†…å®¹'}`;
            }
        }

        let model = options.model;
        if (options.p) model = 'Assistant';
        if (options.f) model = 'Assistant';
        if (options.l) model = 'Assistant';

        const { PreferencesManager } = await import('./agent/preferences');

        if (options.contextStrategy) {
            const validStrategies = ['smart', 'minimal', 'full'];
            if (validStrategies.includes(options.contextStrategy)) {
                PreferencesManager.setPreferences({ contextStrategy: options.contextStrategy });
                console.log(chalk.cyan(`Context strategy set to: ${options.contextStrategy}`));
            } else {
                console.log(chalk.red(`Invalid context strategy: ${options.contextStrategy}`));
                console.log(chalk.gray('Valid options: smart, minimal, full'));
            }
        }

        if (!question && !stdinData) {
            await handleAIChat(null, model);
            return;
        }

        const isPlannerEnabled = options.planner || (options.noPlanner !== true && PreferencesManager.getPreference('autoConfirm') === false);

        (global as any).yuangsOptions = {
            showContextRelevance: options.showContextRelevance
        };

        if (isPlannerEnabled) {
            const { DualAgentRuntime } = await import('./agent');
            console.log(chalk.magenta('--- RUNNING WITH DUAL AGENT ENGINE (PLANNER + EXECUTOR) ---'));
            const runtime = new DualAgentRuntime(await import('./ai/client').then(m => m.getConversationHistory()));
            await runtime.run(question || '', undefined, model);
        } else {
            const { AgentRuntime } = await import('./agent');
            console.log(chalk.magenta('--- RUNNING WITH NEW AGENT ENGINE ---'));
            const runtime = new AgentRuntime(await import('./ai/client').then(m => m.getConversationHistory()));
            await runtime.run(question || '', options.exec ? 'command' : 'chat', undefined, model);
        }
    });

program
    .command('list')
    .description('åˆ—å‡ºæ‰€æœ‰åº”ç”¨')
    .action(() => {
        const apps = loadAppsConfig();
        console.log(chalk.bold.cyan('\nğŸ“± åº”ç”¨åˆ—è¡¨\n'));
        Object.entries(apps).forEach(([key, url]) => {
            console.log(`  ${chalk.green('â—')} ${chalk.bold(key.padEnd(10))} ${chalk.blue(url)}`);
        });
    });

program
    .command('history')
    .description('æŸ¥çœ‹åŠæ‰§è¡Œå‘½ä»¤å†å²')
    .option('-l, --last', 'æ‰§è¡Œä¸Šä¸€æ¡å‘½ä»¤')
    .action(async (options) => {
        const history = getCommandHistory();
        if (history.length === 0) {
            console.log(chalk.gray('æš‚æ— å‘½ä»¤å†å²\n'));
            return;
        }

        if (options.last) {
            const lastItem = history[0]; // history is unshift-ed, so 0 is latest
            console.log(chalk.bold.cyan('\nğŸ“‹ ä¸Šä¸€æ¬¡æ‰§è¡Œçš„å‘½ä»¤:\n'));
            console.log(chalk.white(`${lastItem.command}`));
            console.log(chalk.gray(`é—®é¢˜: ${lastItem.question}\n`));

            const rlLast = require('node:readline/promises').createInterface({
                input: process.stdin,
                output: process.stdout
            });
            const confirmLast = await rlLast.question(chalk.cyan('ç¡®è®¤å†æ¬¡æ‰§è¡Œ? (y/N): '));
            rlLast.close();

            if (confirmLast.toLowerCase() === 'y' || confirmLast.toLowerCase() === 'yes') {
                const { exec } = require('child_process');
                console.log(chalk.bold.cyan('æ‰§è¡Œä¸­...\n'));
                exec(lastItem.command, (error: any, stdout: string, stderr: string) => {
                    if (stdout) console.log(stdout);
                    if (stderr) console.error(chalk.red(stderr));
                    if (error) console.error(chalk.red(error.message));
                    process.exit(0);
                });
                return;
            } else {
                console.log(chalk.gray('å·²å–æ¶ˆæ‰§è¡Œ'));
            }
            return;
        }

        console.log(chalk.bold.cyan('\nğŸ“‹ å‘½ä»¤å†å²\n'));
        history.forEach((item, index) => {
            console.log(`${index + 1}. ${chalk.white(item.command)}`);
            console.log(chalk.gray(`   é—®é¢˜: ${item.question}\n`));
        });

        const rlHistory = require('node:readline/promises').createInterface({
            input: process.stdin,
            output: process.stdout
        });
        const indexInput = await rlHistory.question(chalk.cyan('è¾“å…¥åºå·é€‰æ‹©å‘½ä»¤ (ç›´æ¥å›è½¦å–æ¶ˆ): '));
        rlHistory.close();

        if (indexInput.trim()) {
            const index = parseInt(indexInput) - 1;
            if (index >= 0 && index < history.length) {
                const targetCommand = history[index].command;
                console.log(chalk.yellow(`\nå³å°†æ‰§è¡Œ: ${targetCommand}\n`));
                const rlConfirm = require('node:readline/promises').createInterface({
                    input: process.stdin,
                    output: process.stdout
                });
                const confirm = await rlConfirm.question(chalk.cyan('ç¡®è®¤æ‰§è¡Œ? (y/N): '));
                rlConfirm.close();

                if (confirm.toLowerCase() === 'y' || confirm.toLowerCase() === 'yes') {
                    const { exec } = require('child_process');
                    console.log(chalk.bold.cyan('æ‰§è¡Œä¸­...\n'));
                    exec(targetCommand, (error: any, stdout: string, stderr: string) => {
                        if (stdout) console.log(stdout);
                        if (stderr) console.error(chalk.red(stderr));
                        if (error) console.error(chalk.red(error.message));
                        process.exit(0);
                    });
                    return;
                } else {
                    console.log(chalk.gray('å·²å–æ¶ˆæ‰§è¡Œ'));
                }
            } else {
                console.log(chalk.red('æ— æ•ˆçš„åºå·'));
            }
        }
    });

program

program
    .command('macros')
    .description('æŸ¥çœ‹æ‰€æœ‰å¿«æ·æŒ‡ä»¤')
    .action(() => {
        const allMacros = getMacros();
        console.log(chalk.bold.cyan('\nğŸš€ å¿«æ·æŒ‡ä»¤åˆ—è¡¨\n'));
        Object.keys(allMacros).forEach(name => {
            console.log(`  ${chalk.white(name)}: ${chalk.gray(allMacros[name].commands)}`);
        });
    });

program
    .command('save <name>')
    .description('ä¿å­˜å¿«æ·æŒ‡ä»¤')
    .option('-l, --from-last', 'save last executed AI command')
    .option('-g, --global', 'add alias to ~/.zshrc')
    .action(async (name, options) => {
        const addToZshrc = (aliasName: string) => {
            const zshrcPath = path.join(os.homedir(), '.zshrc');
            if (fs.existsSync(zshrcPath)) {
                const aliasLine = `alias ${aliasName}="yuangs run ${aliasName}"`;
                try {
                    const content = fs.readFileSync(zshrcPath, 'utf8');
                    if (!content.includes(aliasLine)) {
                        fs.appendFileSync(zshrcPath, `\n${aliasLine}\n`);
                        console.log(chalk.green(`âœ“ å·²æ·»åŠ  alias åˆ° ~/.zshrc`));
                        console.log(chalk.yellow(`â„¹ï¸  è¯·è¿è¡Œ "source ~/.zshrc" ä»¥ç”Ÿæ•ˆ`));
                    } else {
                        console.log(chalk.yellow(`â„¹ï¸  Alias "${aliasName}" å·²å­˜åœ¨äº ~/.zshrc`));
                    }
                } catch (err) {
                    console.error(chalk.red(`âŒ æ— æ³•å†™å…¥ ~/.zshrc: ${(err as Error).message}`));
                }
            } else {
                console.log(chalk.red(`âŒ æœªæ‰¾åˆ° ~/.zshrc`));
            }
        };

        if (options.fromLast) {
            const history = getCommandHistory();
            if (history.length === 0) {
                console.log(chalk.red('âŒ æš‚æ—  AI å‘½ä»¤å†å²'));
                return;
            }
            const lastItem = history[0];

            saveMacro(name, lastItem.command, `Saved from: ${lastItem.question}`);
            console.log(chalk.green(`âœ“ å·²å°†æœ€è¿‘ä¸€æ¡ AI å‘½ä»¤ä¿å­˜ä¸º "${name}"`));
            console.log(chalk.gray(`  Command: ${lastItem.command}`));

            if (options.global) {
                addToZshrc(name);
            }
            return;
        }

        const rl = require('node:readline/promises').createInterface({
            input: process.stdin,
            output: process.stdout
        });
        const cmd = await rl.question(chalk.cyan('è¯·è¾“å…¥è¦ä¿å­˜çš„å‘½ä»¤: '));
        saveMacro(name, cmd);
        console.log(chalk.green(`âœ“ å¿«æ·æŒ‡ä»¤ "${name}" å·²ä¿å­˜`));
        rl.close();

        if (options.global) {
            addToZshrc(name);
        }
    });

program
    .command('run <name>')
    .description('æ‰§è¡Œå¿«æ·æŒ‡ä»¤')
    .action((name) => {
        if (runMacro(name)) {
            console.log(chalk.green(`âœ“ æ­£åœ¨æ‰§è¡Œ "${name}"...`));
        } else {
            console.log(chalk.red(`é”™è¯¯: å¿«æ·æŒ‡ä»¤ "${name}" ä¸å­˜åœ¨`));
        }
    });

program
    .command('completion [shell]')
    .description('ç”Ÿæˆå¹¶å®‰è£… Shell è¡¥å…¨è„šæœ¬')
    .action(async (shell) => {
        const shellType = shell || process.env.SHELL?.split('/').pop() || 'bash';

        if (!['bash', 'zsh'].includes(shellType)) {
            console.log(chalk.red('é”™è¯¯: ä¸æ”¯æŒçš„ shell ç±»å‹'));
            console.log(chalk.gray('æ”¯æŒçš„ç±»å‹: bash, zsh'));
            process.exit(1);
        }

        console.log(chalk.cyan(`\næ­£åœ¨ä¸º ${shellType} å®‰è£… yuangs è¡¥å…¨...\n`));

        let success = false;
        if (shellType === 'bash') {
            success = await installBashCompletion(program);
        } else if (shellType === 'zsh') {
            success = await installZshCompletion(program);
        }

        if (success) {
            console.log(chalk.green('âœ“ è¡¥å…¨å®‰è£…æˆåŠŸï¼\n'));
            console.log(chalk.yellow('è¯·é‡æ–°åŠ è½½ shell é…ç½®:'));
            console.log(chalk.gray(`  ${shellType === 'bash' ? 'source ~/.bashrc' : 'source ~/.zshrc'}\n`));
        } else {
            console.log(chalk.red('âœ— è¡¥å…¨å®‰è£…å¤±è´¥\n'));
            process.exit(1);
        }
    });

program
    .command('_complete')
    .description('(internal) unified completion entry')
    .option('--words <json>', 'JSON encoded argv')
    .option('--current <index>', 'Current word index')
    .action(async (options) => {
        try {
            const words = JSON.parse(options.words);
            const currentIndex = Number(options.current);

            const res = await complete({ words, currentIndex });

            console.log(res.items.map(i => i.label).join(' '));
        } catch {
            console.log('');
            process.exit(0);
        }
    });

registerCapabilityCommands(program);
registerRegistryCommands(program);
registerExplainCommands(program);
registerReplayCommands(program);
registerSkillsCommands(program);
registerPreferencesCommands(program);
registerConfigCommands(program);
registerSSHCommand(program);
registerRouterCommands(program);

// Add governance diff-edit command
// const diffEditCmd = createDiffEditCommand();
// program.addCommand(diffEditCmd);

program
    .command('help')
    .description('æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯')
    .action(() => {
        console.log(chalk.bold.cyan('\nğŸ¨ è‹‘å¹¿å±±çš„ä¸ªäººåº”ç”¨å¯åŠ¨å™¨ (Modular TSç‰ˆ)\n'));
        console.log(chalk.yellow(`å½“å‰ç‰ˆæœ¬: ${version}`));
        console.log(chalk.white('ä½¿ç”¨æ–¹æ³•:') + chalk.gray(' yuangs <å‘½ä»¤> [å‚æ•°]\n'));
        console.log(chalk.bold('å‘½ä»¤åˆ—è¡¨:'));
        console.log(`  ${chalk.green('ai')} "<é—®é¢˜>"      å‘ AI æé—®`);
        console.log(`    ${chalk.gray('-e')}              ç”Ÿæˆå¹¶æ‰§è¡Œ Linux å‘½ä»¤ (OS æ„ŸçŸ¥)`);
        console.log(`  ${chalk.green('list')}              åˆ—å‡ºæ‰€æœ‰åº”ç”¨`);
        console.log(`  ${chalk.green('history')}           æŸ¥çœ‹å‘½ä»¤å†å²`);
        console.log(`  ${chalk.green('config')}            ç®¡ç†æœ¬åœ°é…ç½® (~/.yuangs.json)`);
        console.log(`  ${chalk.green('macros')}            æŸ¥çœ‹æ‰€æœ‰å¿«æ·æŒ‡ä»¤`);
        console.log(`  ${chalk.green('save')} <åç§°>      ä¿å­˜å¿«æ·æŒ‡ä»¤`);
        console.log(`  ${chalk.green('run')} <åç§°>        æ‰§è¡Œå¿«æ·æŒ‡ä»¤`);
        console.log(`  ${chalk.green('registry')}          Macro Registry ç®¡ç†`);
        console.log(`  ${chalk.green('diff-edit')}         ä»£ç å˜æ›´æ²»ç† (propose/approve/exec/list/status)`);
        console.log(`  ${chalk.green('help')}              æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯\n`);
    });

const apps = loadAppsConfig();

program
    .command('shici')
    .description('æ‰“å¼€å¤è¯—è¯ PWA')
    .action(() => {
        const url = apps['shici'] || DEFAULT_APPS['shici'];
        console.log(chalk.green(`âœ“ æ­£åœ¨æ‰“å¼€ shici...`));
        openUrl(url);
    });

program
    .command('dict')
    .description('æ‰“å¼€è‹±è¯­è¯å…¸')
    .action(() => {
        const url = apps['dict'] || DEFAULT_APPS['dict'];
        console.log(chalk.green(`âœ“ æ­£åœ¨æ‰“å¼€ dict...`));
        openUrl(url);
    });

program
    .command('pong')
    .description('æ‰“å¼€ Pong æ¸¸æˆ')
    .action(() => {
        const url = apps['pong'] || DEFAULT_APPS['pong'];
        console.log(chalk.green(`âœ“ æ­£åœ¨æ‰“å¼€ pong...`));
        openUrl(url);
    });

program
    .argument('[command]', 'è‡ªå®šä¹‰åº”ç”¨å‘½ä»¤')
    .action((command) => {
        // å…ˆæ£€æŸ¥æ˜¯å¦æ˜¯ macro
        const macros = getMacros();
        if (command && macros[command]) {
            runMacro(command);
        } else if (command && apps[command]) {
            openUrl(apps[command]);
        } else {
            program.outputHelp();
        }
    });

async function main() {
    const args = process.argv.slice(2);

    const knownCommands = ['ai', 'list', 'history', 'config', 'macros', 'save', 'run', 'help', 'shici', 'dict', 'pong', 'capabilities', 'completion', '_complete_subcommand', '_describe', 'registry', 'explain', 'replay', 'skills', 'diff-edit', 'ny', 'ni', 'll', 'gdoc', 'install', 'update', 'ssh', 'router'];
    const globalFlags = ['-h', '--help', '-V', '--version', '-v'];
    const firstArg = args[0];
    const isKnownCommand = firstArg && knownCommands.includes(firstArg);
    const isGlobalFlag = firstArg && globalFlags.includes(firstArg);

    if (args.length === 0 && !await readStdin()) {
        console.log(chalk.bold.cyan('\nğŸ¨ è‹‘å¹¿å±±çš„ä¸ªäººåº”ç”¨å¯åŠ¨å™¨ (Modular TSç‰ˆ)\n'));
        console.log(chalk.yellow(`å½“å‰ç‰ˆæœ¬: ${version}`));
        program.outputHelp();
        process.exit(0);
    }

    if (!isKnownCommand && !isGlobalFlag) {
        const stdinData = await readStdin();

        if (stdinData || args.length > 0) {
            const options = parseOptionsFromArgs(args);
            let question = args.filter(arg => !arg.startsWith('-')).join(' ');

            if (stdinData) {
                // æ£€æŸ¥ stdin æ•°æ®æ˜¯å¦æ˜¯ç‰¹æ®Šè¯­æ³•
                const stdinTrimmed = stdinData.trim();

                // Check for ?? pattern which could be expanded by shell glob
                if (stdinTrimmed === '??') {
                    const globMatches = wouldExpandAsGlob(stdinTrimmed, process.cwd());
                    if (globMatches.wouldExpand) {
                        console.log(chalk.yellow('âš ï¸  Zeroâ€‘Mode è§¦å‘ç¬¦ \'??\' åœ¨å½“å‰ç›®å½•å¯èƒ½è¢«è§£é‡Šä¸ºæ–‡ä»¶åå±•å¼€ï¼š'));
                        console.log(chalk.gray('åŒ¹é…åˆ°ï¼š'));
                        globMatches.matches.forEach(match => {
                            console.log(chalk.gray(`- ${match}`));
                        });
                        console.log(chalk.gray('\nè¯·ä½¿ç”¨ \':ai\' æˆ–ç©ºè¡Œ + Enter è¿›å…¥ Zeroâ€‘Mode'));
                        process.exit(1);
                    }
                }

                const isStdinSpecialSyntax = stdinTrimmed.startsWith('@') ||
                    stdinTrimmed.startsWith('#') ||
                    stdinTrimmed === ':ls' ||
                    stdinTrimmed === ':clear' ||
                    stdinTrimmed === ':cat' ||
                    stdinTrimmed.startsWith(':cat ');

                if (isStdinSpecialSyntax) {
                    const result = await handleSpecialSyntax(stdinData, '');

                    if (result.processed) {
                        // å¦‚æœç‰¹æ®Šè¯­æ³•è¢«å¤„ç†ï¼Œä½¿ç”¨å¤„ç†ç»“æœä½œä¸ºé—®é¢˜
                        if (result.result) {
                            question = result.result;
                        } else {
                            // å¦‚æœæ²¡æœ‰ç»“æœï¼Œå¯èƒ½åªæ˜¯æ‰§è¡Œäº†å‘½ä»¤ï¼Œç›´æ¥é€€å‡º
                            process.exit(0);
                        }
                    } else {
                        // å¦‚æœæ²¡æœ‰è¢«å¤„ç†ï¼Œç»§ç»­ä½¿ç”¨åŸå§‹é—®é¢˜
                        console.log('è­¦å‘Š: æœªèƒ½å¤„ç†ç‰¹æ®Šè¯­æ³•ï¼Œä½¿ç”¨åŸå§‹è¾“å…¥');
                        if (options.withContent) {
                            const { parseFilePathsFromLsOutput, readFilesContent, buildPromptWithFileContent } = await import('./core/fileReader');
                            const filePaths = parseFilePathsFromLsOutput(stdinData);
                            const contentMap = readFilesContent(filePaths);
                            question = buildPromptWithFileContent(stdinData, filePaths, contentMap, question || undefined);
                        } else {
                            question = `ä»¥ä¸‹æ˜¯è¾“å…¥å†…å®¹ï¼š\n\n${stdinData}\n\næˆ‘çš„é—®é¢˜æ˜¯ï¼š${question || 'åˆ†æä»¥ä¸Šå†…å®¹'}`;
                        }
                    }
                } else {
                    if (options.withContent) {
                        const { parseFilePathsFromLsOutput, readFilesContent, buildPromptWithFileContent } = await import('./core/fileReader');
                        const filePaths = parseFilePathsFromLsOutput(stdinData);
                        const contentMap = readFilesContent(filePaths);
                        question = buildPromptWithFileContent(stdinData, filePaths, contentMap, question || undefined);
                    } else {
                        question = `ä»¥ä¸‹æ˜¯è¾“å…¥å†…å®¹ï¼š\n\n${stdinData}\n\næˆ‘çš„é—®é¢˜æ˜¯ï¼š${question || 'åˆ†æä»¥ä¸Šå†…å®¹'}`;
                    }
                }
            }

            // If question starts with ??, check for glob expansion
            const questionTrimmed = (question || '').trim();
            if (questionTrimmed.startsWith('??')) {
                const globMatches = wouldExpandAsGlob('??', process.cwd());
                if (globMatches.wouldExpand) {
                    console.log(chalk.yellow('âš ï¸  Zeroâ€‘Mode è§¦å‘ç¬¦ \'??\' åœ¨å½“å‰ç›®å½•å¯èƒ½è¢«è§£é‡Šä¸ºæ–‡ä»¶åå±•å¼€ï¼š'));
                    console.log(chalk.gray('åŒ¹é…åˆ°ï¼š'));
                    globMatches.matches.forEach(match => {
                        console.log(chalk.gray(`- ${match}`));
                    });
                    console.log(chalk.gray('\nè¯·ä½¿ç”¨ \':ai\' æˆ–ç©ºè¡Œ + Enter è¿›å…¥ Zeroâ€‘Mode'));
                    process.exit(1);
                }
            }

            // å¦‚æœ question æœ¬èº«åŒ…å«ç‰¹æ®Šè¯­æ³•ï¼ˆæ²¡æœ‰ stdin æˆ– stdin ä¸æ˜¯ç‰¹æ®Šè¯­æ³•ï¼‰
            const isSpecialSyntaxPrefix = (q: string) => {
                const t = q.trim();
                return t.startsWith('@') || t.startsWith('#') || t === ':ls' || t === ':clear' || t === ':cat' || t.startsWith(':cat ');
            };

            if (!stdinData || !isSpecialSyntaxPrefix(stdinData)) {
                const isQuestionSpecialSyntax = isSpecialSyntaxPrefix(questionTrimmed);

                if (isQuestionSpecialSyntax) {
                    const result = await handleSpecialSyntax(question, stdinData);

                    if (result.processed) {
                        // å¦‚æœç‰¹æ®Šè¯­æ³•è¢«å¤„ç†
                        if (result.result) {
                            // æ£€æŸ¥æ˜¯å¦æ˜¯ç®¡ç†å‘½ä»¤ï¼ˆå¦‚ :ls, :clear, :catï¼‰ï¼Œè¿™äº›å‘½ä»¤çš„ç»“æœåº”è¯¥ç›´æ¥è¾“å‡º
                            const trimmedQuestion = question.trim();
                            const isManagementCommand = trimmedQuestion === ':ls' ||
                                trimmedQuestion === ':clear' ||
                                trimmedQuestion === ':cat' ||
                                trimmedQuestion.startsWith(':cat ');

                            if (isManagementCommand) {
                                // ç›´æ¥è¾“å‡ºç»“æœå¹¶é€€å‡º
                                console.log(result.result);
                                process.exit(0);
                            } else {
                                // å¯¹äºæ–‡ä»¶/ç›®å½•å¼•ç”¨ï¼Œå°†ç»“æœä½œä¸ºé—®é¢˜ä¼ é€’ç»™AI
                                question = result.result;
                            }
                        } else {
                            // å¦‚æœæ²¡æœ‰ç»“æœï¼Œå¯èƒ½åªæ˜¯æ‰§è¡Œäº†å‘½ä»¤ï¼Œç›´æ¥é€€å‡º
                            process.exit(0);
                        }
                    } else {
                        // å¦‚æœæ²¡æœ‰è¢«å¤„ç†ï¼Œç»§ç»­ä½¿ç”¨åŸå§‹é—®é¢˜
                        console.log('è­¦å‘Š: æœªèƒ½å¤„ç†ç‰¹æ®Šè¯­æ³•ï¼Œä½¿ç”¨åŸå§‹è¾“å…¥');
                    }
                }
            }

            let model = options.model;
            if (options.exec) {
                await handleAICommand(question, { execute: false, model, verbose: options.withContent });
            } else {
                await handleAIChat(question || null, model);
            }
            process.exit(0);
        }
    }

    program.parse();
}

main().catch(err => {
    console.error('Fatal error:', err);
    process.exit(1);
});

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ commands/capabilityCommands.ts

````typescript
import chalk from 'chalk';
import { Command } from 'commander';
import { AtomicCapability, COMPOSITE_CAPABILITIES } from '../core/capabilities';
import { CapabilitySystem } from '../core/capabilitySystem';
import { CapabilityRequirement } from '../core/modelMatcher';
import { listExecutionRecords } from '../core/executionStore';
import { ReplayMode } from '../core/replayEngine';

export function registerCapabilityCommands(program: Command): void {
  const capProgram = program.command('capabilities').description('Capability system commands (new architecture)');

  capProgram
    .command('explain')
    .description('Explain current configuration with sources')
    .action(() => {
      const system = new CapabilitySystem();
      console.log(chalk.bold.cyan('\nğŸ“‹ Configuration Snapshot\n'));
      console.log(system.explainConfig());
    });

  capProgram
    .command('match')
    .description('Test capability matching')
    .argument('<capabilities...>', 'Required capabilities (e.g., text_generation reasoning)')
    .action((capabilities) => {
      const system = new CapabilitySystem();

      const { AtomicCapability } = require('../core/capabilities');

      const requirement: CapabilityRequirement = {
        required: capabilities as any,
        preferred: [],
      };

      const result = system.matchCapability(requirement);

      console.log(chalk.bold.cyan('\nğŸ¤– Capability Match Result\n'));

      if (!result.selected) {
        console.log(chalk.red('âŒ No model satisfies requirements\n'));
        result.candidates.forEach(c => {
          console.log(chalk.yellow(`${c.modelName} (${c.provider}):`));
          console.log(chalk.gray(`  ${c.reason}\n`));
        });
        return;
      }

      console.log(chalk.green(`âœ… Selected: ${result.selected.name} (${result.selected.provider})\n`));

      console.log(chalk.bold('Capability coverage:'));
      result.selected.atomicCapabilities.forEach(cap => {
        console.log(chalk.green(`  âœ“ ${cap}`));
      });

      if (result.fallbackOccurred) {
        console.log(chalk.yellow('\nâš ï¸  Fallback was used'));
      }

      console.log(chalk.bold('\nAll candidates:'));
      result.candidates.forEach(c => {
        const icon = c.hasRequired ? chalk.green('âœ“') : chalk.red('âœ—');
        console.log(`  ${icon} ${c.modelName} (${c.provider})`);
        console.log(chalk.gray(`    ${c.reason}\n`));
      });
    });

  capProgram
    .command('list')
    .description('List all available capabilities')
    .action(() => {
      console.log(chalk.bold.cyan('\nğŸ“¦ Available Capabilities\n'));

      console.log(chalk.bold('Atomic Capabilities:'));
      Object.values(AtomicCapability).forEach(cap => {
        console.log(`  - ${chalk.green(cap)}`);
      });

      console.log(chalk.bold('\nComposite Capabilities:'));
      COMPOSITE_CAPABILITIES.forEach(comp => {
        console.log(`  - ${chalk.cyan(comp.name)}`);
        console.log(chalk.gray(`    Composed of: ${comp.composedOf.join(', ')}`));
      });
    });

  capProgram
    .command('history')
    .description('List execution history')
    .option('-l, --limit <n>', 'Limit number of records', '10')
    .action((options) => {
      const limit = parseInt(options.limit);
      const records = listExecutionRecords(limit);

      if (records.length === 0) {
        console.log(chalk.gray('ğŸ“­ No execution history found\n'));
        return;
      }

      console.log(chalk.bold.cyan(`\nğŸ“‹ Execution History (last ${records.length})\n`));

      records.forEach((record, idx) => {
        const status = record.outcome.success
          ? chalk.green('âœ“')
          : chalk.red('âœ—');
        const model = record.decision.selectedModel?.name || 'N/A';
        const time = new Date(record.meta.timestamp).toLocaleString();

        console.log(`${status} ${chalk.white(record.id)}`);
        console.log(chalk.gray(`  Command: ${record.meta.commandName}`));
        console.log(chalk.gray(`  Model: ${model}`));
        console.log(chalk.gray(`  Time: ${time}\n`));
      });
    });

  capProgram
    .command('replay <id>')
    .description('Replay an execution')
    .option('-s, --strict', 'Strict replay (use exact model)')
    .option('-c, --compatible', 'Compatible replay (allow fallback)')
    .option('-v, --verbose', 'Verbose output')
    .action(async (id, options) => {
      const system = new CapabilitySystem();

      let mode: ReplayMode = 'strict';
      if (options.compatible) mode = 'compatible';

      const result = await system.replayExecution(id, {
        mode,
        skipAI: true,
        verbose: options.verbose,
      });

      if (result.success) {
        console.log(chalk.green(`\nâœ… ${result.message}\n`));
        if (result.executedModel) {
          console.log(chalk.gray(`Model: ${result.executedModel}`));
        }
      } else {
        console.log(chalk.red(`\nâŒ ${result.message}\n`));
      }
    });
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ commands/config/index.ts

````typescript
import chalk from 'chalk';
import { Command } from 'commander';
import { handleModelCommand } from './model';
import { handleGeneralConfigCommand } from './general';

/**
 * æ³¨å†Œ config å‘½ä»¤åŠå…¶å­å‘½ä»¤
 */
export function registerConfigCommands(program: Command): void {
    const configCmd = program
        .command('config')
        .description('ç®¡ç†æœ¬åœ°é…ç½® (~/.yuangs.json)');

    // æ¨¡å‹ç®¡ç†å­å‘½ä»¤
    configCmd
        .command('model')
        .description('ç®¡ç†é»˜è®¤ AI æ¨¡å‹')
        .argument('[action]', 'set, reset', 'get')
        .argument('[name]', 'æ¨¡å‹åç§°')
        .action((action, name) => {
            handleModelCommand(action, name);
        });

    // é€šç”¨é…ç½®å­å‘½ä»¤
    configCmd
        .command('get <key>')
        .description('è¯»å–é…ç½®é¡¹')
        .action((key) => {
            handleGeneralConfigCommand('get', key, undefined);
        });

    configCmd
        .command('set <key> <value>')
        .description('è®¾ç½®é…ç½®é¡¹')
        .action((key, value) => {
            handleGeneralConfigCommand('set', key, value);
        });

    configCmd
        .command('list')
        .description('åˆ—å‡ºæ‰€æœ‰é…ç½®é¡¹')
        .action(() => {
            handleGeneralConfigCommand('list', undefined, undefined);
        });
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ commands/config/model.ts

````typescript
import fs from 'fs';
import path from 'path';
import os from 'os';
import chalk from 'chalk';
import {
  isSupportedModel,
  listAvailableModels,
  getModelMetadata,
  getDefaultModel,
  type SupportedModel
} from './modelRegistry';
import { parseUserConfig, userConfigSchema, type UserConfig } from '../../core/validation';

const CONFIG_FILE = path.join(os.homedir(), '.yuangs.json');

/**
 * è¯»å–å¹¶éªŒè¯é…ç½®æ–‡ä»¶
 */
function readConfig(): UserConfig {
  if (fs.existsSync(CONFIG_FILE)) {
    try {
      return parseUserConfig(fs.readFileSync(CONFIG_FILE, 'utf8'));
    } catch (e) {
      // é…ç½®æ–‡ä»¶è§£æå¤±è´¥æ—¶è¿”å›ç©ºé…ç½®
      return {};
    }
  }
  return {};
}

/**
 * å†™å…¥é…ç½®æ–‡ä»¶
 */
function writeConfig(config: UserConfig): void {
  try {
    // ç¡®ä¿å†™å…¥å‰é€šè¿‡ schema éªŒè¯
    const validated = userConfigSchema.parse(config);
    fs.writeFileSync(CONFIG_FILE, JSON.stringify(validated, null, 2));
  } catch (e) {
    console.log(chalk.red(`\nâŒ é…ç½®éªŒè¯å¤±è´¥: ${(e as Error).message}\n`));
    throw e;
  }
}

/**
 * å¤„ç†æ¨¡å‹ç®¡ç†å‘½ä»¤
 */
export function handleModelCommand(action: string, modelName: string): void {
  // å¦‚æœæ²¡æœ‰ action æˆ– action æ˜¯ getï¼Œæ˜¾ç¤ºå½“å‰æ¨¡å‹
  if (!action || action === 'get') {
    showCurrentModel();
    return;
  }

  // å¦‚æœ action æ˜¯ listï¼Œåˆ—å‡ºæ‰€æœ‰æ¨¡å‹
  if (action === 'list') {
    console.log(listAvailableModels());
    return;
  }

  // å¦‚æœ action æ˜¯ setï¼Œè®¾ç½®é»˜è®¤æ¨¡å‹
  if (action === 'set') {
    setDefaultModel(modelName);
    return;
  }

  // å¦‚æœ action æ˜¯ resetï¼Œé‡ç½®ä¸ºé»˜è®¤æ¨¡å‹
  if (action === 'reset') {
    resetDefaultModel();
    return;
  }

  // æœªçŸ¥æ“ä½œ
  console.log(chalk.red(`\nâŒ æœªçŸ¥æ“ä½œ: ${action}`));
  console.log(chalk.gray('\nå¯ç”¨æ“ä½œ: get, list, set, reset\n'));
  console.log(chalk.gray('ç¤ºä¾‹:'));
  console.log(chalk.gray('  yuangs config model get           # æŸ¥çœ‹å½“å‰æ¨¡å‹'));
  console.log(chalk.gray('  yuangs config model list          # åˆ—å‡ºæ‰€æœ‰æ¨¡å‹'));
  console.log(chalk.gray('  yuangs config model set gpt-4o    # è®¾ç½®æ¨¡å‹'));
  console.log(chalk.gray('  yuangs config model reset         # é‡ç½®ä¸ºé»˜è®¤\n'));
}

/**
 * æ˜¾ç¤ºå½“å‰é»˜è®¤æ¨¡å‹
 */
function showCurrentModel(): void {
  const config = readConfig();
  const currentModel = config.defaultModel || getDefaultModel();

  console.log(chalk.bold.cyan('\nğŸ¤– å½“å‰é»˜è®¤æ¨¡å‹\n'));
  console.log(`  ${chalk.green('Model:')} ${chalk.white(currentModel)}`);

  if (isSupportedModel(currentModel)) {
    const meta = getModelMetadata(currentModel);
    console.log(`  ${chalk.green('Provider:')} ${chalk.white(meta.provider)}`);
    console.log(`  ${chalk.green('Description:')} ${chalk.gray(meta.description)}`);
    if (meta.recommended) {
      console.log(`  ${chalk.green('â­ æ¨è')}`);
    }
  }

  console.log(`  ${chalk.green('Source:')} ${chalk.gray('~/.yuangs.json')}\n`);
}

/**
 * è®¾ç½®é»˜è®¤æ¨¡å‹
 */
function setDefaultModel(modelName: string): void {
  if (!modelName) {
    console.log(chalk.red('\nâŒ è¯·æä¾›æ¨¡å‹åç§°\n'));
    console.log(chalk.gray('ç”¨æ³•: yuangs config model set <model-name>\n'));
    console.log(chalk.gray('ç¤ºä¾‹: yuangs config model set gemini-2.5-flash\n'));
    console.log(listAvailableModels());
    return;
  }

  // æ£€æŸ¥æ¨¡å‹æ˜¯å¦æ”¯æŒ
  if (!isSupportedModel(modelName)) {
    console.log(chalk.red(`\nâŒ ä¸æ”¯æŒçš„æ¨¡å‹: ${modelName}\n`));
    console.log(listAvailableModels());
    console.log(chalk.yellow('\nğŸ’¡ æç¤º: å¦‚æœæ‚¨ç¡®è®¤è¯¥æ¨¡å‹å¯ç”¨ï¼Œå¯ä»¥æ‰‹åŠ¨ç¼–è¾‘ ~/.yuangs.json\n'));
    return;
  }

  const config = readConfig();
  const oldModel = config.defaultModel || getDefaultModel();
  const newModel = modelName;

  // æ›´æ–°é…ç½®
  config.defaultModel = newModel;
  writeConfig(config);

  // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
  console.log(chalk.bold.cyan('\nâœ” é»˜è®¤æ¨¡å‹å·²æ›´æ–°\n'));
  console.log(`  ${chalk.green('æ—§æ¨¡å‹:')} ${chalk.white(oldModel)}`);
  console.log(`  ${chalk.green('æ–°æ¨¡å‹:')} ${chalk.white(newModel)}`);
  console.log(`  ${chalk.green('é…ç½®æ–‡ä»¶:')} ${chalk.gray('~/.yuangs.json')}`);
  console.log(chalk.gray('\nâœ… è®¾ç½®å·²ç”Ÿæ•ˆï¼Œä¸‹æ¬¡ AI è°ƒç”¨å°†ä½¿ç”¨æ–°æ¨¡å‹\n'));

  // æ˜¾ç¤ºæ¨¡å‹ä¿¡æ¯
  if (isSupportedModel(newModel)) {
    const meta = getModelMetadata(newModel);
    console.log(chalk.gray(`${meta.provider} - ${meta.description}\n`));
  }
}

/**
 * é‡ç½®ä¸ºé»˜è®¤æ¨¡å‹
 */
function resetDefaultModel(): void {
  const config = readConfig();
  const oldModel = config.defaultModel;
  const defaultModel = getDefaultModel();

  if (!oldModel) {
    console.log(chalk.yellow('\nâš ï¸  å½“å‰æœªè®¾ç½®é»˜è®¤æ¨¡å‹ï¼Œä½¿ç”¨ç³»ç»Ÿé»˜è®¤\n'));
    console.log(`  ${chalk.green('ç³»ç»Ÿé»˜è®¤:')} ${chalk.white(defaultModel)}\n`);
    return;
  }

  // åˆ é™¤ defaultModel å­—æ®µ
  delete config.defaultModel;
  writeConfig(config);

  // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
  console.log(chalk.bold.cyan('\nâœ” é»˜è®¤æ¨¡å‹å·²é‡ç½®\n'));
  console.log(`  ${chalk.green('æ—§æ¨¡å‹:')} ${chalk.white(oldModel)}`);
  console.log(`  ${chalk.green('æ–°æ¨¡å‹:')} ${chalk.white(defaultModel)} (ç³»ç»Ÿé»˜è®¤)`);
  console.log(`  ${chalk.green('é…ç½®æ–‡ä»¶:')} ${chalk.gray('~/.yuangs.json')}`);
  console.log(chalk.gray('\nâœ… è®¾ç½®å·²ç”Ÿæ•ˆï¼Œä¸‹æ¬¡ AI è°ƒç”¨å°†ä½¿ç”¨ç³»ç»Ÿé»˜è®¤æ¨¡å‹\n'));
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ commands/config/modelRegistry.ts

````typescript
import chalk from 'chalk';

/**
 * æ”¯æŒçš„ AI æ¨¡å‹åˆ—è¡¨
 */
export const SUPPORTED_MODELS = [
    // OpenAI Models
    'gpt-4o',
    'gpt-4o-mini',
    'gpt-4-turbo',

    // Claude Models
    'claude-3.5-sonnet',
    'claude-3.5-haiku',

    // Gemini Models
    'gemini-2.5-flash',
    'gemini-2.5-flash-lite',
    'gemini-3-flash-preview',
    'gemini-2.5-pro',

    // Legacy
    'Assistant'
] as const;

export type SupportedModel = typeof SUPPORTED_MODELS[number];

/**
 * æ¨¡å‹å…ƒæ•°æ®
 */
export interface ModelMetadata {
    name: string;
    provider: 'OpenAI' | 'Anthropic' | 'Google' | 'Legacy';
    category: 'pro' | 'flash' | 'turbo' | 'mini' | 'haiku';
    description: string;
    recommended?: boolean;
}

/**
 * æ¨¡å‹å…ƒæ•°æ®æ˜ å°„
 */
const MODEL_METADATA: Record<SupportedModel, ModelMetadata> = {
    'gpt-4o': {
        name: 'GPT-4o',
        provider: 'OpenAI',
        category: 'pro',
        description: 'OpenAI æœ€å…ˆè¿›çš„ GPT-4 æ¨¡å‹',
        recommended: true
    },
    'gpt-4o-mini': {
        name: 'GPT-4o Mini',
        provider: 'OpenAI',
        category: 'mini',
        description: 'GPT-4o çš„è½»é‡ç‰ˆæœ¬',
    },
    'gpt-4-turbo': {
        name: 'GPT-4 Turbo',
        provider: 'OpenAI',
        category: 'turbo',
        description: 'GPT-4 çš„å¿«é€Ÿç‰ˆæœ¬',
    },
    'claude-3.5-sonnet': {
        name: 'Claude 3.5 Sonnet',
        provider: 'Anthropic',
        category: 'pro',
        description: 'Anthropic çš„é«˜æ€§èƒ½æ¨¡å‹',
    },
    'claude-3.5-haiku': {
        name: 'Claude 3.5 Haiku',
        provider: 'Anthropic',
        category: 'haiku',
        description: 'Claude çš„å¿«é€Ÿå“åº”æ¨¡å‹',
    },
    'gemini-2.5-flash': {
        name: 'Gemini 2.5 Flash',
        provider: 'Google',
        category: 'flash',
        description: 'Google çš„å¿«é€Ÿå“åº”æ¨¡å‹',
    },
    'gemini-2.5-flash-lite': {
        name: 'Gemini 2.5 Flash Lite',
        provider: 'Google',
        category: 'flash',
        description: 'Gemini 2.5 çš„è¶…è½»é‡ç‰ˆæœ¬',
    },
    'gemini-3-flash-preview': {
        name: 'Gemini 3 Flash Preview',
        provider: 'Google',
        category: 'flash',
        description: 'Gemini 3 é¢„è§ˆç‰ˆ',
    },
    'gemini-2.5-pro': {
        name: 'Gemini 2.5 Pro',
        provider: 'Google',
        category: 'pro',
        description: 'Google çš„é«˜æ€§èƒ½æ¨¡å‹',
    },
    'Assistant': {
        name: 'Assistant',
        provider: 'Legacy',
        category: 'pro',
        description: 'é»˜è®¤åŠ©æ‰‹æ¨¡å‹',
    }
};

/**
 * æ£€æŸ¥æ¨¡å‹æ˜¯å¦æ”¯æŒ
 */
export function isSupportedModel(model: string): model is SupportedModel {
    return (SUPPORTED_MODELS as readonly string[]).includes(model);
}

/**
 * è·å–æ¨¡å‹å…ƒæ•°æ®
 */
export function getModelMetadata(model: SupportedModel): ModelMetadata {
    return MODEL_METADATA[model];
}

/**
 * åˆ—å‡ºæ‰€æœ‰å¯ç”¨æ¨¡å‹
 */
export function listAvailableModels(): string {
    const byProvider: Record<string, SupportedModel[]> = {};

    for (const model of SUPPORTED_MODELS) {
        const meta = MODEL_METADATA[model];
        if (!byProvider[meta.provider]) {
            byProvider[meta.provider] = [];
        }
        byProvider[meta.provider].push(model);
    }

    let output = chalk.bold.cyan('\nğŸ¤– å¯ç”¨ AI æ¨¡å‹\n\n');

    for (const [provider, models] of Object.entries(byProvider)) {
        output += chalk.yellow(`${provider}:\n`);
        for (const model of models) {
            const meta = MODEL_METADATA[model];
            const recommended = meta.recommended ? chalk.green(' â­ æ¨è') : '';
            const prefix = meta.recommended ? '  *' : '   ';
            output += `${prefix} ${chalk.white(model.padEnd(25))} ${chalk.gray(meta.description)}${recommended}\n`;
        }
        output += '\n';
    }

    return output;
}

/**
 * è·å–é»˜è®¤æ¨¡å‹ï¼ˆæ¨èï¼‰
 */
export function getDefaultModel(): SupportedModel {
    return 'gemini-2.5-flash-lite';
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ commands/context/ContextAssembler.ts

````typescript
import { ContextStore } from './ContextStore';
import { ContextItem } from './ContextTypes';
import { RedactionFinding } from './ContextTypes';

const estimateTokens = (text: string) => Math.ceil(text.length / 4);

const REDACTION_RULES: Array<{
    name: string;
    pattern: RegExp;
    replacement: string;
}> = [
    {
        name: 'OpenAI Key',
        pattern: /sk-[a-zA-Z0-9]{20,}/g,
        replacement: '[REDACTED_API_KEY]'
    },
    {
        name: 'Password',
        pattern: /(password|passwd|secret)\s*[:=]\s*.+/gi,
        replacement: '$1=[REDACTED]'
    },
    {
        name: 'Private Key Block',
        pattern: /-----BEGIN [\s\S]*?PRIVATE KEY-----[\s\S]*?-----END [\s\S]*?PRIVATE KEY-----/g,
        replacement: '[REDACTED_PRIVATE_KEY]'
    }
];

export class ContextAssembler {
    private maxTokens = 32000;

    assemble(store: ContextStore, userInput: string): string {
        if (store.isEmpty()) return userInput;

        const now = Date.now();
        const items = store.all();

        for (const item of items) {
            this.decay(item, now);
            this.computeImportance(item, userInput, now);
        }

        this.promoteToMemoryIfNeeded(items, now);

        const memory = items.filter(i => i.status === 'memory');
        const active = items
            .filter(i => i.importance > 0.6 && i.status !== 'memory' && i.source !== 'antipattern')
            .sort((a, b) => b.importance - a.importance)
            .slice(0, 6);

        const reference = items.filter(
            i => !active.includes(i) && i.status !== 'memory' && i.source !== 'antipattern'
        );

        const antiPatterns = items.filter(i => i.status === 'active' && i.source === 'antipattern').slice(-3);

        const render = (items: ContextItem[]) =>
            items
                .map(i => {
                    const title = i.alias
                        ? `[Context] ${i.source}: ${i.alias} (${i.path})`
                        : `[Context] ${i.source}: ${i.path}`;
                    const body = i.summary ?? i.content ?? '';
                    return `${title}\n---\n${body}\n---`;
                })
                .join('\n\n');

        const renderAntiPatterns = (items: ContextItem[]) =>
            items
                .map(i => `âš ï¸ ${i.content}`)
                .join('\n\n');

        let antiPatternSection = '';
        if (antiPatterns.length > 0) {
            antiPatternSection = `
# Anti-Pattern Warnings
ä»¥ä¸‹æ¨¡å¼æ›¾å¯¼è‡´æ‰§è¡Œå¤±è´¥ï¼Œè¯·é¿å…ï¼š
${renderAntiPatterns(antiPatterns)}

`;
        }

        return `
# System Memory
${render(memory)}

# Active Context
${render(active)}

# Reference Context
${render(reference)}
${antiPatternSection}
ç”¨æˆ·é—®é¢˜ï¼š
${userInput}
`;
    }

    sanitizeContent(content: string): { sanitized: string; findings: RedactionFinding[] } {
        const findings: RedactionFinding[] = [];
        let result = content;

        for (const rule of REDACTION_RULES) {
            const matches = result.match(rule.pattern);
            if (matches) {
                result = result.replace(rule.pattern, rule.replacement);
                findings.push({
                    rule: rule.name,
                    count: matches.length
                });
            }
        }

        return { sanitized: result, findings };
    }

    optimizeForTokens(store: ContextStore, ratio: number) {
        if (ratio < 0.7) return;

        const items = store.all();
        const victims = items
            .filter(i => i.content && !i.pinned && i.status !== 'memory')
            .sort((a, b) => a.importance - b.importance);

        for (const item of victims) {
            item.summary = item.summary ?? item.content!.slice(0, 500) + '...';
            item.content = undefined;
            item.tokens = estimateTokens(item.summary);

            if (store.totalTokens() / this.maxTokens < 0.6) break;
        }
    }

    private computeImportance(
        item: ContextItem,
        query: string,
        now: number
    ) {
        const recency = Math.exp(
            -(now - item.lastUsedAt) / (1000 * 60 * 30)
        );

        const semantic =
            item.content && query
                ? item.content.toLowerCase().includes(query.toLowerCase())
                    ? 1
                    : 0
                : 0;

        const pinned = item.pinned ? 1 : 0;

        item.importance =
            0.5 * recency +
            0.3 * semantic +
            0.2 * pinned;
    }

    private decay(item: ContextItem, now: number) {
        if (item.pinned) return;

        const last = item.lastUsedAt ?? now;
        const hours = (now - last) / 36e5;

        const rate = item.decayRate ?? 0.95;
        item.importance = (item.importance ?? 0.5) * Math.pow(rate, hours);
    }

    private promoteToMemoryIfNeeded(items: ContextItem[], now: number) {
        for (const item of items) {
            if (item.source === 'memory' || item.source === 'antipattern') continue;

            if (item.importance < 0.85) continue;

            if (now - item.lastUsedAt > 1000 * 60 * 10) continue;

            item.status = 'memory';
            item.pinned = true;
        }
    }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ commands/context/ContextStore.ts

````typescript
import fs from 'fs';
import path from 'path';
import crypto from 'crypto';
import { ContextItem, ContextStatus, DriftReport } from './ContextTypes';

export class ContextStore {
    private items = new Map<string, ContextItem>();
    private maxTokens = 32000;

    add(item: ContextItem) {
        this.items.set(item.id, item);
    }

    update(id: string, patch: Partial<ContextItem>) {
        const item = this.items.get(id);
        if (!item) return;
        Object.assign(item, patch);
    }

    remove(id: string) {
        this.items.delete(id);
    }

    get(id: string): ContextItem | undefined {
        return this.items.get(id);
    }

    list(status?: ContextStatus) {
        return [...this.items.values()]
            .filter(i => !status || i.status === status)
            .map((item, i) => ({
                index: i + 1,
                source: item.source,
                path: item.path,
                alias: item.alias,
                tokens: item.tokens,
                importance: item.importance.toFixed(2),
                pinned: item.pinned ? 'ğŸ“Œ' : '',
                ageMin: Math.floor((Date.now() - item.lastUsedAt) / 60000),
                summary: item.summary,
                status: item.status
            }));
    }

    all(): ContextItem[] {
        return [...this.items.values()];
    }

    clear() {
        this.items.clear();
    }

    isEmpty() {
        return this.items.size === 0;
    }

    totalTokens() {
        return [...this.items.values()].reduce((s, i) => s + i.tokens, 0);
    }

    enforceTTL(now = Date.now()) {
        for (const item of this.items.values()) {
            if (item.pinned || !item.ttlMs) continue;

            if (now - item.lastUsedAt > item.ttlMs) {
                item.status = 'expired';
            }
        }
    }

    gc() {
        for (const [id, item] of this.items) {
            if (item.status === 'expired') {
                this.items.delete(id);
            }
        }
    }

    detectDrift(): DriftReport[] {
        const reports: DriftReport[] = [];

        for (const item of this.items.values()) {
            if (item.source !== 'file') continue;
            if (!fs.existsSync(item.path)) continue;

            try {
                const currentContent = fs.readFileSync(item.path, 'utf-8');
                const currentHash = sha256(currentContent);

                if (currentHash !== item.hash) {
                    reports.push({
                        id: item.id,
                        path: item.path,
                        reason: 'hash_changed'
                    });
                }
            } catch (e) {
                continue;
            }
        }

        return reports;
    }

    markAsDrifted(id: string) {
        const item = this.items.get(id);
        if (item) {
            item.status = 'stale';
            item.drifted = true;
        }
    }

    refreshItem(id: string) {
        const item = this.items.get(id);
        if (!item || item.source !== 'file') return;

        if (!fs.existsSync(item.path)) return;

        const raw = fs.readFileSync(item.path, 'utf-8');
        const content = redact(raw).redacted;
        const hash = sha256(content);

        item.content = content;
        item.hash = hash;
        item.status = 'active';
        item.drifted = false;
        item.lastUsedAt = Date.now();
    }

    export() {
        return this.all();
    }

    import(items: any[]) {
        this.items.clear();
        for (const item of items) {
            const itemId = item.id || `${item.source || item.type}:${item.path}`;
            const normalized: ContextItem = {
                id: itemId,
                source: (item.source || item.type) as ContextItem['source'],
                path: item.path,
                alias: item.alias,
                content: item.content,
                summary: item.summary,
                tokens: item.tokens,
                importance: item.importance ?? 0.5,
                lastUsedAt: item.lastUsedAt ?? Date.now(),
                addedAt: item.addedAt ?? Date.now(),
                status: item.status ?? 'active',
                pinned: item.pinned,
                tags: item.tags,
                decayRate: item.decayRate,
                hash: item.hash,
                ttlMs: item.ttlMs,
                drifted: item.drifted
            };
            this.items.set(itemId, normalized);
        }
    }
}

function sha256(input: string): string {
    return crypto.createHash('sha256').update(input).digest('hex');
}

const REDACTION_RULES: Array<{
    name: string;
    pattern: RegExp;
    replacement: string;
}> = [
    {
        name: 'OpenAI Key',
        pattern: /sk-[a-zA-Z0-9]{20,}/g,
        replacement: '[REDACTED_API_KEY]'
    },
    {
        name: 'Password',
        pattern: /(password|passwd|secret)\s*[:=]\s*.+/gi,
        replacement: '$1=[REDACTED]'
    },
    {
        name: 'Private Key Block',
        pattern: /-----BEGIN [\s\S]*?PRIVATE KEY-----[\s\S]*?-----END [\s\S]*?PRIVATE KEY-----/g,
        replacement: '[REDACTED_PRIVATE_KEY]'
    }
];

function redact(text: string): { redacted: string; applied: string[] } {
    let result = text;
    const applied: string[] = [];

    for (const rule of REDACTION_RULES) {
        if (rule.pattern.test(result)) {
            result = result.replace(rule.pattern, rule.replacement);
            applied.push(rule.name);
        }
    }

    return { redacted: result, applied };
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ commands/context/ContextTypes.ts

````typescript
export type ContextSource = 'file' | 'directory' | 'memory' | 'antipattern';

export type ContextStatus = 'active' | 'reference' | 'memory' | 'stale' | 'expired';

export interface ContextItem {
    id: string;
    source: ContextSource;
    path: string;
    alias?: string;

    content?: string;
    summary?: string;

    tokens: number;

    importance: number;
    lastUsedAt: number;
    addedAt: number;

    status: ContextStatus;

    pinned?: boolean;
    tags?: string[];
    decayRate?: number;

    hash?: string;
    ttlMs?: number;
    drifted?: boolean;
}

export interface DriftReport {
    id: string;
    path: string;
    reason: 'mtime_changed' | 'hash_changed';
}

export interface RedactionFinding {
    rule: string;
    count: number;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ commands/context/index.ts

````typescript
export { ContextStore } from './ContextStore';
export { ContextAssembler } from './ContextAssembler';
export type {
    ContextSource,
    ContextStatus,
    ContextItem,
    DriftReport,
    RedactionFinding
} from './ContextTypes';

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ commands/contextBuffer.ts

````typescript
export type ContextItem = {
    id: string;
    type: 'file' | 'directory' | 'memory' | 'antipattern';
    path: string;
    alias?: string;

    content?: string;
    summary?: string;

    tokens: number;
    importance: number;
    lastUsedAt: number;
    pinned?: boolean;
    tags?: string[];
    decayRate?: number;
};

const estimateTokens = (text: string) => Math.ceil(text.length / 4);

export class ContextBuffer {
    private items: ContextItem[] = [];
    private maxTokens = 32000;

    add(
        item: Partial<ContextItem> & { type: ContextItem['type']; path: string },
        bypassTokenLimit = false
    ) {
        const text = item.content ?? item.summary ?? '';
        const tokens = estimateTokens(text);

        const itemId = item.id || `${item.type}:${item.path}:${Date.now()}`;
        const full: ContextItem = {
            ...item,
            id: itemId,
            tokens,
            importance: 0.5,
            lastUsedAt: Date.now()
        };

        this.items.push(full);
        if (!bypassTokenLimit) {
            this.trimIfNeeded();
        }
    }

    clear() {
        this.items = [];
    }

    list() {
        return this.items.map((item, i) => ({
            index: i + 1,
            type: item.type,
            path: item.path,
            alias: item.alias,
            tokens: item.tokens,
            importance: item.importance.toFixed(2),
            pinned: item.pinned ? 'ğŸ“Œ' : '',
            ageMin: Math.floor((Date.now() - item.lastUsedAt) / 60000),
            summary: item.summary
        }));
    }

    isEmpty() {
        return this.items.length === 0;
    }

    export() {
        return this.items;
    }

    import(items: ContextItem[]) {
        this.items = items.map(i => ({
            ...i,
            id: i.id || `${i.type}:${i.path}`,
            importance: i.importance ?? 0.5,
            lastUsedAt: i.lastUsedAt ?? Date.now()
        }));
    }

    private totalTokens() {
        return this.items.reduce((s, i) => s + i.tokens, 0);
    }

    private computeImportance(item: ContextItem, query: string) {
        const now = Date.now();
        const recency = Math.exp(-(now - item.lastUsedAt) / (1000 * 60 * 30));
        const pinned = item.pinned ? 1 : 0;

        let semantic = 0;
        if (item.content && query) {
            semantic = item.content.toLowerCase().includes(query.toLowerCase())
                ? 1
                : 0;
        }

        item.importance =
            0.5 * recency +
            0.3 * semantic +
            0.2 * pinned;
    }

    private decay(item: ContextItem) {
        if (item.pinned) return;

        const now = Date.now();
        const last = item.lastUsedAt ?? now;
        const hours = (now - last) / 36e5;

        const rate = item.decayRate ?? 0.95;
        item.importance = (item.importance ?? 0.5) * Math.pow(rate, hours);
    }

    private trimIfNeeded() {
        while (this.totalTokens() > this.maxTokens) {
            const victim = this.items
                .filter(i => !i.pinned)
                .sort((a, b) => a.importance - b.importance)[0];

            if (!victim) break;
            this.items = this.items.filter(i => i !== victim);
        }
    }

    optimizeForTokens(ratio: number) {
        if (ratio < 0.7) return;

        const victims = this.items
            .filter(i => i.content && !i.pinned)
            .sort((a, b) => a.importance - b.importance);

        for (const item of victims) {
            item.summary = item.summary ?? item.content!.slice(0, 500) + '...';
            item.content = undefined;
            item.tokens = estimateTokens(item.summary);

            if (this.totalTokens() / this.maxTokens < 0.6) break;
        }
    }

    promoteToMemoryIfNeeded() {
        const now = Date.now();

        for (const item of this.items) {
            if (item.type === 'memory' || item.type === 'antipattern') continue;

            if (item.importance < 0.85) continue;

            if (now - item.lastUsedAt > 1000 * 60 * 10) continue;

            item.type = 'memory';
            item.pinned = true;
        }
    }

    buildPrompt(userInput: string): string {
        if (this.isEmpty()) return userInput;

        for (const item of this.items) {
            this.decay(item);
            this.computeImportance(item, userInput);
        }

        this.promoteToMemoryIfNeeded();

        this.items = this.items.filter(
            i => i.type !== 'memory' || (i.importance ?? 0) > 0.2
        );

        const memory = this.items.filter(i => i.type === 'memory');
        const active = this.items
            .filter(i => i.importance > 0.6 && i.type !== 'memory' && i.type !== 'antipattern')
            .sort((a, b) => b.importance - a.importance)
            .slice(0, 6);

        const reference = this.items.filter(
            i => !active.includes(i) && i.type !== 'memory' && i.type !== 'antipattern'
        );

        const antiPatterns = this.items.filter(i => i.type === 'antipattern').slice(-3);

        const render = (items: ContextItem[]) =>
            items
                .map(i => {
                    const title = i.alias
                        ? `[Context] ${i.type}: ${i.alias} (${i.path})`
                        : `[Context] ${i.type}: ${i.path}`;
                    const body = i.summary ?? i.content ?? '';
                    return `${title}\n---\n${body}\n---`;
                })
                .join('\n\n');

        const renderAntiPatterns = (items: ContextItem[]) =>
            items
                .map(i => `âš ï¸ ${i.content}`)
                .join('\n\n');

        let antiPatternSection = '';
        if (antiPatterns.length > 0) {
            antiPatternSection = `
# Anti-Pattern Warnings
ä»¥ä¸‹æ¨¡å¼æ›¾å¯¼è‡´æ‰§è¡Œå¤±è´¥ï¼Œè¯·é¿å…ï¼š
${renderAntiPatterns(antiPatterns)}

`;
        }

        return `
# System Memory
${render(memory)}

# Active Context
${render(active)}

# Reference Context
${render(reference)}
${antiPatternSection}
ç”¨æˆ·é—®é¢˜ï¼š
${userInput}
`;
    }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ commands/contextStorage.ts

````typescript
import fs from 'fs/promises';
import path from 'path';
import { ContextItem } from './context/ContextTypes';

const CONTEXT_DIR = path.resolve(process.cwd(), '.ai');
const CONTEXT_FILE = path.join(CONTEXT_DIR, 'context.json');

export async function loadContext(): Promise<any[]> {
    try {
        const raw = await fs.readFile(CONTEXT_FILE, 'utf-8');
        return JSON.parse(raw);
    } catch {
        return [];
    }
}

export async function saveContext(items: any[]) {
    await fs.mkdir(CONTEXT_DIR, { recursive: true });
    await fs.writeFile(CONTEXT_FILE, JSON.stringify(items, null, 2));
}

export async function clearContextStorage() {
    await fs.rm(CONTEXT_FILE, { force: true });
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ commands/explainCommands.ts

````typescript
import chalk from 'chalk';
import { Command } from 'commander';
import { explainExecution } from '../core/explain';
import { loadExecutionRecord, listExecutionRecords } from '../core/executionStore';

export function registerExplainCommands(program: Command): void {
  program
    .command('explain [id]')
    .description('Explain an execution (use "last" for most recent)')
    .action((id) => {
      let record;

      if (!id || id === 'last') {
        const records = listExecutionRecords(1);
        if (records.length === 0) {
          console.log(chalk.red('âŒ No execution records found\n'));
          return;
        }
        record = records[0];
        console.log(chalk.gray(`Showing most recent execution: ${record.id}\n`));
      } else {
        record = loadExecutionRecord(id);
        if (!record) {
          console.log(chalk.red(`âŒ Execution record "${id}" not found\n`));
          return;
        }
      }

      const explanation = explainExecution(record);
      console.log(explanation);
    });
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ commands/gitContext.ts

````typescript
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

async function run(cmd: string): Promise<string | null> {
    try {
        const { stdout } = await execAsync(cmd, { maxBuffer: 1024 * 1024 });
        return stdout.trim() || null;
    } catch {
        return null;
    }
}

export async function getGitContext() {
    const staged = await run('git diff --staged');
    const unstaged = await run('git diff');

    if (!staged && !unstaged) return null;

    let result = `ä»¥ä¸‹æ˜¯ Git å˜æ›´å†…å®¹ï¼š\n`;

    if (staged) {
        result += `\nã€å·²æš‚å­˜ã€‘\n\`\`\`diff\n${staged}\n\`\`\`\n`;
    }

    if (unstaged) {
        result += `\nã€æœªæš‚å­˜ã€‘\n\`\`\`diff\n${unstaged}\n\`\`\`\n`;
    }

    return result;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ commands/handleAIChat.ts

````typescript
import chalk from 'chalk';
import ora from 'ora';
import readline from 'readline';
import { callAI_Stream, getConversationHistory, addToConversationHistory, clearConversationHistory, getUserConfig } from '../ai/client';
import fs from 'fs';
import path from 'path';
import crypto from 'crypto';
import { buildPromptWithFileContent, readFilesContent } from '../core/fileReader';
import { exec, spawn } from 'child_process';
import { promisify } from 'util';
import { ContextBuffer } from './contextBuffer';
import { ContextStore, ContextAssembler, ContextItem } from './context';
import { loadContext, saveContext, clearContextStorage } from './contextStorage';
import { getGitContext } from './gitContext';
import {
    Mode,
    detectMode,
    createCompleter,
    executeCommand as shellExecuteCommand,
    listPlugins
} from './shellCompletions';
import { runMacro } from '../core/macros';
import { StreamMarkdownRenderer } from '../utils/renderer';
import { wouldExpandAsGlob } from '../utils/globDetector';
const execAsync = promisify(exec);

// å…¨å±€å˜é‡ï¼šå­˜å‚¨æœ€åçš„ AI è¾“å‡ºå†…å®¹ï¼Œç”¨äºå¿«é€Ÿæ’å…¥
let lastAIOutput: string = '';
let clipboardContent: string = '';

function findCommonPrefix(strings: string[]): string {
    if (strings.length === 0) return '';
    if (strings.length === 1) return strings[0];

    let common = '';
    const first = strings[0];

    for (let i = 0; i < first.length; i++) {
        const char = first[i];
        if (strings.every(s => s[i] === char)) {
            common += char;
        } else {
            break;
        }
    }

    return common;
}

async function executeCommand(filePath: string, command?: string) {
    const fullPath = path.resolve(filePath);
    const commandStr = command || '';

    if (command) {
        const { stdout, stderr } = await exec(commandStr, { cwd: path.dirname(fullPath) });
        console.log(stdout);
        if (stderr) console.error(chalk.red(stderr));
    } else {
        const { stdout, stderr } = await exec(fullPath, { cwd: process.cwd() });
        console.log(stdout);
        if (stderr) console.error(chalk.red(stderr));
    }
}

async function readFileContent(filePath: string): Promise<string> {
    const fullPath = path.resolve(filePath);
    return await fs.promises.readFile(fullPath, 'utf-8');
}

async function showFileSelector(rl: readline.Interface): Promise<string | null> {
    return new Promise((resolve) => {
        try {
            const currentDir = process.cwd();
            const files = fs.readdirSync(currentDir);

            if (files.length === 0) {
                console.log(chalk.yellow('å½“å‰ç›®å½•ä¸ºç©º\n'));
                resolve(null);
                return;
            }

            console.log(chalk.bold.cyan('ğŸ“ å½“å‰ç›®å½•æ–‡ä»¶åˆ—è¡¨:\n'));

            files.forEach((file, index) => {
                const fullPath = path.join(currentDir, file);
                const isDir = fs.statSync(fullPath).isDirectory();
                const icon = isDir ? chalk.cyan('ğŸ“') : chalk.green('ğŸ“„');
                const padding = (index + 1).toString().padStart(2);
                console.log(`  [${padding}] ${icon} ${file}`);
            });
            console.log();

            rl.question(chalk.cyan('è¯·é€‰æ‹©æ–‡ä»¶ (è¾“å…¥åºå·ï¼Œæˆ–æŒ‰ Enter è¿”å›): '), (choice) => {
                if (choice.trim() === '') {
                    console.log(chalk.gray('å·²å–æ¶ˆé€‰æ‹©\n'));
                    resolve(null);
                    return;
                }

                const index = parseInt(choice) - 1;
                if (isNaN(index) || index < 0 || index >= files.length) {
                    console.log(chalk.red('æ— æ•ˆçš„åºå·\n'));
                    resolve(null);
                    return;
                }

                const selectedFile = files[index];
                console.log(chalk.green(`âœ“ å·²é€‰æ‹©: ${selectedFile}\n`));
                resolve(selectedFile);
            });
        } catch (error) {
            console.error(chalk.red(`è¯»å–ç›®å½•å¤±è´¥: ${error}\n`));
            resolve(null);
        }
    });
}

async function handleFileReference(filePath: string, question?: string): Promise<string> {
    const fullPath = path.resolve(filePath);

    if (!fs.existsSync(fullPath) || !fs.statSync(fullPath).isFile()) {
        console.log(chalk.red(`é”™è¯¯: æ–‡ä»¶ "${filePath}" ä¸å­˜åœ¨æˆ–ä¸æ˜¯ä¸€ä¸ªæ–‡ä»¶\n`));
        return question || '';
    }

    const spinner = ora(chalk.cyan('æ­£åœ¨è¯»å–æ–‡ä»¶...')).start();

    try {
        const content = fs.readFileSync(fullPath, 'utf-8');
        const relativePath = path.relative(process.cwd(), fullPath);

        const contentMap = new Map<string, string>();
        contentMap.set(relativePath, content);

        const prompt = buildPromptWithFileContent(
            `æ–‡ä»¶: ${relativePath}`,
            [relativePath],
            contentMap,
            question || `è¯·åˆ†ææ–‡ä»¶: ${relativePath}`
        );

        spinner.stop();
        console.log(chalk.green(`âœ“ å·²è¯»å–æ–‡ä»¶: ${relativePath}\n`));
        return prompt;
    } catch (error) {
        spinner.stop();
        console.error(chalk.red(`è¯»å–æ–‡ä»¶å¤±è´¥: ${error}\n`));
        return question || '';
    }
}

async function handleFileReferenceInput(input: string): Promise<string> {
    const match = input.match(/^@\s*(.+?)\s*(?:\n(.*))?$/s);
    if (!match) {
        console.log(chalk.yellow('æ ¼å¼é”™è¯¯ï¼Œæ­£ç¡®ç”¨æ³•: @æ–‡ä»¶è·¯å¾„ [é—®é¢˜]\n'));
        return '';
    }

    const filePath = match[1].trim();
    const question = match[2] ? match[2].trim() : '';
    return handleFileReference(filePath, question);
}

async function handleDirectoryReference(input: string): Promise<string> {
    const match = input.match(/^#\s*(.+?)\s*(?:\n(.*))?$/s);
    if (!match) {
        console.log(chalk.yellow('æ ¼å¼é”™è¯¯ï¼Œæ­£ç¡®ç”¨æ³•: # ç›®å½•è·¯å¾„ [é—®é¢˜]\n'));
        return input;
    }

    const dirPath = match[1].trim();
    const question = match[2] ? match[2].trim() : 'è¯·åˆ†æè¿™ä¸ªç›®å½•ä¸‹çš„æ–‡ä»¶';

    const fullPath = path.resolve(dirPath);

    if (!fs.existsSync(fullPath) || !fs.statSync(fullPath).isDirectory()) {
        console.log(chalk.red(`é”™è¯¯: ç›®å½• "${dirPath}" ä¸å­˜åœ¨æˆ–ä¸æ˜¯ä¸€ä¸ªç›®å½•\n`));
        return question;
    }

    const spinner = ora(chalk.cyan('æ­£åœ¨è¯»å–æ–‡ä»¶...')).start();

    try {
        const findCommand = process.platform === 'darwin' || process.platform === 'linux'
            ? `find "${fullPath}" -type f`
            : `dir /s /b "${fullPath}"`;

        const { stdout } = await execAsync(findCommand);
        const filePaths = stdout.trim().split('\n').filter(f => f);

        spinner.stop();

        if (filePaths.length === 0) {
            console.log(chalk.yellow(`ç›®å½• "${dirPath}" ä¸‹æ²¡æœ‰æ–‡ä»¶\n`));
            return question;
        }

        const contentMap = readFilesContent(filePaths);

        const relativeFilePaths = filePaths.map(p => path.relative(process.cwd(), p));

        const prompt = buildPromptWithFileContent(
            `ç›®å½•: ${dirPath}\næ‰¾åˆ° ${filePaths.length} ä¸ªæ–‡ä»¶`,
            relativeFilePaths,
            contentMap,
            question
        );

        const globalOptions = (global as any).yuangsOptions || {};
        if (globalOptions.showContextRelevance && question) {
            const { SmartContextManager } = await import('../agent/smartContextManager');
            const contextManager = new SmartContextManager();

            const enhancedContext = await contextManager.getEnhancedContext({
                query: question,
                minRelevance: 0.3,
                maxTokens: 5000,
                enableSmartSummary: true
            });

            if (enhancedContext.summary) {
                console.log(chalk.cyan('\nğŸ“Š Context Relevance Analysis\n'));
                console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                console.log(enhancedContext.summary);

                if (enhancedContext.rankedItems.length > 0) {
                    console.log(chalk.cyan('\nğŸ“‹ Ranked Files (Top 10)\n'));
                    enhancedContext.rankedItems.slice(0, 10).forEach((item, i) => {
                        const relevancePercent = (item.relevance * 100).toFixed(0);
                        const color = item.relevance > 0.8 ? chalk.green :
                            item.relevance > 0.5 ? chalk.yellow : chalk.gray;
                        console.log(`  ${i + 1}. ${color(item.path)} ${chalk.gray(`(${relevancePercent}%)`)}`);
                        if (item.matchReasons.length > 0) {
                            console.log(`     ${chalk.gray(item.matchReasons.join(', '))}`);
                        }
                    });
                }
                console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n');
            }
        }

        console.log(chalk.green(`âœ“ å·²è¯»å– ${contentMap.size} ä¸ªæ–‡ä»¶\n`));
        return prompt;
    } catch (error) {
        spinner.stop();
        console.error(chalk.red(`è¯»å–ç›®å½•å¤±è´¥: ${error}\n`));
        return question;
    }
}

export async function handleAIChat(initialQuestion: string | null, model?: string) {
    if (initialQuestion) {
        // å…ˆæ£€æŸ¥æ˜¯å¦ä¸ºç‰¹æ®Šè¯­æ³•
        const { handleSpecialSyntax } = await import('../utils/syntaxHandler');
        const result = await handleSpecialSyntax(initialQuestion);

        if (result.processed) {
            // å¦‚æœæ˜¯ç®¡ç†å‘½ä»¤ï¼ˆ:ls, :cat, :clearï¼‰ï¼Œç›´æ¥è¾“å‡ºç»“æœ
            if (result.result) {
                console.log(result.result);
            }
            return;
        }

        // ä¸æ˜¯ç‰¹æ®Šè¯­æ³•ï¼Œæ­£å¸¸å‘ç»™ AI
        const { AgentRuntime } = await import('../agent');
        const runtime = new AgentRuntime(getConversationHistory());

        const spinner = ora(chalk.cyan('AI æ­£åœ¨æ€è€ƒ...')).start();
        const renderer = new StreamMarkdownRenderer(chalk.bgHex('#3b82f6').white.bold(' ğŸ¤– AI ') + ' ', spinner, true);

        await runtime.run(initialQuestion, 'chat' as any, (chunk) => {
            renderer.onChunk(chunk);
        }, model, renderer);

        const fullResponse = renderer.finish();
        lastAIOutput = fullResponse;
        addToConversationHistory('user', initialQuestion);
        addToConversationHistory('assistant', fullResponse || '');
        return;
    }

    console.log(chalk.bold.cyan('\nğŸ¤– è¿›å…¥ AI äº¤äº’æ¨¡å¼ (è¾“å…¥ exit é€€å‡º)\n'));

    const contextStore = new ContextStore();
    const contextAssembler = new ContextAssembler();
    const persisted = await loadContext();
    contextStore.import(persisted);

    if (persisted.length > 0) {
        console.log(chalk.yellow(`ğŸ“¦ å·²æ¢å¤ ${persisted.length} æ¡ä¸Šä¸‹æ–‡\n`));
    }

    // åˆå§‹åŒ– AgentRuntime (v2.0 å¼•æ“)
    const { AgentRuntime } = await import('../agent');
    const runtime = new AgentRuntime(getConversationHistory());

    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
        terminal: true,
        completer: createCompleter(),
        historySize: 1000
    });

    readline.emitKeypressEvents(process.stdin);

    process.stdin.on('keypress', (str, key) => {
        if (key.ctrl && key.name === 'r') {
            rl.write(null, { ctrl: true, name: 'r' });
        }
        // Ctrl+Y: æ’å…¥æœ€åä¸€æ¡ AI è¾“å‡ºåˆ°å‘½ä»¤è¡Œ
        if (key.ctrl && key.name === 'y') {
            rl.write(lastAIOutput);
            console.log(chalk.gray('\n[å·²æ’å…¥æœ€åä¸€æ¡ AI è¾“å‡º]'));
        }
    });

    // Helper to wrap rl.question in a Promise
    const ask = (query: string): Promise<string> => {
        return new Promise((resolve) => {
            rl.question(query, (answer) => {
                resolve(answer);
            });
        });
    };

    try {
        while (true) {
            const input = await ask(chalk.green('ä½ ï¼š'));
            const trimmed = input.trim();

            const { handleSpecialSyntax } = await import('../utils/syntaxHandler');
            const specialResult = await handleSpecialSyntax(trimmed);
            if (specialResult.processed) {
                if (specialResult.result) {
                    console.log(specialResult.result);
                }
                continue;
            }

            // === åœºæ™¯ 5.1: åŸå­æ‰§è¡Œ (:exec) ===
            if (trimmed.startsWith(':exec ')) {
                const cmd = trimmed.slice(6).trim();
                if (cmd) {
                    console.log(chalk.cyan(`\nâš¡ï¸ [Atomic Exec] ${cmd}\n`));
                    rl.pause();
                    try {
                        await shellExecuteCommand(cmd, (code) => {
                            if (code !== 0) console.log(chalk.red(`Exited with ${code}`));
                        });
                    } finally {
                        rl.resume();
                    }
                }
                continue;
            }

            if (trimmed.startsWith('@')) {
                rl.pause();
                try {
                    // æ–°å¢ï¼šæ”¯æŒæ‰§è¡Œå‘½ä»¤çš„è¯­æ³•
                    // @ filename:command - æ·»åŠ å¹¶æ‰§è¡Œå‘½ä»¤
                    // @!filename - æ·»åŠ å¹¶ç«‹å³æ‰§è¡Œæ–‡ä»¶

                    const execMatch = trimmed.match(/^@\s*(.+?)\s*:\s*([^].*)?$/);
                    const immediateExecMatch = trimmed.match(/^@\s*!\s*(.+?)$/);

                    if (execMatch && execMatch[2]) {
                        // @ filename:command - æ·»åŠ å¹¶æ‰§è¡Œå‘½ä»¤
                        const filePath = execMatch[1].trim();
                        const commandStr = execMatch[2].trim();

                        const content = await readFileContent(filePath);

                        contextStore.add({
                            id: `file:${filePath}`,
                            source: 'file',
                            path: filePath,
                            content,
                            tokens: Math.ceil(content.length / 4),
                            importance: 0.5,
                            lastUsedAt: Date.now(),
                            addedAt: Date.now(),
                            status: 'active'
                        });

                        const displayName = filePath;
                        console.log(chalk.green(`âœ“ å·²åŠ å…¥æ–‡ä»¶ä¸Šä¸‹æ–‡: ${displayName}\n`));

                        await saveContext(contextStore.export());

                        console.log(chalk.cyan(`âš¡ï¸  æ­£åœ¨æ‰§è¡Œ: ${commandStr}\n`));

                        const { stdout, stderr } = await exec(commandStr, { cwd: path.dirname(filePath) });
                        console.log(stdout);
                        if (stderr) console.error(chalk.red(stderr));

                        await saveContext(contextStore.export());
                        console.log(chalk.green(`âœ“ æ‰§è¡Œå®Œæˆ\n`));

                        rl.resume();
                        continue;
                    }

                    if (immediateExecMatch) {
                        // åœºæ™¯ 3.2: @!filename - æ·»åŠ è„šæœ¬æºç å¹¶æ•è·æ‰§è¡Œè¾“å‡º
                        const filePath = immediateExecMatch[1].trim();
                        const fullPath = path.resolve(filePath);

                        if (fs.existsSync(fullPath)) {
                            // 1. è¯»å–æºç 
                            const sourceContent = await readFileContent(filePath);

                            console.log(chalk.cyan(`âš¡ï¸ æ­£åœ¨æ‰§è¡Œå¹¶æ•è·: ${filePath}\n`));

                            // 2. æ‰§è¡Œå¹¶æ•è·
                            const { stdout, stderr } = await execAsync(`chmod +x "${fullPath}" && "${fullPath}"`, { cwd: process.cwd() });
                            console.log(stdout); // å®æ—¶æ‰“å°ç»™ç”¨æˆ·çœ‹
                            if (stderr) console.error(chalk.red(stderr));

                            // 3. æ„é€ ç»„åˆä¸Šä¸‹æ–‡ (å¥‘çº¦ï¼šå‘½ä»¤å†…å®¹ + å®é™…è¾“å‡º)
                            const combinedContent = `
=== Source: ${filePath} ===
\`\`\`bash
${sourceContent}
\`\`\`

=== Stdout ===
\`\`\`
${stdout}
\`\`\`

=== Stderr ===
\`\`\`
${stderr}
\`\`\`
`;

                            contextStore.add({
                                id: `file:${filePath} [Run Log]`,
                                source: 'file',
                                path: `${filePath} [Run Log]`,
                                alias: 'Execution Log',
                                content: combinedContent,
                                tokens: Math.ceil(combinedContent.length / 4),
                                importance: 0.5,
                                lastUsedAt: Date.now(),
                                addedAt: Date.now(),
                                status: 'active'
                            });

                            await saveContext(contextStore.export());
                            console.log(chalk.green(`\nâœ“ å·²æ•è·è„šæœ¬æºç åŠæ‰§è¡Œæ—¥å¿—åˆ°ä¸Šä¸‹æ–‡\n`));
                        } else {
                            console.log(chalk.red(`é”™è¯¯: æ–‡ä»¶ ${filePath} ä¸å­˜åœ¨`));
                        }

                        rl.resume();
                        continue;
                    }

                    // å¢å¼ºçš„åŒ¹é…æ¨¡å¼ï¼Œæ”¯æŒè¡Œå·æŒ‡å®š: @ filepath:startLine-endLine as alias
                    const match = trimmed.match(/^@\s*(.+?)(?::(\d+)(?:-(\d+))?)?(?:\s+as\s+(.+))?$/);
                    const filePath = match?.[1] ?? (await showFileSelector(rl));
                    const lineStart = match?.[2] ? parseInt(match[2]) : null;
                    const lineEnd = match?.[3] ? parseInt(match[3]) : null;
                    const alias = match?.[4];

                    if (!filePath) continue;

                    const absolutePath = path.resolve(filePath);
                    let content = await fs.promises.readFile(absolutePath, 'utf-8');

                    // å¦‚æœæŒ‡å®šäº†è¡Œå·èŒƒå›´ï¼Œåˆ™æå–ç›¸åº”è¡Œ
                    if (lineStart !== null) {
                        const lines = content.split('\n');

                        // éªŒè¯è¡Œå·èŒƒå›´
                        if (lineStart < 1 || lineStart > lines.length) {
                            console.log(chalk.red(`\né”™è¯¯: èµ·å§‹è¡Œå· ${lineStart} è¶…å‡ºæ–‡ä»¶èŒƒå›´ (æ–‡ä»¶å…±æœ‰ ${lines.length} è¡Œ)\n`));
                            rl.resume();
                            continue;
                        }

                        const startIdx = lineStart - 1; // è½¬æ¢ä¸ºæ•°ç»„ç´¢å¼•ï¼ˆä»0å¼€å§‹ï¼‰
                        let endIdx = lineEnd ? Math.min(lineEnd, lines.length) : lines.length; // å¦‚æœæœªæŒ‡å®šç»“æŸè¡Œï¼Œåˆ™åˆ°æ–‡ä»¶æœ«å°¾

                        if (lineEnd && (lineEnd < lineStart || lineEnd > lines.length)) {
                            console.log(chalk.red(`\né”™è¯¯: ç»“æŸè¡Œå· ${lineEnd} è¶…å‡ºæœ‰æ•ˆèŒƒå›´ (åº”åœ¨ ${lineStart}-${lines.length} ä¹‹é—´)\n`));
                            rl.resume();
                            continue;
                        }

                        // æå–æŒ‡å®šèŒƒå›´çš„è¡Œ
                        content = lines.slice(startIdx, endIdx).join('\n');

                        // æ›´æ–°è·¯å¾„æ˜¾ç¤ºï¼ŒåŒ…å«è¡Œå·ä¿¡æ¯
                        const rangeInfo = lineEnd ? `${lineStart}-${lineEnd}` : `${lineStart}`;
                        const pathWithRange = `${filePath}:${rangeInfo}`;

                        contextStore.add({
                            id: `file:${pathWithRange}`,
                            source: 'file',
                            path: pathWithRange,
                            alias,
                            content,
                            tokens: Math.ceil(content.length / 4),
                            importance: 0.5,
                            lastUsedAt: Date.now(),
                            addedAt: Date.now(),
                            status: 'active'
                        });
                    } else {
                        // åŸå§‹è¡Œä¸ºï¼šæ·»åŠ æ•´ä¸ªæ–‡ä»¶
                        contextStore.add({
                            id: `file:${filePath}`,
                            source: 'file',
                            path: filePath,
                            alias,
                            content,
                            tokens: Math.ceil(content.length / 4),
                            importance: 0.5,
                            lastUsedAt: Date.now(),
                            addedAt: Date.now(),
                            status: 'active'
                        });
                    }

                    await saveContext(contextStore.export());
                    const displayName = alias ? `${alias} (${filePath}${lineStart !== null ? `:${lineStart}${lineEnd ? `-${lineEnd}` : ''}` : ''})` :
                        (filePath + (lineStart !== null ? `:${lineStart}${lineEnd ? `-${lineEnd}` : ''}` : ''));
                    console.log(chalk.green(`âœ… å·²åŠ å…¥æ–‡ä»¶ä¸Šä¸‹æ–‡: ${displayName}\n`));
                } catch (err: unknown) {
                    const message = err instanceof Error ? err.message : String(err);
                    console.error(chalk.red(`\n[å¤„ç†é”™è¯¯]: ${message}\n`));
                } finally {
                    rl.resume();
                }
                continue;
            }

            if (trimmed.startsWith('#')) {
                rl.pause();
                try {
                    const match = trimmed.match(/^#\s*(.+?)\s*(?:\n(.*))?$/s);
                    if (!match) {
                        console.log(chalk.yellow('æ ¼å¼é”™è¯¯ï¼Œæ­£ç¡®ç”¨æ³•: # ç›®å½•è·¯å¾„\n'));
                        rl.resume();
                        continue;
                    }

                    const dirPath = match[1].trim();
                    const fullPath = path.resolve(dirPath);

                    if (!fs.existsSync(fullPath) || !fs.statSync(fullPath).isDirectory()) {
                        console.log(chalk.red(`é”™è¯¯: ç›®å½• "${dirPath}" ä¸å­˜åœ¨æˆ–ä¸æ˜¯ä¸€ä¸ªç›®å½•\n`));
                        rl.resume();
                        continue;
                    }

                    const findCommand = process.platform === 'darwin' || process.platform === 'linux'
                        ? `find "${fullPath}" -type f`
                        : `dir /s /b "${fullPath}"`;

                    const { stdout } = await execAsync(findCommand);
                    const filePaths = stdout.trim().split('\n').filter(f => f);

                    if (filePaths.length === 0) {
                        console.log(chalk.yellow(`ç›®å½• "${dirPath}" ä¸‹æ²¡æœ‰æ–‡ä»¶\n`));
                        rl.resume();
                        continue;
                    }

                    const userConfig = getUserConfig();
                    const maxFileTokens = userConfig.maxFileTokens || 20000;
                    const maxTotalTokensLimit = userConfig.maxTotalTokens || 200000;
                    const contentMap = readFilesContent(filePaths);

                    // é€ä¸ªæ·»åŠ æ–‡ä»¶ï¼Œè€Œä¸æ˜¯å°†æ‰€æœ‰å†…å®¹åˆå¹¶ä¸ºä¸€ä¸ªå¤§çš„ç›®å½•é¡¹
                    // è¿™æ ·å¯ä»¥æ›´å¥½åœ°æ§åˆ¶tokenä½¿ç”¨ï¼Œå¹¶ä¿ç•™ä¹‹å‰çš„ä¸Šä¸‹æ–‡
                    let addedCount = 0;
                    for (const [filePath, content] of contentMap) {
                        // æ£€æŸ¥å•ä¸ªæ–‡ä»¶å¤§å°ï¼Œå¦‚æœå¤ªå¤§åˆ™è·³è¿‡
                        const fileTokens = Math.ceil(content.length / 4);
                        if (fileTokens > maxFileTokens) { // ä½¿ç”¨é…ç½®çš„æ–‡ä»¶ä¸Šé™
                            console.log(chalk.yellow(`âš ï¸  è·³è¿‡å¤§æ–‡ä»¶: ${filePath} (å¤ªå¤§)`));
                            continue;
                        }

                        contextStore.add({
                            id: `file:${filePath}`,
                            source: 'file',
                            path: filePath,
                            content: content,
                            tokens: Math.ceil(content.length / 4),
                            importance: 0.5,
                            lastUsedAt: Date.now(),
                            addedAt: Date.now(),
                            status: 'active'
                        });
                        addedCount++;

                        // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°tokené™åˆ¶ï¼Œå¦‚æœè¾¾åˆ°åˆ™åœæ­¢æ·»åŠ æ›´å¤šæ–‡ä»¶
                        // æˆ‘ä»¬éœ€è¦æ‰‹åŠ¨è®¡ç®—æ€»tokensï¼Œå› ä¸ºtotalTokensæ˜¯ç§æœ‰æ–¹æ³•
                        const currentTotalTokens = contextStore.export().reduce((sum, item) => sum + item.tokens, 0);
                        if (currentTotalTokens > maxTotalTokensLimit) { // ä½¿ç”¨æ€»ä¸Šä¸‹æ–‡ä¸Šé™
                            console.log(chalk.yellow(`âš ï¸  è¾¾åˆ°tokené™åˆ¶ï¼Œåœæ­¢æ·»åŠ æ›´å¤šæ–‡ä»¶`));
                            break;
                        }
                    }

                    await saveContext(contextStore.export());
                    console.log(chalk.green(`âœ“ å·²æˆåŠŸåŠ å…¥ ${addedCount} ä¸ªæ–‡ä»¶åˆ°ä¸Šä¸‹æ–‡\n`));
                } catch (err: unknown) {
                    const message = err instanceof Error ? err.message : String(err);
                    console.error(chalk.red(`\n[å¤„ç†é”™è¯¯]: ${message}\n`));
                } finally {
                    rl.resume();
                }
                continue;
            }

            if (['exit', 'quit', 'bye'].includes(trimmed.toLowerCase())) {
                console.log(chalk.cyan('ğŸ‘‹ å†è§ï¼'));
                break;
            }

            if (trimmed === '/clear') {
                clearConversationHistory();
                console.log(chalk.yellow('âœ“ å¯¹è¯å†å²å·²æ¸…ç©º\n'));
                continue;
            }

            if (trimmed === '/history') {
                const history = getConversationHistory();
                if (history.length === 0) {
                    console.log(chalk.gray('æš‚æ— å¯¹è¯å†å²\n'));
                } else {
                    history.forEach((msg) => {
                        const prefix = msg.role === 'user' ? chalk.green('ä½ : ') : chalk.blue('AI: ');
                        console.log(prefix + msg.content);
                    });
                }
                continue;
            }

            if (trimmed === ':ls') {
                const list = contextStore.list();
                if (list.length === 0) {
                    console.log(chalk.gray('ğŸ“­ å½“å‰æ²¡æœ‰ä¸Šä¸‹æ–‡\n'));
                } else {
                    console.table(list);
                }
                continue;
            }

            if (trimmed === ':cat' || trimmed.startsWith(':cat ')) {
                const parts = trimmed.split(' ');
                const index = parts.length > 1 ? parseInt(parts[1]) : null;
                const items = contextStore.export();

                if (items.length === 0) {
                    console.log(chalk.gray('ğŸ“­ å½“å‰æ²¡æœ‰ä¸Šä¸‹æ–‡å†…å®¹å¯æŸ¥é˜…\n'));
                } else if (index !== null) {
                    if (index < 1 || index > items.length) {
                        console.log(chalk.red(`âŒ ç´¢å¼• ${index} è¶…å‡ºèŒƒå›´ (1-${items.length})\n`));
                    } else {
                        const item = items[index - 1];
                        console.log(chalk.cyan(`\n=== [${index}] ${item.path} ===`));
                        console.log(item.content);
                        console.log(chalk.cyan(`=== End ===\n`));
                    }
                } else {
                    console.log(chalk.cyan('\n=== å½“å‰å®Œæ•´ä¸Šä¸‹æ–‡å†…å®¹ ==='));
                    items.forEach((item, i) => {
                        console.log(chalk.yellow(`\n--- [${i + 1}] ${item.path} ---`));
                        console.log(item.content);
                    });
                    console.log(chalk.cyan('\n==========================\n'));
                }
                continue;
            }

            if (trimmed === ':clear') {
                contextStore.clear();
                await clearContextStorage();
                console.log(chalk.yellow('ğŸ§¹ ä¸Šä¸‹æ–‡å·²æ¸…ç©ºï¼ˆå«æŒä¹…åŒ–ï¼‰\n'));
                continue;
            }

            if (trimmed === ':plugins') {
                const plugins = listPlugins();
                if (plugins.length === 0) {
                    console.log(chalk.gray('ğŸ“­ å½“å‰æ²¡æœ‰åŠ è½½çš„æ’ä»¶\n'));
                } else {
                    console.log(chalk.cyan('å·²åŠ è½½çš„æ’ä»¶:\n'));
                    plugins.forEach(p => console.log(chalk.green(`  - ${p}`)));
                    console.log();
                }
                continue;
            }

            // æ£€æµ‹ yuangs macro å‘½ä»¤ï¼Œé€ä¼ æ‰§è¡Œä¸ç»è¿‡AI
            if (trimmed.startsWith('yuangs macro') || trimmed.startsWith('ygs macro')) {
                rl.pause();
                try {
                    const parts = trimmed.split(/\s+/);
                    if (parts.length >= 3) { // è‡³å°‘æœ‰ 'yuangs', 'macro', 'name'
                        const macroName = parts[2];
                        console.log(chalk.cyan(`\nğŸ”„ æ‰§è¡Œå®: ${macroName}\n`));

                        const success = runMacro(macroName);
                        if (success) {
                            console.log(chalk.green(`âœ“ å® "${macroName}" æ‰§è¡Œå®Œæˆ\n`));
                        } else {
                            console.log(chalk.red(`âœ— å® "${macroName}" ä¸å­˜åœ¨æˆ–æ‰§è¡Œå¤±è´¥\n`));
                        }
                    } else {
                        console.log(chalk.yellow('ç”¨æ³•: yuangs macro <name> æˆ– ygs macro <name>\n'));
                    }
                } catch (err: unknown) {
                    const message = err instanceof Error ? err.message : String(err);
                    console.error(chalk.red(`\n[Macro Error]: ${message}`));
                } finally {
                    rl.resume();
                }
                continue;
            }

            // Alternative Zero-Mode entry: :ai command
            if (trimmed === ':ai') {
                rl.pause();
                try {
                    console.log(chalk.cyan('AI æ¨¡å¼å¯åŠ¨...\n'));

                    // Use empty context or current context for AI interaction
                    let finalPrompt = contextStore.isEmpty()
                        ? 'ä½ å¥½ï¼Œè¯·å¼€å§‹å¯¹è¯'
                        : contextAssembler.assemble(contextStore, 'ä½ å¥½ï¼Œè¯·åŸºäºä»¥ä¸Šä¸Šä¸‹æ–‡å¼€å§‹å¯¹è¯');

                    const spinner = ora(chalk.cyan('AI æ­£åœ¨æ€è€ƒ...')).start();
                    const renderer = new StreamMarkdownRenderer(chalk.bgHex('#3b82f6').white.bold(' ğŸ¤– AI ') + ' ', spinner, true);

                    await runtime.run(finalPrompt, 'chat' as any, (chunk) => {
                        renderer.onChunk(chunk);
                    }, model, renderer);

                    const fullResponse = renderer.finish();
                    lastAIOutput = fullResponse;

                    // åŒæ­¥ä¸Šä¸‹æ–‡åˆ°å…¨å±€å†å²ï¼ˆä¸ºäº†å…¼å®¹æ€§ï¼‰
                    addToConversationHistory('user', finalPrompt);
                    addToConversationHistory('assistant', fullResponse);
                } catch (err: unknown) {
                    const message = err instanceof Error ? err.message : String(err);
                    console.error(chalk.red(`\n[AI execution error]: ${message}`));
                } finally {
                    rl.resume();
                }
                continue;
            }

            if (!trimmed) {
                // Empty line + Enter as alternative to ?? for Zero-Mode
                rl.pause();
                try {
                    console.log(chalk.cyan('AI æ¨¡å¼å¯åŠ¨ (ç©ºè¡Œè§¦å‘)...\n'));

                    // Use empty context or current context for AI interaction
                    let finalPrompt = contextStore.isEmpty()
                        ? 'ä½ å¥½ï¼Œè¯·å¼€å§‹å¯¹è¯'
                        : contextAssembler.assemble(contextStore, 'ä½ å¥½ï¼Œè¯·åŸºäºä»¥ä¸Šä¸Šä¸‹æ–‡å¼€å§‹å¯¹è¯');

                    const spinner = ora(chalk.cyan('AI æ­£åœ¨æ€è€ƒ...')).start();
                    const renderer = new StreamMarkdownRenderer(chalk.bgHex('#3b82f6').white.bold(' ğŸ¤– AI ') + ' ', spinner, true);

                    await runtime.run(finalPrompt, 'chat' as any, (chunk) => {
                        renderer.onChunk(chunk);
                    }, model, renderer);

                    const fullResponse = renderer.finish();
                    lastAIOutput = fullResponse;

                    // åŒæ­¥ä¸Šä¸‹æ–‡åˆ°å…¨å±€å†å²ï¼ˆä¸ºäº†å…¼å®¹æ€§ï¼‰
                    addToConversationHistory('user', finalPrompt);
                    addToConversationHistory('assistant', fullResponse);
                } catch (err: unknown) {
                    const message = err instanceof Error ? err.message : String(err);
                    console.error(chalk.red(`\n[AI execution error]: ${message}`));
                } finally {
                    rl.resume();
                }
                continue;
            }

            // Check for ?? pattern which could be expanded by shell glob
            if (trimmed === '??' || trimmed.startsWith('?? ')) {
                const globMatches = wouldExpandAsGlob('??', process.cwd());
                if (globMatches.wouldExpand) {
                    console.log(chalk.yellow('âš ï¸  Zeroâ€‘Mode è§¦å‘ç¬¦ \'??\' åœ¨å½“å‰ç›®å½•å¯èƒ½è¢«è§£é‡Šä¸ºæ–‡ä»¶åå±•å¼€ï¼š'));
                    console.log(chalk.gray('åŒ¹é…åˆ°ï¼š'));
                    globMatches.matches.forEach(match => {
                        console.log(chalk.gray(`- ${match}`));
                    });
                    console.log(chalk.gray('\nè¯·ä½¿ç”¨ \':ai\' æˆ–ç©ºè¡Œ + Enter è¿›å…¥ Zeroâ€‘Mode'));
                    continue; // Skip processing and go to next input
                }
            }

            const mode = detectMode(trimmed);

            if (mode === 'command') {
                rl.pause();
                try {
                    await shellExecuteCommand(trimmed, (code) => {
                        if (code !== 0) {
                            console.log(chalk.red(`\n[command exited with code ${code}]\n`));
                        }
                    });
                } catch (err: unknown) {
                    const message = err instanceof Error ? err.message : String(err);
                    console.error(chalk.red(`\n[Command Error]: ${message}`));
                } finally {
                    rl.resume();
                }
                continue;
            }

            let finalPrompt = contextStore.isEmpty()
                ? trimmed
                : contextAssembler.assemble(contextStore, trimmed);

            const gitContext = await getGitContext();

            if (gitContext) {
                finalPrompt = `
${gitContext}

${finalPrompt}
`;
            }

            try {
                rl.pause();

                // ä½¿ç”¨ AgentRuntime æ‰§è¡Œæé—®
                const spinner = ora(chalk.cyan('AI æ­£åœ¨æ€è€ƒ...')).start();
                const renderer = new StreamMarkdownRenderer(chalk.bgHex('#3b82f6').white.bold(' ğŸ¤– AI ') + ' ', spinner, true);

                await runtime.run(finalPrompt, 'chat' as any, (chunk) => {
                    renderer.onChunk(chunk);
                }, model, renderer);

                    const fullResponse = renderer.finish();
                    lastAIOutput = fullResponse;

                // åŒæ­¥ä¸Šä¸‹æ–‡åˆ°å…¨å±€å†å²ï¼ˆä¸ºäº†å…¼å®¹æ€§ï¼‰
                addToConversationHistory('user', finalPrompt);
                addToConversationHistory('assistant', fullResponse);
            } catch (err: unknown) {
                const message = err instanceof Error ? err.message : String(err);
                console.error(chalk.red(`\n[AI execution error]: ${message}`));
            } finally {
                rl.resume();
            }
        }
    } catch (criticalErr: unknown) {
        const message = criticalErr instanceof Error ? criticalErr.message : String(criticalErr);
        console.error(chalk.red(`\n[Critical Loop Error]: ${message}`));
    } finally {
        rl.close();
    }
}

async function askOnceStream(question: string, model?: string) {
    const messages = [...getConversationHistory()];
    messages.push({ role: 'user', content: question });

    const spinner = ora(chalk.cyan('AI æ­£åœ¨æ€è€ƒ...')).start();

    // åˆå§‹åŒ–æ¸²æŸ“å™¨
    const renderer = new StreamMarkdownRenderer(chalk.bgHex('#3b82f6').white.bold(' ğŸ¤– AI ') + ' ', spinner, true);

    try {
        await callAI_Stream(messages, model, (chunk) => {
            renderer.onChunk(chunk);
        });

        const fullResponse = renderer.finish();
        lastAIOutput = fullResponse;

        addToConversationHistory('user', question);
        addToConversationHistory('assistant', fullResponse);
    } catch (error: any) {
        if (spinner.isSpinning) {
            spinner.stop();
        }
        throw error;
    }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ commands/handleAICommand.ts

````typescript
import chalk from 'chalk';
import ora from 'ora';
import { getOSProfile } from '../core/os';
import { buildCommandPrompt } from '../ai/prompt';
import { askAI } from '../ai/client';
import { exec } from '../core/executor';
import { assessRisk } from '../core/risk';
import { autoFixCommand } from '../core/autofix';
import { confirm } from '../utils/confirm';
import { saveHistory } from '../utils/history';
import { safeParseJSON, AICommandPlan, AIFixPlan } from '../core/validation';
import { getMacros, runMacro } from '../core/macros';
import { CapabilitySystem } from '../core/capabilitySystem';
import { inferCapabilityRequirement } from '../core/capabilityInference';
import { CapabilityMatchResult } from '../core/modelMatcher';
import { ContextBuffer } from './contextBuffer';
import { loadContext, saveContext } from './contextStorage';

function validateAIPlan(obj: any): obj is AICommandPlan {
    return (
        typeof obj === 'object' &&
        obj !== null &&
        typeof obj.plan === 'string' &&
        ['low', 'medium', 'high'].includes(obj.risk) &&
        (typeof obj.command === 'string' || typeof obj.macro === 'string')
    );
}

export async function handleAICommand(
    userInput: string,
    options: { execute: boolean; model?: string; dryRun?: boolean; autoYes?: boolean; verbose?: boolean }
) {
    const os = getOSProfile();
    const macros = getMacros();
    const capabilitySystem = new CapabilitySystem();
    const spinner = ora(chalk.cyan('ğŸ§  AI æ­£åœ¨è§„åˆ’ä¸­...')).start();

    const startTime = Date.now();

    try {
        const requirement = inferCapabilityRequirement(userInput);

        let matchResult: CapabilityMatchResult;
        let selectedModel: string;

        if (options.model) {
            matchResult = {
                selected: null,
                candidates: [],
                fallbackOccurred: false,
            };

            selectedModel = options.model;
        } else {
            matchResult = capabilitySystem.matchCapability(requirement);
            selectedModel = matchResult.selected?.name || 'Assistant';
        }

        spinner.stop();
        
        // Load context
        const contextBuffer = new ContextBuffer();
        const persistedContext = await loadContext();
        contextBuffer.import(persistedContext);
        const contextStr = contextBuffer.isEmpty() ? '' : contextBuffer.buildPrompt('');

        const prompt = buildCommandPrompt(userInput, os, macros, contextStr);
        const raw = await askAI(prompt, selectedModel);

        const { aiCommandPlanSchema } = require('../core/validation');
        const parseResult = safeParseJSON(raw, aiCommandPlanSchema, {} as AICommandPlan);

        if (!parseResult.success) {
            console.log(chalk.red('\nâŒ AI è¾“å‡ºä¸æ˜¯åˆæ³• JSON:'));
            console.log(raw);
            console.log(chalk.gray('\néªŒè¯é”™è¯¯: ' + parseResult.error.issues.map((e: any) => e.message).join(', ')));
            return { code: 1 };
        }

        const plan = parseResult.data;

        const isUsingMacro = !!plan.macro;
        let actualCommand = plan.macro ? macros[plan.macro]?.commands : plan.command;

        if (!actualCommand) {
            console.log(chalk.red('\nâŒ æ— æ•ˆçš„è®¡åˆ’ï¼š'));
            if (plan.macro) {
                console.log(chalk.red(`æœªæ‰¾åˆ°åä¸º "${plan.macro}" çš„ Macro`));
            } else {
                console.log(chalk.red('æœªæä¾›æœ‰æ•ˆçš„å‘½ä»¤'));
            }
            return { code: 1 };
        }

        const commandToExecute: string = actualCommand;
        const finalRisk = assessRisk(commandToExecute, plan.risk);

        console.log(chalk.bold.cyan('\nğŸ§  è®¡åˆ’: ') + plan.plan);

        if (isUsingMacro) {
            console.log(chalk.bold.green('âœ¨ å¤ç”¨ Macro: ') + chalk.yellow(plan.macro!));
            console.log(chalk.gray('   (å·²éªŒè¯çš„å‘½ä»¤ï¼Œæ— éœ€é‡æ–°ç”Ÿæˆ)'));
        } else {
            console.log(chalk.bold.green('ğŸ’» å‘½ä»¤: ') + chalk.yellow(commandToExecute));
        }

        const riskColor = finalRisk === 'high' ? chalk.red : (finalRisk === 'medium' ? chalk.yellow : chalk.green);
        console.log(chalk.bold('âš ï¸  é£é™©åˆ¤æ–­: ') + riskColor(finalRisk.toUpperCase()));

        if (options.verbose) {
            console.log(chalk.bold.cyan('\nğŸ” Capability åŒ¹é…è¯¦æƒ…:'));
            console.log(chalk.gray(`  ç”¨æˆ·æ„å›¾èƒ½åŠ›: ${requirement.required.join(', ')}`));
            console.log(chalk.gray(`  ä½¿ç”¨çš„æ¨¡å‹: ${selectedModel}`));

            if (matchResult.selected) {
                console.log(chalk.gray(`  æ¨¡å‹èƒ½åŠ›è¦†ç›–: ${matchResult.selected.atomicCapabilities.join(', ')}`));
            }

            if (matchResult.fallbackOccurred) {
                console.log(chalk.yellow('  âš ï¸  è§¦å‘äº† Fallback'));
            }

            matchResult.candidates.forEach(c => {
                const icon = c.hasRequired ? chalk.green('âœ“') : chalk.red('âœ—');
                console.log(chalk.gray(`  ${icon} ${c.modelName}: ${c.reason}`));
            });
        }

        if (options.dryRun) {
            console.log(chalk.gray('\n[Dry Run] ä»…æ¨¡æ‹Ÿï¼Œä¸æ‰§è¡Œå‘½ä»¤ã€‚'));
            return { code: 0 };
        }

        console.log(chalk.gray('â”€'.repeat(50)));
        if (isUsingMacro) {
            console.log(chalk.yellow('âš ï¸  æ³¨æ„: AI æ­£åœ¨å¤ç”¨å·²éªŒè¯çš„ Macroã€‚'));
        } else {
            console.log(chalk.yellow('âš ï¸  æ³¨æ„: ä»¥ä¸Šå‘½ä»¤ç”± AI ç”Ÿæˆï¼Œè¯·åœ¨æ‰§è¡Œå‰ä»”ç»†æ£€æŸ¥ã€‚'));
            console.log(chalk.gray('   AI å¯èƒ½ä¼šçŠ¯é”™ï¼Œå®‰å…¨ç”±æ‚¨æŒæ§ã€‚'));
        }
        console.log(chalk.gray('â”€'.repeat(50)));

        let shouldExecute = options.execute || options.autoYes;

        if (!shouldExecute) {
            shouldExecute = await confirm('æ˜¯å¦æ‰§è¡Œè¯¥å‘½ä»¤ï¼Ÿ');
        }

        if (!shouldExecute) {
            console.log(chalk.gray('æ‰§è¡Œå·²å–æ¶ˆã€‚'));
            return { code: 1 };
        }

        console.log(chalk.gray('\næ‰§è¡Œä¸­...\n'));
        let result: { code: number | null; stdout?: string; stderr?: string };

        if (isUsingMacro) {
            const macroSuccess = runMacro(plan.macro!);
            result = { code: 0, stdout: '', stderr: '' };
            console.log(chalk.green('âœ“ Macro å·²æ‰§è¡Œ'));
        } else {
            result = await exec(commandToExecute);
        }

        const latencyMs = Date.now() - startTime;

        if (!isUsingMacro && result.code !== 0 && result.code !== null) {
            // === Anti-Pattern Memory ===
            const failBuffer = new ContextBuffer();
            const persistedFailContext = await loadContext();
            failBuffer.import(persistedFailContext);

            failBuffer.add({
                type: 'antipattern',
                path: `fail:${userInput}`,
                content: `
Intent:
${userInput}

Command:
${commandToExecute}

Error:
${result.stderr}
`,
                tags: ['failure', 'command']
            });

            await saveContext(failBuffer.export());

            console.log(chalk.red('\nâŒ æ‰§è¡Œå¤±è´¥ï¼Œå°è¯•è‡ªåŠ¨ä¿®å¤...'));
            const fixedPlan = await autoFixCommand(
                commandToExecute,
                result.stderr!,
                os,
                selectedModel
            );

            if (fixedPlan && fixedPlan.command) {
                console.log(chalk.bold.cyan('ğŸ” ä¿®å¤æ–¹æ¡ˆ: ') + fixedPlan.plan);
                console.log(chalk.bold.green('ğŸ’» ä¿®å¤å‘½ä»¤: ') + chalk.yellow(fixedPlan.command));

                const retry = await confirm('æ˜¯å¦æ‰§è¡Œä¿®å¤åçš„å‘½ä»¤ï¼Ÿ');
                if (retry) {
                    console.log(chalk.gray('\næ­£åœ¨é‡è¯•...\n'));
                    result = await exec(fixedPlan.command);
                    if (result.code === 0) {
                        saveHistory({
                            question: userInput,
                            command: fixedPlan.command,
                        });
                        console.log(chalk.green('\nâœ“ ä¿®å¤å‘½ä»¤æ‰§è¡ŒæˆåŠŸå¹¶å·²å­˜å…¥å†å²åº“'));
                        return result;
                    }
                }
            }
        }

        if (result.code === 0) {
            saveHistory({
                question: userInput,
                command: commandToExecute,
            });

            if (isUsingMacro) {
                console.log(chalk.green('\nâœ“ Macro æ‰§è¡ŒæˆåŠŸå¹¶å·²å­˜å…¥å†å²åº“'));
            } else {
                console.log(chalk.green('\nâœ“ æ‰§è¡ŒæˆåŠŸå¹¶å·²å­˜å…¥å†å²åº“'));
            }

            const reward =
                result.code === 0
                    ? latencyMs < 500 ? 1 : 0.5
                    : -1;

            if (!isUsingMacro) {
                capabilitySystem.createAndSaveExecutionRecord(
                    'ai-command',
                    requirement,
                    matchResult,
                    commandToExecute,
                    userInput,
                    'command'
                );

                const { listExecutionRecords, saveExecutionRecord } = await import('../core/executionStore');
                const records = listExecutionRecords(1);
                if (records.length > 0) {
                    const lastRecord = records[0];
                    lastRecord.outcome.reward = reward;
                    saveExecutionRecord(lastRecord);
                }
            }

            // === Execution Result to Context ===
            const successBuffer = new ContextBuffer();
            const persistedContext = await loadContext();
            successBuffer.import(persistedContext);

            successBuffer.add({
                type: 'memory',
                path: `Execution: ${commandToExecute}`,
                alias: 'Last Successful Execution',
                content: `
Command:
${commandToExecute}

Stdout:
${result.stdout ?? ''}

Stderr:
${result.stderr ?? ''}
`
            }, true);

            await saveContext(successBuffer.export());

            // === Trigger Reflection ===
            if (Math.random() < 0.1) {
                try {
                    const { ReflectionAgent } = await import('../agent/ReflectionAgent');
                    await ReflectionAgent.run();
                } catch (error) {
                    // Reflection is optional, fail silently
                }
            }

            // Clear context after successful one-shot command execution
            await saveContext([]);
        }

        return result;
    } catch (error: unknown) {
        const message = error instanceof Error ? error.message : String(error);
        spinner.fail(chalk.red('å‘ç”Ÿé”™è¯¯: ' + message));
        return { code: 1 };
    }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ commands/handleConfig.ts

````typescript
import fs from 'fs';
import path from 'path';
import os from 'os';
import chalk from 'chalk';
import { parseUserConfig, userConfigSchema, type UserConfig } from '../core/validation';

const CONFIG_FILE = path.join(os.homedir(), '.yuangs.json');

export function handleConfig(args: string[]) {
    const action = args[0]; // get, set, list

    if (!action || action === 'list') {
        const config = readConfig();
        console.log(chalk.bold.cyan('\nâš™ï¸  å½“å‰é…ç½® (~/.yuangs.json):\n'));
        if (Object.keys(config).length === 0) {
            console.log(chalk.gray('  (é…ç½®æ–‡ä»¶ä¸å­˜åœ¨æˆ–ä¸ºç©º)'));
        } else {
            Object.entries(config).forEach(([key, value]) => {
                console.log(`  ${chalk.white(key)}: ${chalk.green(value)}`);
            });
        }
        console.log('\nä½¿ç”¨æ–¹æ³•:');
        console.log(chalk.gray('  yuangs config set <key> <value>'));
        console.log(chalk.gray('  yuangs config get <key>\n'));
        return;
    }

    if (action === 'set') {
        const key = args[1];
        const value = args[2];
        if (!key || !value) {
            console.log(chalk.red('é”™è¯¯: è¯·æä¾› key å’Œ valueã€‚ä¾‹å¦‚: yuangs config set defaultModel gemini-2.5-flash-lite'));
            return;
        }
        const config = readConfig();
        config[key] = value;
        writeConfig(config);
        console.log(chalk.green(`âœ“ å·²å°† ${key} è®¾ç½®ä¸º ${value}`));
        return;
    }

    if (action === 'get') {
        const key = args[1];
        if (!key) {
            console.log(chalk.red('é”™è¯¯: è¯·æä¾› keyã€‚ä¾‹å¦‚: yuangs config get defaultModel'));
            return;
        }
        const config = readConfig();
        if (config[key] !== undefined) {
            console.log(config[key]);
        } else {
            console.log(chalk.yellow(`é…ç½®é¡¹ ${key} ä¸å­˜åœ¨`));
        }
        return;
    }
}

function readConfig(): UserConfig {
    if (fs.existsSync(CONFIG_FILE)) {
        try {
            return parseUserConfig(fs.readFileSync(CONFIG_FILE, 'utf8'));
        } catch (e) {
            return {};
        }
    }
    return {};
}

function writeConfig(config: UserConfig) {
    const validated = userConfigSchema.parse(config);
    fs.writeFileSync(CONFIG_FILE, JSON.stringify(validated, null, 2));
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ commands/preferencesCommands.ts

````typescript
import chalk from 'chalk';
import { Command } from 'commander';
import {
  PreferencesManager,
  buildPersonalizedPrompt,
  applyOutputFormat,
  buildContextStrategyPrompt
} from '../agent/preferences';

export function registerPreferencesCommands(program: Command): void {
  const preferencesProgram = program
    .command('preferences')
    .description('Manage AI interaction preferences');

  // List all preferences
  preferencesProgram
    .command('list')
    .description('List all current preferences')
    .action(() => {
      const prefs = PreferencesManager.getPreferences();

      console.log(chalk.bold.cyan('\nğŸ“‹ Current Preferences\n'));
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');

      Object.entries(prefs).forEach(([key, value]) => {
        const formattedKey = formatKey(key);
        const formattedValue = formatValue(key, value);
        console.log(`  ${chalk.bold(formattedKey)}: ${formattedValue}`);
      });

      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n');
    });

  // Get a specific preference
  preferencesProgram
    .command('get <key>')
    .description('Get a specific preference value')
    .action((key: string) => {
      const prefs = PreferencesManager.getPreferences();

      if (key in prefs) {
        const formattedKey = formatKey(key);
        const formattedValue = formatValue(key, (prefs as any)[key]);
        console.log(chalk.bold.cyan(`${formattedKey}: ${formattedValue}`));
      } else {
        console.log(chalk.red(`Unknown preference: ${key}`));
        console.log(chalk.gray('Use "yuangs preferences list" to see all available preferences.'));
      }
    });

  // Set a preference
  preferencesProgram
    .command('set <key> <value>')
    .description('Set a preference value')
    .action((key: string, value: string) => {
      const parsedValue = parseValue(key, value);

      if (parsedValue === null) {
        console.log(chalk.red(`Invalid value for ${key}: ${value}`));
        return;
      }

      PreferencesManager.setPreferences({ [key]: parsedValue } as any);
      const formattedKey = formatKey(key);
      const formattedValue = formatValue(key, parsedValue);
      console.log(chalk.green(`âœ“ ${formattedKey} set to ${formattedValue}`));
    });

  // Reset preferences to defaults
  preferencesProgram
    .command('reset')
    .description('Reset all preferences to defaults')
    .option('-y, --yes', 'Skip confirmation')
    .action((options) => {
      if (!options.yes) {
        console.log(chalk.yellow('âš ï¸  This will reset all preferences to default values.'));
        console.log(chalk.gray('Use --yes to confirm.\n'));
        return;
      }

      PreferencesManager.resetPreferences();
      console.log(chalk.green('âœ“ All preferences reset to defaults'));
    });

  // Show current prompt personalization
  preferencesProgram
    .command('show-prompt')
    .description('Show current personalized prompt')
    .action(() => {
      const prefs = PreferencesManager.getPreferences();
      const basePrompt = 'ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„æŠ€æœ¯åŠ©æ‰‹ï¼ˆYuangs AIï¼‰ï¼Œä¸“ç²¾äºè½¯ä»¶å¼€å‘ã€ç³»ç»Ÿç®¡ç†å’Œé—®é¢˜è§£å†³ã€‚';
      const personalized = buildPersonalizedPrompt(basePrompt, prefs);

      console.log(chalk.bold.cyan('\nğŸ“ Current Personalized Prompt\n'));
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      console.log(personalized);
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n');
    });

  // Quick setup wizard
  preferencesProgram
    .command('setup')
    .description('Interactive preference setup')
    .action(async () => {
      const readline = (await import('readline')).createInterface({
        input: process.stdin,
        output: process.stdout
      });

      const updates: any = {};

      console.log(chalk.bold.cyan('\nğŸ”§ Yuangs AI Preference Setup\n'));
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n');

      // Verbosity
      const verbosity = await ask(readline,
        'Verbosity level (concise/normal/detailed) [default: normal]: ',
        'normal'
      );
      if (['concise', 'normal', 'detailed'].includes(verbosity)) {
        updates.verbosity = verbosity;
      }

      // Language
      const language = await ask(readline,
        'Language (zh-CN/en-US/auto) [default: auto]: ',
        'auto'
      );
      if (['zh-CN', 'en-US', 'auto'].includes(language)) {
        updates.language = language;
      }

      // Explanation style
      const explanation = await ask(readline,
        'Explanation style (technical/beginner/adaptive) [default: adaptive]: ',
        'adaptive'
      );
      if (['technical', 'beginner', 'adaptive'].includes(explanation)) {
        updates.explanation = explanation;
      }

      // Context strategy
      const contextStrategy = await ask(readline,
        'Context strategy (smart/minimal/full) [default: smart]: ',
        'smart'
      );
      if (['smart', 'minimal', 'full'].includes(contextStrategy)) {
        updates.contextStrategy = contextStrategy;
      }

      // Auto-confirm
      const autoConfirm = await ask(readline,
        'Auto-confirm commands (yes/no) [default: no]: ',
        'no'
      );
      if (['yes', 'no'].includes(autoConfirm)) {
        updates.autoConfirm = autoConfirm === 'yes';
      }

      readline.close();

      if (Object.keys(updates).length > 0) {
        PreferencesManager.setPreferences(updates);
        console.log(chalk.green('\nâœ“ Preferences updated successfully!'));
      } else {
        console.log(chalk.yellow('\nNo changes made.'));
      }
    });
}

function formatKey(key: string): string {
  return key
    .replace(/([A-Z])/g, ' $1')
    .replace(/^./, str => str.toUpperCase())
    .trim();
}

function formatValue(key: string, value: any): string {
  if (typeof value === 'boolean') {
    return value ? chalk.green('enabled') : chalk.red('disabled');
  }
  if (typeof value === 'string') {
    return chalk.cyan(`"${value}"`);
  }
  return String(value);
}

function parseValue(key: string, value: string): any {
  switch (key) {
    case 'verbosity':
      if (['concise', 'normal', 'detailed'].includes(value)) {
        return value;
      }
      return null;

    case 'language':
      if (['zh-CN', 'en-US', 'auto'].includes(value)) {
        return value;
      }
      return null;

    case 'codeStyle':
      if (['functional', 'imperative', 'any'].includes(value)) {
        return value;
      }
      return null;

    case 'explanation':
      if (['technical', 'beginner', 'adaptive'].includes(value)) {
        return value;
      }
      return null;

    case 'outputFormat':
      if (['markdown', 'plain', 'structured'].includes(value)) {
        return value;
      }
      return null;

    case 'contextStrategy':
      if (['smart', 'minimal', 'full'].includes(value)) {
        return value;
      }
      return null;

    case 'autoConfirm':
      if (['true', 'yes', '1', 'enabled'].includes(value.toLowerCase())) {
        return true;
      }
      if (['false', 'no', '0', 'disabled'].includes(value.toLowerCase())) {
        return false;
      }
      return null;

    default:
      return value;
  }
}

function ask(rl: any, question: string, defaultVal: string): Promise<string> {
  return new Promise((resolve) => {
    rl.question(`${chalk.cyan(question)}`, (answer: string) => {
      resolve(answer.trim() || defaultVal);
    });
  });
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ commands/replayCommands.ts

````typescript
import chalk from 'chalk';
import * as fs from 'fs';
import * as path from 'path';
import { Command } from 'commander';
import { CapabilitySystem } from '../core/capabilitySystem';
import { ReplayMode } from '../core/replayEngine';
import { diffExecution, formatReplayDiff } from '../core/replayDiff';
import { loadExecutionRecord, listExecutionRecords } from '../core/executionStore';
import { Replayer } from '../audit/Replayer';

export function registerReplayCommands(program: Command): void {
  program
    .command('replay <id_or_file>')
    .description('Replay an execution (ID) or SSH session (.cast file)')
    .option('-s, --strict', 'Strict replay (use exact model)')
    .option('-c, --compatible', 'Compatible replay (allow fallback)')
    .option('-r, --re-evaluate', 'Re-evaluate with current config')
    .option('-v, --verbose', 'Verbose output')
    .option('--dry', 'Dry run - show what would happen without executing')
    .option('--explain', 'Show explanation before replay')
    .option('--diff', 'Show diff between original and current config')
    .option('--speed <n>', 'Playback speed multiplier (default: 1.0)', parseFloat, 1.0)
    .action(async (idOrFile, options) => {
      // æ£€æŸ¥æ˜¯å¦æ˜¯ .cast æ–‡ä»¶
      if (idOrFile.endsWith('.cast') || fs.existsSync(idOrFile)) {
        try {
            const replayer = new Replayer(idOrFile);
            await replayer.load();
            await replayer.play(options.speed || 1.0);
            return;
        } catch (error: any) {
            // å¦‚æœæ–‡ä»¶è¯»å–å¤±è´¥ï¼Œæˆ–è€…ä¸æ˜¯æ­£å¸¸çš„ cast æ–‡ä»¶ï¼Œä¸”çœ‹èµ·æ¥åƒ IDï¼Œåˆ™ç»§ç»­åŸé€»è¾‘
            if (!idOrFile.endsWith('.cast')) {
               // fallthrough
            } else {
               console.error(chalk.red(`âŒ playback failed: ${error.message}`));
               return;
            }
        }
      }

      // === Original Logic ===
      const id = idOrFile;
      const system = new CapabilitySystem();

      let mode: ReplayMode = 'strict';
      if (options.compatible) mode = 'compatible';
      if (options.reEvaluate) mode = 're-evaluate';

      // Handle diff option
      if (options.diff) {
        const record = loadExecutionRecord(id);
        if (!record) {
          console.log(chalk.red(`âŒ Execution record "${id}" not found\n`));
          return;
        }

        // Create a "current" record with current config
        const currentConfig = system.loadMergedConfig();
        const currentRecord: any = {
          ...record,
          configSnapshot: currentConfig,
          decision: {
            ...record.decision,
            // In a real scenario, we'd re-evaluate the decision
            // For now, use the same decision
          },
        };

        const diff = diffExecution(record, currentRecord);
        console.log(formatReplayDiff(diff));

        // If --diff is combined with --dry, exit after showing diff
        if (options.dry) {
          console.log(chalk.gray('\n[Dry] Diff shown, no execution\n'));
          return;
        }

        // Otherwise, proceed with replay
        console.log('');
      }

      const result = await system.replayExecution(id, {
        mode,
        skipAI: true,
        verbose: options.verbose,
        dry: options.dry,
        explain: options.explain,
      });

      if (result.success) {
        console.log(chalk.green(`âœ… ${result.message}`));
        if (result.executedModel) {
          console.log(chalk.gray(`Model: ${result.executedModel}`));
        }
      } else {
        console.log(chalk.red(`âŒ ${result.message}`));
      }
    });
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ commands/routerCommands.ts

````typescript
import chalk from 'chalk';
import { Command } from 'commander';
import {
  getRouter,
  executeTask,
  getStats,
  TaskType,
  RoutingStrategy,
  ModelStats,
} from '../core/modelRouter';
import {
  loadConfig,
  saveConfig,
  resetConfig,
  getConfigPath,
  addEnabledAdapter,
  removeEnabledAdapter,
  setTaskTypeMapping,
  removeTaskTypeMapping,
} from '../core/modelRouter/config';

/**
 * æ³¨å†Œè·¯ç”±å™¨å‘½ä»¤
 */
export function registerRouterCommands(program: Command): void {
  const routerCmd = program
    .command('router')
    .description('ç®¡ç†å¤šæ¨¡å‹è·¯ç”±ç³»ç»Ÿ');

  // åˆ—å‡ºæ‰€æœ‰å·²æ³¨å†Œçš„é€‚é…å™¨
  routerCmd
    .command('list')
    .description('åˆ—å‡ºæ‰€æœ‰å·²æ³¨å†Œçš„æ¨¡å‹é€‚é…å™¨')
    .action(async () => {
      try {
        const router = getRouter();
        const adapters = router.getAdapters();

        if (adapters.length === 0) {
          console.log(chalk.yellow('æ²¡æœ‰å·²æ³¨å†Œçš„æ¨¡å‹é€‚é…å™¨'));
          return;
        }

        console.log(chalk.bold.cyan('\nğŸ¤– å·²æ³¨å†Œçš„æ¨¡å‹é€‚é…å™¨\n'));

        for (const adapter of adapters) {
          const available = await adapter.isAvailable();
          const statusIcon = available ? chalk.green('âœ“') : chalk.red('âœ—');
          const statusText = available ? chalk.green('å¯ç”¨') : chalk.red('ä¸å¯ç”¨');

          console.log(`${statusIcon} ${chalk.bold(adapter.name)} (${adapter.provider})`);
          console.log(`   ç‰ˆæœ¬: ${adapter.version}`);
          console.log(`   çŠ¶æ€: ${statusText}`);
          console.log(`   æ”¯æŒçš„ä»»åŠ¡: ${adapter.capabilities.supportedTaskTypes.join(', ')}`);
          console.log(`   ä¸Šä¸‹æ–‡çª—å£: ${adapter.capabilities.maxContextWindow}`);
          console.log(`   å¹³å‡å“åº”æ—¶é—´: ${adapter.capabilities.avgResponseTime}ms`);
          console.log(`   æˆæœ¬ç­‰çº§: ${adapter.capabilities.costLevel}/5`);
          if (adapter.capabilities.specialCapabilities) {
            console.log(`   ç‰¹æ®Šèƒ½åŠ›: ${adapter.capabilities.specialCapabilities.join(', ')}`);
          }
          console.log();
        }
      } catch (error: any) {
        console.error(chalk.red(`é”™è¯¯: ${error.message}`));
        process.exit(1);
      }
    });

  // æŸ¥çœ‹ç»Ÿè®¡ä¿¡æ¯
  routerCmd
    .command('stats [model]')
    .description('æŸ¥çœ‹æ¨¡å‹ä½¿ç”¨ç»Ÿè®¡ä¿¡æ¯')
    .action((model) => {
      try {
        const router = getRouter();
        const stats = router.getStats(model) as ModelStats | ModelStats[];

        if (Array.isArray(stats)) {
          if (stats.length === 0) {
            console.log(chalk.yellow('æš‚æ— ç»Ÿè®¡æ•°æ®'));
            return;
          }

          console.log(chalk.bold.cyan('\nğŸ“Š æ¨¡å‹ä½¿ç”¨ç»Ÿè®¡\n'));

          for (const stat of stats) {
            printModelStats(stat);
          }
        } else {
          console.log(chalk.bold.cyan(`\nğŸ“Š ${stats.modelName} ä½¿ç”¨ç»Ÿè®¡\n`));
          printModelStats(stats);
        }
      } catch (error: any) {
        console.error(chalk.red(`é”™è¯¯: ${error.message}`));
        process.exit(1);
      }
    });

  // æµ‹è¯•é€‚é…å™¨
  routerCmd
    .command('test <adapter>')
    .description('æµ‹è¯•æŒ‡å®šçš„æ¨¡å‹é€‚é…å™¨')
    .option('-p, --prompt <text>', 'æµ‹è¯•æç¤ºè¯', 'ä½ å¥½ï¼Œè¯·ä»‹ç»ä¸€ä¸‹è‡ªå·±')
    .action(async (adapterName, options) => {
      try {
        const router = getRouter();
        const adapters = router.getAdapters();
        const adapter = adapters.find((a) => a.name === adapterName);

        if (!adapter) {
          console.error(chalk.red(`æ‰¾ä¸åˆ°é€‚é…å™¨: ${adapterName}`));
          process.exit(1);
        }

        console.log(chalk.cyan(`æ­£åœ¨æµ‹è¯• ${adapter.name}...\n`));

        const available = await adapter.healthCheck();
        if (!available) {
          console.error(chalk.red(`âœ— ${adapter.name} å¥åº·æ£€æŸ¥å¤±è´¥ï¼Œæ¨¡å‹ä¸å¯ç”¨`));
          process.exit(1);
        }

        console.log(chalk.green(`âœ“ ${adapter.name} å¥åº·æ£€æŸ¥é€šè¿‡\n`));

        const result = await router.executeTask(
          adapter,
          options.prompt,
          {
            type: TaskType.CONVERSATION,
            description: 'æµ‹è¯•è¯·æ±‚',
          }
        );

        if (result.success) {
          console.log(chalk.green(`\nâœ“ æµ‹è¯•æˆåŠŸ\n`));
          console.log(chalk.bold('å“åº”å†…å®¹:'));
          console.log(result.content);
          console.log(chalk.gray(`\næ‰§è¡Œæ—¶é—´: ${result.executionTime}ms`));
        } else {
          console.error(chalk.red(`\nâœ— æµ‹è¯•å¤±è´¥: ${result.error}`));
          process.exit(1);
        }
      } catch (error: any) {
        console.error(chalk.red(`é”™è¯¯: ${error.message}`));
        process.exit(1);
      }
    });

  // ç­–ç•¥ç®¡ç†
  const policyCmd = routerCmd
    .command('policy')
    .description('ç®¡ç†è·¯ç”±ç­–ç•¥');

  policyCmd
    .command('list')
    .description('åˆ—å‡ºæ‰€æœ‰å¯ç”¨çš„è·¯ç”±ç­–ç•¥')
    .action(() => {
      try {
        const router = getRouter();
        const policies = router.getPolicies();
        const config = loadConfig();

        console.log(chalk.bold.cyan('\nğŸ“œ å¯ç”¨è·¯ç”±ç­–ç•¥\n'));

        for (const policy of policies) {
          const isCurrent = (config.defaultStrategy === RoutingStrategy.AUTO && policy.name === 'balanced') ||
            (config.defaultStrategy === RoutingStrategy.FASTEST_FIRST && policy.name === 'latency-critical') ||
            (config.defaultStrategy === RoutingStrategy.CHEAPEST_FIRST && policy.name === 'cost-saving') ||
            (config.defaultStrategy === RoutingStrategy.BEST_QUALITY && policy.name === 'quality-first');

          const prefix = isCurrent ? chalk.green('â†’ ') : '  ';
          console.log(`${prefix}${chalk.bold(policy.name)}`);
          console.log(`    ${chalk.gray(policy.description)}`);
          console.log();
        }
      } catch (error: any) {
        console.error(chalk.red(`é”™è¯¯: ${error.message}`));
        process.exit(1);
      }
    });

  policyCmd
    .command('set <name>')
    .description('è®¾ç½®é»˜è®¤è·¯ç”±ç­–ç•¥')
    .action((name) => {
      try {
        const config = loadConfig();
        let strategy: RoutingStrategy;

        switch (name) {
          case 'balanced':
          case 'auto':
            strategy = RoutingStrategy.AUTO;
            break;
          case 'latency-critical':
          case 'fast':
            strategy = RoutingStrategy.FASTEST_FIRST;
            break;
          case 'cost-saving':
          case 'cheap':
            strategy = RoutingStrategy.CHEAPEST_FIRST;
            break;
          case 'quality-first':
          case 'best':
            strategy = RoutingStrategy.BEST_QUALITY;
            break;
          default:
            console.error(chalk.red(`æœªçŸ¥ç­–ç•¥: ${name}`));
            process.exit(1);
        }

        saveConfig({ defaultStrategy: strategy });
        console.log(chalk.green(`âœ“ å·²å°†é»˜è®¤ç­–ç•¥è®¾ç½®ä¸º: ${name}`));
      } catch (error: any) {
        console.error(chalk.red(`é”™è¯¯: ${error.message}`));
        process.exit(1);
      }
    });

  // æ¢ç´¢é…ç½®ç®¡ç†
  const explorationCmd = routerCmd
    .command('exploration')
    .description('ç®¡ç†è·¯ç”±æ¢ç´¢æœºåˆ¶ (Îµ-greedy / UCB1)');

  explorationCmd
    .command('set <strategy>')
    .description('è®¾ç½®æ¢ç´¢ç­–ç•¥ (none, epsilon_greedy, ucb1)')
    .option('-e, --epsilon <value>', 'è®¾ç½® epsilon å€¼ (ä»…ç”¨äº epsilon_greedy)', '0.1')
    .action((strategy, options) => {
      try {
        const config = loadConfig();
        saveConfig({
          exploration: {
            strategy: strategy as any,
            epsilon: parseFloat(options.epsilon)
          }
        });
        console.log(chalk.green(`âœ“ å·²æ›´æ–°æ¢ç´¢é…ç½®: ç­–ç•¥=${strategy}, Epsilon=${options.epsilon}`));
      } catch (error: any) {
        console.error(chalk.red(`é”™è¯¯: ${error.message}`));
        process.exit(1);
      }
    });

  explorationCmd
    .command('show')
    .description('æ˜¾ç¤ºå½“å‰æ¢ç´¢é…ç½®')
    .action(() => {
      const config = loadConfig();
      console.log(chalk.bold.cyan('\nğŸ” å½“å‰æ¢æµ‹é…ç½®\n'));
      console.log(`  ç­–ç•¥: ${chalk.white(config.exploration?.strategy || 'none')}`);
      console.log(`  Epsilon: ${chalk.white(config.exploration?.epsilon || 'N/A')}`);
      console.log();
    });

  // é…ç½®ç®¡ç†
  const configCmd = routerCmd
    .command('config')
    .description('ç®¡ç†è·¯ç”±å™¨é…ç½®');

  configCmd
    .command('show')
    .description('æ˜¾ç¤ºå½“å‰é…ç½®')
    .action(() => {
      try {
        const config = loadConfig();
        console.log(chalk.bold.cyan('\nâš™ï¸  å½“å‰é…ç½®\n'));
        console.log(JSON.stringify(config, null, 2));
        console.log(chalk.gray(`\né…ç½®æ–‡ä»¶ä½ç½®: ${getConfigPath()}`));
      } catch (error: any) {
        console.error(chalk.red(`é”™è¯¯: ${error.message}`));
        process.exit(1);
      }
    });

  configCmd
    .command('set <key> <value>')
    .description('è®¾ç½®é…ç½®é¡¹')
    .action((key, value) => {
      try {
        const config = loadConfig();
        let parsedValue: any = value;

        // å°è¯•è§£æ JSON å€¼
        try {
          parsedValue = JSON.parse(value);
        } catch {
          // ä¿æŒåŸå§‹å­—ç¬¦ä¸²å€¼
        }

        (config as any)[key] = parsedValue;
        saveConfig(config);
        console.log(chalk.green(`âœ“ å·²è®¾ç½® ${key} = ${JSON.stringify(parsedValue)}`));
      } catch (error: any) {
        console.error(chalk.red(`é”™è¯¯: ${error.message}`));
        process.exit(1);
      }
    });

  configCmd
    .command('reset')
    .description('é‡ç½®é…ç½®ä¸ºé»˜è®¤å€¼')
    .action(() => {
      try {
        resetConfig();
        console.log(chalk.green('âœ“ é…ç½®å·²é‡ç½®ä¸ºé»˜è®¤å€¼'));
      } catch (error: any) {
        console.error(chalk.red(`é”™è¯¯: ${error.message}`));
        process.exit(1);
      }
    });

  // é€‚é…å™¨ç®¡ç†
  configCmd
    .command('enable <adapter>')
    .description('å¯ç”¨æŒ‡å®šçš„é€‚é…å™¨')
    .action((adapter) => {
      try {
        addEnabledAdapter(adapter);
        console.log(chalk.green(`âœ“ å·²å¯ç”¨é€‚é…å™¨: ${adapter}`));
      } catch (error: any) {
        console.error(chalk.red(`é”™è¯¯: ${error.message}`));
        process.exit(1);
      }
    });

  configCmd
    .command('disable <adapter>')
    .description('ç¦ç”¨æŒ‡å®šçš„é€‚é…å™¨')
    .action((adapter) => {
      try {
        removeEnabledAdapter(adapter);
        console.log(chalk.green(`âœ“ å·²ç¦ç”¨é€‚é…å™¨: ${adapter}`));
      } catch (error: any) {
        console.error(chalk.red(`é”™è¯¯: ${error.message}`));
        process.exit(1);
      }
    });

  // ä»»åŠ¡ç±»å‹æ˜ å°„
  configCmd
    .command('map <taskType> <modelName>')
    .description('è®¾ç½®ä»»åŠ¡ç±»å‹åˆ°æ¨¡å‹çš„æ˜ å°„')
    .action((taskType, modelName) => {
      try {
        setTaskTypeMapping(taskType, modelName);
        console.log(chalk.green(`âœ“ å·²å°†ä»»åŠ¡ç±»å‹ ${taskType} æ˜ å°„åˆ°æ¨¡å‹ ${modelName}`));
      } catch (error: any) {
        console.error(chalk.red(`é”™è¯¯: ${error.message}`));
        process.exit(1);
      }
    });

  configCmd
    .command('unmap <taskType>')
    .description('ç§»é™¤ä»»åŠ¡ç±»å‹æ˜ å°„')
    .action((taskType) => {
      try {
        removeTaskTypeMapping(taskType);
        console.log(chalk.green(`âœ“ å·²ç§»é™¤ä»»åŠ¡ç±»å‹ ${taskType} çš„æ˜ å°„`));
      } catch (error: any) {
        console.error(chalk.red(`é”™è¯¯: ${error.message}`));
        process.exit(1);
      }
    });

  // è·¯ç”±å™¨åŒ»ç”Ÿï¼šè¡Œä¸ºéªŒæ”¶å¥—ä»¶
  routerCmd
    .command('doctor')
    .description('å¯¹è·¯ç”±å™¨è¿›è¡Œç³»ç»Ÿæ€§å¥åº·æ£€æŸ¥ä¸è¡Œä¸ºéªŒæ”¶')
    .option('--chaos', 'å¼€å¯å‹åŠ›/å¼‚å¸¸æ¨¡æ‹Ÿï¼ˆæ³¨å…¥æ¨¡æ‹Ÿå»¶è¿Ÿå’Œæ•…éšœï¼‰')
    .action(async (options) => {
      console.log(chalk.bold.cyan('\nğŸ©º å¼€å§‹æ‰§è¡Œ ModelRouter ç³»ç»Ÿè‡ªæ£€...\n'));
      const router = getRouter();

      const runStep = async (name: string, fn: () => Promise<void>) => {
        process.stdout.write(`  ${chalk.white(name.padEnd(40))}`);
        try {
          await fn();
          console.log(chalk.green(' [é€šè¿‡]'));
        } catch (e: any) {
          console.log(chalk.red(' [å¤±è´¥]'));
          console.error(chalk.red(`     â””â”€ åŸå› : ${e.message}`));
        }
      };

      // Step 1: ç­–ç•¥æ³¨å†Œå®Œæ•´æ€§
      await runStep('ç­–ç•¥å®¹å™¨å®Œæ•´æ€§éªŒè¯', async () => {
        const policies = router.getPolicies();
        if (policies.length < 4) throw new Error(`ç­–ç•¥ç¼ºå¤±: æœŸæœ› 4, å®é™… ${policies.length}`);
      });

      // Step 2: Gate è¿‡æ»¤å¥‘çº¦éªŒè¯
      await runStep('Gate ç¡¬çº¦æŸéš”ç¦»è¾¹ç•Œæ£€æŸ¥', async () => {
        const result = await router.route(
          { type: TaskType.ANALYSIS, description: 'long content', contextSize: 500000 },
          { strategy: RoutingStrategy.AUTO }
        );
        // éªŒè¯ Qwen (é€šå¸¸ context è¾ƒå°) è¿™ç§æ¨¡å‹æ˜¯å¦è¢«éš”ç¦»
        const hasLowContextModel = result.candidates.some(c => c.name === 'qwen');
        if (hasLowContextModel) throw new Error('Gate æœªèƒ½æœ‰æ•ˆéš”ç¦»ä½å®¹é‡æ¨¡å‹');
      });

      // Step 3: Cost-Saving ç­–ç•¥è¯­ä¹‰éªŒè¯
      await runStep('Cost-Saving å†³ç­–ä¸€è‡´æ€§éªŒè¯', async () => {
        const result = await router.route(
          { type: TaskType.GENERAL, description: 'cheap task' },
          { strategy: RoutingStrategy.CHEAPEST_FIRST }
        );
        // å¯»æ‰¾å…¨é‡ä¸­æˆæœ¬æœ€ä½çš„
        const minCost = Math.min(...router.getAdapters().map(a => a.capabilities.costLevel));
        if (result.adapter.capabilities.costLevel > minCost) {
          throw new Error(`æœªé€‰å®šæœ€ä½æˆæœ¬æ¨¡å‹(æœŸæœ› <=ç­‰çº§${minCost}, å®é™… ç­‰çº§${result.adapter.capabilities.costLevel})`);
        }
      });

      // Step 4: æ‰§è¡Œ->ç»Ÿè®¡åé¦ˆé—­ç¯éªŒè¯
      await runStep('å®æ—¶ç»Ÿè®¡(Stats)é—­ç¯é“¾è·¯éªŒè¯', async () => {
        const adapter = router.getAdapters()[0];
        const initial = (router.getStats(adapter.name) as any).totalRequests;
        await router.executeTask(adapter, 'test', { type: TaskType.CONVERSATION, description: 'doctor test' });
        const current = (router.getStats(adapter.name) as any).totalRequests;
        if (current <= initial) throw new Error('æ‰§è¡Œå Stats æœªèƒ½æ­£ç¡®ç´¯åŠ ');
      });

      if (options.chaos) {
        console.log(chalk.yellow('\nğŸŒ€ æ‰§è¡Œæ··æ²Œæµ‹è¯• (Chaos Simulation)...'));
        // è¿™é‡Œå°†æ¥å¯ä»¥æ³¨å…¥æ¨¡æ‹Ÿçš„é«˜å»¶è¿Ÿ
        console.log(chalk.gray('  - æ¨¡æ‹Ÿé«˜å»¶è¿Ÿæ³¨å…¥æµ‹è¯•: è§„åˆ’ä¸­å¿ƒ...'));
        console.log(chalk.green('  âœ“ æ··æ²Œæµ‹è¯•å®Œæˆ'));
      }

      console.log(chalk.bold.cyan('\nğŸ è‡ªæ£€æ€»ç»“: ç³»ç»Ÿæ¶æ„å¥‘çº¦å®Œæ•´ï¼Œå†³ç­–é“¾è·¯æ­£å¸¸ã€‚'));
      console.log();
    });

  // æ‰§è¡Œä»»åŠ¡
  routerCmd
    .command('exec <prompt>')
    .description('ä½¿ç”¨è·¯ç”±å™¨æ‰§è¡Œä»»åŠ¡')
    .option('-t, --type <type>', 'ä»»åŠ¡ç±»å‹', 'general')
    .option('-s, --strategy <strategy>', 'è·¯ç”±ç­–ç•¥', 'auto')
    .option('-m, --model <model>', 'æ‰‹åŠ¨æŒ‡å®šæ¨¡å‹')
    .action(async (prompt, options) => {
      try {
        const taskType = options.type as TaskType;
        const strategy = options.strategy as RoutingStrategy;

        console.log(chalk.cyan('æ­£åœ¨æ‰§è¡Œä»»åŠ¡...\n'));

        const result = await executeTask(
          prompt,
          {
            type: taskType,
            description: prompt,
          },
          {
            strategy: options.model ? RoutingStrategy.MANUAL : strategy,
            manualModelName: options.model,
          },
          (chunk) => {
            process.stdout.write(chunk);
          }
        );

        if (result.success) {
          console.log(chalk.green(`\n\nâœ“ ä»»åŠ¡æ‰§è¡ŒæˆåŠŸ`));
          console.log(chalk.gray(`æ‰§è¡Œæ—¶é—´: ${result.executionTime}ms`));
        } else {
          console.error(chalk.red(`\nâœ— ä»»åŠ¡æ‰§è¡Œå¤±è´¥: ${result.error}`));
          process.exit(1);
        }
      } catch (error: any) {
        console.error(chalk.red(`é”™è¯¯: ${error.message}`));
        process.exit(1);
      }
    });
}

/**
 * æ‰“å°æ¨¡å‹ç»Ÿè®¡ä¿¡æ¯
 */
function printModelStats(stats: ModelStats): void {
  const successRate =
    stats.totalRequests > 0
      ? ((stats.successCount / stats.totalRequests) * 100).toFixed(1)
      : '0.0';

  console.log(chalk.bold(stats.modelName));
  console.log(`  æ€»è¯·æ±‚æ•°: ${stats.totalRequests}`);
  console.log(`  æˆåŠŸ: ${chalk.green(stats.successCount)} | å¤±è´¥: ${chalk.red(stats.failureCount)}`);
  console.log(`  æˆåŠŸç‡: ${successRate}%`);
  console.log(`  å¹³å‡å“åº”æ—¶é—´: ${stats.avgResponseTime.toFixed(0)}ms`);
  console.log(`  æ€» tokens: ${stats.totalTokens}`);
  console.log(`  æœ€åä½¿ç”¨: ${stats.lastUsed.toLocaleString()}`);
  console.log();
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ commands/shellCompletions.ts

````typescript
import readline from 'readline';
import fs from 'fs';
import path from 'path';
import { spawn } from 'child_process';
import { execSync } from 'child_process';

/* ========================================
   TYPE DEFINITIONS
   ======================================== */

export type Mode = 'chat' | 'file' | 'dir' | 'command';

export interface CompletionContext {
    line: string;
    cursor: number;
    mode: Mode;
    cwd: string;
}

export interface CommandPlugin {
    command: string;
    complete(args: string[], context: CompletionContext): string[];
}

/* ========================================
   PROJECT CONTEXT
   ======================================== */

let PROJECT_ROOT: string | null = null;

export function findProjectRoot(start = process.cwd()): string {
    if (PROJECT_ROOT) return PROJECT_ROOT;

    let dir = start;
    const MAX_DEPTH = 10;
    let depth = 0;

    while (dir !== path.dirname(dir) && depth < MAX_DEPTH) {
        if (fs.existsSync(path.join(dir, 'package.json')) ||
            fs.existsSync(path.join(dir, '.git'))) {
            PROJECT_ROOT = dir;
            return dir;
        }
        dir = path.dirname(dir);
        depth++;
    }

    PROJECT_ROOT = start;
    return start;
}

const PRIORITY_DIRS = ['src', 'packages', 'apps', 'lib', 'components'];

export function sortEntries(entries: fs.Dirent[]): fs.Dirent[] {
    return entries.sort((a, b) => {
        const ai = PRIORITY_DIRS.indexOf(a.name);
        const bi = PRIORITY_DIRS.indexOf(b.name);

        if (ai === -1 && bi === -1) return 0;
        if (ai === -1) return 1;
        if (bi === -1) return -1;
        return ai - bi;
    });
}

/* ========================================
   CACHING SYSTEM
   ======================================== */

interface CacheEntry<T> {
    ts: number;
    value: T;
}

const cache = new Map<string, CacheEntry<any>>();
const TTL = 2000; // 2 seconds

export function cached<T>(key: string, fn: () => T): T {
    const now = Date.now();
    const hit = cache.get(key);

    if (hit && now - hit.ts < TTL) {
        return hit.value;
    }

    const value = fn();
    cache.set(key, { ts: now, value });
    return value;
}

export function clearCache(): void {
    cache.clear();
}

/* ========================================
   MODE DETECTION
   ======================================== */

export function detectMode(line: string): Mode {
    const trimmed = line.trimStart();

    // Check for explicit command prefixes
    if (trimmed.startsWith('$') || trimmed.startsWith('!')) {
        return 'command';
    }

    const tokens = line.split(/\s+/);
    const last = tokens[tokens.length - 1];

    // Check for file reference (@)
    if (last?.startsWith('@')) {
        return 'file';
    }

    // Check for directory reference (#)
    if (last?.startsWith('#')) {
        return 'dir';
    }

    // Check if first token is a command (fish-style)
    const first = tokens[0];
    if (first) {
        const commands = loadCommands();
        if (commands.includes(first)) {
            return 'command';
        }
    }

    // Default to chat mode
    return 'chat';
}

/* ========================================
   COMMAND COMPLETION (PATH)
   ======================================== */

let commandCache: string[] | null = null;

// Common shell builtins that should always be available
const SHELL_BUILTINS = [
    'cd', 'pwd', 'ls', 'mkdir', 'rmdir', 'rm', 'cp', 'mv', 'cat',
    'echo', 'grep', 'find', 'head', 'tail', 'less', 'more',
    'chmod', 'chown', 'touch', 'ln', 'df', 'du', 'free',
    'ps', 'top', 'kill', 'killall', 'bg', 'fg', 'jobs',
    'export', 'unset', 'env', 'alias', 'unalias',
    'history', 'type', 'which', 'whereis', 'man',
    'sleep', 'wait', 'date', 'cal', 'uptime', 'uname',
    'tar', 'gzip', 'gunzip', 'zip', 'unzip',
    'curl', 'wget', 'ssh', 'scp', 'rsync'
];

export function loadCommands(): string[] {
    return cached('PATH_COMMANDS', () => {
        const paths = process.env.PATH?.split(path.delimiter) ?? [];
        const cmds = new Set<string>(SHELL_BUILTINS);

        for (const p of paths) {
            try {
                for (const f of fs.readdirSync(p)) {
                    cmds.add(f);
                }
            } catch {
                // Ignore directories we can't read
            }
        }

        commandCache = [...cmds];
        return commandCache;
    });
}

export function completeCommands(partial: string): string[] {
    return loadCommands().filter(cmd => cmd.startsWith(partial));
}

/* ========================================
   FILE/DIRECTORY COMPLETION
   ======================================== */

function splitToken(line: string): { prefix: string; token: string } {
    const match = line.match(/(.+?\s)?([^\s]*)$/);
    return {
        prefix: match?.[1] ?? '',
        token: match?.[2] ?? ''
    };
}

export function completePath(
    raw: string,
    type: 'file' | 'dir'
): string[] {
    // Remove sigil (@ or #)
    const withoutSigil = raw.slice(1);

    // Handle case: only sigil (e.g., "@")
    if (!withoutSigil) {
        const currentDir = process.cwd();
        try {
            let entries = fs.readdirSync(currentDir, { withFileTypes: true });
            entries = sortEntries(entries);
            return entries
                .filter(e => type === 'file' ? e.isFile() : e.isDirectory())
                .map(e => (type === 'file' ? '@' : '#') + e.name);
        } catch {
            return [];
        }
    }

    // Extract base directory and partial name
    const baseDir = withoutSigil.includes(path.sep)
        ? path.dirname(withoutSigil)
        : '.';

    const partial = withoutSigil.includes(path.sep)
        ? path.basename(withoutSigil)
        : withoutSigil;

    const resolvedBase = path.resolve(baseDir);

    if (!fs.existsSync(resolvedBase) || !fs.statSync(resolvedBase).isDirectory()) {
        return [];
    }

    let entries: fs.Dirent[];
    try {
        entries = fs.readdirSync(resolvedBase, { withFileTypes: true });
        entries = sortEntries(entries);
    } catch {
        return [];
    }

    return entries
        .filter(e => {
            const matchesPrefix = e.name.startsWith(partial);
            if (!matchesPrefix) return false;
            return type === 'file' ? e.isFile() : e.isDirectory();
        })
        .map(e => {
            const fullName = (baseDir === '.' ? '' : baseDir + path.sep) + e.name;
            const sigil = type === 'file' ? '@' : '#';
            return sigil + fullName;
        });
}

/* ========================================
   FILE:LINE COMPLETION
   ======================================== */

export function completeFileWithLine(token: string): string[] {
    const [filePath, linePart] = token.slice(1).split(':');

    if (!filePath) {
        return completePath('@' + token, 'file');
    }

    const absolutePath = path.resolve(filePath);

    if (!fs.existsSync(absolutePath)) {
        return [];
    }

    if (linePart !== undefined) {
        // Suggest common line numbers
        const lineNums = ['1', '10', '20', '50', '100', '200'];
        const matches = lineNums.filter(ln => ln.startsWith(linePart));
        return matches.map(ln => '@' + filePath + ':' + ln);
    }

    // File exists, add colon for line input
    return ['@' + filePath + ':'];
}

/* ========================================
   ARGUMENT COMPLETION (GIT, etc.)
   ======================================== */

export function completeGitArgs(args: string[]): string[] {
    try {
        if (args.length <= 1) {
            // Complete subcommands
            const subcommands = [
                'add', 'branch', 'checkout', 'commit', 'diff',
                'log', 'merge', 'pull', 'push', 'rebase',
                'status', 'reset', 'revert', 'stash'
            ];
            return subcommands.filter(cmd => cmd.startsWith(args[1] || ''));
        }

        if (args[1] === 'checkout' && args.length <= 2) {
            // Complete branches
            try {
                const branches = execSync('git branch --all', {
                    encoding: 'utf8',
                    cwd: process.cwd()
                });
                return branches
                    .split('\n')
                    .map(l => l.replace(/^[* ]+/, '').trim())
                    .filter(b => b && b.startsWith(args[2] || ''));
            } catch {
                return [];
            }
        }
    } catch {
        // Not in a git repo or git not available
    }

    return [];
}

/* ========================================
   SMART COMPLETER (Main Entry)
   ======================================== */

export function createCompleter(): readline.Completer {
    return (line: string) => {
        try {
            const mode = detectMode(line);
            const { prefix, token } = splitToken(line);

            if (mode === 'file' && token.startsWith('@')) {
                if (token.includes(':')) {
                    // File:line mode
                    const matches = completeFileWithLine(token);
                    return [matches, token];
                }

                // File completion
                const matches = completePath(token, 'file');
                return [matches, token];
            }

            if (mode === 'dir' && token.startsWith('#')) {
                // Directory completion
                const matches = completePath(token, 'dir');
                return [matches, token];
            }

            if (mode === 'command') {
                // Command completion
                const cmdLine = line.replace(/^[$!]/, '');
                const parts = cmdLine.split(/\s+/);
                const cmd = parts[0];
                const current = parts[parts.length - 1] || '';

                // Git argument completion
                if (cmd === 'git') {
                    const matches = completeGitArgs(parts);
                    const filtered = matches.filter(m => m.startsWith(current));
                    return [filtered, current];
                }

                // General command completion
                const matches = completeCommands(current);
                return [matches, current];
            }

            // Default: no completion in chat mode
            return [[], line];
        } catch (error) {
            // Fail gracefully
            return [[], line];
        }
    };
}

/* ========================================
   COMMAND EXECUTION
   ======================================== */

export async function executeCommand(
    cmdLine: string,
    onExit?: (code: number | null) => void
): Promise<void> {
    const trimmed = cmdLine.trim();
    const command = trimmed.replace(/^[$!]\s*/, '');

    const child = spawn(command, {
        stdio: 'inherit',
        shell: true,
        cwd: process.cwd()
    });

    child.on('exit', (code) => {
        if (onExit) {
            onExit(code);
        }
    });

    child.on('error', (err) => {
        console.error(`\n[Command Error]: ${err.message}`);
        if (onExit) {
            onExit(1);
        }
    });

    return new Promise((resolve) => {
        child.on('close', () => resolve());
    });
}

/* ========================================
   GHOST TEXT (Suggestions)
   ======================================== */

let currentGhostText = '';

export function predictGhostText(line: string): string {
    const mode = detectMode(line);

    if (mode === 'command') {
        const cmdLine = line.replace(/^[$!]/, '');

        // Git suggestions
        if (cmdLine === 'git ch') return 'eckout';
        if (cmdLine === 'git st') return 'atus';
        if (cmdLine === 'git co') return 'mmit';

        // NPM suggestions
        if (cmdLine === 'npm r') return 'un dev';
        if (cmdLine === 'npm b') return 'uild';

        // LS suggestions
        if (cmdLine === 'ls -') return 'la';

        // Common patterns
        if (cmdLine === 'gi') return 't';
    }

    return '';
}

export function renderGhost(rl: readline.Interface): void {
    if (!currentGhostText) return;
    process.stdout.write(`\x1b[90m${currentGhostText}\x1b[0m`);
}

export function clearGhost(rl: readline.Interface): void {
    if (currentGhostText) {
        process.stdout.write(`\x1b[2K\r`);
        currentGhostText = '';
    }
}

export function updateGhost(line: string): void {
    currentGhostText = predictGhostText(line);
}

/* ========================================
   PLUGIN SYSTEM
   ======================================== */

const plugins = new Map<string, CommandPlugin>();
const PLUGIN_DIR = path.join(findProjectRoot(), '.shell', 'plugins');

export function loadPlugins(): void {
    if (!fs.existsSync(PLUGIN_DIR)) {
        try {
            fs.mkdirSync(PLUGIN_DIR, { recursive: true });
        } catch {
            // Can't create plugin directory
        }
        return;
    }

    try {
        for (const file of fs.readdirSync(PLUGIN_DIR)) {
            if (file.endsWith('.js') || file.endsWith('.ts')) {
                try {
                    const pluginPath = path.join(PLUGIN_DIR, file);
                    const plugin = require(pluginPath);
                    if (plugin.command && plugin.complete) {
                        plugins.set(plugin.command, plugin);
                    }
                } catch {
                    // Invalid plugin
                }
            }
        }
    } catch {
        // Can't read plugin directory
    }
}

export function getPlugin(command: string): CommandPlugin | undefined {
    return plugins.get(command);
}

export function listPlugins(): string[] {
    return [...plugins.keys()];
}

/* ========================================
   INITIALIZE
   ======================================== */

export function initialize(): void {
    findProjectRoot();
    loadPlugins();
    loadCommands();
}

// Auto-initialize on import
initialize();

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ commands/skillsCommands.ts

````typescript
import chalk from 'chalk';
import { Command } from 'commander';
import { getAllSkills, computeSkillScore, Skill } from '../agent/skills';
import fs from 'fs';
import path from 'path';
import os from 'os';

const SKILLS_FILE = path.join(os.homedir(), '.yuangs_skills.json');

function loadSkills() {
    if (fs.existsSync(SKILLS_FILE)) {
        try {
            const data = fs.readFileSync(SKILLS_FILE, 'utf-8');
            return JSON.parse(data);
        } catch (e) {
            return [];
        }
    }
    return [];
}

function saveSkills(skills: any[]) {
    try {
        fs.writeFileSync(SKILLS_FILE, JSON.stringify(skills, null, 2));
    } catch (e) {
        console.error(chalk.red(`Failed to save skills to ${SKILLS_FILE}`));
    }
}

export function registerSkillsCommands(program: Command): void {
    const skillsProgram = program.command('skills').description('Skill management commands');

    skillsProgram
        .command('list')
        .description('List all skills')
        .action(() => {
            const skills = getAllSkills();
            const now = Date.now();

            if (skills.length === 0) {
                console.log(chalk.gray('ğŸ“­ No skills found\n'));
                return;
            }

            console.log(chalk.bold.cyan(`\nğŸ“¦ Skills (${skills.length})\n`));

            skills.forEach((skill) => {
                const status = skill.enabled ? chalk.green('âœ”') : chalk.gray('âŠ˜');
                const score = computeSkillScore(skill, now);
                const daysAgo = Math.floor((now - skill.lastUsed) / (1000 * 60 * 60 * 24));

                console.log(`${status} ${chalk.bold(skill.name)}`);
                console.log(chalk.gray(`  Confidence: ${(score * 100).toFixed(0)}%`));
                console.log(chalk.gray(`  Success: ${skill.successCount} / Failure: ${skill.failureCount}`));
                console.log(chalk.gray(`  Last used: ${daysAgo === 0 ? 'today' : `${daysAgo} days ago`}\n`));
            });
        });

    skillsProgram
        .command('explain <name>')
        .description('Explain a specific skill')
        .action((name) => {
            const skills = getAllSkills();
            const skill = skills.find(s => s.name === name || s.id === name);

            if (!skill) {
                console.log(chalk.red(`âŒ Skill "${name}" not found\n`));
                return;
            }

            console.log(chalk.bold.cyan(`\nğŸ“– Skill Details: ${skill.name}\n`));
            console.log(chalk.white(`Description: ${skill.description}`));
            console.log(chalk.gray(`\nWhen to use:`));
            console.log(chalk.white(`  ${skill.whenToUse}`));
            console.log(chalk.gray(`\nMetrics:`));
            console.log(chalk.white(`  Success: ${skill.successCount} / Failure: ${skill.failureCount}`));
            console.log(chalk.white(`  Confidence: ${(skill.confidence * 100).toFixed(0)}%`));
            console.log(chalk.white(`  Enabled: ${skill.enabled ? 'Yes' : 'No'}`));
            console.log(chalk.gray(`\nCreated: ${new Date(skill.createdAt).toLocaleString()}`));
            console.log(chalk.gray(`Last used: ${new Date(skill.lastUsed).toLocaleString()}\n`));
        });

    skillsProgram
        .command('disable <name>')
        .description('Disable a skill')
        .action((name) => {
            const skills = loadSkills() as Skill[];
            const skillIndex = skills.findIndex(s => s.name === name || s.id === name);

            if (skillIndex === -1) {
                console.log(chalk.red(`âŒ Skill "${name}" not found\n`));
                return;
            }

            if (!skills[skillIndex].enabled) {
                console.log(chalk.yellow(`â„¹ï¸  Skill "${name}" is already disabled\n`));
                return;
            }

            skills[skillIndex].enabled = false;
            saveSkills(skills);
            console.log(chalk.green(`âœ“ Skill "${name}" has been disabled\n`));
        });

    skillsProgram
        .command('enable <name>')
        .description('Enable a skill')
        .action((name) => {
            const skills = loadSkills() as Skill[];
            const skillIndex = skills.findIndex(s => s.name === name || s.id === name);

            if (skillIndex === -1) {
                console.log(chalk.red(`âŒ Skill "${name}" not found\n`));
                return;
            }

            if (skills[skillIndex].enabled) {
                console.log(chalk.yellow(`â„¹ï¸  Skill "${name}" is already enabled\n`));
                return;
            }

            skills[skillIndex].enabled = true;
            saveSkills(skills);
            console.log(chalk.green(`âœ“ Skill "${name}" has been enabled\n`));
        });
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ commands/ssh/index.ts

````typescript
import { Command } from 'commander';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import { SSHSession } from '../../ssh/SSHSession';
import { InputBuffer } from '../../ssh/InputBuffer';
import { SSHGovernedExecutor, GovernanceService, ExecutionContext, ExecDecision } from '../../ssh/GovernedExecutor';
import { Recorder } from '../../audit/Recorder';
import { startWebTerminal } from './server';

/**
 * ç®€å•çš„æ²»ç†æœåŠ¡å®ç° (MVP)
 * TODO: æ¥å…¥å®Œæ•´çš„ GovernanceService
 */
class SimpleGovernanceService implements GovernanceService {
  async evaluate(ctx: ExecutionContext): Promise<ExecDecision> {
    const cmd = ctx.command.trim();

    // å±é™©å‘½ä»¤é»‘åå•
    const dangerousPatterns = [
      /rm\s+-rf\s+\//,           // rm -rf /
      /dd\s+if=.*of=\/dev\//,    // dd å†™å…¥è®¾å¤‡
      /mkfs/,                    // æ ¼å¼åŒ–
      /:\(\)\{\s*:\|:&\s*\};:/,  // fork bomb
    ];

    for (const pattern of dangerousPatterns) {
      if (pattern.test(cmd)) {
        return {
          allowed: false,
          reason: 'Detected potentially destructive command',
          riskLevel: 'R3',
          disclosure: {
            command: cmd,
            riskLevel: 'R3',
            impact: 'This command could cause irreversible system damage',
            requiresConfirmation: true,
          },
        };
      }
    }

    // sudo å‘½ä»¤éœ€è¦é¢å¤–æ£€æŸ¥
    if (cmd.startsWith('sudo ')) {
      const sudoCmd = cmd.substring(5).trim();
      
      // é€’å½’æ£€æŸ¥ sudo åçš„å‘½ä»¤
      const sudoDecision = await this.evaluate({
        ...ctx,
        command: sudoCmd,
      });

      if (!sudoDecision.allowed) {
        return {
          allowed: false,
          reason: `Sudo execution blocked: ${sudoDecision.reason}`,
          riskLevel: 'R2',
        };
      }

      return {
        allowed: true,
        normalizedCmd: cmd,
        reasoning: 'Privileged command approved with caution',
      };
    }

    // é»˜è®¤å…è®¸
    return {
      allowed: true,
      normalizedCmd: cmd,
    };
  }
}

/**
 * SSH é…ç½®
 */
interface SSHConfig {
  host: string;
  port?: number;
  username: string;
  privateKey?: string;
  password?: string;
}

/**
 * åŠ è½½ SSH é…ç½®
 */
function loadSSHConfig(host: string): SSHConfig | null {
  const configPath = path.join(os.homedir(), '.yuangs', 'ssh_config.json');
  
  if (!fs.existsSync(configPath)) {
    return null;
  }

  try {
    const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
    return config.hosts?.[host] || null;
  } catch (error) {
    console.error(`Failed to load SSH config: ${error}`);
    return null;
  }
}

/**
 * è§£æ SSH è¿æ¥å­—ç¬¦ä¸²
 * æ”¯æŒæ ¼å¼: user@host, user@host:port
 */
function parseSSHString(connectionString: string): Partial<SSHConfig> {
  const match = connectionString.match(/^(?:([^@]+)@)?([^:]+)(?::(\d+))?$/);
  
  if (!match) {
    throw new Error(`Invalid SSH connection string: ${connectionString}`);
  }

  const [, username, host, port] = match;

  return {
    host,
    username: username || os.userInfo().username,
    port: port ? parseInt(port, 10) : 22,
  };
}

/**
/**
 * å‡†å¤‡ SSH é…ç½®
 */
async function prepareSSHConfig(connection: string, options: any): Promise<SSHConfig> {
  // è§£æè¿æ¥å­—ç¬¦ä¸²
  const parsed = parseSSHString(connection);
  
  // å°è¯•åŠ è½½é…ç½®
  const savedConfig = loadSSHConfig(parsed.host!);
  
  const config: SSHConfig = {
    host: parsed.host!,
    username: parsed.username!,
    port: parseInt(options.port, 10) || parsed.port || 22,
  };

  // å¤„ç†è®¤è¯
  if (options.identity) {
    config.privateKey = fs.readFileSync(options.identity, 'utf-8');
  } else if (savedConfig?.privateKey) {
    config.privateKey = fs.readFileSync(savedConfig.privateKey, 'utf-8');
  } else if (options.password) {
    config.password = options.password;
  } else if (savedConfig?.password) {
    config.password = savedConfig.password;
  } else {
    // å°è¯•é»˜è®¤å¯†é’¥
    const defaultKeyPath = path.join(os.homedir(), '.ssh', 'id_rsa');
    if (fs.existsSync(defaultKeyPath)) {
      config.privateKey = fs.readFileSync(defaultKeyPath, 'utf-8');
    } else {
      throw new Error('No authentication method provided');
    }
  }

  return config;
}

/**
 * å¯åŠ¨å‘½ä»¤è¡Œç»ˆç«¯
 */
async function startCommandLineTerminal(connection: string, config: SSHConfig) {
  console.log(`ğŸ” Connecting to ${config.username}@${config.host}:${config.port}...`);

  // åˆ›å»º SSH ä¼šè¯
  const session = new SSHSession();
  await session.connect(config);

  console.log(`âœ… Connected to ${config.host}`);
  console.log(`ğŸ›¡ï¸  AI Governance enabled`);
  
  // è·å–åˆå§‹ç»ˆç«¯å°ºå¯¸
  const width = process.stdout.columns || 80;
  const height = process.stdout.rows || 24;

  // åˆå§‹åŒ–å½•åƒæœº
  const recorder = new Recorder({
    user: config.username,
    host: config.host,
    width,
    height,
    command: `yuangs ssh ${connection}`
  });

  console.log(`ğŸ“ Session recording started: ${recorder.getFilePath()}\n`);

  // åˆ›å»ºæ²»ç†æœåŠ¡
  const governance = new SimpleGovernanceService();

  // åˆ›å»ºæ²»ç†æ‰§è¡Œå™¨ (ä¼ å…¥ recorder)
  const executor = new SSHGovernedExecutor(session, governance, recorder);

  // åˆ›å»ºè¾“å…¥ç¼“å†²åŒº
  const inputBuffer = new InputBuffer();
  
  // è¿½è¸ªå½“å‰è¡Œå·²å‘é€ç»™æœåŠ¡å™¨çš„å­—ç¬¦
  let lineBuffer = '';

  // å¤„ç†ç»ˆç«¯ resize
  // å…³é”®: åŒæ—¶æ›´æ–° SSH PTY å’Œ å½•åƒæœº
  process.stdout.on('resize', () => {
    const { columns, rows } = process.stdout;
    const w = columns || 80;
    const h = rows || 24;
    session.resize(w, h);
    recorder.recordResize(w, h);
  });

  // è®¾ç½®åŸå§‹æ¨¡å¼
  if (process.stdin.isTTY) {
    process.stdin.setRawMode(true);
  }
  process.stdin.resume();

  // å¤„ç†ç”¨æˆ·è¾“å…¥
  process.stdin.on('data', async (chunk: Buffer) => {
    const input = chunk.toString();

    // æ£€æŸ¥æ˜¯å¦æ˜¯å®Œæ•´å‘½ä»¤
    const cmd = inputBuffer.push(input);

    if (cmd !== null) {
      // æ£€æµ‹åˆ°å®Œæ•´å‘½ä»¤
      
      // å¯¹å·²å‘é€ç¼“å†²åŒºè¿›è¡Œ Backspace å¤„ç†ï¼Œä»¥åŒ¹é… cmd çš„æ ¼å¼
      const processedLineBuffer = InputBuffer.processBackspace(lineBuffer);

      // è®¡ç®— unsentCommand
      let unsent = '';
      
      if (cmd.startsWith(processedLineBuffer)) {
          unsent = cmd.slice(processedLineBuffer.length);
      } else {
          // å¦‚æœ buffer ä¸åŒ¹é… (æå…¶ç½•è§), å…¨é‡é‡å‘ä»¥é˜²ä¸‡ä¸€
          unsent = cmd;
      }
      
      // å®Œæ•´å‘½ä»¤: è¿›å…¥æ²»ç†æµç¨‹
      await executor.handleCommand(cmd, config.host, config.username, unsent);
      
      // æ¸…ç©ºå·²å‘é€ç¼“å†²åŒº
      lineBuffer = '';
    } else {
      // éå®Œæ•´å‘½ä»¤: ç›´æ¥é€ä¼  (æ‰“å­—ä½“éªŒ)
      // ä¹Ÿè¦è®°å½•è¾“å…¥! å¦åˆ™å›æ”¾æ—¶çœ‹ä¸åˆ°æ‰“å­—è¿‡ç¨‹
      // æ³¨æ„: è¿™é‡Œè®°å½•çš„æ˜¯åŸå§‹æŒ‰é”® (æ¯”å¦‚ 'l', 's', Backspace ç­‰)
      // åªæœ‰å½“ GovernedExecutor.isSensitive() ä¸º false æ—¶æ‰è®°å½•
      if (!executor.isSensitive()) {
         recorder.recordInput(input);
      }
      session.write(chunk);
      lineBuffer += input;
    }
  });

  // å¤„ç†ä¼šè¯å…³é—­
  session.on('close', () => {
    recorder.close();
    console.log('\n\nğŸ”Œ Connection closed');
    process.exit(0);
  });

  // å¤„ç† Ctrl+C
  process.on('SIGINT', () => {
    recorder.close();
    console.log('\n\nğŸ‘‹ Disconnecting...');
    session.close();
    process.exit(0);
  });
}

/**
 * SSH å‘½ä»¤å®ç°
 */
export function registerSSHCommand(program: Command): void {
  program
    .command('ssh <connection>')
    .description('Connect to remote host with AI governance')
    .option('-p, --port <port>', 'SSH port', '22')
    .option('-i, --identity <file>', 'Private key file')
    .option('--password <password>', 'Password (not recommended)')
    .option('--web', 'Launch in web-based terminal (Beta)', false)
    .action(async (connection: string, options: any) => {
      try {
        const config = await prepareSSHConfig(connection, options);
        
        if (options.web) {
            await startWebTerminal(config);
        } else {
            await startCommandLineTerminal(connection, config);
        }
      } catch (error: any) {
        console.error(`âŒ SSH connection failed: ${error.message}`);
        process.exit(1);
      }
    });
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ commands/ssh/server.ts

````typescript
import express from 'express';
import { createServer } from 'http';
import { Server, Socket } from 'socket.io';
import open from 'open';
import path from 'path';
import { SSHSession } from '../../ssh/SSHSession';
import { SSHGovernedExecutor, GovernanceService, ExecDecision } from '../../ssh/GovernedExecutor';
import { InputBuffer } from '../../ssh/InputBuffer';

export async function startWebTerminal(config: any, port: number = 3000) {
    const app = express();
    const httpServer = createServer(app);
    const io = new Server(httpServer);

    // Fix path resolution: dist/commands/ssh -> ../../../public
    const publicPath = path.join(__dirname, '../../../public');
    console.log(`ğŸ“‚ Serving static files from: ${publicPath}`);

    // Serve index.html at root path
    app.get('/', (req, res) => {
        res.sendFile(path.join(publicPath, 'index.html'));
    });

    // Serve other static files
    app.use(express.static(publicPath));

    io.on('connection', async (socket: Socket) => {
        console.log('ğŸŒ Browser connected to yuangs-web-term');

        // Initialize with the default config
        let currentConfig = { ...config };
        let session = new SSHSession();
        const inputBuffer = new InputBuffer();

        // è¿™é‡Œæ¥å…¥ä½ ç°æœ‰çš„æ²»ç†æœåŠ¡é€»è¾‘
        const governance: GovernanceService = {
            evaluate: async (ctx): Promise<ExecDecision> => {
                const cmd = ctx.command.trim();

                // 1. é€šçŸ¥å‰ç«¯ï¼šAI æ­£åœ¨æ€è€ƒ (å¢åŠ å»¶è¿Ÿæ¨¡æ‹Ÿæ·±åº¦åˆ†æ)
                socket.emit('governance_evaluating', {
                    command: cmd,
                    timestamp: new Date().toLocaleTimeString()
                });

                // æ¨¡æ‹Ÿ AI ç¥ç»ç½‘ç»œåˆ†æå»¶è¿Ÿ (å·²ä¼˜åŒ–ä¸º 20ms ä»¥æå‡æ€§èƒ½)
                await new Promise(r => setTimeout(r, 20));

                // 2. ç®€å•çš„å±é™©æ£€æµ‹é€»è¾‘ (ç”¨äºæ¼”ç¤ºè§†è§‰æ•ˆæœ)
                const dangerousPatterns = [
                    { regex: /rm\s+-rf\s+\//, reason: 'éæ³•çš„æ–‡ä»¶ç³»ç»Ÿæ ¹ç›®å½•åˆ é™¤å°è¯•', impact: 'ç³»ç»Ÿå°†å½»åº•å´©æºƒ', risk: 'R3' },
                    { regex: /mkfs/, reason: 'æ ¼å¼åŒ–ç£ç›˜å°è¯•', impact: 'ç£ç›˜æ•°æ®å°†å…¨éƒ¨ä¸¢å¤±', risk: 'R3' },
                    { regex: /dd\s+if=.*of=\/dev\//, reason: 'åº•å±‚è®¾å¤‡å†™è¦†ç›–å°è¯•', impact: 'å¯èƒ½ç ´åå¼•å¯¼æ‰‡åŒº', risk: 'R3' }
                ];

                for (const p of dangerousPatterns) {
                    if (p.regex.test(cmd)) {
                        const decision: ExecDecision = {
                            allowed: false,
                            reason: p.reason,
                            riskLevel: p.risk,
                            disclosure: {
                                command: cmd,
                                impact: p.impact,
                                riskLevel: p.risk,
                                requiresConfirmation: true
                            }
                        };

                        // ğŸš¨ å‘é€è¯¦ç»†å†³ç­–ç»™å‰ç«¯é¢„è§ˆ
                        socket.emit('governance_decision', decision);

                        // ğŸš¨ è§¦å‘å…¨å±è§†è§‰è­¦æŠ¥
                        socket.emit('governance_alert', {
                            level: 'critical',
                            message: 'BLOCK: ' + p.risk
                        });

                        return decision;
                    }
                }

                // å®‰å…¨å‘½ä»¤
                const safeDecision: ExecDecision = {
                    allowed: true,
                    normalizedCmd: ctx.command,
                    reasoning: 'å‘½ä»¤é€šè¿‡å¤šç»´è¯­ä¹‰å®‰å…¨å®¡è®¡ï¼Œåˆ†ææ˜¾ç¤ºä¸ºä½é£é™©ç³»ç»Ÿç®¡ç†ä»»åŠ¡ã€‚'
                };
                socket.emit('governance_decision', safeDecision);

                return safeDecision;
            }
        };

        let executor = new SSHGovernedExecutor(session, governance);

        // Handle server change request from frontend
        socket.on('change_server', async (serverInfo: string) => {
            try {
                // Parse server info in format user@host or user@host:port
                const parts = serverInfo.split('@');
                if (parts.length < 2) {
                    socket.emit('output', `\r\nâŒ Invalid server format. Use: user@host or user@host:port\r\n`);
                    return;
                }

                const username = parts[0];
                const hostParts = parts[1].split(':');
                const host = hostParts[0];
                const port = hostParts[1] ? parseInt(hostParts[1]) : 22;

                // Close existing session
                if (session.isConnected()) {
                    session.close();
                }

                // Create new session with new config
                session = new SSHSession();
                executor = new SSHGovernedExecutor(session, governance);

                currentConfig = {
                    host: host,
                    port: port,
                    username: username,
                    readyTimeout: 60000, // Use the timeout we set earlier
                    privateKey: config.privateKey, // Use the same private key
                };

                // Connect to the new server
                await session.connect(currentConfig);
                socket.emit('output', `\r\nğŸ›¡ï¸ Switched to server: ${serverInfo}\r\n`);

                // Setup event handlers for the new session
                session.on('data', (data: Buffer) => {
                    socket.emit('output', data.toString());
                });

            } catch (err: any) {
                socket.emit('output', `\r\nâŒ Server switch failed: ${err.message}\r\n`);
            }
        });

        try {
            await session.connect(currentConfig);
            socket.emit('output', '\r\nğŸ›¡ï¸  yuangs AI Governance Web Shell Connected\r\n');

            // æ ¸å¿ƒæ¡¥æ¥ï¼šSSH è¾“å‡º -> WebSocket -> æµè§ˆå™¨
            session.on('data', (data: Buffer) => {
                let output = data.toString();
                
                // Filter out shell prompt symbols that appear after command completion
                // This removes lines that are just prompt symbols with whitespace
                const lines = output.split('\n');
                const filteredLines = lines.filter(line => {
                    const trimmed = line.trim();
                    // Remove lines that are only % or # (with optional spaces)
                    if (trimmed === '%' || trimmed === '#') {
                        return false;
                    }
                    // Remove lines that start with % or # followed only by spaces or end of line
                    if (/^[%#]\s*$/.test(line)) {
                        return false;
                    }
                    // Remove lines that are ONLY a prompt symbol (no other content)
                    if (/^[\s]*[%#][\s]*$/.test(line)) {
                        return false;
                    }
                    return true;
                });
                
                // Further filter: if a line starts with prompt but has content, keep the content
                const processedLines = filteredLines.map(line => {
                    // If line starts with just % or # at the beginning (possibly with spaces before)
                    // and then has actual content, remove the prompt symbol
                    // Example: "% ls" -> "ls", "  # pwd" -> "pwd"
                    const match = line.match(/^[\s]*[%#][\s]+(.+)$/);
                    if (match) {
                        return match[1]; // Return content after the prompt
                    }
                    return line;
                });
                
                output = processedLines.join('\n');
                
                socket.emit('output', output);
            });

            // è¿½è¸ªå½“å‰è¡Œå·²å‘é€ç»™æœåŠ¡å™¨çš„å­—ç¬¦
            let lineBuffer = '';

            // æ ¸å¿ƒæ¡¥æ¥ï¼šæµè§ˆå™¨è¾“å…¥ -> WebSocket -> æ²»ç†æ‰§è¡Œå™¨
            socket.on('input', async (data: string) => {
                const cmd = inputBuffer.push(data);
                if (cmd !== null) {

                    // å¯¹å·²å‘é€ç¼“å†²åŒºè¿›è¡Œ Backspace å¤„ç†ï¼Œä»¥åŒ¹é… cmd çš„æ ¼å¼
                    const processedLineBuffer = InputBuffer.processBackspace(lineBuffer);

                    // è®¡ç®— unsentCommand
                    let unsent = '';

                    if (cmd.startsWith(processedLineBuffer)) {
                        unsent = cmd.slice(processedLineBuffer.length);
                    } else {
                        // å¦‚æœ buffer ä¸åŒ¹é… (æå…¶ç½•è§), å…¨é‡é‡å‘ä»¥é˜²ä¸‡ä¸€
                        unsent = cmd;
                    }

                    // è§¦å‘æ²»ç†é€»è¾‘ (ä¼ å…¥ unsent éƒ¨åˆ†)
                    await executor.handleCommand(cmd, currentConfig.host, currentConfig.username, unsent);

                    // æ¸…ç©ºå·²å‘é€ç¼“å†²åŒº
                    lineBuffer = '';
                } else {
                    // æ™®é€šå­—ç¬¦ç›´æ¥é€ä¼ ï¼ˆä¸ºäº†æ‰“å­—å›æ˜¾æµç•…ï¼‰
                    // åªæœ‰åœ¨éæ•æ„Ÿæ¨¡å¼æ‰è®°å½•/é€ä¼ ?
                    // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œç›´æ¥é€ä¼ ï¼ŒInputBuffer ä¼šåœ¨å†…éƒ¨èšåˆ
                    session.write(data);
                    lineBuffer += data;
                }
            });

            socket.on('resize', ({ cols, rows }: { cols: number, rows: number }) => {
                session.resize(cols, rows);
            });

            socket.on('disconnect', () => {
                session.close();
                console.log('ğŸ”Œ Browser disconnected');
            });

        } catch (err: any) {
            socket.emit('output', `\r\nâŒ Connection Failed: ${err.message}\r\n`);
        }
    });

    httpServer.listen(port, '0.0.0.0', () => {
        const url = `http://0.0.0.0:${port}`;
        console.log(`ğŸš€ yuangs-web-term is running at ${url}`);
        // Don't auto-open browser when binding to all interfaces (for remote access)
        // open(url); // è‡ªåŠ¨æ‰“å¼€æµè§ˆå™¨
    });
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/apps.ts

````typescript
import { exec } from 'child_process';
import fs from 'fs';
import path from 'path';
import yaml from 'js-yaml';
import os from 'os';
import { DEFAULT_APPS, parseAppsConfig } from './validation';

export { DEFAULT_APPS };

export function loadAppsConfig(): Record<string, string> {
    const configPaths = [
        path.join(process.cwd(), 'yuangs.config.json'),
        path.join(process.cwd(), 'yuangs.config.yaml'),
        path.join(process.cwd(), 'yuangs.config.yml'),
        path.join(process.cwd(), '.yuangs.json'),
        path.join(process.cwd(), '.yuangs.yaml'),
        path.join(process.cwd(), '.yuangs.yml'),
        path.join(os.homedir(), '.yuangs.json'),
        path.join(os.homedir(), '.yuangs.yaml'),
        path.join(os.homedir(), '.yuangs.yml'),
    ];

    for (const configPath of configPaths) {
        if (fs.existsSync(configPath)) {
            try {
                const configContent = fs.readFileSync(configPath, 'utf8');
                let config: Record<string, string>;
                if (configPath.endsWith('.yaml') || configPath.endsWith('.yml')) {
                    config = yaml.load(configContent) as Record<string, string>;
                } else {
                    config = parseAppsConfig(configContent);
                }
                return config;
            } catch (error) { }
        }
    }
    return DEFAULT_APPS;
}


export function openUrl(url: string) {
    let command;
    switch (process.platform) {
        case 'darwin': command = `open "${url}"`; break;
        case 'win32': command = `start "${url}"`; break;
        default: command = `xdg-open "${url}"`; break;
    }
    exec(command);
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/autofix.ts

````typescript
import { OSProfile } from './os';
import { buildFixPrompt } from '../ai/prompt';
import { askAI } from '../ai/client';
import { safeParseJSON, AIFixPlan, aiFixPlanSchema } from './validation';

export async function autoFixCommand(
    originalCmd: string,
    stderr: string,
    os: OSProfile,
    model?: string
): Promise<AIFixPlan | null> {
    const prompt = buildFixPrompt(originalCmd, stderr, os);
    const raw = await askAI(prompt, model);

    const parseResult = safeParseJSON(raw, aiFixPlanSchema, {} as AIFixPlan);

    if (!parseResult.success) {
        return null;
    }

    return parseResult.data;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/capabilities.ts

````typescript
export enum AtomicCapability {
  TEXT_GENERATION = 'text_generation',
  CODE_GENERATION = 'code_generation',
  TOOL_CALLING = 'tool_calling',
  LONG_CONTEXT = 'long_context',
  REASONING = 'reasoning',
  STREAMING = 'streaming',
}

export interface CompositeCapability {
  name: string;
  composedOf: AtomicCapability[];
}

export const COMPOSITE_CAPABILITIES: CompositeCapability[] = [
  {
    name: 'interactive_agent',
    composedOf: [AtomicCapability.TOOL_CALLING, AtomicCapability.REASONING],
  },
  {
    name: 'large_repo_analysis',
    composedOf: [AtomicCapability.LONG_CONTEXT, AtomicCapability.REASONING],
  },
  {
    name: 'safe_code_editing',
    composedOf: [AtomicCapability.CODE_GENERATION, AtomicCapability.REASONING],
  },
];

export enum ConstraintCapability {
  PREFER_DETERMINISTIC = 'prefer_deterministic',
  LOW_COST = 'low_cost',
  FAST_RESPONSE = 'fast_response',
}

export const CAPABILITY_VERSION = '1.0';

export function isAtomicCapability(value: string): value is AtomicCapability {
  return Object.values(AtomicCapability).includes(value as AtomicCapability);
}

export function isConstraintCapability(value: string): value is ConstraintCapability {
  return Object.values(ConstraintCapability).includes(value as ConstraintCapability);
}

export function resolveCompositeCapability(name: string): AtomicCapability[] {
  const composite = COMPOSITE_CAPABILITIES.find(c => c.name === name);
  if (!composite) {
    throw new Error(`Unknown composite capability: ${name}`);
  }
  return composite.composedOf;
}

export function expandCapabilities(
  capabilities: Array<AtomicCapability | string>
): Set<AtomicCapability> {
  const result = new Set<AtomicCapability>();

  for (const cap of capabilities) {
    if (isAtomicCapability(cap)) {
      result.add(cap);
    } else {
      const atomicCaps = resolveCompositeCapability(cap);
      atomicCaps.forEach(c => result.add(c));
    }
  }

  return result;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/capabilityInference.ts

````typescript
import { AtomicCapability } from '../core/capabilities';
import type { CapabilityRequirement } from '../core/modelMatcher';

export function inferCapabilityRequirement(userInput: string): CapabilityRequirement {
  const required: AtomicCapability[] = [];

  const input = userInput.toLowerCase();

  if (input.includes('ä»£ç ') || input.includes('script') || input.includes('æ–‡ä»¶') || input.includes('create') || input.includes('write')) {
    required.push(AtomicCapability.CODE_GENERATION);
  }

  if (input.includes('åˆ†æ') || input.includes('ç†è§£') || input.includes('è§£é‡Š') || input.includes('æ¨ç†')) {
    required.push(AtomicCapability.REASONING);
  }

  if (input.includes('é•¿') || input.includes('large') || input.includes('ä»“åº“') || input.includes('ç›®å½•') || input.includes('æ‰€æœ‰æ–‡ä»¶')) {
    required.push(AtomicCapability.LONG_CONTEXT);
  }

  return {
    required: Array.from(new Set(required)),
    preferred: [],
  };
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/capabilitySystem.ts

````typescript
import {
  CapabilityRequirement,
  matchModelWithFallback,
  ModelCapabilities,
  CapabilityMatchResult,
} from './modelMatcher';
import {
  mergeConfigs,
  loadConfigAt,
  dumpConfigSnapshot,
  getConfigFilePaths,
  MergedConfig,
} from './configMerge';
import {
  createExecutionRecord,
  ExecutionRecord,
} from './executionRecord';
import {
  saveExecutionRecord,
  loadExecutionRecord,
  listExecutionRecords,
} from './executionStore';
import { replayEngine, ReplayOptions, ReplayResult } from './replayEngine';

export class CapabilitySystem {
  private primaryModels: ModelCapabilities[] = [];
  private fallbackModels: ModelCapabilities[] = [];

  constructor() {
    this.initializeDefaultModels();
  }

  private initializeDefaultModels(): void {
    // åˆå§‹åŒ–ä¸ºç©ºæ•°ç»„ï¼Œè®©é…ç½®æ–‡ä»¶æˆä¸ºä¸»è¦æ¥æº
    this.primaryModels = [];
    this.fallbackModels = [];
  }

  matchCapability(requirement: CapabilityRequirement): CapabilityMatchResult {
    const allModels = this.getAllModels();
    const primaryModels = [...this.primaryModels, ...this.loadCustomModels()];
    return matchModelWithFallback(
      primaryModels,
      this.fallbackModels,
      requirement
    );
  }

  loadMergedConfig(): MergedConfig {
    const builtin = {
      aiProxyUrl: 'https://aiproxy.want.biz/v1/chat/completions',
      defaultModel: 'Assistant',
      accountType: 'paid',
    };

    const filePaths = getConfigFilePaths();
    const projectConfig = filePaths.project ? loadConfigAt(filePaths.project) : null;
    const userGlobal = loadConfigAt(filePaths.userGlobal);

    return mergeConfigs(builtin, userGlobal, projectConfig, null);
  }

  loadCustomModels(): ModelCapabilities[] {
    const filePaths = getConfigFilePaths();
    const projectConfig = filePaths.project ? loadConfigAt(filePaths.project) : null;
    const userGlobal = loadConfigAt(filePaths.userGlobal);

    const customModelsArray = [];
    if (userGlobal?.models && Array.isArray(userGlobal.models)) {
      customModelsArray.push(...userGlobal.models as ModelCapabilities[]);
    }
    if (projectConfig?.models && Array.isArray(projectConfig.models)) {
      customModelsArray.push(...projectConfig.models as ModelCapabilities[]);
    }

    return customModelsArray;
  }

  getAllModels(): ModelCapabilities[] {
    const customModels = this.loadCustomModels();
    return [...this.primaryModels, ...this.fallbackModels, ...customModels];
  }

  createAndSaveExecutionRecord(
    commandName: string,
    requirement: CapabilityRequirement,
    matchResult: CapabilityMatchResult,
    command?: string,
    rawInput?: string,
    mode?: string
  ): string {
    const config = this.loadMergedConfig();
    const record = createExecutionRecord(
      commandName,
      requirement,
      config,
      matchResult,
      { success: matchResult.selected !== null },
      command,
      rawInput,
      mode
    );

    const filePath = saveExecutionRecord(record);
    return record.id;
  }

  replayExecution(recordId: string, options: ReplayOptions): Promise<ReplayResult> {
    return replayEngine.replay(recordId, options);
  }

  explainConfig(): string {
    const config = this.loadMergedConfig();
    return dumpConfigSnapshot(config);
  }
}

export const capabilitySystem = new CapabilitySystem();

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/completion.legacy.ts

````typescript
import fs from 'fs';
import path from 'path';
import { Command } from 'commander';
import { loadAppsConfig } from './apps';
import { getMacros } from './macros';
export function getAllCommands(program: Command): string[] {
    const commands: string[] = [];

    program.commands.forEach(cmd => {
        if (cmd.name()) {
            commands.push(cmd.name());
        }
        if (cmd.aliases()) {
            commands.push(...cmd.aliases());
        }
    });

    try {
        const apps = loadAppsConfig();
        Object.keys(apps).forEach(app => {
            if (!commands.includes(app)) {
                commands.push(app);
            }
        });
    } catch {
    }

    try {
        const macros = getMacros();
        Object.keys(macros).forEach(macro => {
            if (!commands.includes(macro)) {
                commands.push(macro);
            }
        });
    } catch {
    }

    return [...new Set(commands)].sort();
}

/**
 * è·å–å‘½ä»¤çš„å­å‘½ä»¤æˆ–å‚æ•°
 */
export function getCommandSubcommands(program: Command, commandName: string): string[] {
    const command = program.commands.find(cmd => cmd.name() === commandName);
    if (!command) return [];

    const subcommands: string[] = [];

    command.commands.forEach(cmd => {
        if (cmd.name()) {
            subcommands.push(cmd.name());
        }
    });

    command.options.forEach(opt => {
        opt.flags.split(/[, ]+/).forEach(flag => {
            if (flag.startsWith('--')) {
                subcommands.push(flag);
            } else if (flag.startsWith('-')) {
                subcommands.push(flag);
            }
        });
    });

    return [...new Set(subcommands)].sort();
}

/**
 * ç”Ÿæˆ Bash è¡¥å…¨è„šæœ¬
 */
export function generateBashCompletion(program: Command): string {
    const commands = getAllCommands(program);

    return `#!/bin/bash
# yuangs bash completion

_yuangs_completion() {
    local cur prev words cword
    _init_completion || return

    # è¡¥å…¨å‘½ä»¤å
    if [[ \${COMP_CWORD} -eq 1 ]]; then
        COMPREPLY=($(compgen -W '${commands.join(' ')}' -- "\${cur}"))
        return
    fi

    # è¡¥å…¨å­å‘½ä»¤å’Œå‚æ•°
    local cmd="\${words[1]}"
    case "\${cmd}" in
        ${commands.map(cmd => `
        ${cmd})
            case "\${prev}" in
                -m|--model)
                    COMPREPLY=($(compgen -W "gemini-2.5-flash-lite gemini-2.5-pro" -- "\${cur}"))
                    ;;
                *)
                    COMPREPLY=($(compgen -W "$(yuangs _complete_subcommand ${cmd})" -- "\${cur}"))
                    ;;
            esac
            ;;
        `).join('\n')}

        *)
            ;;
    esac
}

complete -F _yuangs_completion yuangs
`;
}

/**
 * ç”Ÿæˆ Zsh è¡¥å…¨è„šæœ¬
 */
export function generateZshCompletion(program: Command): string {
    const commands = getAllCommands(program);

    return `#compdef yuangs
# yuangs zsh completion

_yuangs() {
    local -a commands
    commands=(
${commands.map(cmd => `        '${cmd}:$(yuangs _describe ${cmd})'`).join('\n')}
    )

    if (( CURRENT == 2 )); then
        _describe 'command' commands
    else
        local cmd="\${words[2]}"
        case "\${cmd}" in
${commands.map(cmd => `
            ${cmd})
                _values 'options' $(yuangs _complete_subcommand ${cmd})
                ;;
`).join('\n')}
            *)
                ;;
        esac
    fi
}

_yuangs
`;
}

export async function installBashCompletion(program: Command): Promise<boolean> {
    const bashrcPath = path.join(process.env.HOME || '', '.bashrc');
    const bashCompletionDir = path.join(process.env.HOME || '', '.bash_completion.d');

    try {
        if (!fs.existsSync(bashCompletionDir)) {
            fs.mkdirSync(bashCompletionDir, { recursive: true });
        }

        const completionPath = path.join(bashCompletionDir, 'yuangs-completion.bash');
        const completionScript = generateBashCompletion(program);

        fs.writeFileSync(completionPath, completionScript, { mode: 0o644 });
        const sourceLine = `# yuangs completion
if [ -f ~/.bash_completion.d/yuangs-completion.bash ]; then
    source ~/.bash_completion.d/yuangs-completion.bash
fi
`;

        let bashrc = '';
        if (fs.existsSync(bashrcPath)) {
            bashrc = fs.readFileSync(bashrcPath, 'utf-8');
        }

        if (!bashrc.includes('yuangs-completion.bash')) {
            fs.appendFileSync(bashrcPath, `\n${sourceLine}`);
        }

        return true;
    } catch (error) {
        console.error('å®‰è£… Bash è¡¥å…¨å¤±è´¥:', error);
        return false;
    }
}

export async function installZshCompletion(program: Command): Promise<boolean> {
    const zshrcPath = path.join(process.env.HOME || '', '.zshrc');
    const zfuncDir = path.join(process.env.HOME || '', '.zfunctions');

    try {
        if (!fs.existsSync(zfuncDir)) {
            fs.mkdirSync(zfuncDir, { recursive: true });
        }

        const completionPath = path.join(zfuncDir, '_yuangs');
        const completionScript = generateZshCompletion(program);

        fs.writeFileSync(completionPath, completionScript, { mode: 0o644 });
        let zshrc = '';
        if (fs.existsSync(zshrcPath)) {
            zshrc = fs.readFileSync(zshrcPath, 'utf-8');
        }

        const fpathLine = 'fpath=(~/.zfunctions $fpath)';
        const autoloadLine = 'autoload -U compinit && compinit';

        if (!zshrc.includes('fpath=')) {
            fs.appendFileSync(zshrcPath, `\n${fpathLine}`);
        }

        if (!zshrc.includes('autoload -U compinit')) {
            fs.appendFileSync(zshrcPath, `\n${autoloadLine}`);
        }

        return true;
    } catch (error) {
        console.error('å®‰è£… Zsh è¡¥å…¨å¤±è´¥:', error);
        return false;
    }
}

/**
 * è·å–å‘½ä»¤æè¿°ï¼ˆç”¨äºè¡¥å…¨æç¤ºï¼‰
 */
export function getCommandDescription(program: Command, commandName: string): string {
    const command = program.commands.find(cmd => cmd.name() === commandName);
    return command?.description() || '';
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/completion/builtin.ts

````typescript
import type { CompletionItem } from './types';

export function getBuiltinCommands(): Array<{ name: string; description: string }> {
  return [
    { name: 'ai', description: 'å‘ AI æé—®' },
    { name: 'list', description: 'åˆ—å‡ºæ‰€æœ‰åº”ç”¨' },
    { name: 'history', description: 'æŸ¥çœ‹åŠæ‰§è¡Œå‘½ä»¤å†å²' },
    { name: 'config', description: 'ç®¡ç†æœ¬åœ°é…ç½®' },
    { name: 'macros', description: 'æŸ¥çœ‹æ‰€æœ‰å¿«æ·æŒ‡ä»¤' },
    { name: 'save', description: 'ä¿å­˜å¿«æ·æŒ‡ä»¤' },
    { name: 'run', description: 'æ‰§è¡Œå¿«æ·æŒ‡ä»¤' },
    { name: 'help', description: 'æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯' },
    { name: 'completion', description: 'å®‰è£… Shell è¡¥å…¨' },
    { name: 'shici', description: 'æ‰“å¼€å¤è¯—è¯ PWA' },
    { name: 'dict', description: 'æ‰“å¼€è‹±è¯­è¯å…¸' },
    { name: 'pong', description: 'æ‰“å¼€ Pong æ¸¸æˆ' }
  ];
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/completion/cache.ts

````typescript
import type { CompletionItem } from './types';

export class CompletionCache {
  private static instance: CompletionCache;
  private cache: Map<string, CompletionItem[]>;
  private timestamp: number;
  private readonly ttl: number = 5000;

  private constructor() {
    this.cache = new Map();
    this.timestamp = Date.now();
  }

  static getInstance(): CompletionCache {
    if (!CompletionCache.instance) {
      CompletionCache.instance = new CompletionCache();
    }
    return CompletionCache.instance;
  }

  get(key: string): CompletionItem[] | null {
    const now = Date.now();
    if (now - this.timestamp > this.ttl) {
      this.cache.clear();
      this.timestamp = now;
      return null;
    }
    return this.cache.get(key) || null;
  }

  set(key: string, items: CompletionItem[]): void {
    this.cache.set(key, items);
  }

  invalidate(): void {
    this.cache.clear();
    this.timestamp = 0;
  }

  invalidatePattern(pattern: RegExp): void {
    for (const key of this.cache.keys()) {
      if (pattern.test(key)) {
        this.cache.delete(key);
      }
    }
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/completion/index.ts

````typescript
import { CompletionRequest, CompletionResponse } from './types';
import { resolveCompletion } from './resolver';

export async function complete(
  req: CompletionRequest
): Promise<CompletionResponse> {
  if (!Array.isArray(req.words)) {
    return { items: [], isPartial: false };
  }

  if (
    typeof req.currentIndex !== 'number' ||
    req.currentIndex < 0 ||
    req.currentIndex >= req.words.length
  ) {
    return { items: [], isPartial: false };
  }

  return resolveCompletion(req);
}

export { setProgramInstance } from './resolver';

export {
  getAllCommands,
  getCommandSubcommands,
  getCommandDescription,
  installBashCompletion,
  installZshCompletion
} from '../completion.legacy';

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/completion/path.ts

````typescript
import fs from 'fs';
import path from 'path';

export type PathKind = 'file' | 'dir';

export function resolvePathSuggestions(
  input: string,
  kind: PathKind
): string[] {
  const cwd = process.cwd();
  const normalized = input.replace(/^~(?=$|\/)/, process.env.HOME || '');
  const isDirInput = normalized.endsWith(path.sep);

  const baseDir = isDirInput
    ? path.resolve(cwd, normalized)
    : path.resolve(cwd, path.dirname(normalized));

  const prefix = isDirInput ? '' : path.basename(normalized);

  try {
    const entries = fs.readdirSync(baseDir, { withFileTypes: true });
    return entries
      .filter(e => !e.name.startsWith('.'))
      .filter(e => {
        if (kind === 'file') return e.isFile();
        return e.isDirectory();
      })
      .filter(e => e.name.startsWith(prefix))
      .map(e => {
        const fullPath = path.join(baseDir, e.name);
        const suggestion = e.isDirectory()
          ? fullPath + path.sep
          : fullPath;
        return suggestion.replace(/^\\/g, '');
      });
  } catch {
    return [];
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/completion/resolver.ts

````typescript
import { CompletionRequest, CompletionResponse, CompletionItem } from './types';
import { unique } from './utils';
import { getBuiltinCommands } from './builtin';
import { loadAppsConfig } from '../apps';
import { getMacros } from '../macros';
import { Command } from 'commander';

let programInstance: Command | null = null;

export function setProgramInstance(program: Command): void {
  programInstance = program;
}

function getProgramInstance(): Command {
  return programInstance || ({} as Command);
}

export async function resolveCompletion(
  req: CompletionRequest
): Promise<CompletionResponse> {
  const { words, currentIndex } = req;

  const currentWord = words[currentIndex] ?? '';
  const previousWord = words[currentIndex - 1] ?? '';

  if (currentIndex === 1) {
    return completeTopLevel(currentWord);
  }

  return completeSubcommand(words.slice(1, currentIndex), currentWord, previousWord);
}

function completeTopLevel(prefix: string): CompletionResponse {
  const items: CompletionItem[] = [];

  const commands = getBuiltinCommands();
  commands.forEach(cmd => {
    items.push({ label: cmd.name });
  });

  try {
    const apps = loadAppsConfig();
    Object.keys(apps).forEach(name => {
      if (!items.find(i => i.label === name)) {
        items.push({ label: name });
      }
    });
  } catch {}

  try {
    const macros = getMacros();
    Object.keys(macros).forEach(name => {
      if (!items.find(i => i.label === name)) {
        items.push({ label: name });
      }
    });
  } catch {}

  const filtered = items.filter(item => item.label.startsWith(prefix));

  return {
    items: unique(filtered),
    isPartial: true
  };
}

function completeSubcommand(
  path: string[],
  prefix: string,
  prev: string
): CompletionResponse {
  const items: CompletionItem[] = [];

  if (prev === '--model' || prev === '-m') {
    items.push(
      { label: 'gemini-2.5-flash-lite' },
      { label: 'gemini-2.5-pro' },
      { label: 'Assistant' },
      { label: 'GPT-4o-mini' }
    );
  } else if (path.length > 0) {
    const baseCommand = path[0];
    const cmd = getProgramInstance().commands.find((c: any) => c.name() === baseCommand);

    if (cmd) {
      cmd.options.forEach((opt: any) => {
        opt.flags.split(/[, ]+/).forEach((flag: string) => {
          if (flag.startsWith('-') && !flag.startsWith('--')) {
            items.push({ label: flag });
          }
        });
      });

      cmd.commands.forEach((subcmd: any) => {
        items.push({ label: subcmd.name() });
      });
    }
  }

  const filtered = items.filter(item => item.label.startsWith(prefix));

  return {
    items: unique(filtered),
    isPartial: true
  };
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/completion/types.ts

````typescript
// core/completion/types.ts

/**
 * yuangs Completion Protocol v1.1
 * ç»ˆæ€è¡¥å…¨åè®® - å”¯ä¸€ã€å¼ºçº¦æŸ
 */

export interface CompletionRequest {
  /**
   * å®Œæ•´ argvï¼Œä¸åŒ…å« node
   * e.g. ['yuangs', 'ai', 'chat', '--m']
   */
  words: string[];

  /**
   * cursor æ‰€åœ¨ index
   */
  currentIndex: number;
}

export interface CompletionItem {
  label: string;
  insertText?: string;
  detail?: string;
}

export interface CompletionResponse {
  items: CompletionItem[];
  isPartial: boolean;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/completion/utils.ts

````typescript
import { CompletionItem } from './types';

export function unique(items: CompletionItem[]): CompletionItem[] {
  const seen = new Set<string>();
  return items.filter(i => {
    if (seen.has(i.label)) return false;
    seen.add(i.label);
    return true;
  });
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/configMerge.ts

````typescript
import fs from 'fs';
import path from 'path';
import os from 'os';
import yaml from 'js-yaml';

export type ConfigSource = 'built-in' | 'user-global' | 'project' | 'command-override';

export interface ConfigFieldSource<T = unknown> {
  value: T;
  source: ConfigSource;
  filePath?: string;
}

export interface MergedConfig {
  aiProxyUrl: ConfigFieldSource<string>;
  defaultModel: ConfigFieldSource<string>;
  accountType: ConfigFieldSource<'free' | 'pro'>;
  [key: string]: ConfigFieldSource<unknown>;
}

export function loadConfigAt(filePath: string): Record<string, unknown> | null {
  if (!fs.existsSync(filePath)) {
    return null;
  }

  try {
    const content = fs.readFileSync(filePath, 'utf8');
    if (filePath.endsWith('.yaml') || filePath.endsWith('.yml')) {
      return yaml.load(content) as Record<string, unknown>;
    }
    return JSON.parse(content);
  } catch (error) {
    console.warn(`Failed to load config from ${filePath}:`, error);
    return null;
  }
}

export function mergeConfigs(
  builtin: Record<string, unknown>,
  userGlobal: Record<string, unknown> | null,
  project: Record<string, unknown> | null,
  commandOverride: Record<string, unknown> | null
): MergedConfig {
  const merged: MergedConfig = {} as MergedConfig;

  const addField = (key: string, value: unknown, source: ConfigSource, filePath?: string) => {
    merged[key] = { value, source, filePath };
  };

  Object.entries(builtin).forEach(([key, value]) => {
    addField(key, value, 'built-in');
  });

  if (userGlobal) {
    Object.entries(userGlobal).forEach(([key, value]) => {
      addField(key, value, 'user-global', path.join(os.homedir(), '.yuangs.json'));
    });
  }

  if (project) {
    Object.entries(project).forEach(([key, value]) => {
      addField(key, value, 'project');
    });
  }

  if (commandOverride) {
    Object.entries(commandOverride).forEach(([key, value]) => {
      addField(key, value, 'command-override');
    });
  }

  return merged;
}

export function dumpConfigSnapshot(config: MergedConfig): string {
  const output: Record<string, any> = {};

  Object.entries(config).forEach(([key, field]) => {
    output[key] = {
      value: field.value,
      source: field.source,
      filePath: field.filePath,
    };
  });

  return JSON.stringify(output, null, 2);
}

function findProjectConfig(cwd = process.cwd()): string | null {
  let dir = cwd;
  const configFiles = ['.yuangs.json', '.yuangs.yaml', '.yuangs.yml', 'yuangs.config.json'];

  while (dir && dir !== path.dirname(dir)) {
    for (const filename of configFiles) {
      const candidate = path.join(dir, filename);
      if (fs.existsSync(candidate)) {
        return candidate;
      }
    }
    dir = path.dirname(dir);
  }

  const root = path.parse(cwd).root;
  for (const filename of configFiles) {
    const rootCandidate = path.join(root, filename);
    if (fs.existsSync(rootCandidate)) {
      return rootCandidate;
    }
  }

  return null;
}

export function getConfigFilePaths(): {
  userGlobal: string;
  project: string | null;
} {
  return {
    userGlobal: path.join(os.homedir(), '.yuangs.json'),
    project: findProjectConfig(),
  };
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/db.ts

````typescript
import Database from 'better-sqlite3';
import path from 'path';
import os from 'os';
import fs from 'fs';
import { AIRequestMessage } from './validation';

const DB_DIR = path.resolve(os.homedir(), '.yuangs_chat_history');
const DB_FILE = path.join(DB_DIR, 'history.db');

// Ensure directory exists
if (!fs.existsSync(DB_DIR)) {
    fs.mkdirSync(DB_DIR, { recursive: true });
}

let dbInstance: Database.Database | null = null;

function getDb() {
    if (!dbInstance) {
        dbInstance = new Database(DB_FILE);
        // Initialize schema
        dbInstance.exec(`
            CREATE TABLE IF NOT EXISTS messages (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                role TEXT NOT NULL,
                content TEXT NOT NULL,
                timestamp INTEGER DEFAULT (unixepoch())
            );
            CREATE INDEX IF NOT EXISTS idx_timestamp ON messages(timestamp);
        `);
    }
    return dbInstance;
}

export function appendMessageToDB(role: string, content: string) {
    const db = getDb();
    const stmt = db.prepare('INSERT INTO messages (role, content, timestamp) VALUES (?, ?, ?)');
    stmt.run(role, content, Date.now());
}

export function getRecentMessagesFromDB(limit: number = 20): AIRequestMessage[] {
    const db = getDb();
    // Get last N messages order by timestamp desc, then reverse to get chronological order
    const stmt = db.prepare('SELECT role, content FROM messages ORDER BY id DESC LIMIT ?');
    const rows = stmt.all(limit) as { role: string; content: string }[];

    // Reverse to return in chronological order (oldest -> newest)
    return rows.reverse().map(row => ({
        role: row.role as 'system' | 'user' | 'assistant',
        content: row.content
    }));
}

export function clearMessagesInDB() {
    const db = getDb();
    db.exec('DELETE FROM messages');
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/executionRecord.ts

````typescript
import { MergedConfig } from './configMerge';
import { ModelCapabilities, CapabilityMatchExplanation } from './modelMatcher';
import { CapabilityRequirement } from './modelMatcher';
import { Skill } from '../agent/skills';

export interface ExecutionMeta {
  commandName: string;
  timestamp: string;
  toolVersion: string;
  projectPath: string;
  args?: any;
  rawInput?: string;
  mode?: string;
  replayable?: boolean;
  version?: string;
}

export interface CapabilityIntent {
  required: string[];
  preferred: string[];
  capabilityVersion: string;
}

export interface ModelDecision {
  candidateModels: CapabilityMatchExplanation[];
  selectedModel: ModelCapabilities | null;
  usedFallback: boolean;
  fallbackReason?: string;
  strategy?: string;
  reason?: string;
  skills?: Skill[];
}

export interface ExecutionOutcome {
  success: boolean;
  failureReason?: 'capability-mismatch' | 'provider-error' | 'user-abort' | 'timeout' | 'other';
  tokenCount?: number;
  latencyMs?: number;
  reward?: number;
}

export interface ExecutionRecord {
  id: string;
  meta: ExecutionMeta;
  intent: CapabilityIntent;
  configSnapshot: MergedConfig;
  decision: ModelDecision;
  outcome: ExecutionOutcome;
  command?: string;
}

export function createExecutionId(): string {
  return `exec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

export function createExecutionRecord(
  commandName: string,
  requirement: CapabilityRequirement,
  config: MergedConfig,
  matchResult: any,
  outcome: Partial<ExecutionOutcome> = {},
  command?: string,
  rawInput?: string,
  mode?: string
): ExecutionRecord {
  const version = require('../../package.json').version;

  return {
    id: createExecutionId(),
    meta: {
      commandName,
      timestamp: new Date().toISOString(),
      toolVersion: version,
      projectPath: process.cwd(),
      rawInput,
      mode,
      version,
      replayable: true,
    },
    intent: {
      required: requirement.required.map(String),
      preferred: requirement.preferred.map(String),
      capabilityVersion: require('./capabilities').CAPABILITY_VERSION,
    },
    configSnapshot: config,
    decision: {
      candidateModels: matchResult.candidates || [],
      selectedModel: matchResult.selected,
      usedFallback: matchResult.fallbackOccurred,
    },
    outcome: {
      success: outcome.success ?? false,
      ...outcome,
    },
    command,
  };
}

export function serializeExecutionRecord(record: ExecutionRecord): string {
  return JSON.stringify(record, null, 2);
}

export function deserializeExecutionRecord(json: string): ExecutionRecord {
  return JSON.parse(json) as ExecutionRecord;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/executionStore.ts

````typescript
import fs from 'fs';
import path from 'path';
import os from 'os';
import { ExecutionRecord, serializeExecutionRecord, deserializeExecutionRecord } from './executionRecord';

const RECORD_DIR = path.join(os.homedir(), '.yuangs', 'executions');

export function ensureRecordDir(): void {
  if (!fs.existsSync(RECORD_DIR)) {
    fs.mkdirSync(RECORD_DIR, { recursive: true });
  }
}

export function saveExecutionRecord(record: ExecutionRecord): string {
  ensureRecordDir();

  const filename = `${record.id}.json`;
  const filepath = path.join(RECORD_DIR, filename);

  fs.writeFileSync(filepath, serializeExecutionRecord(record), 'utf8');

  return filepath;
}

export function loadExecutionRecord(id: string): ExecutionRecord | null {
  ensureRecordDir();

  const filename = `${id}.json`;
  const filepath = path.join(RECORD_DIR, filename);

  if (!fs.existsSync(filepath)) {
    return null;
  }

  try {
    const content = fs.readFileSync(filepath, 'utf8');
    return deserializeExecutionRecord(content);
  } catch (error) {
    console.error(`Failed to load execution record ${id}:`, error);
    return null;
  }
}

export function listExecutionRecords(limit: number = 50): ExecutionRecord[] {
  ensureRecordDir();

  const files = fs.readdirSync(RECORD_DIR)
    .filter(f => f.endsWith('.json'))
    .sort((a, b) => {
      const statA = fs.statSync(path.join(RECORD_DIR, a));
      const statB = fs.statSync(path.join(RECORD_DIR, b));
      return statB.mtimeMs - statA.mtimeMs;
    })
    .slice(0, limit);

  const records: ExecutionRecord[] = [];

  for (const file of files) {
    const record = loadExecutionRecord(file.replace('.json', ''));
    if (record) {
      records.push(record);
    }
  }

  return records;
}

export function deleteExecutionRecord(id: string): boolean {
  ensureRecordDir();

  const filename = `${id}.json`;
  const filepath = path.join(RECORD_DIR, filename);

  if (!fs.existsSync(filepath)) {
    return false;
  }

  try {
    fs.unlinkSync(filepath);
    return true;
  } catch (error) {
    console.error(`Failed to delete execution record ${id}:`, error);
    return false;
  }
}

export function clearAllExecutionRecords(): void {
  ensureRecordDir();

  const files = fs.readdirSync(RECORD_DIR).filter(f => f.endsWith('.json'));

  for (const file of files) {
    const filepath = path.join(RECORD_DIR, file);
    try {
      fs.unlinkSync(filepath);
    } catch (error) {
      console.error(`Failed to delete ${filepath}:`, error);
    }
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/executor.ts

````typescript
import { spawn } from 'child_process';

export type ExecResult = {
    stdout: string;
    stderr: string;
    code: number | null;
};

export async function exec(command: string): Promise<ExecResult> {
    return new Promise((resolve) => {
        let stdout = '';
        let stderr = '';

        // Use user's preferred shell back with full support for their environment
        const shell = process.env.SHELL || true;
        const child = spawn(command, [], { shell });

        child.stdout.on('data', (data) => {
            stdout += data.toString();
            process.stdout.write(data);
        });

        child.stderr.on('data', (data) => {
            stderr += data.toString();
            process.stderr.write(data);
        });

        child.on('close', (code) => {
            resolve({ stdout, stderr, code });
        });

        child.on('error', (err) => {
            stderr += err.message;
            resolve({ stdout, stderr, code: 1 });
        });
    });
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/explain.ts

````typescript
import { ExecutionRecord } from './executionRecord';
import { computeSkillScore, Skill } from '../agent/skills';

/**
 * Explain Output Spec v1
 * - Stable, human-readable, diff-friendly
 * - No side effects
 * - Do NOT change without bumping spec version
 */
export function explainExecution(record: ExecutionRecord): string {
  const lines: string[] = [];

  lines.push('=== Execution Explanation ===');

  /* =========================
   * [1] Command
   * ========================= */
  lines.push('[1] Command');
  lines.push(`- Name: ${record.meta.commandName ?? 'N/A'}`);

  if (record.command) {
    lines.push(`- Args: ${record.command}`);
  }

  if (record.meta.rawInput) {
    lines.push(`- Raw: ${record.meta.rawInput}`);
  }
  lines.push('');

  /* =========================
   * [2] Decision
   * ========================= */
  const decision = record.decision ?? {};

  lines.push('[2] Decision');
  lines.push(`- Strategy: ${decision.strategy ?? 'capability-match'}`);
  lines.push(
    `- Selected Model: ${decision.selectedModel?.name ?? 'N/A'}`
  );
  lines.push(
    `- Reason: ${decision.reason ?? 'Capability-based selection with fallback support'}`
  );
  lines.push('');

  /* =========================
   * [3] Model
   * ========================= */
  const model = decision.selectedModel;

  lines.push('[3] Model');
  lines.push(`- Name: ${model?.name ?? 'N/A'}`);
  lines.push(`- Provider: ${model?.provider ?? 'N/A'}`);
  lines.push(`- Context Window: ${model?.contextWindow ?? 'default'}`);
  lines.push(`- Cost Profile: ${model?.costProfile ?? 'default'}`);
  lines.push('');

  /* =========================
   * [4] Skills
   * ========================= */
  lines.push('[4] Skills');

  const skills: Skill[] = decision.skills ?? [];
  const now = Date.now();

  if (skills.length === 0) {
    lines.push('- (none)');
  } else {
    const scored = skills
      .map(skill => ({
        skill,
        score: computeSkillScore(skill, now),
      }))
      .sort((a, b) => b.score - a.score);

    for (const { skill, score } of scored) {
      const totalUses = skill.successCount + skill.failureCount;
      const successRate =
        totalUses === 0 ? 0.5 : skill.successCount / totalUses;

      lines.push(`- ${skill.name}`);
      lines.push(`    score: ${score.toFixed(3)}`);
      lines.push(`    confidence: ${skill.confidence.toFixed(3)}`);
      lines.push(`    successRate: ${successRate.toFixed(3)}`);
      lines.push(`    enabled: ${skill.enabled}`);
      lines.push(
        `    lastUsed: ${new Date(skill.lastUsed).toISOString()}`
      );
    }
  }
  lines.push('');

  /* =========================
   * [5] Meta
   * ========================= */
  lines.push('[5] Meta');
  lines.push(`- Execution ID: ${record.id}`);
  lines.push(
    `- Timestamp: ${new Date(record.meta.timestamp).toISOString()}`
  );
  lines.push(`- Replayable: ${record.meta.replayable ?? true}`);
  lines.push(`- Version: ${record.meta.version ?? 'unknown'}`);

  lines.push('=============================');

  return lines.join('\n');
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/fileReader.ts

````typescript
import fs from 'fs';
import path from 'path';

export function parseFilePathsFromLsOutput(output: string): string[] {
    const lines = output.trim().split('\n');
    const filePaths: string[] = [];

    for (const line of lines) {
        const parts = line.trim().split(/\s+/);
        const lastPart = parts[parts.length - 1];
        
        if (lastPart && !lastPart.startsWith('-') && lastPart !== '.' && lastPart !== '..') {
            filePaths.push(lastPart);
        }
    }

    return filePaths;
}

export function readFilesContent(filePaths: string[]): Map<string, string> {
    const contentMap = new Map<string, string>();

    for (const filePath of filePaths) {
        try {
            const fullPath = path.resolve(filePath);
            if (fs.existsSync(fullPath) && fs.statSync(fullPath).isFile()) {
                const content = fs.readFileSync(fullPath, 'utf-8');
                contentMap.set(filePath, content);
            }
        } catch (error) {
            console.error(`æ— æ³•è¯»å–æ–‡ä»¶: ${filePath}`);
        }
    }

    return contentMap;
}

export function buildPromptWithFileContent(
    originalOutput: string,
    filePaths: string[],
    contentMap: Map<string, string>,
    question?: string
): string {
    let prompt = '';

    prompt += '## æ–‡ä»¶åˆ—è¡¨\n';
    prompt += '```\n';
    prompt += originalOutput;
    prompt += '```\n\n';

    if (contentMap.size > 0) {
        prompt += '## æ–‡ä»¶å†…å®¹\n\n';
        for (const [filePath, content] of contentMap) {
            prompt += `### ${filePath}\n`;
            prompt += '```\n';
            const maxChars = 5000;
            const truncated = content.length > maxChars 
                ? content.substring(0, maxChars) + '\n... (å†…å®¹è¿‡é•¿å·²æˆªæ–­)'
                : content;
            prompt += truncated;
            prompt += '\n```\n\n';
        }
    }

    if (question) {
        prompt += `\n## æˆ‘çš„é—®é¢˜\n${question}`;
    } else {
        prompt += '\n## æˆ‘çš„é—®é¢˜\nè¯·åˆ†æä»¥ä¸Šæ–‡ä»¶åˆ—è¡¨å’Œæ–‡ä»¶å†…å®¹';
    }

    return prompt;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/kernel/ASTParser.ts

````typescript
/**
 * Enhanced AST Parser for X-Resolver
 *
 * å¢å¼ºç‰ˆ AST è§£æå™¨ï¼Œæ”¯æŒï¼š
 * 1. æå–å¯¼å‡ºç¬¦å·ï¼ˆå‡½æ•°ã€ç±»ã€æ¥å£ã€ç±»å‹åˆ«åï¼‰
 * 2. æå– JSDoc æ³¨é‡Šå’Œæ ‡ç­¾
 * 3. æä¾›ç¬¦å·çš„å®Œæ•´å…ƒæ•°æ®ï¼ˆåç§°ã€ç±»å‹ã€JSDocã€è¡Œå·ç­‰ï¼‰
 *
 * ä½¿ç”¨ TypeScript Compiler API å®ç°ç²¾ç¡®è§£æ
 */

import * as ts from 'typescript';
import * as fs from 'fs/promises';

/**
 * ç¬¦å·å…ƒæ•°æ®æ¥å£
 */
export interface SymbolMetadata {
  /** ç¬¦å·åç§° */
  name: string;
  /** ç¬¦å·ç±»å‹ */
  kind: string;
  /** JSDoc æ³¨é‡Šå†…å®¹ */
  jsDoc: string;
  /** èµ·å§‹è¡Œå·ï¼ˆä»1å¼€å§‹ï¼‰ */
  startLine: number;
  /** æ˜¯å¦å·²å¯¼å‡º */
  isExported: boolean;
}

/**
 * AST è§£æç»“æœ
 */
export interface ASTParseResult {
  /** æå–çš„ç¬¦å·åˆ—è¡¨ */
  symbols: SymbolMetadata[];
  /** è§£ææ˜¯å¦æˆåŠŸ */
  success: boolean;
  /** é”™è¯¯ä¿¡æ¯ï¼ˆå¦‚æœå¤±è´¥ï¼‰ */
  error?: string;
}

/**
 * å¢å¼ºç‰ˆ AST è§£æå™¨
 *
 * ä¸º X-Resolver æä¾›ç²¾ç¡®çš„ç¬¦å·æå–èƒ½åŠ›
 */
export class EnhancedASTParser {
  /**
   * ä»æ–‡ä»¶ä¸­æå–å¯¼å‡ºç¬¦å·åŠå…¶ JSDoc
   *
   * @param filePath - è¦è§£æçš„æ–‡ä»¶è·¯å¾„
   * @returns åŒ…å«ç¬¦å·å…ƒæ•°æ®çš„è§£æç»“æœ
   */
  async parseFile(filePath: string): Promise<ASTParseResult> {
    try {
      const content = await fs.readFile(filePath, 'utf-8');
      return this.parse(content, filePath);
    } catch (error) {
      return {
        symbols: [],
        success: false,
        error: error instanceof Error ? error.message : 'Failed to read file'
      };
    }
  }

  /**
   * ä»ä»£ç å­—ç¬¦ä¸²ä¸­æå–å¯¼å‡ºç¬¦å·åŠå…¶ JSDoc
   *
   * @param code - è¦è§£æçš„ä»£ç å­—ç¬¦ä¸²
   * @param filePath - æ–‡ä»¶è·¯å¾„ï¼ˆç”¨äºé”™è¯¯æ¶ˆæ¯å’Œè¡Œå·è®¡ç®—ï¼‰
   * @returns åŒ…å«ç¬¦å·å…ƒæ•°æ®çš„è§£æç»“æœ
   */
  parse(code: string, filePath: string): ASTParseResult {
    try {
      const sourceFile = ts.createSourceFile(
        filePath,
        code,
        ts.ScriptTarget.Latest,
        true
      );

      const symbols: SymbolMetadata[] = [];
      this.visitAndExtractSymbols(sourceFile, symbols);

      return {
        symbols,
        success: true
      };
    } catch (error) {
      return {
        symbols: [],
        success: false,
        error: error instanceof Error ? error.message : 'Unknown parsing error'
      };
    }
  }

  /**
   * é€’å½’éå† AST èŠ‚ç‚¹ï¼Œæå–å¯¼å‡ºç¬¦å·åŠå…¶ JSDoc
   *
   * @param node - AST èŠ‚ç‚¹
   * @param symbols - ç¬¦å·åˆ—è¡¨ï¼ˆè¾“å‡ºå‚æ•°ï¼‰
   */
  private visitAndExtractSymbols(node: ts.Node, symbols: SymbolMetadata[]): void {
    let isExported = false;

    // æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦æœ‰å¯¼å‡ºä¿®é¥°ç¬¦ï¼ˆä»…åœ¨æ”¯æŒçš„èŠ‚ç‚¹ç±»å‹ä¸Šï¼‰
    if (ts.canHaveModifiers(node)) {
      const modifiers = ts.getModifiers(node);
      isExported = modifiers?.some(m => m.kind === ts.SyntaxKind.ExportKeyword) ?? false;
    }

    // æå–ç¬¦å·åç§°å’Œ JSDoc
    let name = '';
    let kind = '';

    if ((ts.isFunctionDeclaration(node) ||
         ts.isClassDeclaration(node) ||
         ts.isInterfaceDeclaration(node) ||
         ts.isTypeAliasDeclaration(node) ||
         ts.isEnumDeclaration(node)) && node.name) {
      name = node.name.text;
      kind = this.mapNodeKindToString(node.kind);
    } else if (ts.isVariableStatement(node) && isExported) {
      const declaration = node.declarationList.declarations[0];
      if (declaration && ts.isIdentifier(declaration.name)) {
        name = declaration.name.text;
        kind = 'Variable';
      }
    }

    // å¦‚æœæ‰¾åˆ°äº†ç¬¦å·åç§°ï¼Œæå–å…¶å…ƒæ•°æ®
    if (name) {
      const sourceFile = node.getSourceFile();
      const startLine = sourceFile.getLineAndCharacterOfPosition(node.getStart()).line + 1;
      const jsDoc = this.extractJSDoc(node);

      symbols.push({
        name,
        kind,
        jsDoc,
        startLine,
        isExported
      });
    }

    // é€’å½’å¤„ç†å­èŠ‚ç‚¹
    ts.forEachChild(node, (child) => this.visitAndExtractSymbols(child, symbols));
  }

  /**
   * ä»èŠ‚ç‚¹æå– JSDoc æ³¨é‡Š
   *
   * @param node - AST èŠ‚ç‚¹
   * @returns æå–çš„ JSDoc æ–‡æ¡£å­—ç¬¦ä¸²
   */
  private extractJSDoc(node: ts.Node): string {
    const jsDocNodes = (node as any).jsDoc;

    if (!jsDocNodes || !Array.isArray(jsDocNodes) || jsDocNodes.length === 0) {
      return '';
    }

    const jsDoc = jsDocNodes[0];
    const comment = jsDoc.comment || '';

    const tags = jsDoc.tags?.map((tag: any) => {
      const tagName = tag.tagName?.text || '';
      const tagComment = tag.comment || '';
      const paramName = tag.name?.text || '';

      const paramText = paramName ? `${tagName} ${paramName}` : tagName;
      return tagComment ? `@${paramText} ${tagComment}` : `@${paramText}`;
    }).join('\n') || '';

    const docText = [comment, tags].filter(Boolean).join('\n').trim();

    return docText;
  }

  /**
   * å°† TypeScript èŠ‚ç‚¹ç±»å‹æ˜ å°„ä¸ºå¯è¯»å­—ç¬¦ä¸²
   *
   * @param kind - TypeScript è¯­æ³•ç§ç±»
   * @returns å¯è¯»çš„ç¬¦å·ç±»å‹å­—ç¬¦ä¸²
   */
  private mapNodeKindToString(kind: ts.SyntaxKind): string {
    switch (kind) {
      case ts.SyntaxKind.FunctionDeclaration:
        return 'Function';
      case ts.SyntaxKind.ClassDeclaration:
        return 'Class';
      case ts.SyntaxKind.InterfaceDeclaration:
        return 'Interface';
      case ts.SyntaxKind.TypeAliasDeclaration:
        return 'Type';
      case ts.SyntaxKind.EnumDeclaration:
        return 'Enum';
      case ts.SyntaxKind.VariableStatement:
        return 'Variable';
      default:
        return 'Symbol';
    }
  }

  /**
   * è·å–æ–‡ä»¶ä¸­æ‰€æœ‰å¯¼å‡ºçš„ç¬¦å·åç§°ï¼ˆå¿«æ·æ–¹æ³•ï¼‰
   *
   * @param filePath - æ–‡ä»¶è·¯å¾„
   * @returns å¯¼å‡ºç¬¦å·åç§°æ•°ç»„
   */
  async getExportedSymbolNames(filePath: string): Promise<string[]> {
    const result = await this.parseFile(filePath);
    if (!result.success) {
      return [];
    }
    return result.symbols.filter(s => s.isExported).map(s => s.name);
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/kernel/AtomicTransactionManager.ts

````typescript
/**
 * Atomic Transaction Manager for X-Resolver
 *
 * åŸå­äº‹åŠ¡ç®¡ç†å™¨ - ç¡®ä¿å¤šæ–‡ä»¶ä¿®æ”¹çš„åŸå­æ€§
 *
 * æ ¸å¿ƒåŠŸèƒ½ï¼š
 * 1. å¼€å¯å¤šæ–‡ä»¶ç»„åˆäº‹åŠ¡
 * 2. ä¸ºäº‹åŠ¡ä¸­çš„æ–‡ä»¶åˆ›å»ºå¿«ç…§
 * 3. éªŒè¯å¹¶æäº¤äº‹åŠ¡
 * 4. å¤±è´¥æ—¶å…¨ç›˜å›é€€
 */

import * as fs from 'fs/promises';
import * as path from 'path';

/**
 * äº‹åŠ¡çŠ¶æ€
 */
export enum TransactionState {
  /** æœªå¼€å§‹ */
  IDLE = 'idle',
  /** è¿›è¡Œä¸­ */
  ACTIVE = 'active',
  /** å·²æäº¤ */
  COMMITTED = 'committed',
  /** å·²å›æ»š */
  ROLLED_BACK = 'rolled_back'
}

/**
 * äº‹åŠ¡å…ƒæ•°æ®
 */
export interface TransactionMetadata {
  /** äº‹åŠ¡ ID */
  id: string;
  /** äº‹åŠ¡åç§° */
  name: string;
  /** æ¶‰åŠçš„æ–‡ä»¶åˆ—è¡¨ */
  files: string[];
  /** äº‹åŠ¡çŠ¶æ€ */
  state: TransactionState;
  /** åˆ›å»ºæ—¶é—´ */
  createdAt: Date;
  /** å¿«ç…§ç›®å½•è·¯å¾„ */
  snapshotDir: string;
}

/**
 * äº‹åŠ¡æäº¤ç»“æœ
 */
export interface CommitResult {
  /** æ˜¯å¦æˆåŠŸ */
  success: boolean;
  /** æäº¤çš„æ–‡ä»¶æ•°é‡ */
  filesCommitted: number;
  /** é”™è¯¯ä¿¡æ¯ï¼ˆå¦‚æœå¤±è´¥ï¼‰ */
  error?: string;
}

/**
 * åŸå­äº‹åŠ¡ç®¡ç†å™¨
 *
 * ç®¡ç†å¤šæ–‡ä»¶ä¿®æ”¹çš„åŸå­æ€§ï¼Œç¡®ä¿è¦ä¹ˆå…¨éƒ¨æˆåŠŸï¼Œè¦ä¹ˆå…¨éƒ¨å›æ»š
 */
export class AtomicTransactionManager {
  private transactions: Map<string, TransactionMetadata> = new Map();
  private snapshotBaseDir: string;

  constructor(snapshotBaseDir: string = '.yuangs/snapshots') {
    this.snapshotBaseDir = snapshotBaseDir;
  }

  /**
   * ç”Ÿæˆå”¯ä¸€äº‹åŠ¡ ID
   */
  private generateTransactionId(): string {
    return `txn_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * å¼€å¯å¤šæ–‡ä»¶ç»„åˆäº‹åŠ¡
   *
   * @param taskName - ä»»åŠ¡åç§°
   * @param files - æ¶‰åŠçš„æ–‡ä»¶åˆ—è¡¨
   * @returns äº‹åŠ¡ ID
   */
  async startBatch(taskName: string, files: string[]): Promise<string> {
    const transactionId = this.generateTransactionId();
    const snapshotDir = path.join(this.snapshotBaseDir, transactionId);

    console.log(`\n[Atomic] ğŸ”’ Starting transaction "${taskName}" (${files.length} files)`);
    console.log(`[Atomic] Transaction ID: ${transactionId}`);

    await fs.mkdir(snapshotDir, { recursive: true });

    for (const file of files) {
      await this.createSnapshot(file, snapshotDir);
    }

    const metadata: TransactionMetadata = {
      id: transactionId,
      name: taskName,
      files,
      state: TransactionState.ACTIVE,
      createdAt: new Date(),
      snapshotDir
    };

    this.transactions.set(transactionId, metadata);

    console.log(`[Atomic] âœ… Snapshots created for ${files.length} files\n`);

    return transactionId;
  }

  /**
   * ä¸ºå•ä¸ªæ–‡ä»¶åˆ›å»ºå¿«ç…§
   */
  private async createSnapshot(filePath: string, snapshotDir: string): Promise<void> {
    try {
      const content = await fs.readFile(filePath, 'utf-8');
      const relativePath = path.relative(process.cwd(), filePath);
      const snapshotPath = path.join(snapshotDir, relativePath);

      await fs.mkdir(path.dirname(snapshotPath), { recursive: true });
      await fs.writeFile(snapshotPath, content, 'utf-8');
    } catch (error) {
      console.warn(`[Atomic] Failed to create snapshot for ${filePath}: ${error}`);
      throw error;
    }
  }

  /**
   * æäº¤äº‹åŠ¡
   *
   * @param transactionId - äº‹åŠ¡ ID
   * @returns æäº¤ç»“æœ
   */
  async commitBatch(transactionId: string): Promise<CommitResult> {
    const transaction = this.transactions.get(transactionId);

    if (!transaction) {
      return {
        success: false,
        filesCommitted: 0,
        error: `Transaction ${transactionId} not found`
      };
    }

    if (transaction.state !== TransactionState.ACTIVE) {
      return {
        success: false,
        filesCommitted: 0,
        error: `Transaction ${transactionId} is not in active state`
      };
    }

    try {
      await this.clearSnapshots(transaction.snapshotDir);

      transaction.state = TransactionState.COMMITTED;

      console.log(`[Atomic] âœ… Transaction "${transaction.name}" committed successfully\n`);

      return {
        success: true,
        filesCommitted: transaction.files.length
      };
    } catch (error) {
      return {
        success: false,
        filesCommitted: 0,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * å›æ»šäº‹åŠ¡
   *
   * @param transactionId - äº‹åŠ¡ ID
   */
  async abortBatch(transactionId: string): Promise<void> {
    const transaction = this.transactions.get(transactionId);

    if (!transaction) {
      console.warn(`[Atomic] Transaction ${transactionId} not found`);
      return;
    }

    console.warn(`\n[Atomic] âš ï¸ Aborting transaction "${transaction.name}"...`);

    await this.rollbackAll(transaction.snapshotDir);

    transaction.state = TransactionState.ROLLED_BACK;

    console.log(`[Atomic] âœ… Transaction rolled back successfully\n`);
  }

  /**
   * å…¨ç›˜å›é€€åˆ°å¿«ç…§çŠ¶æ€
   */
  private async rollbackAll(snapshotDir: string): Promise<void> {
    const snapshotFiles = await this.listSnapshotFiles(snapshotDir);

    for (const snapshotPath of snapshotFiles) {
      try {
        const content = await fs.readFile(snapshotPath, 'utf-8');
        const relativePath = path.relative(snapshotDir, snapshotPath);
        const originalPath = path.join(process.cwd(), relativePath);

        await fs.mkdir(path.dirname(originalPath), { recursive: true });
        await fs.writeFile(originalPath, content, 'utf-8');
      } catch (error) {
        console.warn(`[Atomic] Failed to restore ${snapshotPath}: ${error}`);
      }
    }

    await this.clearSnapshots(snapshotDir);
  }

  /**
   * æ¸…ç†å¿«ç…§ç›®å½•
   */
  private async clearSnapshots(snapshotDir: string): Promise<void> {
    try {
      await fs.rm(snapshotDir, { recursive: true, force: true });
    } catch (error) {
      console.warn(`[Atomic] Failed to clear snapshots ${snapshotDir}: ${error}`);
    }
  }

  /**
   * åˆ—å‡ºå¿«ç…§ç›®å½•ä¸­çš„æ‰€æœ‰æ–‡ä»¶
   */
  private async listSnapshotFiles(snapshotDir: string): Promise<string[]> {
    const files: string[] = [];

    async function walk(dir: string) {
      const entries = await fs.readdir(dir, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);

        if (entry.isDirectory()) {
          await walk(fullPath);
        } else if (entry.isFile()) {
          files.push(fullPath);
        }
      }
    }

    try {
      await walk(snapshotDir);
    } catch (error) {
      console.warn(`[Atomic] Failed to list snapshot files: ${error}`);
    }

    return files;
  }

  /**
   * è·å–äº‹åŠ¡çŠ¶æ€
   */
  getTransactionState(transactionId: string): TransactionState | null {
    const transaction = this.transactions.get(transactionId);
    return transaction ? transaction.state : null;
  }

  /**
   * æ¸…ç†æ‰€æœ‰å·²å®Œæˆçš„äº‹åŠ¡
   */
  async cleanupCompletedTransactions(): Promise<void> {
    const completedTransactions = Array.from(this.transactions.values())
      .filter(t => t.state === TransactionState.COMMITTED || t.state === TransactionState.ROLLED_BACK);

    for (const transaction of completedTransactions) {
      this.transactions.delete(transaction.id);
    }

    console.log(`[Atomic] ğŸ§¹ Cleaned up ${completedTransactions.length} completed transactions`);
  }

  /**
   * è·å–æ´»è·ƒäº‹åŠ¡åˆ—è¡¨
   */
  getActiveTransactions(): TransactionMetadata[] {
    return Array.from(this.transactions.values())
      .filter(t => t.state === TransactionState.ACTIVE);
  }

  /**
   * è®¾ç½®å¿«ç…§åŸºç¡€ç›®å½•
   */
  setSnapshotBaseDir(dir: string): void {
    this.snapshotBaseDir = dir;
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/kernel/FastScanner.ts

````typescript
/**
 * Fast Scanner for X-Resolver
 *
 * å¿«é€Ÿæ‰«æå™¨ï¼Œä½¿ç”¨ ripgrep è¿›è¡Œæé€Ÿæ–‡ä»¶æœç´¢
 * å¦‚æœ ripgrep ä¸å¯ç”¨ï¼Œåˆ™å›é€€åˆ°åŸç”Ÿ Node.js æ–‡ä»¶ç³»ç»Ÿéå†
 *
 * ä¸»è¦åŠŸèƒ½ï¼š
 * - æŸ¥æ‰¾å¼•ç”¨æŒ‡å®šæ–‡ä»¶/æ¨¡å—çš„å…¶ä»–æ–‡ä»¶
 * - æ”¯æŒå¤šç§å¯¼å…¥è¯­æ³•ï¼ˆç›¸å¯¹è·¯å¾„ã€ç»å¯¹è·¯å¾„ã€åˆ«åï¼‰
 * - æ™ºèƒ½æ’é™¤ node_modules å’Œå…¶ä»–æ— å…³ç›®å½•
 */

import { execSync } from 'child_process';
import * as fs from 'fs/promises';
import * as path from 'path';
import ora, { Ora } from 'ora';
import chalk from 'chalk';

/**
 * æ‰«æç»“æœ
 */
export interface ScanResult {
  /** å‘ç°çš„æ¶ˆè´¹è€…æ–‡ä»¶è·¯å¾„åˆ—è¡¨ */
  consumerFiles: string[];
  /** æ˜¯å¦ä½¿ç”¨äº† ripgrep */
  usedRipgrep: boolean;
  /** æ‰«æè€—æ—¶ï¼ˆæ¯«ç§’ï¼‰ */
  duration: number;
}

/**
 * é»˜è®¤å¿½ç•¥çš„ç›®å½•
 */
const DEFAULT_IGNORE_DIRS = [
  'node_modules',
  '.git',
  '.yuangs',
  'dist',
  'build',
  'coverage',
  '.next',
  '.nuxt',
  'target',
  'bin',
  'obj'
];

/**
 * å¿«é€Ÿæ‰«æå™¨
 *
 * ä½¿ç”¨ ripgrep è¿›è¡Œæé€Ÿæœç´¢ï¼Œä¸å¯ç”¨æ—¶è‡ªåŠ¨å›é€€åˆ°åŸç”Ÿéå†
 */
 export class FastScanner {
  private ignoreDirs: Set<string>;
  private ripgrepAvailable: boolean | null = null;
  private scanStats: {
    filesScanned: number;
    directoriesProcessed: number;
    currentDirectory: string;
    startTime: number;
  } | null = null;

  constructor(ignoreDirs: string[] = DEFAULT_IGNORE_DIRS) {
    this.ignoreDirs = new Set(ignoreDirs);
  }

  /**
   * æ£€æŸ¥ ripgrep æ˜¯å¦å¯ç”¨
   */
  private async checkRipgrepAvailable(): Promise<boolean> {
    if (this.ripgrepAvailable !== null) {
      return this.ripgrepAvailable;
    }

    try {
      execSync('rg --version', { encoding: 'utf-8', stdio: 'pipe' });
      this.ripgrepAvailable = true;
      return true;
    } catch (error) {
      this.ripgrepAvailable = false;
      return false;
    }
  }

  /**
   * æŸ¥æ‰¾å¼•ç”¨æŒ‡å®šæ¨¡å—çš„æ–‡ä»¶
   *
   * @param baseName - æ¨¡å—åç§°ï¼ˆä¸å«æ‰©å±•åï¼‰
   * @param searchDir - æœç´¢ç›®å½•ï¼ˆé»˜è®¤ä¸ºå½“å‰ç›®å½•ï¼‰
   * @returns æ‰«æç»“æœ
   */
  async findConsumerFiles(baseName: string, searchDir: string = '.'): Promise<ScanResult> {
    const startTime = Date.now();

    const hasRipgrep = await this.checkRipgrepAvailable();
    let consumerFiles: string[] = [];

    if (hasRipgrep) {
      consumerFiles = await this.scanWithRipgrep(baseName, searchDir);
    } else {
      // Add spinner for fallback scan
      const spinner = ora(chalk.cyan('Fallback scanning (ripgrep unavailable)...')).start();
      consumerFiles = await this.fallbackScan(baseName, searchDir, spinner);

      if (this.scanStats) {
        const elapsed = ((Date.now() - this.scanStats.startTime) / 1000).toFixed(2);
        spinner.succeed(chalk.green(`Scan complete: ${this.scanStats.filesScanned} files, ${this.scanStats.directoriesProcessed} dirs in ${elapsed}s`));
      } else {
        spinner.succeed('Scan complete');
      }

      this.scanStats = null;
    }

    const duration = Date.now() - startTime;

    return {
      consumerFiles,
      usedRipgrep: hasRipgrep,
      duration
    };
  }

  /**
   * ä½¿ç”¨ ripgrep è¿›è¡Œå¿«é€Ÿæ‰«æ
   */
  private async scanWithRipgrep(baseName: string, searchDir: string): Promise<string[]> {
    try {
      const ignoreArgs = Array.from(this.ignoreDirs).map(dir => `--glob '!${dir}'`).join(' ');

      // ä¿®å¤ï¼šç¡®ä¿æœç´¢ç›®å½•æ­£ç¡®ï¼Œå¹¶æ·»åŠ æ›´å®Œæ•´çš„å¯¼å…¥æ¨¡å¼
      const patterns = [
        `from ['\\"].*${this.escapeRegex(baseName)}['\\"]`,
        `import ['\\"].*${this.escapeRegex(baseName)}['\\"]`,
        `require\\(['\\"].*${this.escapeRegex(baseName)}['\\"]\\)`,
      ];

      const pattern = patterns.join('|');
      const cmd = `rg -l "${pattern}" ${ignoreArgs} --type ts --type js .`;

      const output = execSync(cmd, {
        encoding: 'utf-8',
        cwd: searchDir,
        stdio: 'pipe'
      });

      // å°†ç›¸å¯¹è·¯å¾„è½¬æ¢ä¸ºç»å¯¹è·¯å¾„
      const relativePaths = output.split('\n').filter(Boolean);
      return relativePaths.map(relPath => path.resolve(searchDir, relPath));
    } catch (error: any) {
      if (error.status === 1) {
        // ripgrep æ‰¾ä¸åˆ°åŒ¹é…é¡¹ï¼Œè¿”å›ç©ºæ•°ç»„
        return [];
      }
      // å…¶ä»–é”™è¯¯ï¼Œå°è¯•ä½¿ç”¨ fallback
      console.warn(`[FastScanner] ripgrep scan failed, using fallback: ${error.message}`);
      return [];
    }
  }

  /**
   * å›é€€åˆ°åŸç”Ÿæ–‡ä»¶ç³»ç»Ÿéå†
   */
  private async fallbackScan(
    baseName: string,
    dir: string = '.',
    spinner: Ora | null = null,
    depth: number = 0
  ): Promise<string[]> {
    const results: string[] = [];

    // Initialize stats on first call
    if (depth === 0) {
      this.scanStats = {
        filesScanned: 0,
        directoriesProcessed: 0,
        currentDirectory: dir,
        startTime: Date.now()
      };
    }

    try {
      const entries = await fs.readdir(dir, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);

        if (entry.isDirectory()) {
          if (this.ignoreDirs.has(entry.name)) {
            continue;
          }

          // Update stats before recursion
          if (this.scanStats) {
            this.scanStats.directoriesProcessed++;
            this.scanStats.currentDirectory = fullPath;

            // Update spinner periodically (every 5 directories)
            if (spinner && this.scanStats.directoriesProcessed % 5 === 0) {
              const elapsed = ((Date.now() - this.scanStats.startTime) / 1000).toFixed(1);
              spinner.text = `Scanning: ${this.scanStats.filesScanned} files, ${this.scanStats.directoriesProcessed} dirs\n` +
                             `Current: ${path.basename(fullPath)} (${elapsed}s)`;
            }
          }

          const subResults = await this.fallbackScan(baseName, fullPath, spinner, depth + 1);
          results.push(...subResults);
        } else if (this.isSourceFile(entry.name)) {
          // Update file count
          if (this.scanStats) {
            this.scanStats.filesScanned++;

            // Update spinner periodically (every 20 files)
            if (spinner && this.scanStats.filesScanned % 20 === 0) {
              const elapsed = ((Date.now() - this.scanStats.startTime) / 1000).toFixed(1);
              spinner.text = `Scanning: ${this.scanStats.filesScanned} files, ${this.scanStats.directoriesProcessed} dirs\n` +
                             `Current: ${path.basename(dir)} (${elapsed}s)`;
            }
          }

          const content = await fs.readFile(fullPath, 'utf-8');

          if (this.containsModuleImport(content, baseName)) {
            results.push(fullPath);
          }
        }
      }
    } catch (error) {
      console.warn(`[FastScanner] Failed to scan directory ${dir}: ${error}`);
    }

    // Final update when recursion unwinds to root
    if (depth === 0 && spinner && this.scanStats) {
      const elapsed = ((Date.now() - this.scanStats.startTime) / 1000).toFixed(2);
      spinner.text = `Complete: ${this.scanStats.filesScanned} files, ${this.scanStats.directoriesProcessed} dirs (${elapsed}s)`;
    }

    return results;
  }

  /**
   * åˆ¤æ–­æ–‡ä»¶æ˜¯å¦ä¸ºæºæ–‡ä»¶
   */
  private isSourceFile(filename: string): boolean {
    const ext = path.extname(filename).toLowerCase();
    return ['.ts', '.js', '.tsx', '.jsx'].includes(ext);
  }

  /**
   * æ£€æŸ¥ä»£ç æ˜¯å¦åŒ…å«å¯¹æŒ‡å®šæ¨¡å—çš„å¯¼å…¥
   */
  private containsModuleImport(content: string, baseName: string): boolean {
    const importPatterns = [
      // import è¯­å¥çš„å„ç§å½¢å¼
      `from './${baseName}`,
      `from "./${baseName}`,
      `from '../${baseName}`,
      `from "../${baseName}`,
      `from './${baseName}.ts`,
      `from "./${baseName}.ts`,
      `from './${baseName}.js`,
      `from "./${baseName}.js`,
      `from './${baseName}'`,
      `from "./${baseName}"`,
      `import './${baseName}`,
      `import "./${baseName}`,
      `import '../${baseName}`,
      `import "../${baseName}`,
      `import './${baseName}.ts`,
      `import "./${baseName}.ts`,
      `import './${baseName}.js`,
      `import "./${baseName}.js`,
      `import './${baseName}'`,
      `import "./${baseName}"`,
      // require è¯­å¥
      `require('./${baseName}`,
      `require("./${baseName}`,
      `require('../${baseName}`,
      `require("../${baseName}`,
      `require('./${baseName}.ts`,
      `require("./${baseName}.ts`,
      `require('./${baseName}.js`,
      `require("./${baseName}.js`,
      `require('./${baseName}')`,
      `require("./${baseName}")`,
    ];

    return importPatterns.some(pattern => content.includes(pattern));
  }

  /**
   * è½¬ä¹‰æ­£åˆ™è¡¨è¾¾å¼ç‰¹æ®Šå­—ç¬¦
   */
  private escapeRegex(str: string): string {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  /**
   * è®¾ç½®å¿½ç•¥ç›®å½•
   */
  setIgnoreDirs(dirs: string[]): void {
    this.ignoreDirs = new Set(dirs);
  }

  /**
   * æ·»åŠ å¿½ç•¥ç›®å½•
   */
  addIgnoreDir(dir: string): void {
    this.ignoreDirs.add(dir);
  }

  /**
   * ç§»é™¤å¿½ç•¥ç›®å½•
   */
  removeIgnoreDir(dir: string): void {
    this.ignoreDirs.delete(dir);
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/kernel/PostCheckVerifier.ts

````typescript
/**
 * Post-Check Verifier for Atomic Transactions
 *
 * åéªŒè¯æ£€æŸ¥å™¨ - ç¡®ä¿ä»£ç ä¿®æ”¹åçš„å·¥ç¨‹è´¨é‡
 *
 * æ ¸å¿ƒåŠŸèƒ½ï¼š
 * 1. æ‰§è¡Œ TypeScript ç±»å‹æ£€æŸ¥
 * 2. è¿è¡Œè‡ªå®šä¹‰éªŒè¯å‘½ä»¤
 * 3. æ•è·å¹¶ç»“æ„åŒ–é”™è¯¯ä¿¡æ¯
 * 4. ä¸º AI æä¾›å¯ä¿®å¤çš„åé¦ˆ
 */

import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

/**
 * éªŒè¯ç»“æœ
 */
export interface VerificationResult {
  /** éªŒè¯æ˜¯å¦é€šè¿‡ */
  passed: boolean;
  /** è¾“å‡ºæ—¥å¿—ï¼ˆæ ‡å‡†è¾“å‡ºï¼‰ */
  stdout?: string;
  /** é”™è¯¯æ—¥å¿—ï¼ˆæ ‡å‡†é”™è¯¯ï¼‰ */
  stderr?: string;
  /** å®Œæ•´çš„é”™è¯¯ä¿¡æ¯ */
  error?: string;
  /** éªŒè¯è€—æ—¶ï¼ˆæ¯«ç§’ï¼‰ */
  duration: number;
}

/**
 * éªŒè¯å™¨é…ç½®
 */
export interface VerifierConfig {
  /** TypeScript æ£€æŸ¥å‘½ä»¤ï¼ˆé»˜è®¤: npx tsc --noEmitï¼‰ */
  typeCheckCommand: string;
  /** è‡ªå®šä¹‰éªŒè¯å‘½ä»¤ï¼ˆå¯é€‰ï¼‰ */
  customCheckCommand?: string;
  /** å·¥ä½œç›®å½•ï¼ˆé»˜è®¤: å½“å‰ç›®å½•ï¼‰ */
  cwd?: string;
  /** è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ */
  timeout?: number;
}

/**
 * åéªŒè¯æ£€æŸ¥å™¨
 *
 * æ‰§è¡Œç¼–è¯‘æ£€æŸ¥å’Œè‡ªå®šä¹‰éªŒè¯ï¼Œç¡®ä¿ä»£ç ä¿®æ”¹ä¸ä¼šç ´åé¡¹ç›®
 */
export class PostCheckVerifier {
  private config: VerifierConfig;

  constructor(config?: Partial<VerifierConfig>) {
    this.config = {
      typeCheckCommand: 'npx tsc --noEmit',
      cwd: process.cwd(),
      timeout: 60000,
      ...config
    };
  }

  /**
   * æ‰§è¡Œç±»å‹æ£€æŸ¥
   *
   * @returns éªŒè¯ç»“æœ
   */
  async verifyTypeCheck(): Promise<VerificationResult> {
    return this.runCheck(this.config.typeCheckCommand, 'Type Check');
  }

  /**
   * æ‰§è¡Œè‡ªå®šä¹‰éªŒè¯
   *
   * @returns éªŒè¯ç»“æœ
   */
  async verifyCustomCheck(): Promise<VerificationResult> {
    if (!this.config.customCheckCommand) {
      return {
        passed: true,
        duration: 0
      };
    }

    return this.runCheck(this.config.customCheckCommand, 'Custom Check');
  }

  /**
   * æ‰§è¡Œæ‰€æœ‰éªŒè¯
   *
   * @returns éªŒè¯ç»“æœï¼ˆä»»ä½•ä¸€é¡¹å¤±è´¥å³æ•´ä½“å¤±è´¥ï¼‰
   */
  async verifyAll(): Promise<VerificationResult> {
    const typeCheckResult = await this.verifyTypeCheck();

    if (!typeCheckResult.passed) {
      return {
        ...typeCheckResult,
        error: `Type check failed:\n${typeCheckResult.error}`
      };
    }

    const customCheckResult = await this.verifyCustomCheck();

    if (!customCheckResult.passed) {
      return {
        ...customCheckResult,
        error: `Custom check failed:\n${customCheckResult.error}`
      };
    }

    return {
      passed: true,
      duration: typeCheckResult.duration + customCheckResult.duration
    };
  }

  /**
   * è¿è¡Œå•ä¸ªæ£€æŸ¥å‘½ä»¤
   */
  private async runCheck(
    command: string,
    checkName: string
  ): Promise<VerificationResult> {
    const startTime = Date.now();

    try {
      console.log(`\n[Verifier] ğŸ›¡ï¸ Executing ${checkName}: ${command}...`);

      const { stdout, stderr } = await execAsync(command, {
        cwd: this.config.cwd,
        timeout: this.config.timeout,
        encoding: 'utf-8'
      });

      const duration = Date.now() - startTime;

      return {
        passed: true,
        stdout,
        stderr,
        duration
      };
    } catch (error: any) {
      const duration = Date.now() - startTime;

      let errorMessage = '';

      if (error.stdout) {
        errorMessage += error.stdout;
      }

      if (error.stderr) {
        if (errorMessage) errorMessage += '\n';
        errorMessage += error.stderr;
      }

      if (error.killed && error.signal === 'SIGTERM') {
        errorMessage += '\nCommand timed out';
      }

      if (!errorMessage) {
        errorMessage = error.message || 'Unknown error';
      }

      return {
        passed: false,
        stdout: error.stdout,
        stderr: error.stderr,
        error: errorMessage,
        duration
      };
    }
  }

  /**
   * æ ¼å¼åŒ–é”™è¯¯ä¿¡æ¯ï¼Œä¾¿äº AI ç†è§£
   */
  formatErrorForAI(result: VerificationResult): string {
    if (result.passed) {
      return 'âœ… Verification passed: All checks successful.';
    }

    let formatted = 'âŒ Verification failed. Please fix the following errors:\n\n';

    if (result.error) {
      const errorLines = result.error.split('\n');
      const relevantLines = errorLines.filter(line => {
        return line.includes('error TS') ||
               line.includes('error ') ||
               line.includes('Error:');
      });

      if (relevantLines.length > 0) {
        formatted += '=== Type Errors ===\n';
        formatted += relevantLines.slice(0, 50).join('\n');
        if (relevantLines.length > 50) {
          formatted += `\n... and ${relevantLines.length - 50} more errors`;
        }
        formatted += '\n\n';
      } else {
        formatted += `=== Error Details ===\n${result.error.slice(0, 2000)}\n\n`;
      }
    }

    return formatted;
  }

  /**
   * æå–æ–‡ä»¶è·¯å¾„å’Œè¡Œå·ï¼ˆç”¨äºå®šä½é”™è¯¯ï¼‰
   */
  extractErrorLocations(result: VerificationResult): Array<{ file: string; line: number; message: string }> {
    if (result.passed || !result.error) {
      return [];
    }

    const locations: Array<{ file: string; line: number; message: string }> = [];

    const errorPattern = /([^(:]+)\((\d+),\d+\): (error TS\d+: .+)/g;
    let match;

    while ((match = errorPattern.exec(result.error)) !== null) {
      locations.push({
        file: match[1],
        line: parseInt(match[2], 10),
        message: match[3]
      });
    }

    return locations;
  }

  /**
   * æ›´æ–°é…ç½®
   */
  updateConfig(config: Partial<VerifierConfig>): void {
    this.config = { ...this.config, ...config };
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/kernel/XResolver.ts

````typescript
/**
 * X-Resolver: Cross-File Symbol Dependency Resolver
 *
 * è·¨æ–‡ä»¶ç¬¦å·ä¾èµ–è§£æå™¨ - yuangs çš„å…¨åŸŸæ„ŸçŸ¥æ ¸å¿ƒ
 *
 * æ ¸å¿ƒåŠŸèƒ½ï¼š
 * 1. æ¢æµ‹ç›®æ ‡æ–‡ä»¶çš„æ‰€æœ‰å¯¼å‡ºç¬¦å·ï¼ˆå‡½æ•°ã€ç±»ã€æ¥å£ã€ç±»å‹ï¼‰
 * 2. æœç´¢é¡¹ç›®ä¸­æ‰€æœ‰å¼•ç”¨è¿™äº›ç¬¦å·çš„æ–‡ä»¶
 * 3. æå–ç›¸å…³çš„ä»£ç ç‰‡æ®µå’Œ JSDoc æ–‡æ¡£
 * 4. ä¸º Agent æä¾›è·¨æ–‡ä»¶ä¸Šä¸‹æ–‡æ„ŸçŸ¥
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import { EnhancedASTParser, SymbolMetadata } from './ASTParser';
import { FastScanner } from './FastScanner';
import * as ts from 'typescript';

/**
 * ç¬¦å·å½±å“åˆ†æç»“æœ
 */
export interface SymbolImpact {
  /** æ¶ˆè´¹è€…æ–‡ä»¶è·¯å¾„ */
  filePath: string;
  /** ä½¿ç”¨çš„å¯¼å‡ºç¬¦å·åˆ—è¡¨ */
  symbols: string[];
  /** ç›¸å…³ä»£ç ç‰‡æ®µï¼ˆç»è¿‡æ™ºèƒ½åˆ‡ç‰‡ï¼‰ */
  snippet: string;
  /** ç¬¦å·çš„ JSDoc æ–‡æ¡£ */
  jsDoc?: string;
}

/**
 * X-Resolver è§£æç»“æœ
 */
export interface XResolverResult {
  /** ç›®æ ‡æ–‡ä»¶è·¯å¾„ */
  targetFile: string;
  /** å¯¼å‡ºçš„ç¬¦å·åˆ—è¡¨ */
  exportedSymbols: SymbolMetadata[];
  /** å—å½±å“çš„ä½¿ç”¨è€…åˆ—è¡¨ */
  impacts: SymbolImpact[];
  /** æ‰«æè€—æ—¶ï¼ˆæ¯«ç§’ï¼‰ */
  duration: number;
}

/**
 * è·¨æ–‡ä»¶ç¬¦å·è§£æå™¨
 *
 * ä¸º yuangs Agent æä¾›è·¨æ–‡ä»¶ä¾èµ–æ„ŸçŸ¥èƒ½åŠ›
 */
export class XResolver {
  private astParser: EnhancedASTParser;
  private scanner: FastScanner;

  constructor(astParser?: EnhancedASTParser, scanner?: FastScanner) {
    this.astParser = astParser || new EnhancedASTParser();
    this.scanner = scanner || new FastScanner();
  }

  /**
   * åˆ†æç›®æ ‡æ–‡ä»¶çš„è·¨æ–‡ä»¶å½±å“åŸŸ
   *
   * @param targetFilePath - è¦åˆ†æçš„ç›®æ ‡æ–‡ä»¶è·¯å¾„
   * @returns è·¨æ–‡ä»¶å½±å“åˆ†æç»“æœ
   */
  async getImpactAnalysis(targetFilePath: string): Promise<XResolverResult> {
    const startTime = Date.now();

    const parseResult = await this.astParser.parseFile(targetFilePath);

    if (!parseResult.success) {
      return {
        targetFile: targetFilePath,
        exportedSymbols: [],
        impacts: [],
        duration: Date.now() - startTime
      };
    }

    const exportedSymbols = parseResult.symbols.filter(s => s.isExported);

    if (exportedSymbols.length === 0) {
      return {
        targetFile: targetFilePath,
        exportedSymbols: [],
        impacts: [],
        duration: Date.now() - startTime
      };
    }

    const baseName = path.basename(targetFilePath, path.extname(targetFilePath));
    const scanResult = await this.scanner.findConsumerFiles(baseName, path.dirname(targetFilePath));

    const impacts: SymbolImpact[] = [];

    for (const consumerFile of scanResult.consumerFiles) {
      const impact = await this.extractImpactContext(consumerFile, exportedSymbols);
      if (impact) {
        impacts.push(impact);
      }
    }

    return {
      targetFile: targetFilePath,
      exportedSymbols,
      impacts,
      duration: Date.now() - startTime
    };
  }

  /**
   * ä»æ¶ˆè´¹è€…æ–‡ä»¶ä¸­æå–ç›¸å…³ä¸Šä¸‹æ–‡
   */
  private async extractImpactContext(
    consumerFile: string,
    exportedSymbols: SymbolMetadata[]
  ): Promise<SymbolImpact | null> {
    try {
      const content = await fs.readFile(consumerFile, 'utf-8');
      const sourceFile = ts.createSourceFile(
        consumerFile,
        content,
        ts.ScriptTarget.Latest,
        true
      );

      const usedSymbols = exportedSymbols.filter(sym => content.includes(sym.name));

      if (usedSymbols.length === 0) {
        return null;
      }

      const snippet = this.extractRelevantSnippet(content, sourceFile, usedSymbols);
      const jsDoc = this.getAggregatedJSDoc(usedSymbols);

      return {
        filePath: consumerFile,
        symbols: usedSymbols.map(s => s.name),
        snippet,
        jsDoc
      };
    } catch (error) {
      console.warn(`[X-Resolver] Failed to analyze ${consumerFile}: ${error}`);
      return null;
    }
  }

  /**
   * æå–ç›¸å…³ä»£ç ç‰‡æ®µï¼ˆæ™ºèƒ½åˆ‡ç‰‡ï¼‰
   */
  private extractRelevantSnippet(
    content: string,
    sourceFile: ts.SourceFile,
    usedSymbols: SymbolMetadata[]
  ): string {
    const lines = content.split('\n');
    const matchedLines = new Set<number>();

    lines.forEach((line, idx) => {
      if (usedSymbols.some(sym => line.includes(sym.name))) {
        for (let i = Math.max(0, idx - 3); i <= Math.min(lines.length - 1, idx + 5); i++) {
          matchedLines.add(i);
        }
      }
    });

    const sortedLines = Array.from(matchedLines).sort((a, b) => a - b);

    let snippet = '';
    for (let i = 0; i < sortedLines.length; i++) {
      const lineNum = sortedLines[i];
      const prevLine = i > 0 ? sortedLines[i - 1] : -1;

      if (lineNum > prevLine + 1) {
        snippet += '\n// ...\n';
      }

      snippet += `${lineNum + 1}: ${lines[lineNum]}\n`;
    }

    return snippet.trim();
  }

  /**
   * èšåˆç¬¦å·çš„ JSDoc
   */
  private getAggregatedJSDoc(symbols: SymbolMetadata[]): string {
    const docs = symbols.filter(s => s.jsDoc).map(s => {
      return `=== ${s.name} (${s.kind}) ===\n${s.jsDoc}`;
    });

    return docs.length > 0 ? docs.join('\n\n') : '';
  }

  /**
   * æ¸²æŸ“ä¸º AI å‹å¥½çš„ä¸Šä¸‹æ–‡æ ¼å¼
   */
  renderAsAIContext(result: XResolverResult): string {
    let context = `\n${'='.repeat(60)}\n`;
    context += `X-RESOLVER: CROSS-FILE DEPENDENCY CONTEXT\n`;
    context += `Target: ${result.targetFile}\n`;
    context += `Exported Symbols: ${result.exportedSymbols.length}\n`;
    context += `Affected Files: ${result.impacts.length}\n`;
    context += `Analysis Time: ${result.duration}ms\n`;
    context += `${'='.repeat(60)}\n\n`;

    if (result.exportedSymbols.length > 0) {
      context += `[EXPORTED SYMBOLS]\n`;
      for (const symbol of result.exportedSymbols) {
        context += `- ${symbol.name} (${symbol.kind}) at line ${symbol.startLine}\n`;
        if (symbol.jsDoc) {
          const shortDoc = symbol.jsDoc.split('\n')[0];
          if (shortDoc) {
            context += `  Doc: ${shortDoc}\n`;
          }
        }
      }
      context += '\n';
    }

    if (result.impacts.length > 0) {
      context += `[AFFECTED FILES]\n\n`;
      for (const impact of result.impacts) {
        context += `<<< EXTERNAL DEPENDENCY REFERENCE >>>\n`;
        context += `File: ${impact.filePath}\n`;
        context += `Role: READ-ONLY (This file consumes symbols from target file)\n`;
        context += `Symbols Used: ${impact.symbols.join(', ')}\n`;

        if (impact.jsDoc) {
          context += `\n--- SYMBOL CONTRACT (JSDoc) ---\n`;
          context += `${impact.jsDoc}\n`;
        }

        context += `\n--- USAGE SNIPPET ---\n`;
        context += `${impact.snippet}\n`;
        context += `<<< END OF REFERENCE >>>\n\n`;
      }
    }

    return context;
  }

  /**
   * å¿«æ·æ–¹æ³•ï¼šä»…è·å–å¯¼å‡ºç¬¦å·
   */
  async getExportedSymbols(filePath: string): Promise<SymbolMetadata[]> {
    const result = await this.astParser.parseFile(filePath);
    return result.success ? result.symbols.filter(s => s.isExported) : [];
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/macros.ts

````typescript
import fs from 'fs';
import path from 'path';
import os from 'os';
import { parseMacros, type Macro } from './validation';

const USER_MACROS_FILE = path.join(os.homedir(), '.yuangs_macros.json');

export type { Macro };

function loadMacrosFromFile(filePath: string): Record<string, Macro> {
    if (fs.existsSync(filePath)) {
        try {
            return parseMacros(fs.readFileSync(filePath, 'utf8'));
        } catch (e) { }
    }
    return {};
}

function findProjectMacros(cwd = process.cwd()): string | null {
    let dir = cwd;
    while (dir && dir !== path.dirname(dir)) {
        const candidate = path.join(dir, 'yuangs_macros.json');
        if (fs.existsSync(candidate)) {
            return candidate;
        }
        dir = path.dirname(dir);
    }
    // Check root one last time
    const rootCandidate = path.join(targetRoot(dir), 'yuangs_macros.json');
    if (fs.existsSync(rootCandidate)) return rootCandidate;
    
    return null;
}

// Helper to reliably stop at root (dirname('/') is '/')
function targetRoot(dir: string) {
    return path.parse(dir).root;
}

export function getMacros(): Record<string, Macro> {
    const userMacros = loadMacrosFromFile(USER_MACROS_FILE);
    
    const projectMacrosPath = findProjectMacros();
    const projectMacros = projectMacrosPath ? loadMacrosFromFile(projectMacrosPath) : {};

    return {
        ...userMacros,
        ...projectMacros // Project overrides User
    };
}

export function saveMacro(name: string, commands: string, description: string = '') {
    // Only load USER macros for saving
    const macros = loadMacrosFromFile(USER_MACROS_FILE);
    macros[name] = {
        commands,
        description,
        createdAt: new Date().toISOString()
    };
    fs.writeFileSync(USER_MACROS_FILE, JSON.stringify(macros, null, 2));
    return true;
}

export function deleteMacro(name: string) {
    // Only delete from USER macros
    const macros = loadMacrosFromFile(USER_MACROS_FILE);
    if (macros[name]) {
        delete macros[name];
        fs.writeFileSync(USER_MACROS_FILE, JSON.stringify(macros, null, 2));
        return true;
    }
    return false;
}

export function runMacro(name: string) {
    const macros = getMacros();
    const macro = macros[name];
    if (!macro) return false;

    const { spawn } = require('child_process');
    spawn(macro.commands, [], { shell: true, stdio: 'inherit' });
    return true;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/metrics/MetricsCollector.ts

````typescript
import { ModelStats, DomainHealth, DomainState } from '../modelRouter/types';

/**
 * æŒ‡æ ‡å¿«ç…§ï¼Œç”¨äºäº¤ç»™ç›‘ç£å™¨è¿›è¡Œå†³ç­–
 */
export interface MetricsSnapshot {
    globalLatencyEMA: number;
    globalSuccessRateEMA: number;
    domainHealth: Map<string, { state: DomainState; successEMA: number; latencyEMA: number }>;
    allStats: Map<string, ModelStats>;
}

/**
 * æŒ‡æ ‡æ”¶é›†å™¨æ¥å£ (è§‚æµ‹é¢)
 */
export interface MetricsCollector {
    /** è®°å½•å•æ¬¡è¯·æ±‚ç»“æœ */
    recordRequest(
        adapterName: string,
        domain: string,
        latencyMs: number,
        success: boolean,
        costLevel: number
    ): void;

    /** è·å–å½“å‰ç³»ç»ŸæŒ‡æ ‡å¿«ç…§ */
    snapshot(domainHealthMap: Map<string, DomainHealth>): MetricsSnapshot;

    /** è·å–æ‰€æœ‰ç»Ÿè®¡æ•°æ® (Router å…¼å®¹æ—§æ¥å£) */
    getAllStats(): Map<string, ModelStats>;

    /** è·å–ç‰¹å®šæ¨¡å‹ç»Ÿè®¡ */
    getStats(name: string): ModelStats | undefined;
}

/**
 * é»˜è®¤æŒ‡æ ‡æ”¶é›†å™¨å®ç°
 * é‡‡ç”¨åŠ¨æ€ Alpha æŒ‡æ•°ç§»åŠ¨å¹³å‡ (EMA)
 */
export class DefaultMetricsCollector implements MetricsCollector {
    private stats: Map<string, ModelStats> = new Map();
    private globalLatencyEMA: number = 1000;
    private globalSuccessRateEMA: number = 1.0;

    recordRequest(
        adapterName: string,
        domain: string,
        latencyMs: number,
        success: boolean,
        costLevel: number
    ): void {
        let s = this.stats.get(adapterName);
        if (!s) {
            s = {
                modelName: adapterName,
                totalRequests: 0,
                successCount: 0,
                failureCount: 0,
                avgResponseTime: 0,
                totalTokens: 0,
                lastUsed: new Date(),
                recentFailures: 0,
                successEMA: 1.0,
                latencyEMA: 1000,
                costEMA: 3,
            };
            this.stats.set(adapterName, s);
        }

        s.totalRequests++;
        s.lastUsed = new Date();

        // åŠ¨æ€ Î± = 1 / sqrt(N)
        const alpha = Math.max(0.05, Math.min(0.3, 1 / Math.sqrt(s.totalRequests)));

        if (success) {
            s.successCount++;
            s.recentFailures = 0;
            s.successEMA = (1 - alpha) * s.successEMA + alpha * 1;
            s.latencyEMA = (1 - alpha) * s.latencyEMA + alpha * latencyMs;
            s.costEMA = (1 - alpha) * s.costEMA + alpha * costLevel;
        } else {
            s.failureCount++;
            s.recentFailures++;
            s.successEMA = (1 - alpha) * s.successEMA + alpha * 0;
            s.lastFailureAt = new Date();
        }

        // æ›´æ–°å…¨å±€ EMA
        this.globalLatencyEMA = (1 - alpha) * this.globalLatencyEMA + alpha * latencyMs;
        this.globalSuccessRateEMA = (1 - alpha) * this.globalSuccessRateEMA + alpha * (success ? 1 : 0);

        // æ›´æ–°å¹³å‡å€¼ (ç´¯ç§¯å¹³å‡)
        s.avgResponseTime = (s.avgResponseTime * (s.totalRequests - 1) + latencyMs) / s.totalRequests;
    }

    snapshot(domainHealthMap: Map<string, DomainHealth>): MetricsSnapshot {
        const domainSummary = new Map<string, { state: DomainState; successEMA: number; latencyEMA: number }>();

        // èšåˆå„åŸŸæŒ‡æ ‡
        domainHealthMap.forEach((health, domain) => {
            // è®¡ç®—è¯¥åŸŸä¸‹æ‰€æœ‰æ¨¡å‹çš„å¹³å‡ EMA
            const modelsInDomain = Array.from(this.stats.values()).filter(s => {
                // è¿™é‡Œç®€å•å‡è®¾ domain åå­—å’Œ provider ä¸€è‡´ï¼Œæˆ–è€…åœ¨ record æ—¶ä¼ å…¥
                // ç›®å‰ Router é€»è¾‘ä¸­ domain å·²çŸ¥
                return true; // å®é™…å®ç°ä¸­éœ€æ›´ç²¾å‡†è¿‡æ»¤
            });

            domainSummary.set(domain, {
                state: health.state,
                successEMA: 0.9, // ç®€åŒ–å®ç°ï¼Œå®é™…åº”ä» modelsInDomain èšåˆ
                latencyEMA: 1000
            });
        });

        return {
            globalLatencyEMA: this.globalLatencyEMA,
            globalSuccessRateEMA: this.globalSuccessRateEMA,
            domainHealth: domainSummary,
            allStats: new Map(this.stats)
        };
    }

    getAllStats() {
        return this.stats;
    }

    getStats(name: string) {
        return this.stats.get(name);
    }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/modelMatcher.ts

````typescript
import { AtomicCapability, ConstraintCapability, expandCapabilities } from './capabilities';

export interface ModelCapabilities {
  name: string;
  provider: string;
  atomicCapabilities: AtomicCapability[];
  contextWindow?: number;
  costProfile?: 'low' | 'medium' | 'high';
}

export interface CapabilityRequirement {
  required: AtomicCapability[];
  preferred: AtomicCapability[];
  constraints?: ConstraintCapability[];
}

export interface CapabilityMatchExplanation {
  modelName: string;
  provider: string;
  hasRequired: boolean;
  hasPreferred: AtomicCapability[];
  missingRequired: AtomicCapability[];
  reason: string;
}

export interface CapabilityMatchResult {
  selected: ModelCapabilities | null;
  candidates: CapabilityMatchExplanation[];
  fallbackOccurred: boolean;
}

export function matchModel(
  models: ModelCapabilities[],
  requirement: CapabilityRequirement
): CapabilityMatchResult {
  const explanations: CapabilityMatchExplanation[] = [];

  for (const model of models) {
    const hasRequired = requirement.required.every(cap =>
      model.atomicCapabilities.includes(cap)
    );

    const missingRequired = requirement.required.filter(cap =>
      !model.atomicCapabilities.includes(cap)
    );

    const hasPreferred = requirement.preferred.filter(cap =>
      model.atomicCapabilities.includes(cap)
    );

    const explanation: CapabilityMatchExplanation = {
      modelName: model.name,
      provider: model.provider,
      hasRequired,
      hasPreferred,
      missingRequired,
      reason: hasRequired
        ? `Has all required capabilities. Matches ${hasPreferred.length}/${requirement.preferred.length} preferred.`
        : `Missing required capabilities: ${missingRequired.map(c => String(c)).join(', ')}`,
    };

    explanations.push(explanation);
  }

  const matchingModels = explanations.filter(e => e.hasRequired);

  if (matchingModels.length === 0) {
    return {
      selected: null,
      candidates: explanations,
      fallbackOccurred: false,
    };
  }

  const bestMatch = matchingModels[0];
  const selectedModel = models.find(m => m.name === bestMatch.modelName);

  return {
    selected: selectedModel || null,
    candidates: explanations,
    fallbackOccurred: false,
  };
}

export function matchModelWithFallback(
  models: ModelCapabilities[],
  fallbackModels: ModelCapabilities[],
  requirement: CapabilityRequirement
): CapabilityMatchResult {
  const primaryResult = matchModel(models, requirement);

  if (primaryResult.selected) {
    return primaryResult;
  }

  const fallbackResult = matchModel(fallbackModels, requirement);

  return {
    ...fallbackResult,
    fallbackOccurred: fallbackResult.selected !== null,
  };
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/modelRouter/BaseAdapter.ts

````typescript
import { spawn } from 'child_process';
import {
  ModelAdapter,
  ModelCapabilities,
  TaskConfig,
  ModelExecutionResult,
} from './types';
import { contextManager } from './ContextManager';

/**
 * åŸºç¡€æ¨¡å‹é€‚é…å™¨æŠ½è±¡ç±»
 * æä¾›é€šç”¨çš„åŠŸèƒ½å®ç°
 */
export abstract class BaseAdapter implements ModelAdapter {
  abstract name: string;
  abstract version: string;
  abstract provider: string;
  abstract capabilities: ModelCapabilities;

  // ä¼šè¯IDï¼Œç”¨äºä¸Šä¸‹æ–‡ç®¡ç†
  protected sessionId: string = 'default';

  /**
   * è®¾ç½®ä¼šè¯ID
   */
  setSessionId(sessionId: string): void {
    this.sessionId = sessionId;
  }

  /**
   * è·å–ä¼šè¯ID
   */
  getSessionId(): string {
    return this.sessionId;
  }

  /**
   * æ„å»ºå¸¦ä¸Šä¸‹æ–‡çš„å®Œæ•´prompt
   */
  protected buildPromptWithContext(prompt: string, includeContext: boolean = true): string {
    if (!includeContext) {
      return prompt;
    }

    // è·å–æœ€è¿‘çš„å¯¹è¯å†å²
    const recentMessages = contextManager.getRecentMessages(this.sessionId, 5);
    
    if (recentMessages.length === 0) {
      return prompt;
    }

    // æ„å»ºå¸¦å†å²çš„prompt
    let fullPrompt = 'ä»¥ä¸‹æ˜¯ä¹‹å‰çš„å¯¹è¯å†å²:\n\n';
    
    for (const msg of recentMessages) {
      const roleLabel = msg.role === 'user' ? 'ç”¨æˆ·' : 'åŠ©æ‰‹';
      fullPrompt += `${roleLabel}: ${msg.content}\n\n`;
    }
    
    fullPrompt += `ç°åœ¨ç”¨æˆ·çš„æ–°é—®é¢˜æ˜¯:\n${prompt}`;
    
    return fullPrompt;
  }

  /**
   * ä¿å­˜å¯¹è¯åˆ°ä¸Šä¸‹æ–‡
   */
  protected saveToContext(userPrompt: string, assistantResponse: string): void {
    contextManager.addUserMessage(this.sessionId, userPrompt);
    contextManager.addAssistantMessage(this.sessionId, assistantResponse);
  }

  /**
   * æ£€æŸ¥ CLI å‘½ä»¤æ˜¯å¦å¯ç”¨
   */
  protected async checkCommand(command: string): Promise<boolean> {
    return new Promise((resolve) => {
      const child = spawn('command', ['-v', command]);
      child.on('close', (code) => {
        resolve(code === 0);
      });
      child.on('error', () => {
        resolve(false);
      });
    });
  }

  /**
   * ä½¿ç”¨ spawn æ‰§è¡Œå‘½ä»¤ï¼ˆæ”¯æŒæµå¼è¾“å‡ºå’Œè‡ªåŠ¨è½¬ä¹‰ï¼‰
   * @param command è¦æ‰§è¡Œçš„å‘½ä»¤
   * @param args å‘½ä»¤å‚æ•°æ•°ç»„
   * @param timeout è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
   * @param onChunk æµå¼è¾“å‡ºå›è°ƒå‡½æ•°
   */
  protected async runSpawnCommand(
    command: string,
    args: string[],
    timeout: number = 30000,
    onChunk?: (chunk: string) => void
  ): Promise<{ stdout: string; stderr: string }> {
    return new Promise((resolve, reject) => {
      const child = spawn(command, args);
      
      let stdout = '';
      let stderr = '';
      let timeoutId: NodeJS.Timeout | null = null;
      let isResolved = false;

      // è®¾ç½®è¶…æ—¶
      if (timeout > 0) {
        timeoutId = setTimeout(() => {
          if (!isResolved) {
            isResolved = true;
            child.kill();
            reject(new Error(`å‘½ä»¤æ‰§è¡Œè¶…æ—¶ (${timeout}ms)`));
          }
        }, timeout);
      }

      // å®æ—¶ç›‘å¬æ ‡å‡†è¾“å‡º
      child.stdout.on('data', (data) => {
        const str = data.toString();
        stdout += str;
        
        // å¦‚æœæä¾›äº† onChunk å›è°ƒï¼Œä¸”è¾“å‡ºä¸æ˜¯ JSON æ ¼å¼ï¼Œåˆ™å®æ—¶å›è°ƒ
        if (onChunk && !this.isJsonOutput(str)) {
          onChunk(str);
        }
      });

      // ç›‘å¬æ ‡å‡†é”™è¯¯è¾“å‡º
      child.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      // è¿›ç¨‹å…³é—­äº‹ä»¶
      child.on('close', (code) => {
        if (timeoutId) clearTimeout(timeoutId);
        if (isResolved) return;
        isResolved = true;

        if (code === 0) {
          resolve({ stdout, stderr });
        } else {
          // æœ‰äº› CLI å³ä½¿æˆåŠŸä¹Ÿå¯èƒ½è¾“å‡º warning åˆ° stderr
          // å¦‚æœæœ‰ stdout è¾“å‡ºï¼Œè®¤ä¸ºæ‰§è¡ŒæˆåŠŸ
          if (stdout.trim()) {
            resolve({ stdout, stderr });
          } else {
            reject(new Error(`å‘½ä»¤æ‰§è¡Œå¤±è´¥ (exit code ${code}): ${stderr || stdout}`));
          }
        }
      });

      // è¿›ç¨‹é”™è¯¯äº‹ä»¶
      child.on('error', (err) => {
        if (timeoutId) clearTimeout(timeoutId);
        if (isResolved) return;
        isResolved = true;
        reject(new Error(`å‘½ä»¤æ‰§è¡Œå¤±è´¥: ${err.message}`));
      });
    });
  }

  /**
   * åˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦åƒæ˜¯ JSON æ ¼å¼
   */
  private isJsonOutput(str: string): boolean {
    const trimmed = str.trim();
    return trimmed.startsWith('{') || trimmed.startsWith('[');
  }

  /**
   * æå– JSON å†…å®¹ï¼ˆå¤„ç† CLI è¾“å‡ºä¸­çš„å¹²æ‰°æ—¥å¿—ï¼‰
   * @param output CLI è¾“å‡ºå­—ç¬¦ä¸²
   * @returns æå–çš„ JSON å­—ç¬¦ä¸²ï¼Œå¦‚æœæ²¡æœ‰æ‰¾åˆ°åˆ™è¿”å›åŸå­—ç¬¦ä¸²
   */
  protected extractJsonContent(output: string): string {
    try {
      // æŸ¥æ‰¾ç¬¬ä¸€ä¸ª { å’Œæœ€åä¸€ä¸ª } ä¹‹é—´çš„å†…å®¹
      const firstBrace = output.indexOf('{');
      const lastBrace = output.lastIndexOf('}');
      
      if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
        return output.substring(firstBrace, lastBrace + 1);
      }
      
      // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œå°è¯•æŸ¥æ‰¾æ•°ç»„æ ¼å¼
      const firstBracket = output.indexOf('[');
      const lastBracket = output.lastIndexOf(']');
      
      if (firstBracket !== -1 && lastBracket !== -1 && lastBracket > firstBracket) {
        return output.substring(firstBracket, lastBracket + 1);
      }
      
      return output;
    } catch {
      return output;
    }
  }

  /**
   * æµ‹é‡æ‰§è¡Œæ—¶é—´
   */
  protected async measureExecutionTime<T>(
    fn: () => Promise<T>
  ): Promise<{ result: T; executionTime: number }> {
    const start = Date.now();
    const result = await fn();
    const executionTime = Date.now() - start;
    return { result, executionTime };
  }

  /**
   * æ˜¯å¦å¯ç”¨ï¼ˆé»˜è®¤æ£€æŸ¥å¥åº·çŠ¶æ€ï¼‰
   */
  async isAvailable(): Promise<boolean> {
    return this.healthCheck();
  }

  /**
   * æ‰§è¡Œä»»åŠ¡ï¼ˆå­ç±»å¿…é¡»å®ç°ï¼‰
   */
  abstract execute(
    prompt: string,
    config: TaskConfig,
    onChunk?: (chunk: string) => void
  ): Promise<ModelExecutionResult>;

  /**
   * å¥åº·æ£€æŸ¥ï¼ˆå­ç±»å¿…é¡»å®ç°ï¼‰
   */
  abstract healthCheck(): Promise<boolean>;

  /**
   * åˆ›å»ºæˆåŠŸç»“æœ
   */
  protected createSuccessResult(
    content: string,
    executionTime: number,
    metadata?: Record<string, any>
  ): ModelExecutionResult {
    return {
      modelName: this.name,
      success: true,
      content,
      executionTime,
      metadata,
    };
  }

  /**
   * åˆ›å»ºå¤±è´¥ç»“æœ
   */
  protected createErrorResult(
    error: string,
    executionTime: number
  ): ModelExecutionResult {
    return {
      modelName: this.name,
      success: false,
      error,
      executionTime,
    };
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/modelRouter/ModelRouter.ts

````typescript
import * as crypto from 'crypto';
import {
  ModelAdapter,
  TaskConfig,
  RoutingConfig,
  RoutingResult,
  RoutingStrategy,
  ModelExecutionResult,
  ModelStats,
  TaskType,
  DomainHealth,
  DomainState,
  ExplorationStrategy,
  SupervisorConfig
} from './types';
import { RoutingPolicy } from './policies/types';
import { DslPolicy } from './policies/DslPolicy';
import { ModelSupervisor } from './ModelSupervisor';
import { MetricsCollector, DefaultMetricsCollector } from '../metrics/MetricsCollector';
import { SupervisorActionLogger, ConsoleSupervisorActionLogger } from '../observability/SupervisorActionLog';

/**
 * æ¨¡å‹è·¯ç”±å™¨ - æ‰§è¡Œé¢ (Execution Plane)
 * è´Ÿè´£äººè°ƒé…å’Œæ‰§è¡Œï¼Œä¿æŒæ ¸å¿ƒé€»è¾‘ç®€å•
 */
export class ModelRouter {
  private adapters: Map<string, ModelAdapter> = new Map();
  private policies: Map<string, RoutingPolicy> = new Map();
  private domainHealth: Map<string, DomainHealth> = new Map();

  private metrics: MetricsCollector;
  private supervisor: ModelSupervisor;
  private supervisorLogger: SupervisorActionLogger;

  private roundRobinIndex = 0;
  private activeOverrideStrategy: RoutingStrategy | null = null;

  constructor(
    supervisorConfig?: SupervisorConfig,
    metrics?: MetricsCollector,
    logger?: SupervisorActionLogger
  ) {
    this.metrics = metrics || new DefaultMetricsCollector();
    this.supervisor = new ModelSupervisor(supervisorConfig || ModelSupervisor.getDefaultConfig());
    this.supervisorLogger = logger || new ConsoleSupervisorActionLogger();

    this.registerDefaultPolicies();
  }

  private registerDefaultPolicies() {
    this.registerPolicy(new DslPolicy({
      name: 'balanced',
      description: 'å‡è¡¡ç­–ç•¥ï¼šç»¼åˆè€ƒè™‘åŒ¹é…åº¦ã€æ€§èƒ½ã€æˆæœ¬å’Œå†å²è¡¨ç°',
      weights: { taskMatch: 0.4, context: 0.2, latency: 0.2, cost: 0.1, history: 0.1 }
    }));

    this.registerPolicy(new DslPolicy({
      name: 'cost-saving',
      description: 'æˆæœ¬ä¼˜å…ˆæ¨¡å¼ï¼šä¼˜å…ˆé€‰æ‹©å»‰ä»·çš„æ¨¡å‹ï¼Œä¿è¯åŸºç¡€å¯ç”¨',
      weights: { cost: 0.7, taskMatch: 0.2, history: 0.1 }
    }));

    this.registerPolicy(new DslPolicy({
      name: 'latency-critical',
      description: 'è¿½æ±‚æè‡´å“åº”é€Ÿåº¦ï¼šä¼˜å…ˆé€‰æ‹©å¹³å‡å“åº”æ—¶é—´æœ€çŸ­çš„æ¨¡å‹',
      weights: { latency: 0.7, taskMatch: 0.2, history: 0.1 }
    }));

    this.registerPolicy(new DslPolicy({
      name: 'quality-first',
      description: 'é«˜å¤æ‚åº¦ä»»åŠ¡ä¼˜å…ˆï¼šç”±ä»£ç ä¸“å®¶å’Œå¤§å‹è¯­è¨€æ¨¡å‹å¤„ç†',
      gate: { minContext: 32000 },
      weights: { quality: 0.6, history: 0.2, taskMatch: 0.2 }
    }));
  }

  registerPolicy(policy: RoutingPolicy) {
    this.policies.set(policy.name, policy);
  }

  registerAdapter(adapter: ModelAdapter): void {
    this.adapters.set(adapter.name, adapter);
  }

  unregisterAdapter(adapterName: string): boolean {
    return this.adapters.delete(adapterName);
  }

  getAdapters(): ModelAdapter[] {
    return Array.from(this.adapters.values());
  }

  getPolicies(): RoutingPolicy[] {
    return Array.from(this.policies.values());
  }

  getStats(modelName?: string): ModelStats | ModelStats[] {
    if (modelName) {
      return this.metrics.getStats(modelName) || this.createEmptyStats(modelName);
    }
    return Array.from(this.metrics.getAllStats().values());
  }

  async route(
    taskConfig: TaskConfig,
    routingConfig: RoutingConfig
  ): Promise<RoutingResult> {
    if (routingConfig.strategy === RoutingStrategy.MANUAL && routingConfig.manualModelName) {
      const adapter = this.adapters.get(routingConfig.manualModelName);
      if (!adapter) throw new Error(`æ¨¡å‹ ${routingConfig.manualModelName} æœªæ³¨å†Œ`);
      if (!(await adapter.isAvailable())) throw new Error(`æ¨¡å‹ ${routingConfig.manualModelName} ä¸å¯ç”¨`);

      return {
        adapter,
        reason: 'æ‰‹åŠ¨æŒ‡å®šæ¨¡å‹',
        candidates: [{ name: adapter.name, score: 1.0, reason: 'æ‰‹åŠ¨æŒ‡å®š' }],
        isFallback: false,
      };
    }

    const allAdapters = this.getAdapters();
    if (allAdapters.length === 0) throw new Error('æ²¡æœ‰ä»»ä½•å·²æ³¨å†Œçš„æ¨¡å‹é€‚é…å™¨');

    if (routingConfig.strategy === RoutingStrategy.ROUND_ROBIN) {
      const availableAdapters = await this.getAvailableAdapters();
      if (availableAdapters.length === 0) throw new Error('æ²¡æœ‰å¯ç”¨çš„æ¨¡å‹é€‚é…å™¨');
      const adapter = this.selectRoundRobin(availableAdapters);
      return {
        adapter,
        reason: `è½®è¯¢é€‰æ‹© ${adapter.name}`,
        candidates: [{ name: adapter.name, score: 1.0, reason: 'è½®è¯¢é€‰æ‹©' }],
        isFallback: false
      };
    }

    // æ›´æ–°ç³»ç»Ÿç¯æ€ (CB/CB probe)
    this.updateDomainHealthStates();

    // ç›‘ç£è¯„ä¼°
    const snapshot = this.metrics.snapshot(this.domainHealth);
    const action = this.supervisor.evaluate(snapshot, routingConfig.strategy);

    let activeStrategy: RoutingStrategy = routingConfig.strategy;
    let supervisorNote = '';

    if (action && action.type === 'switch_strategy') {
      const previous = activeStrategy;
      activeStrategy = action.targetStrategy as RoutingStrategy;
      supervisorNote = ` [ç›‘ç£å™¨å¹²é¢„: ${action.reason}]`;

      // è®°å½•ç»“æ„åŒ–æ—¥å¿—
      this.supervisorLogger.log({
        eventId: crypto.randomUUID(),
        timestamp: Date.now(),
        action,
        previousStrategy: previous,
        currentStrategy: activeStrategy,
        snapshot: {
          globalLatencyEMA: snapshot.globalLatencyEMA,
          globalSuccessRateEMA: snapshot.globalSuccessRateEMA,
          domainHealth: Object.fromEntries(
            Array.from(snapshot.domainHealth.entries()).map(([k, v]) => [k, { state: v.state, successEMA: v.successEMA, latencyEMA: v.latencyEMA }])
          )
        }
      });
    }

    let policyName = 'balanced';
    switch (activeStrategy) {
      case RoutingStrategy.FASTEST_FIRST: policyName = 'latency-critical'; break;
      case RoutingStrategy.CHEAPEST_FIRST: policyName = 'cost-saving'; break;
      case RoutingStrategy.BEST_QUALITY: policyName = 'quality-first'; break;
      default: policyName = 'balanced'; break;
    }

    const policy = this.policies.get(policyName);
    if (!policy) {
      const fallbackPolicy = this.policies.get('balanced')!;
      return this.executePolicyWithExploration(fallbackPolicy, allAdapters, taskConfig, routingConfig, supervisorNote);
    }

    return this.executePolicyWithExploration(policy, allAdapters, taskConfig, routingConfig, supervisorNote);
  }

  private async executePolicyWithExploration(
    policy: RoutingPolicy,
    adapters: ModelAdapter[],
    taskConfig: TaskConfig,
    routingConfig: RoutingConfig,
    supervisorNote?: string
  ): Promise<RoutingResult> {
    try {
      const result = await policy.select(adapters, taskConfig, routingConfig, this.metrics.getAllStats(), this.domainHealth);

      const allowedCandidates = result.candidates.filter((c: any) => {
        const adapter = this.adapters.get(c.name);
        return adapter ? this.isAdapterAllowedByCircuitBreaker(adapter) : false;
      });

      if (allowedCandidates.length === 0) throw new Error('æ‰€æœ‰ç­–ç•¥å€™é€‰å‡è¢«ç†”æ–­ä¿æŠ¤æ‹¦æˆª');

      let bestCandidate = allowedCandidates.sort((a: any, b: any) => b.score - a.score)[0];
      let finalAdapter = this.adapters.get(bestCandidate.name)!;
      let finalReason = `ç­–ç•¥(${policy.name}): ${result.reason}${supervisorNote || ''}`;

      const exploration = routingConfig.exploration;
      const strategy = exploration?.strategy || ExplorationStrategy.NONE;

      if (strategy === ExplorationStrategy.EPSILON_GREEDY) {
        const epsilon = exploration?.epsilon || 0;
        if (epsilon > 0 && Math.random() < epsilon) {
          const otherCandidates = allowedCandidates.filter((c: any) => c.name !== bestCandidate.name);
          if (otherCandidates.length > 0) {
            const picked = otherCandidates[Math.floor(Math.random() * otherCandidates.length)];
            const pickedAdapter = this.adapters.get(picked.name);
            if (pickedAdapter) {
              finalAdapter = pickedAdapter;
              finalReason = `Îµ-greedy é‡‡æ ·(${epsilon}): éšæœºé€‰ä¸­ [${picked.name}]ï¼ŒåŸå®š [${bestCandidate.name}] (${picked.reason})`;
            }
          }
        }
      } else if (strategy === ExplorationStrategy.UCB1) {
        const statsMap = this.metrics.getAllStats();
        const totalRuns = Array.from(statsMap.values()).reduce((sum, s) => sum + s.totalRequests, 0);

        const candidatesWithUCB = allowedCandidates.map((c: any) => {
          const ucb = this.calculateUCB1(statsMap.get(c.name), totalRuns);
          return { ...c, combinedScore: c.score * 0.7 + ucb * 0.3, ucb };
        });

        candidatesWithUCB.sort((a: any, b: any) => b.combinedScore - a.combinedScore);
        const topOne = candidatesWithUCB[0];

        if (topOne.name !== bestCandidate.name) {
          finalAdapter = this.adapters.get(topOne.name)!;
          finalReason = `UCB1 æ¢ç´¢: é€‰ä¸­ [${topOne.name}] (UCB=${topOne.ucb.toFixed(3)})ï¼ŒåŸå®š [${bestCandidate.name}]`;
        }
      }

      return {
        adapter: finalAdapter,
        reason: finalReason,
        candidates: allowedCandidates,
        isFallback: false
      }
    } catch (error: any) {
      throw new Error(`ç­–ç•¥è·¯ç”±å¤±è´¥: ${error.message}`);
    }
  }

  async executeTask(
    adapter: ModelAdapter,
    prompt: string,
    config: TaskConfig,
    onChunk?: (chunk: string) => void
  ): Promise<ModelExecutionResult> {
    const domain = adapter.failureDomain ?? adapter.provider;

    try {
      const result = await adapter.execute(prompt, config, onChunk);

      this.metrics.recordRequest(adapter.name, domain, result.executionTime, result.success, adapter.capabilities.costLevel);

      if (result.success) {
        const health = this.domainHealth.get(domain);
        if (health && health.state === 'half-open') {
          health.state = 'closed';
          console.log(`ğŸ“¡ æ•…éšœåŸŸ [${domain}] å·²è‡ªåŠ¨æ¢å¤ (Closed)`);
        }
      } else {
        const health = this.domainHealth.get(domain);
        if (health && health.state === 'half-open') {
          health.state = 'open';
          health.openedAt = Date.now();
          console.warn(`ğŸ“¡ æ•…éšœåŸŸ [${domain}] æ¢æµ‹å¤±è´¥ï¼Œå»¶é•¿ç†”æ–­æ—¶é—´ (Open)`);
        }
      }
      return result;
    } catch (error: any) {
      this.metrics.recordRequest(adapter.name, domain, 0, false, adapter.capabilities.costLevel);
      const health = this.domainHealth.get(domain);
      if (health && health.state === 'half-open') {
        health.state = 'open';
        health.openedAt = Date.now();
      }
      throw error;
    }
  }

  private async getAvailableAdapters(): Promise<ModelAdapter[]> {
    const adapters = Array.from(this.adapters.values());
    const availabilityChecks = await Promise.all(
      adapters.map(async (adapter) => ({
        adapter,
        available: await adapter.isAvailable(),
      }))
    );

    return availabilityChecks
      .filter((check) => check.available)
      .map((check) => check.adapter);
  }

  private selectRoundRobin(adapters: ModelAdapter[]): ModelAdapter {
    const adapter = adapters[this.roundRobinIndex % adapters.length];
    this.roundRobinIndex++;
    return adapter;
  }

  private updateDomainHealthStates() {
    const now = Date.now();
    const adapters = this.getAdapters();
    const domains = new Set(adapters.map(a => a.failureDomain ?? a.provider));

    for (const domain of domains) {
      let health = this.domainHealth.get(domain);
      if (!health) {
        health = { state: 'closed' };
        this.domainHealth.set(domain, health);
      }

      const domainAdapters = adapters.filter(a => (a.failureDomain ?? a.provider) === domain);
      const isUnstable = domainAdapters.some(a => {
        const s = this.metrics.getStats(a.name);
        return s && (s.recentFailures >= 3 || s.successEMA < 0.4);
      });

      const isStable = domainAdapters.every(a => {
        const s = this.metrics.getStats(a.name);
        return s && s.successEMA > 0.85;
      });

      if (health.state === 'closed' && isUnstable) {
        health.state = 'open';
        health.openedAt = now;
        console.warn(`ğŸš¨ æ•…éšœåŸŸ [${domain}] è¡¨ç°æå·®æˆ–è¿ç»­é”™è¯¯ï¼Œå·²è§¦å‘ç†”æ–­æ‹¦æˆª (Open)`);
      } else if (health.state === 'open' && now - (health.openedAt || 0) > 30000) {
        health.state = 'half-open';
        console.log(`ğŸ“¡ æ•…éšœåŸŸ [${domain}] è¿›å…¥åŠæ¢æµ‹æ¨¡å¼ (Half-Open)`);
      } else if (health.state === 'half-open' && isStable) {
        health.state = 'closed';
        console.log(`âœ… æ•…éšœåŸŸ [${domain}] EMA æŒ‡æ ‡å·²æ¢å¤ï¼Œç†”æ–­çŠ¶æ€é‡ç½® (Closed)`);
      }
    }
  }

  private isAdapterAllowedByCircuitBreaker(adapter: ModelAdapter): boolean {
    const domain = adapter.failureDomain ?? adapter.provider;
    const health = this.domainHealth.get(domain);
    if (!health || health.state === 'closed') return true;
    if (health.state === 'open') return false;
    if (health.state === 'half-open') return Math.random() < 0.1;
    return true;
  }

  private calculateUCB1(stats: ModelStats | undefined, totalRuns: number): number {
    if (!stats || stats.totalRequests === 0) return 1.0;
    const mean = stats.successCount / stats.totalRequests;
    const explorationBonus = Math.sqrt((2 * Math.log(Math.max(totalRuns, 1))) / stats.totalRequests);
    return Math.min(mean + explorationBonus, 2.0) / 2.0;
  }

  private createEmptyStats(modelName: string): ModelStats {
    return {
      modelName,
      totalRequests: 0,
      successCount: 0,
      failureCount: 0,
      avgResponseTime: 0,
      totalTokens: 0,
      lastUsed: new Date(),
      recentFailures: 0,
      successEMA: 1.0,
      latencyEMA: 1000,
      costEMA: 3,
    };
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/modelRouter/adapters/CodebuddyAdapter.ts

````typescript
import { BaseAdapter } from '../BaseAdapter';
import { ModelCapabilities, TaskConfig, ModelExecutionResult, TaskType } from '../types';

/**
 * Codebuddy CLI é€‚é…å™¨
 * ä¸“é—¨ç”¨äºä»£ç ç›¸å…³çš„ä»»åŠ¡
 */
export class CodebuddyAdapter extends BaseAdapter {
  name = 'codebuddy';
  version = '1.0.0';
  provider = 'Codebuddy';

  capabilities: ModelCapabilities = {
    supportedTaskTypes: [
      TaskType.CODE_GENERATION,
      TaskType.CODE_REVIEW,
      TaskType.DEBUG,
      TaskType.ANALYSIS,
    ],
    maxContextWindow: 100000,
    avgResponseTime: 3000,
    costLevel: 3,
    supportsStreaming: true,
    specialCapabilities: ['code-expert', 'repository-aware', 'multi-file-context'],
  };

  /**
   * å¥åº·æ£€æŸ¥ï¼šæ£€æŸ¥ codebuddy CLI æ˜¯å¦å®‰è£…
   */
  async healthCheck(): Promise<boolean> {
    try {
      await this.checkCommand('codebuddy');
      return true;
    } catch {
      return false;
    }
  }

  /**
   * æ‰§è¡Œä»»åŠ¡
   */
  async execute(
    prompt: string,
    config: TaskConfig,
    onChunk?: (chunk: string) => void
  ): Promise<ModelExecutionResult> {
    try {
      const { result, executionTime } = await this.measureExecutionTime(async () => {
        // æ„å»ºå‚æ•°æ•°ç»„
        const args = ['-p', prompt];
        
        // æ ¹æ®ä»»åŠ¡ç±»å‹æ·»åŠ  flags
        this.addTaskSpecificArgs(args, config.type);

        const { stdout, stderr } = await this.runSpawnCommand(
          'codebuddy',
          args,
          config.expectedResponseTime || 60000, // Codebuddy å¯èƒ½éœ€è¦æ›´é•¿æ—¶é—´
          onChunk
        );

        if (stderr && !stdout) {
          throw new Error(stderr);
        }

        // è§£æè¾“å‡º
        return this.parseCodebuddyOutput(stdout);
      });

      return this.createSuccessResult(result, executionTime, {
        model: 'codebuddy',
        provider: this.provider,
        taskType: config.type,
      });
    } catch (error: any) {
      return this.createErrorResult(
        `Codebuddy CLI æ‰§è¡Œå¤±è´¥: ${error.message}`,
        0
      );
    }
  }

  /**
   * æ ¹æ®ä»»åŠ¡ç±»å‹æ·»åŠ ç‰¹å®šçš„ args
   */
  private addTaskSpecificArgs(args: string[], taskType: TaskType): void {
    switch (taskType) {
      case TaskType.CODE_GENERATION:
        args.push('--mode', 'generate');
        break;
      case TaskType.CODE_REVIEW:
        args.push('--mode', 'review');
        break;
      case TaskType.DEBUG:
        args.push('--mode', 'debug');
        break;
      case TaskType.ANALYSIS:
        args.push('--mode', 'analyze');
        break;
    }
  }

  /**
   * è§£æ Codebuddy CLI è¾“å‡º
   */
  private parseCodebuddyOutput(output: string): string {
    try {
      // å°è¯•è§£æ JSON
      const jsonContent = this.extractJsonContent(output);
      
      if (jsonContent !== output) {
        try {
          const parsed = JSON.parse(jsonContent);
          if (parsed.response) {
            return parsed.response;
          }
          if (parsed.content) {
            return parsed.content;
          }
        } catch {
          // JSON è§£æå¤±è´¥ï¼Œç»§ç»­å¤„ç†
        }
      }

      // å¦‚æœä¸æ˜¯ JSONï¼Œè¿‡æ»¤æ—¥å¿—è¡Œ
      const lines = output.split('\n');
      const contentLines = lines.filter(line => {
        const trimmed = line.trim();
        return trimmed.length > 0 && 
               !trimmed.startsWith('[INFO]') && 
               !trimmed.startsWith('[DEBUG]') &&
               !trimmed.startsWith('[WARN]') &&
               !trimmed.startsWith('Loading');
      });

      return contentLines.join('\n').trim();
    } catch {
      return output.trim();
    }
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/modelRouter/adapters/GoogleAdapter.ts

````typescript
import { BaseAdapter } from '../BaseAdapter';
import { ModelCapabilities, TaskConfig, ModelExecutionResult, TaskType } from '../types';

/**
 * Gemini CLI é€‚é…å™¨
 * æ”¯æŒ Gemini ç³»åˆ—æ¨¡å‹
 * ä½¿ç”¨ https://github.com/google-gemini/gemini-cli
 */
export class GoogleAdapter extends BaseAdapter {
  name = 'google-gemini';
  version = '1.0.0';
  provider = 'Google';
  failureDomain = 'google';

  capabilities: ModelCapabilities = {
    supportedTaskTypes: [
      TaskType.CODE_GENERATION,
      TaskType.CODE_REVIEW,
      TaskType.CONVERSATION,
      TaskType.TRANSLATION,
      TaskType.SUMMARIZATION,
      TaskType.ANALYSIS,
      TaskType.DEBUG,
      TaskType.GENERAL,
    ],
    maxContextWindow: 1000000, // Gemini 1M+ context
    avgResponseTime: 2000,
    costLevel: 2,
    supportsStreaming: true,
    specialCapabilities: ['long-context', 'multimodal'],
  };

  /**
   * å¥åº·æ£€æŸ¥ï¼šæ£€æŸ¥ Gemini CLI æ˜¯å¦å®‰è£…å¹¶å·²é…ç½®
   */
  async healthCheck(): Promise<boolean> {
    try {
      const available = await this.checkCommand('gemini');
      if (!available) {
        console.warn('âš ï¸  Gemini CLI æœªå®‰è£…');
        return false;
      }

      // æ£€æŸ¥ç‰ˆæœ¬ä»¥ç¡®è®¤å®‰è£…
      const { stdout } = await this.runSpawnCommand(
        'gemini',
        ['--version'],
        30000 // å¢åŠ è¶…æ—¶æ—¶é—´ï¼Œgemini cli å¯åŠ¨è¾ƒæ…¢
      );

      if (!stdout.trim()) return false;

      // æ£€æŸ¥æ˜¯å¦é…ç½®äº† API key ç¯å¢ƒå˜é‡
      if (!process.env.GEMINI_API_KEY) {
        console.warn('âš ï¸  æœªé…ç½® GEMINI_API_KEY ç¯å¢ƒå˜é‡');
        return false;
      }

      // åŸºæœ¬æ£€æŸ¥é€šè¿‡ï¼Œè®¤ä¸ºå¯ç”¨
      // å®é™…çš„ API è°ƒç”¨ä¼šåœ¨ execute ä¸­è¿›è¡Œ
      return true;
    } catch {
      return false;
    }
  }

  /**
   * æ‰§è¡Œä»»åŠ¡
   */
  async execute(
    prompt: string,
    config: TaskConfig,
    onChunk?: (chunk: string) => void
  ): Promise<ModelExecutionResult> {
    try {
      const { result, executionTime } = await this.measureExecutionTime(async () => {
        // æ ¹æ®ä»»åŠ¡ç±»å‹é€‰æ‹©åˆé€‚çš„æ¨¡å‹
        const model = this.selectModel(config.type);

        // æ„å»ºå‚æ•°æ•°ç»„
        const args = [
          prompt,                 // æç¤ºè¯ä½œä¸ºç¬¬ä¸€ä¸ªä½ç½®å‚æ•°
          '--model', model,
          '--output-format', 'json'  // ä½¿ç”¨ JSON æ ¼å¼è¾“å‡º
        ];

        const { stdout, stderr } = await this.runSpawnCommand(
          'gemini',
          args,
          config.expectedResponseTime || 60000,
          onChunk
        );

        // æ£€æŸ¥æ˜¯å¦æœ‰ API key é”™è¯¯
        if (stdout.includes('GEMINI_API_KEY') || stderr.includes('GEMINI_API_KEY')) {
          throw new Error('æœªé…ç½® GEMINI_API_KEY ç¯å¢ƒå˜é‡ã€‚è¯·è®¾ç½®åé‡è¯•ã€‚');
        }

        if (stderr && !stdout) {
          throw new Error(stderr);
        }

        // è§£æè¾“å‡º
        return this.parseGeminiOutput(stdout);
      });

      return this.createSuccessResult(result, executionTime, {
        model: this.selectModel(config.type),
        provider: this.provider,
      });
    } catch (error: any) {
      return this.createErrorResult(
        `Gemini CLI æ‰§è¡Œå¤±è´¥: ${error.message}`,
        0
      );
    }
  }

  /**
   * æ ¹æ®ä»»åŠ¡ç±»å‹é€‰æ‹©æ¨¡å‹
   */
  private selectModel(taskType: TaskType): string {
    switch (taskType) {
      case TaskType.CODE_GENERATION:
      case TaskType.CODE_REVIEW:
        return 'gemini-2.5-pro';
      case TaskType.CONVERSATION:
      case TaskType.GENERAL:
        return 'gemini-2.5-flash';
      default:
        return 'gemini-2.5-flash';
    }
  }

  /**
   * è§£æ Gemini CLI è¾“å‡º
   */
  private parseGeminiOutput(output: string): string {
    try {
      // Gemini CLI åœ¨ JSON æ¨¡å¼ä¸‹è¾“å‡ºç»“æ„åŒ–æ•°æ®
      const jsonContent = this.extractJsonContent(output);

      try {
        const parsed = JSON.parse(jsonContent);

        // Gemini CLI JSON è¾“å‡ºæ ¼å¼: { response: "...", ... }
        if (parsed.response) {
          return parsed.response;
        }

        // å¦‚æœæ²¡æœ‰ response å­—æ®µï¼Œå°è¯•å…¶ä»–å¯èƒ½çš„å­—æ®µ
        if (parsed.text) {
          return parsed.text;
        }

        if (parsed.content) {
          return parsed.content;
        }

        // å¦‚æœæ˜¯ Google API æ ¼å¼
        if (parsed.candidates?.[0]?.content?.parts?.[0]?.text) {
          return parsed.candidates[0].content.parts[0].text;
        }

        return jsonContent;
      } catch {
        // JSON è§£æå¤±è´¥ï¼Œç»§ç»­å¤„ç†
      }

      // å¦‚æœä¸æ˜¯ JSON æ ¼å¼ï¼Œç›´æ¥è¿”å›æ¸…ç†åçš„æ–‡æœ¬
      const lines = output.split('\n').filter(line => {
        const trimmed = line.trim();
        return trimmed.length > 0 &&
          !trimmed.startsWith('[') &&
          !trimmed.startsWith('WARNING') &&
          !trimmed.startsWith('Updates');
      });

      return lines.join('\n').trim();
    } catch {
      return output.trim();
    }
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/modelRouter/adapters/QwenAdapter.ts

````typescript
import { BaseAdapter } from '../BaseAdapter';
import { ModelCapabilities, TaskConfig, ModelExecutionResult, TaskType } from '../types';

/**
 * Qwen CLI é€‚é…å™¨
 * æ”¯æŒé€šä¹‰åƒé—®ç³»åˆ—æ¨¡å‹
 */
export class QwenAdapter extends BaseAdapter {
  name = 'qwen';
  version = '1.0.0';
  provider = 'Alibaba';

  capabilities: ModelCapabilities = {
    supportedTaskTypes: [
      TaskType.CODE_GENERATION,
      TaskType.CODE_REVIEW,
      TaskType.CONVERSATION,
      TaskType.TRANSLATION,
      TaskType.SUMMARIZATION,
      TaskType.ANALYSIS,
      TaskType.COMMAND_GENERATION,
      TaskType.DEBUG,
      TaskType.GENERAL,
    ],
    maxContextWindow: 32000,
    avgResponseTime: 1500,
    costLevel: 2,
    supportsStreaming: true,
    specialCapabilities: ['chinese-optimized', 'code-specialized'],
  };

  /**
   * å¥åº·æ£€æŸ¥ï¼šæ£€æŸ¥ qwen CLI æ˜¯å¦å®‰è£…
   */
  async healthCheck(): Promise<boolean> {
    try {
      await this.checkCommand('qwen');
      return true;
    } catch {
      return false;
    }
  }

  /**
   * æ‰§è¡Œä»»åŠ¡
   */
  async execute(
    prompt: string,
    config: TaskConfig,
    onChunk?: (chunk: string) => void
  ): Promise<ModelExecutionResult> {
    try {
      const { result, executionTime } = await this.measureExecutionTime(async () => {
        // æ ¹æ®ä»»åŠ¡ç±»å‹é€‰æ‹©æ¨¡å‹
        const model = this.selectModel(config.type);
        
        // æ„å»ºå¸¦ä¸Šä¸‹æ–‡çš„å®Œæ•´promptï¼ˆå¦‚æœé…ç½®ä¸­å¯ç”¨äº†ä¸Šä¸‹æ–‡ï¼‰
        const useContext = config.metadata?.useContext !== false;
        const fullPrompt = useContext ? this.buildPromptWithContext(prompt) : prompt;
        
        // æ„å»ºå‚æ•°æ•°ç»„ï¼Œprompt ä½œä¸ºä½ç½®å‚æ•°
        const args = [fullPrompt];
        
        // æ·»åŠ æ¨¡å‹å‚æ•°
        if (model) {
          args.push('-m', model);
        }

        // ä½¿ç”¨ spawn æ‰§è¡Œå‘½ä»¤
        const { stdout, stderr } = await this.runSpawnCommand(
          'qwen',
          args,
          config.expectedResponseTime || 30000,
          onChunk
        );

        if (stderr && !stdout) {
          throw new Error(stderr);
        }

        // è§£æè¾“å‡º
        const response = this.parseQwenOutput(stdout);
        
        // ä¿å­˜åˆ°ä¸Šä¸‹æ–‡
        if (useContext) {
          this.saveToContext(prompt, response);
        }
        
        return response;
      });

      return this.createSuccessResult(result, executionTime, {
        model: this.selectModel(config.type),
        provider: this.provider,
      });
    } catch (error: any) {
      return this.createErrorResult(
        `Qwen CLI æ‰§è¡Œå¤±è´¥: ${error.message}`,
        0
      );
    }
  }

  /**
   * æ ¹æ®ä»»åŠ¡ç±»å‹é€‰æ‹©æ¨¡å‹
   */
  private selectModel(taskType: TaskType): string {
    switch (taskType) {
      case TaskType.CODE_GENERATION:
      case TaskType.CODE_REVIEW:
        return 'qwen-coder-plus';
      case TaskType.CONVERSATION:
      case TaskType.TRANSLATION:
        return 'qwen-plus';
      case TaskType.COMMAND_GENERATION:
        return 'qwen-turbo';
      default:
        return 'qwen-plus';
    }
  }

  /**
   * è§£æ Qwen CLI è¾“å‡º
   */
  private parseQwenOutput(output: string): string {
    try {
      // æå– JSON å†…å®¹ï¼ˆå¤„ç† CLI å¹²æ‰°æ—¥å¿—ï¼‰
      const jsonContent = this.extractJsonContent(output);
      
      // å°è¯•è§£æ JSON æ ¼å¼
      const lines = jsonContent.split('\n');
      for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed.startsWith('{')) {
          try {
            const parsed = JSON.parse(trimmed);
            if (parsed.output?.text) {
              return parsed.output.text;
            }
            if (parsed.response) {
              return parsed.response;
            }
            if (parsed.content) {
              return parsed.content;
            }
          } catch {
            // ç»§ç»­å°è¯•ä¸‹ä¸€è¡Œ
          }
        }
      }
      
      // å¦‚æœä¸æ˜¯ JSONï¼Œè¿‡æ»¤æ‰å¯èƒ½çš„æ—¥å¿—è¡Œ
      const filteredLines = output.split('\n').filter(line => {
        const trimmed = line.trim();
        return trimmed.length > 0 && 
               !trimmed.startsWith('[INFO]') && 
               !trimmed.startsWith('[DEBUG]') &&
               !trimmed.startsWith('[WARN]') &&
               !trimmed.startsWith('Loading');
      });
      
      return filteredLines.join('\n').trim();
    } catch {
      return output.trim();
    }
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/modelRouter/config.ts

````typescript
import fs from 'fs';
import path from 'path';
import os from 'os';
import { RoutingStrategy, ExplorationStrategy } from './types';

/**
 * æ¨¡å‹è·¯ç”±é…ç½®æ–‡ä»¶
 */
export interface ModelRouterConfig {
  /** é»˜è®¤è·¯ç”±ç­–ç•¥ */
  defaultStrategy: RoutingStrategy;

  /** æœ€å¤§å“åº”æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ */
  maxResponseTime?: number;

  /** æœ€å¤§æˆæœ¬ç­‰çº§ */
  maxCostLevel?: number;

  /** æ˜¯å¦å¯ç”¨åå¤‡æ¨¡å‹ */
  enableFallback: boolean;

  /** å¯ç”¨çš„é€‚é…å™¨åˆ—è¡¨ */
  enabledAdapters: string[];

  /** ä»»åŠ¡ç±»å‹åˆ°æ¨¡å‹çš„æ˜ å°„ï¼ˆå¯é€‰ï¼‰ */
  taskTypeMapping?: Record<string, string>;

  /** é€‚é…å™¨é…ç½® */
  adapterConfigs?: Record<string, any>;

  /** æ¢ç´¢é…ç½® */
  exploration?: {
    strategy: ExplorationStrategy | string;
    epsilon?: number;
  };
}

const DEFAULT_CONFIG: ModelRouterConfig = {
  defaultStrategy: RoutingStrategy.AUTO,
  maxResponseTime: 30000,
  maxCostLevel: 5,
  enableFallback: true,
  enabledAdapters: ['google-gemini', 'qwen', 'codebuddy'],
  taskTypeMapping: {},
  adapterConfigs: {},
  exploration: {
    strategy: 'none',
    epsilon: 0.1
  }
};

const CONFIG_FILE = path.join(os.homedir(), '.yuangs-router.json');

/**
 * åŠ è½½é…ç½®
 */
export function loadConfig(): ModelRouterConfig {
  try {
    if (fs.existsSync(CONFIG_FILE)) {
      const content = fs.readFileSync(CONFIG_FILE, 'utf8');
      const config = JSON.parse(content);
      return { ...DEFAULT_CONFIG, ...config };
    }
  } catch (error) {
    console.warn('åŠ è½½è·¯ç”±é…ç½®å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤é…ç½®:', error);
  }
  return DEFAULT_CONFIG;
}

/**
 * ä¿å­˜é…ç½®
 */
export function saveConfig(config: Partial<ModelRouterConfig>): void {
  try {
    const currentConfig = loadConfig();
    const newConfig = { ...currentConfig, ...config };
    fs.writeFileSync(CONFIG_FILE, JSON.stringify(newConfig, null, 2), 'utf8');
  } catch (error) {
    throw new Error(`ä¿å­˜è·¯ç”±é…ç½®å¤±è´¥: ${error}`);
  }
}

/**
 * é‡ç½®é…ç½®ä¸ºé»˜è®¤å€¼
 */
export function resetConfig(): void {
  try {
    fs.writeFileSync(CONFIG_FILE, JSON.stringify(DEFAULT_CONFIG, null, 2), 'utf8');
  } catch (error) {
    throw new Error(`é‡ç½®è·¯ç”±é…ç½®å¤±è´¥: ${error}`);
  }
}

/**
 * è·å–é…ç½®æ–‡ä»¶è·¯å¾„
 */
export function getConfigPath(): string {
  return CONFIG_FILE;
}

/**
 * æ›´æ–°å•ä¸ªé…ç½®é¡¹
 */
export function updateConfigItem(key: keyof ModelRouterConfig, value: any): void {
  const config = loadConfig();
  (config as any)[key] = value;
  saveConfig(config);
}

/**
 * æ·»åŠ å¯ç”¨çš„é€‚é…å™¨
 */
export function addEnabledAdapter(adapterName: string): void {
  const config = loadConfig();
  if (!config.enabledAdapters.includes(adapterName)) {
    config.enabledAdapters.push(adapterName);
    saveConfig(config);
  }
}

/**
 * ç§»é™¤å¯ç”¨çš„é€‚é…å™¨
 */
export function removeEnabledAdapter(adapterName: string): void {
  const config = loadConfig();
  config.enabledAdapters = config.enabledAdapters.filter((name) => name !== adapterName);
  saveConfig(config);
}

/**
 * è®¾ç½®ä»»åŠ¡ç±»å‹æ˜ å°„
 */
export function setTaskTypeMapping(taskType: string, modelName: string): void {
  const config = loadConfig();
  if (!config.taskTypeMapping) {
    config.taskTypeMapping = {};
  }
  config.taskTypeMapping[taskType] = modelName;
  saveConfig(config);
}

/**
 * ç§»é™¤ä»»åŠ¡ç±»å‹æ˜ å°„
 */
export function removeTaskTypeMapping(taskType: string): void {
  const config = loadConfig();
  if (config.taskTypeMapping) {
    delete config.taskTypeMapping[taskType];
    saveConfig(config);
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/modelRouter/index.ts

````typescript
/**
 * æ¨¡å‹è·¯ç”±ç³»ç»Ÿ
 * 
 * è¿™ä¸ªæ¨¡å—æä¾›äº†ä¸€ä¸ªç»Ÿä¸€çš„æ¥å£æ¥æ•´åˆå¤šä¸ª AI CLI å·¥å…·ï¼Œ
 * æ ¹æ®ä»»åŠ¡ç‰¹æ€§æ™ºèƒ½è·¯ç”±åˆ°æœ€åˆé€‚çš„æ¨¡å‹æ‰§è¡Œã€‚
 * 
 * ä¸»è¦ç‰¹æ€§ï¼š
 * 1. æ”¯æŒå¤šç§è·¯ç”±ç­–ç•¥ï¼ˆè‡ªåŠ¨ã€è½®è¯¢ã€æœ€å¿«ä¼˜å…ˆç­‰ï¼‰
 * 2. å¯æ‰©å±•çš„é€‚é…å™¨ç³»ç»Ÿ
 * 3. ä»»åŠ¡æ‰§è¡Œç»Ÿè®¡å’Œç›‘æ§
 * 4. çµæ´»çš„é…ç½®ç®¡ç†
 * 
 * @example
 * ```typescript
 * import { createRouter, TaskType, RoutingStrategy } from './modelRouter';
 * 
 * const router = createRouter();
 * 
 * const result = await router.executeTask({
 *   type: TaskType.CODE_GENERATION,
 *   description: 'ç”Ÿæˆä¸€ä¸ªå¿«é€Ÿæ’åºå‡½æ•°',
 * }, {
 *   strategy: RoutingStrategy.AUTO,
 * });
 * 
 * console.log(result.content);
 * ```
 */

export * from './types';
export * from './BaseAdapter';
export * from './ModelRouter';
export * from './config';
export * from './ContextManager';

// å¯¼å‡ºé€‚é…å™¨
export { GoogleAdapter } from './adapters/GoogleAdapter';
export { QwenAdapter } from './adapters/QwenAdapter';
export { CodebuddyAdapter } from './adapters/CodebuddyAdapter';

import { ModelRouter } from './ModelRouter';
import { GoogleAdapter } from './adapters/GoogleAdapter';
import { QwenAdapter } from './adapters/QwenAdapter';
import { CodebuddyAdapter } from './adapters/CodebuddyAdapter';
import { loadConfig } from './config';
import {
  TaskConfig,
  RoutingConfig,
  RoutingStrategy,
  ModelExecutionResult,
} from './types';

let globalRouter: ModelRouter | null = null;

/**
 * åˆ›å»ºå¹¶åˆå§‹åŒ–ä¸€ä¸ªæ¨¡å‹è·¯ç”±å™¨
 */
export function createRouter(): ModelRouter {
  const router = new ModelRouter();
  const config = loadConfig();

  // æ³¨å†Œå¯ç”¨çš„é€‚é…å™¨
  if (config.enabledAdapters.includes('google-gemini')) {
    router.registerAdapter(new GoogleAdapter());
  }

  if (config.enabledAdapters.includes('qwen')) {
    router.registerAdapter(new QwenAdapter());
  }

  if (config.enabledAdapters.includes('codebuddy')) {
    router.registerAdapter(new CodebuddyAdapter());
  }

  return router;
}

/**
 * è·å–å…¨å±€è·¯ç”±å™¨å®ä¾‹ï¼ˆå•ä¾‹ï¼‰
 */
export function getRouter(): ModelRouter {
  if (!globalRouter) {
    globalRouter = createRouter();
  }
  return globalRouter;
}

/**
 * é‡ç½®å…¨å±€è·¯ç”±å™¨
 */
export function resetRouter(): void {
  globalRouter = null;
}

/**
 * å¿«æ·å‡½æ•°ï¼šæ‰§è¡Œä»»åŠ¡
 */
export async function executeTask(
  prompt: string,
  taskConfig: TaskConfig,
  routingConfig?: Partial<RoutingConfig>,
  onChunk?: (chunk: string) => void
): Promise<ModelExecutionResult> {
  const router = getRouter();
  const config = loadConfig();

  // åˆå¹¶é…ç½®
  const finalRoutingConfig: RoutingConfig = {
    strategy: config.defaultStrategy,
    maxResponseTime: config.maxResponseTime,
    maxCostLevel: config.maxCostLevel,
    enableFallback: config.enableFallback,
    ...routingConfig,
  };

  // æ£€æŸ¥æ˜¯å¦æœ‰ä»»åŠ¡ç±»å‹æ˜ å°„
  if (config.taskTypeMapping && config.taskTypeMapping[taskConfig.type]) {
    finalRoutingConfig.strategy = RoutingStrategy.MANUAL;
    finalRoutingConfig.manualModelName = config.taskTypeMapping[taskConfig.type];
  }

  // è·¯ç”±åˆ°åˆé€‚çš„æ¨¡å‹
  const routingResult = await router.route(taskConfig, finalRoutingConfig);

  console.log(`ğŸ¤– ä½¿ç”¨æ¨¡å‹: ${routingResult.adapter.name}`);
  console.log(`ğŸ“‹ åŸå› : ${routingResult.reason}`);

  // æ‰§è¡Œä»»åŠ¡
  return router.executeTask(routingResult.adapter, prompt, taskConfig, onChunk);
}

/**
 * å¿«æ·å‡½æ•°ï¼šè·å–æ‰€æœ‰é€‚é…å™¨çš„ç»Ÿè®¡ä¿¡æ¯
 */
export function getStats() {
  const router = getRouter();
  return router.getStats();
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/modelRouter/policies/BasePolicy.ts

````typescript
import { ModelAdapter, TaskConfig, RoutingConfig, ModelStats, DomainHealth } from '../types';
import { RoutingPolicy, PolicyResult, ScoredCandidate } from './types';

export abstract class BasePolicy implements RoutingPolicy {
    abstract name: string;
    abstract description: string;

    async select(
        adapters: ModelAdapter[],
        taskConfig: TaskConfig,
        routingConfig: RoutingConfig,
        modelStats: Map<string, ModelStats>,
        domainHealth: Map<string, DomainHealth>
    ): Promise<PolicyResult> {
        // 1. Gate (Filter) - ç¡¬çº¦æŸ (åŒ…å«æ•…éšœåŸŸéš”ç¦»)
        const candidates = await this.gate(adapters, taskConfig, modelStats, domainHealth);

        if (candidates.length === 0) {
            throw new Error('æ²¡æœ‰å¯ç”¨çš„æ¨¡å‹ï¼ˆå·²è¢« Gate è¿‡æ»¤ï¼Œå¯èƒ½è§¦å‘äº†æ•…éšœåŸŸä¿æŠ¤ï¼‰');
        }

        // 2. Score (Sort) - è½¯æ’åº
        const scoredCandidates = this.score(candidates, taskConfig, routingConfig, modelStats);

        if (scoredCandidates.length === 0) {
            throw new Error('è¯„åˆ†åæ²¡æœ‰åˆé€‚çš„æ¨¡å‹');
        }

        // æŒ‰åˆ†æ•°é™åºæ’åº
        scoredCandidates.sort((a, b) => b.score - a.score);

        const selected = scoredCandidates[0];

        return {
            adapter: selected.adapter,
            reason: selected.reason,
            candidates: scoredCandidates.map((c) => ({
                name: c.adapter.name,
                score: c.score,
                reason: c.reason,
            })),
        };
    }

    /**
     * Gate é˜¶æ®µï¼šè¿‡æ»¤æ‰ä¸ç¬¦åˆç¡¬æ€§è¦æ±‚çš„æ¨¡å‹ï¼ŒåŒ…å«æ•…éšœåŸŸè¯†åˆ«
     */
    protected async gate(
        adapters: ModelAdapter[],
        task: TaskConfig,
        modelStats: Map<string, ModelStats>,
        domainHealthMap: Map<string, DomainHealth>
    ): Promise<ModelAdapter[]> {
        const passedAdapters: ModelAdapter[] = [];

        // å¹¶è¡Œæ£€æŸ¥å¯ç”¨æ€§
        const availabilityResults = await Promise.all(
            adapters.map(async (adapter) => ({
                adapter,
                available: await adapter.isAvailable(),
            }))
        );

        for (const { adapter, available } of availabilityResults) {
            if (!available) continue;

            const domain = adapter.failureDomain ?? adapter.provider;
            const health = domainHealthMap.get(domain);

            // ç†”æ–­ä¿æŠ¤è¿‡æ»¤
            if (health) {
                if (health.state === 'open') continue;
                if (health.state === 'half-open') {
                    // Half-open ä»…å…è®¸ 10% æ¢æµ‹æµé‡é€šè¿‡ Gate
                    if (Math.random() >= 0.1) continue;
                }
            }

            // æ£€æŸ¥ä¸Šä¸‹æ–‡çª—å£
            if (task.contextSize && adapter.capabilities.maxContextWindow < task.contextSize) {
                continue;
            }

            // æ£€æŸ¥ä»»åŠ¡ç±»å‹æ”¯æŒ
            if (!adapter.capabilities.supportedTaskTypes.includes(task.type)) {
                continue;
            }

            passedAdapters.push(adapter);
        }

        return passedAdapters;
    }

    /**
     * Score é˜¶æ®µï¼šå¯¹é€šè¿‡ Gate çš„æ¨¡å‹è¿›è¡Œæ‰“åˆ†
     */
    protected abstract score(
        adapters: ModelAdapter[],
        task: TaskConfig,
        config: RoutingConfig,
        modelStats: Map<string, ModelStats>
    ): ScoredCandidate[];
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/modelRouter/policies/DslPolicy.ts

````typescript
import { ModelAdapter, TaskConfig, RoutingConfig, ModelStats, DomainHealth, PolicyDsl, TaskType } from '../types';
import { BasePolicy } from './BasePolicy';
import { ScoredCandidate } from './types';

/**
 * é€šç”¨ DSL é©±åŠ¨ç­–ç•¥
 * é€šè¿‡é…ç½®æƒé‡å’Œ Gate è§„åˆ™æ¥å®šä¹‰è·¯ç”±è¡Œä¸º
 */
export class DslPolicy extends BasePolicy {
    constructor(private dsl: PolicyDsl) {
        super();
    }

    get name() { return this.dsl.name; }
    get description() { return this.dsl.description; }

    /**
     * å®ç° DSL é©±åŠ¨çš„ Gate è¿‡æ»¤
     */
    protected async gate(
        adapters: ModelAdapter[],
        task: TaskConfig,
        modelStats: Map<string, ModelStats>,
        domainHealthMap: Map<string, DomainHealth>
    ): Promise<ModelAdapter[]> {
        // å…ˆè°ƒç”¨åŸºç±»çš„é€šç”¨è¿‡æ»¤ (TaskType, ContextSize, FailureDomain)
        let filtered = await super.gate(adapters, task, modelStats, domainHealthMap);

        const gateConfig = this.dsl.gate;
        if (!gateConfig) return filtered;

        return filtered.filter(adapter => {
            // 1. æœ€å°ä¸Šä¸‹æ–‡é˜ˆå€¼
            if (gateConfig.minContext && adapter.capabilities.maxContextWindow < gateConfig.minContext) {
                return false;
            }

            // 2. æµå¼è¾“å‡ºè¦æ±‚
            if (gateConfig.requireStreaming && !adapter.capabilities.supportsStreaming) {
                return false;
            }

            // 3. ç‰¹æ®Šèƒ½åŠ›è¦æ±‚
            if (gateConfig.requiredCapabilities) {
                const hasAll = gateConfig.requiredCapabilities.every(req =>
                    adapter.capabilities.specialCapabilities?.includes(req)
                );
                if (!hasAll) return false;
            }

            return true;
        });
    }

    /**
     * å®ç° DSL é©±åŠ¨çš„åŠ æƒè¯„åˆ†
     */
    protected score(
        adapters: ModelAdapter[],
        task: TaskConfig,
        config: RoutingConfig,
        modelStats: Map<string, ModelStats>
    ): ScoredCandidate[] {
        const weights = this.dsl.weights;

        return adapters.map(adapter => {
            let totalScore = 0;
            let reasons: string[] = [];

            // 1. ä»»åŠ¡åŒ¹é…åº¦ (Task Match)
            if (weights.taskMatch) {
                const isSupported = adapter.capabilities.supportedTaskTypes.includes(task.type);
                const score = isSupported ? 1.0 : 0.0;
                totalScore += score * weights.taskMatch;
                if (isSupported) reasons.push('ä»»åŠ¡ç±»å‹åŒ¹é…');
            }

            // 2. ä¸Šä¸‹æ–‡å¯Œä½™åº¦ (Context Capacity)
            if (weights.context) {
                const requested = task.contextSize || 0;
                const ratio = Math.min(adapter.capabilities.maxContextWindow / Math.max(requested * 2, 8000), 1.0);
                totalScore += ratio * weights.context;
                if (ratio > 0.8) reasons.push('ä¸Šä¸‹æ–‡èµ„æºå……è¶³');
            }

            // 3. å»¶è¿Ÿæ€§èƒ½ (Latency)
            if (weights.latency) {
                // å½’ä¸€åŒ–å»¶è¿Ÿ: < 1s ä¸º 1.0, > 10s ä¸º 0.0
                const latency = adapter.capabilities.avgResponseTime;
                const score = Math.max(0, 1 - (latency / 10000));
                totalScore += score * weights.latency;
                if (score > 0.8) reasons.push('å“åº”é€Ÿåº¦å¿«');
            }

            // 4. æˆæœ¬æ•ˆç›Š (Cost)
            if (weights.cost) {
                // ç­‰çº§ 1(æœ€å»‰ä»·) -> 1.0, ç­‰çº§ 5(æœ€æ˜‚è´µ) -> 0.2
                const score = (6 - adapter.capabilities.costLevel) * 0.2;
                totalScore += score * weights.cost;
                if (score > 0.7) reasons.push('æ€§ä»·æ¯”é«˜');
            }

            // 5. å†å²æˆåŠŸç‡ (History Performance)
            if (weights.history) {
                const stats = modelStats.get(adapter.name);
                let score = 0.5; // æ–°æ¨¡å‹é»˜è®¤ä¸­ç­‰
                if (stats && stats.totalRequests > 0) {
                    score = stats.successCount / stats.totalRequests;
                }
                totalScore += score * weights.history;
                if (score > 0.9) reasons.push('å†å²è¡¨ç°éå¸¸ç¨³å®š');
            }

            // 6. è´¨é‡ä¸“å®¶ (Quality/Expert)
            if (weights.quality) {
                let score = 0.5;
                const isSpecialist = (
                    (task.type === TaskType.CODE_GENERATION || task.type === TaskType.DEBUG) &&
                    adapter.capabilities.specialCapabilities?.includes('code-expert')
                );
                if (isSpecialist) score = 1.0;
                totalScore += score * weights.quality;
                if (isSpecialist) reasons.push('é¢†åŸŸä¸“å®¶æ¨¡å‹');
            }

            return {
                adapter,
                score: totalScore,
                reason: reasons.length > 0 ? reasons.join('; ') : 'è¯„åˆ†ç¬¦åˆé¢„æœŸ'
            };
        });
    }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/modelRouter/policies/types.ts

````typescript
import { ModelAdapter, TaskConfig, RoutingConfig, ModelStats, DomainHealth } from '../types';

export interface ScoredCandidate {
    adapter: ModelAdapter;
    score: number;
    reason: string;
}

export interface PolicyResult {
    adapter: ModelAdapter;
    reason: string;
    candidates: Array<{ name: string; score: number; reason: string }>;
}

export interface RoutingPolicy {
    name: string;
    description: string;
    select(
        adapters: ModelAdapter[],
        taskConfig: TaskConfig,
        routingConfig: RoutingConfig,
        modelStats: Map<string, ModelStats>,
        domainHealth: Map<string, DomainHealth>
    ): Promise<PolicyResult>;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/modelRouter/types.ts

````typescript
/**
 * æ¨¡å‹è·¯ç”±ç³»ç»Ÿç±»å‹å®šä¹‰
 * 
 * è¯¥ç³»ç»Ÿå…è®¸æ•´åˆå¤šä¸ª CLI å·¥å…·ï¼ˆå¦‚ Google CLIã€Qwen CLIã€Codebuddy CLI ç­‰ï¼‰
 * æ ¹æ®ä»»åŠ¡ç‰¹æ€§å’Œéœ€æ±‚ï¼Œæ™ºèƒ½è·¯ç”±åˆ°æœ€åˆé€‚çš„æ¨¡å‹æ‰§è¡Œ
 */

/**
 * ä»»åŠ¡ç±»å‹
 */
export enum TaskType {
  CODE_GENERATION = 'code_generation',    // ä»£ç ç”Ÿæˆ
  CODE_REVIEW = 'code_review',            // ä»£ç å®¡æŸ¥
  CONVERSATION = 'conversation',          // å¯¹è¯
  TRANSLATION = 'translation',            // ç¿»è¯‘
  SUMMARIZATION = 'summarization',        // æ‘˜è¦
  ANALYSIS = 'analysis',                  // åˆ†æ
  COMMAND_GENERATION = 'command_generation', // å‘½ä»¤ç”Ÿæˆ
  DEBUG = 'debug',                        // è°ƒè¯•
  GENERAL = 'general'                     // é€šç”¨
}

/**
 * ä»»åŠ¡ä¼˜å…ˆçº§
 */
export enum Priority {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical'
}

/**
 * ä»»åŠ¡é…ç½®
 */
export interface TaskConfig {
  /** ä»»åŠ¡ç±»å‹ */
  type: TaskType;
  /** ä»»åŠ¡æè¿° */
  description: string;
  /** ä¼˜å…ˆçº§ */
  priority?: Priority;
  /** æœŸæœ›çš„å“åº”æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ */
  expectedResponseTime?: number;
  /** ä¸Šä¸‹æ–‡å¤§å°ä¼°è®¡ */
  contextSize?: number;
  /** é¢å¤–çš„å…ƒæ•°æ® */
  metadata?: Record<string, any>;
}

/**
 * æ¨¡å‹èƒ½åŠ›
 */
export interface ModelCapabilities {
  /** æ”¯æŒçš„ä»»åŠ¡ç±»å‹ */
  supportedTaskTypes: TaskType[];
  /** æœ€å¤§ä¸Šä¸‹æ–‡çª—å£ */
  maxContextWindow: number;
  /** å¹³å‡å“åº”æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ */
  avgResponseTime: number;
  /** æˆæœ¬ç­‰çº§ï¼ˆ1-5ï¼Œ5æœ€è´µï¼‰ */
  costLevel: number;
  /** æ˜¯å¦æ”¯æŒæµå¼è¾“å‡º */
  supportsStreaming: boolean;
  /** ç‰¹æ®Šèƒ½åŠ› */
  specialCapabilities?: string[];
}

/**
 * æ¨¡å‹æ‰§è¡Œç»“æœ
 */
export interface ModelExecutionResult {
  /** æ¨¡å‹åç§° */
  modelName: string;
  /** æ‰§è¡Œæ˜¯å¦æˆåŠŸ */
  success: boolean;
  /** å“åº”å†…å®¹ */
  content?: string;
  /** é”™è¯¯ä¿¡æ¯ */
  error?: string;
  /** æ‰§è¡Œæ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ */
  executionTime: number;
  /** ä½¿ç”¨çš„ tokens */
  tokensUsed?: number;
  /** é¢å¤–çš„å…ƒæ•°æ® */
  metadata?: Record<string, any>;
}

/**
 * æ¨¡å‹é€‚é…å™¨æ¥å£
 * æ‰€æœ‰å¤–éƒ¨ CLI å·¥å…·éƒ½éœ€è¦å®ç°è¿™ä¸ªæ¥å£
 */
export interface ModelAdapter {
  /** é€‚é…å™¨åç§° */
  name: string;

  /** é€‚é…å™¨ç‰ˆæœ¬ */
  version: string;

  /** æä¾›è€…ï¼ˆå¦‚ Googleã€Qwenã€Codebuddy ç­‰ï¼‰ */
  provider: string;

  /** æ¨¡å‹èƒ½åŠ›æè¿° */
  capabilities: ModelCapabilities;

  /** æ•…éšœåŸŸï¼ˆå¯é€‰ï¼Œå¦‚ 'google', 'alibaba'ï¼Œç¼ºçœåˆ™ä½¿ç”¨ providerï¼‰ */
  failureDomain?: string;

  /** æ˜¯å¦å¯ç”¨ */
  isAvailable(): Promise<boolean>;

  /** æ‰§è¡Œä»»åŠ¡ */
  execute(
    prompt: string,
    config: TaskConfig,
    onChunk?: (chunk: string) => void
  ): Promise<ModelExecutionResult>;

  /** å¥åº·æ£€æŸ¥ */
  healthCheck(): Promise<boolean>;
}

/**
 * è·¯ç”±ç­–ç•¥
 */
export enum RoutingStrategy {
  /** è‡ªåŠ¨é€‰æ‹©ï¼ˆåŸºäºä»»åŠ¡ç±»å‹å’Œæ¨¡å‹èƒ½åŠ›ï¼‰ */
  AUTO = 'auto',
  /** è½®è¯¢ */
  ROUND_ROBIN = 'round_robin',
  /** æœ€å¿«å“åº”ä¼˜å…ˆ */
  FASTEST_FIRST = 'fastest_first',
  /** æœ€ä½æˆæœ¬ä¼˜å…ˆ */
  CHEAPEST_FIRST = 'cheapest_first',
  /** æœ€ä½³è´¨é‡ä¼˜å…ˆ */
  BEST_QUALITY = 'best_quality',
  /** æ‰‹åŠ¨æŒ‡å®š */
  MANUAL = 'manual'
}

/**
 * æ¢ç´¢ç­–ç•¥
 */
export enum ExplorationStrategy {
  NONE = 'none',
  EPSILON_GREEDY = 'epsilon_greedy',
  UCB1 = 'ucb1'
}

/**
 * è·¯ç”±é…ç½®
 */
export interface RoutingConfig {
  /** è·¯ç”±ç­–ç•¥ */
  strategy: RoutingStrategy;
  /** æ‰‹åŠ¨æŒ‡å®šçš„æ¨¡å‹åç§°ï¼ˆä»…å½“ strategy ä¸º MANUAL æ—¶æœ‰æ•ˆï¼‰ */
  manualModelName?: string;
  /** å…è®¸çš„æœ€å¤§å“åº”æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ */
  maxResponseTime?: number;
  /** å…è®¸çš„æœ€å¤§æˆæœ¬ç­‰çº§ */
  maxCostLevel?: number;
  /** æ˜¯å¦å¯ç”¨åå¤‡æ¨¡å‹ */
  enableFallback?: boolean;
  /** åå¤‡æ¨¡å‹åˆ—è¡¨ */
  fallbackModels?: string[];
  /** æ¢ç´¢é…ç½® (Îµ-greedy / UCB1) */
  exploration?: {
    /** æ¢ç´¢ç­–ç•¥ */
    strategy?: ExplorationStrategy;
    /** æ¢ç´¢æ¦‚ç‡ (ä»…ç”¨äº epsilon_greedy) */
    epsilon?: number;
  };
}

/**
 * è·¯ç”±ç»“æœ
 */
export interface RoutingResult {
  /** é€‰ä¸­çš„æ¨¡å‹é€‚é…å™¨ */
  adapter: ModelAdapter;
  /** é€‰æ‹©åŸå›  */
  reason: string;
  /** å€™é€‰æ¨¡å‹åˆ—è¡¨ */
  candidates: Array<{
    name: string;
    score: number;
    reason: string;
  }>;
  /** æ˜¯å¦ä½¿ç”¨äº†åå¤‡æ¨¡å‹ */
  isFallback: boolean;
}

/**
 * æ¨¡å‹ç»Ÿè®¡ä¿¡æ¯
 */
export interface ModelStats {
  /** æ¨¡å‹åç§° */
  modelName: string;
  /** æ€»è¯·æ±‚æ¬¡æ•° */
  totalRequests: number;
  /** æˆåŠŸæ¬¡æ•° */
  successCount: number;
  /** å¤±è´¥æ¬¡æ•° */
  failureCount: number;
  /** å¹³å‡å“åº”æ—¶é—´ */
  avgResponseTime: number;
  /** æ€» tokens ä½¿ç”¨é‡ */
  totalTokens: number;
  /** æœ€åä½¿ç”¨æ—¶é—´ */
  lastUsed: Date;
  /** æœ€åä¸€æ¬¡å¤±è´¥æ—¶é—´ */
  lastFailureAt?: Date;
  /** æœ€è¿‘è¿ç»­å¤±è´¥æ¬¡æ•° */
  recentFailures: number;

  /** æŒ‡æ•°ç§»åŠ¨å¹³å‡ (EMA) æˆåŠŸç‡ (0.0 - 1.0) */
  successEMA: number;
  /** æŒ‡æ•°ç§»åŠ¨å¹³å‡ (EMA) å»¶è¿Ÿ (ms) */
  latencyEMA: number;
  /** æŒ‡æ•°ç§»åŠ¨å¹³å‡ (EMA) æˆæœ¬ (ç­‰çº§ 1-5) */
  costEMA: number;
}

/**
 * æ•…éšœåŸŸçŠ¶æ€ (ç†”æ–­å™¨)
 */
export type DomainState = 'closed' | 'open' | 'half-open';

/**
 * æ•…éšœåŸŸç›‘æ§çŠ¶æ€
 */
export interface DomainHealth {
  state: DomainState;
  openedAt?: number;
  lastProbeAt?: number;
}

/**
 * å¯¹è¯æ¶ˆæ¯
 */
export interface Message {
  /** è§’è‰²ï¼šuser æˆ– assistant */
  role: 'user' | 'assistant';
  /** æ¶ˆæ¯å†…å®¹ */
  content: string;
  /** æ—¶é—´æˆ³ */
  timestamp: Date;
}

/**
 * å¯¹è¯ä¸Šä¸‹æ–‡
 */
export interface ConversationContext {
  /** ä¼šè¯ID */
  sessionId: string;
  /** æ¶ˆæ¯å†å² */
  messages: Message[];
  /** æœ€å¤§å†å²æ¶ˆæ¯æ•° */
  maxMessages?: number;
  /** æœ€å¤§tokenæ•°ï¼ˆä¼°ç®—ï¼‰ */
  maxTokens?: number;
}

/**
 * ç­–ç•¥æƒé‡é…ç½® (DSL)
 */
export interface PolicyWeights {
  taskMatch?: number;
  context?: number;
  latency?: number;
  cost?: number;
  history?: number;
  quality?: number;
}

/**
 * ç­–ç•¥å®šä¹‰ (DSL)
 */
export interface PolicyDsl {
  name: string;
  description: string;
  gate?: {
    minContext?: number;
    requireStreaming?: boolean;
    requiredCapabilities?: string[];
  };
  weights: PolicyWeights;
}

/**
 * ç›‘ç£å™¨è§¦å‘æ¡ä»¶ (Trigger)
 */
export interface SupervisorTrigger {
  id: string;
  metric: 'global_latency' | 'global_success_rate' | 'google_domain_error';
  operator: '>' | '<' | '>=' | '<=';
  threshold: number;
  action: {
    type: 'switch_strategy';
    targetStrategy: RoutingStrategy;
  };
}

/**
 * ç›‘ç£å™¨é…ç½®
 */
export interface SupervisorConfig {
  enabled: boolean;
  triggers: SupervisorTrigger[];
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/observability/SupervisorActionLog.ts

````typescript
import { RoutingStrategy } from '../modelRouter/types';

/**
 * ç›‘ç£å™¨æ‰§è¡ŒåŠ¨ä½œ
 */
export interface SupervisorAction {
    type: 'switch_strategy';
    targetStrategy: RoutingStrategy;
    reason: string;
}

/**
 * ç›£ç£å™¨æ‰§è¡Œæ—¥å¿— schema
 * 
 * ç”¨äº 100% è¿˜åŸå†³ç­–ç°åœºï¼Œæ”¯æŒç¦»çº¿å›æ”¾ (Incident Replay)
 */
export interface SupervisorActionLog {
    /** å”¯ä¸€äº‹ä»¶ ID */
    eventId: string;

    /** äº‹ä»¶å‘ç”Ÿæ—¶é—´ */
    timestamp: number;

    /** è§¦å‘çš„ action */
    action: SupervisorAction;

    /** æ‰§è¡Œå‰åçš„ç­–ç•¥ */
    previousStrategy: RoutingStrategy;
    currentStrategy: RoutingStrategy;

    /** è§¦å‘æ—¶çš„å…³é”®æŒ‡æ ‡å¿«ç…§ */
    snapshot: {
        globalLatencyEMA: number;
        globalSuccessRateEMA: number;
        domainHealth: Record<
            string,
            {
                state: string;
                successEMA?: number;
                latencyEMA?: number;
            }
        >;
    };
}

/**
 * ç›‘ç£å™¨æ—¥å¿—è®°å½•å™¨æ¥å£
 */
export interface SupervisorActionLogger {
    log(event: SupervisorActionLog): void;
}

/**
 * æ§åˆ¶å°æ—¥å¿—è®°å½•å™¨å®ç°
 */
export class ConsoleSupervisorActionLogger implements SupervisorActionLogger {
    log(event: SupervisorActionLog) {
        // ç”Ÿäº§ç¯å¢ƒä¸‹å¯å¯¹æ¥ ELK / Sentry / OTEL
        console.log(chalk.bold.magenta('\nğŸ“¡ [Supervisor Event Recorded]'));
        console.log(JSON.stringify(event, null, 2));
    }
}

import chalk from 'chalk';

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/os.ts

````typescript
export type OSProfile = {
    name: string;
    shell: string;
    find: 'bsd' | 'gnu';
    stat: 'bsd' | 'gnu';
};

export function getOSProfile(): OSProfile {
    switch (process.platform) {
        case 'darwin':
            return {
                name: 'macOS',
                shell: 'zsh',
                find: 'bsd',
                stat: 'bsd',
            };
        case 'linux':
            return {
                name: 'Linux',
                shell: 'bash',
                find: 'gnu',
                stat: 'gnu',
            };
        case 'win32':
            return {
                name: 'Windows',
                shell: 'cmd',
                find: 'gnu', // Win32 find is different, but for AI context let's assume GNU style tools if they are there, or just label it.
                stat: 'gnu',
            };
        default:
            return {
                name: process.platform,
                shell: 'sh',
                find: 'gnu',
                stat: 'gnu',
            };
    }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/replayDiff.ts

````typescript
import { ExecutionRecord } from './executionRecord';
import { computeSkillScore } from '../agent/skills';

export interface ReplayDiffResult {
  decisionDiff: DecisionDiff;
  modelDiff: ModelDiff;
  skillsDiff: SkillsDiff;
}

interface DecisionDiff {
  changed: boolean;
  strategyChanged: boolean;
  modelChanged: boolean;
  reasonChanged: boolean;
  before?: {
    strategy: string;
    selectedModel: string;
    reason: string;
  };
  after?: {
    strategy: string;
    selectedModel: string;
    reason: string;
  };
}

interface ModelDiff {
  changed: boolean;
  nameChanged: boolean;
  providerChanged: boolean;
  before?: {
    name: string;
    provider: string;
    contextWindow: number | string;
    costProfile: string;
  };
  after?: {
    name: string;
    provider: string;
    contextWindow: number | string;
    costProfile: string;
  };
}

interface SkillsDiff {
  added: SkillChange[];
  removed: SkillChange[];
  changed: SkillChange[];
}

interface SkillChange {
  name: string;
  score?: number;
  enabled?: boolean;
  confidence?: number;
  successRate?: number;
  lastUsed?: string;
}

export function diffExecution(
  original: ExecutionRecord,
  current: ExecutionRecord
): ReplayDiffResult {
  return {
    decisionDiff: diffDecision(original, current),
    modelDiff: diffModel(original, current),
    skillsDiff: diffSkills(original, current),
  };
}

function diffDecision(original: ExecutionRecord, current: ExecutionRecord): DecisionDiff {
  const origDecision = original.decision;
  const currDecision = current.decision;

  const strategyChanged = origDecision?.strategy !== currDecision?.strategy;
  const modelChanged = origDecision?.selectedModel?.name !== currDecision?.selectedModel?.name;
  const reasonChanged = origDecision?.reason !== currDecision?.reason;

  return {
    changed: strategyChanged || modelChanged || reasonChanged,
    strategyChanged,
    modelChanged,
    reasonChanged,
    before: {
      strategy: origDecision?.strategy ?? 'N/A',
      selectedModel: origDecision?.selectedModel?.name ?? 'N/A',
      reason: origDecision?.reason ?? 'N/A',
    },
    after: {
      strategy: currDecision?.strategy ?? 'N/A',
      selectedModel: currDecision?.selectedModel?.name ?? 'N/A',
      reason: currDecision?.reason ?? 'N/A',
    },
  };
}

function diffModel(original: ExecutionRecord, current: ExecutionRecord): ModelDiff {
  const origModel = original.decision.selectedModel;
  const currModel = current.decision.selectedModel;

  if (!origModel || !currModel) {
    return {
      changed: true,
      nameChanged: true,
      providerChanged: true,
      before: origModel ? {
        name: origModel.name,
        provider: origModel.provider,
        contextWindow: origModel.contextWindow ?? 'default',
        costProfile: origModel.costProfile ?? 'default',
      } : undefined,
      after: currModel ? {
        name: currModel.name,
        provider: currModel.provider,
        contextWindow: currModel.contextWindow ?? 'default',
        costProfile: currModel.costProfile ?? 'default',
      } : undefined,
    };
  }

  const nameChanged = origModel.name !== currModel.name;
  const providerChanged = origModel.provider !== currModel.provider;

  return {
    changed: nameChanged || providerChanged,
    nameChanged,
    providerChanged,
    before: {
      name: origModel.name,
      provider: origModel.provider,
      contextWindow: origModel.contextWindow ?? 'default',
      costProfile: origModel.costProfile ?? 'default',
    },
    after: {
      name: currModel.name,
      provider: currModel.provider,
      contextWindow: currModel.contextWindow ?? 'default',
      costProfile: currModel.costProfile ?? 'default',
    },
  };
}

function diffSkills(original: ExecutionRecord, current: ExecutionRecord): SkillsDiff {
  const origSkills = original.decision.skills ?? [];
  const currSkills = current.decision.skills ?? [];

  const origSkillMap = new Map(origSkills.map(s => [s.name, s]));
  const currSkillMap = new Map(currSkills.map(s => [s.name, s]));

  const added: SkillChange[] = [];
  const removed: SkillChange[] = [];
  const changed: SkillChange[] = [];

  const now = Date.now();

  // Find added and changed skills
  for (const skill of currSkills) {
    const origSkill = origSkillMap.get(skill.name);

    if (!origSkill) {
      // Added
      const score = computeSkillScore(skill, now);
      const totalUses = skill.successCount + skill.failureCount;
      const successRate = totalUses === 0 ? 0.5 : skill.successCount / totalUses;

      added.push({
        name: skill.name,
        score,
        enabled: skill.enabled,
        confidence: skill.confidence,
        successRate,
        lastUsed: new Date(skill.lastUsed).toISOString(),
      });
    } else {
      // Check if changed
      const origScore = computeSkillScore(origSkill, now);
      const currScore = computeSkillScore(skill, now);
      const origTotalUses = origSkill.successCount + origSkill.failureCount;
      const currTotalUses = skill.successCount + skill.failureCount;
      const origSuccessRate = origTotalUses === 0 ? 0.5 : origSkill.successCount / origTotalUses;
      const currSuccessRate = currTotalUses === 0 ? 0.5 : skill.successCount / currTotalUses;

      if (
        Math.abs(origScore - currScore) > 0.001 ||
        origSkill.enabled !== skill.enabled ||
        Math.abs(origSuccessRate - currSuccessRate) > 0.001
      ) {
        changed.push({
          name: skill.name,
          score: currScore,
          enabled: skill.enabled,
          confidence: skill.confidence,
          successRate: currSuccessRate,
          lastUsed: new Date(skill.lastUsed).toISOString(),
        });
      }
    }
  }

  // Find removed skills
  for (const skill of origSkills) {
    if (!currSkillMap.has(skill.name)) {
      const score = computeSkillScore(skill, now);
      const totalUses = skill.successCount + skill.failureCount;
      const successRate = totalUses === 0 ? 0.5 : skill.successCount / totalUses;

      removed.push({
        name: skill.name,
        score,
        enabled: skill.enabled,
        confidence: skill.confidence,
        successRate,
        lastUsed: new Date(skill.lastUsed).toISOString(),
      });
    }
  }

  return {
    added,
    removed,
    changed,
  };
}

export function formatReplayDiff(diff: ReplayDiffResult): string {
  const lines: string[] = [];

  lines.push('=== Replay Diff ===');

  // [Decision]
  lines.push('[Decision]');
  if (!diff.decisionDiff.changed) {
    lines.push('- no change');
  } else {
    if (diff.decisionDiff.strategyChanged) {
      lines.push(`- strategy: ${diff.decisionDiff.before?.strategy} â†’ ${diff.decisionDiff.after?.strategy}`);
    }
    if (diff.decisionDiff.modelChanged) {
      lines.push(`- selectedModel: ${diff.decisionDiff.before?.selectedModel} â†’ ${diff.decisionDiff.after?.selectedModel}`);
    }
    if (diff.decisionDiff.reasonChanged) {
      lines.push(`- reason:`);
      lines.push(`    before: "${diff.decisionDiff.before?.reason}"`);
      lines.push(`    after: "${diff.decisionDiff.after?.reason}"`);
    }
  }
  lines.push('');

  // [Model]
  lines.push('[Model]');
  if (!diff.modelDiff.changed) {
    lines.push('- no change');
  } else {
    if (diff.modelDiff.nameChanged) {
      lines.push(`- name: ${diff.modelDiff.before?.name} â†’ ${diff.modelDiff.after?.name}`);
    }
    if (diff.modelDiff.providerChanged) {
      lines.push(`- provider: ${diff.modelDiff.before?.provider} â†’ ${diff.modelDiff.after?.provider}`);
    }
  }
  lines.push('');

  // [Skills]
  lines.push('[Skills]');
  if (diff.skillsDiff.added.length === 0 &&
      diff.skillsDiff.removed.length === 0 &&
      diff.skillsDiff.changed.length === 0) {
    lines.push('- no change');
  } else {
    for (const skill of diff.skillsDiff.added) {
      lines.push(`+ added: ${skill.name} (score=${skill.score?.toFixed(3)})`);
    }
    for (const skill of diff.skillsDiff.removed) {
      lines.push(`- removed: ${skill.name}`);
    }
    for (const skill of diff.skillsDiff.changed) {
      lines.push(`~ changed: ${skill.name} (score=${skill.score?.toFixed(3)}, enabled=${skill.enabled})`);
    }
  }

  lines.push('===================');

  return lines.join('\n');
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/replayEngine.ts

````typescript
import chalk from 'chalk';
import { ExecutionRecord } from './executionRecord';
import { loadExecutionRecord } from './executionStore';
import { explainExecution } from './explain';

export type ReplayMode = 'strict' | 'compatible' | 're-evaluate';

export interface ReplayOptions {
  mode: ReplayMode;
  skipAI?: boolean;
  verbose?: boolean;
  dry?: boolean;
  explain?: boolean;
  diff?: boolean;
}

export interface ReplayResult {
  success: boolean;
  message: string;
  executedModel?: string;
  deviationReason?: string;
}

export class ReplayEngine {
  async replay(recordId: string, options: ReplayOptions = { mode: 'strict' }): Promise<ReplayResult> {
    const record = loadExecutionRecord(recordId);

    if (!record) {
      return {
        success: false,
        message: `Execution record ${recordId} not found`,
      };
    }

    // NOTE: --diff implicitly enables --explain
    if (options.diff) {
      options.explain = true;
    }

    if (options.explain) {
      console.log(explainExecution(record));
      console.log('');

      if (options.dry) {
        return {
          success: true,
          message: '[Explain + Dry] Explanation shown, no execution',
        };
      }
    }

    if (options.mode === 'strict') {
      return this.strictReplay(record, options);
    }

    if (options.mode === 'compatible') {
      return this.compatibleReplay(record, options);
    }

    return this.reEvaluate(record, options);
  }

  private async strictReplay(
    record: ExecutionRecord,
    options: ReplayOptions
  ): Promise<ReplayResult> {
    const selectedModel = record.decision.selectedModel;

    if (options.verbose || options.dry) {
      console.log(chalk.cyan('[Strict Replay]'));
      console.log(chalk.gray(`  Original Model: ${selectedModel?.name || 'N/A'}`));
      console.log(chalk.gray(`  Original Provider: ${selectedModel?.provider || 'N/A'}`));
      console.log(chalk.gray(`  Original Timestamp: ${record.meta.timestamp}`));
      console.log(chalk.gray(`  Original Command: ${record.meta.commandName}`));
    }

    if (options.dry) {
      return {
        success: true,
        message: '[Dry Replay] Command not executed',
        executedModel: selectedModel?.name ?? undefined,
      };
    }

    if (options.skipAI) {
      return {
        success: true,
        message: 'Strict replay prepared (AI execution skipped)',
        executedModel: selectedModel?.name ?? undefined,
      };
    }

    if (!record.command) {
      return {
        success: false,
        message: 'Strict replay: No command to execute (command not stored in record)',
        executedModel: selectedModel?.name ?? undefined,
      };
    }

    const { exec } = require('./executor');

    try {
      console.log(chalk.gray('[Strict Replay] Executing with original parameters...'));
      const result = await exec(record.command);

      return {
        success: result.code === 0 || result.code === null,
        message: result.code === 0 || result.code === null
          ? 'Strict replay completed successfully'
          : `Strict replay failed with code ${result.code}`,
        executedModel: selectedModel?.name ?? undefined,
      };
    } catch (error: unknown) {
      const message = error instanceof Error ? error.message : String(error);
      return {
        success: false,
        message: `Strict replay error: ${message}`,
        executedModel: selectedModel?.name ?? undefined,
      };
    }
  }

  private async compatibleReplay(
    record: ExecutionRecord,
    options: ReplayOptions
  ): Promise<ReplayResult> {
    const originalModel = record.decision.selectedModel;

    if (options.verbose) {
      console.log(chalk.cyan('[Compatible Replay]'));
      console.log(chalk.gray(`  Original Model: ${originalModel?.name || 'N/A'}`));
      console.log(chalk.gray(`  Will attempt fallback if original unavailable`));
    }

    return {
      success: false,
      message: 'Compatible replay not yet implemented in Phase 1',
      executedModel: originalModel?.name,
      deviationReason: 'Phase 1 only supports strict replay',
    };
  }

  private async reEvaluate(
    record: ExecutionRecord,
    options: ReplayOptions
  ): Promise<ReplayResult> {
    if (options.verbose) {
      console.log(chalk.cyan('[Re-evaluate]'));
      console.log(chalk.gray(`  Will re-run capability matching with current config`));
      console.log(chalk.gray(`  Original Intent: ${record.intent.required.join(', ')}`));
    }

    return {
      success: false,
      message: 'Re-evaluate not yet implemented in Phase 1',
    };
  }
}

export const replayEngine = new ReplayEngine();

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/risk.ts

````typescript
export function assessRisk(command: string, aiRisk: 'low' | 'medium' | 'high'): 'low' | 'medium' | 'high' {
    const HIGH_RISK_PATTERNS = [
        /\brm\b/i,
        /\bsudo\b/i,
        /\bmv\b/i,
        /\bdd\b/i,
        /\bchmod\b/i,
        /\bchown\b/i,
        />\s*\/dev\//,
        /:\(\)\s*\{.*\}/, // Fork bomb
        /\bmkfs\b/i,
    ];

    const hasHighRisk = HIGH_RISK_PATTERNS.some(pattern => pattern.test(command));

    if (hasHighRisk) return 'high';
    return aiRisk;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ core/validation.ts

````typescript
import { z } from 'zod';

export type UserConfig = {
    defaultModel?: string;
    aiProxyUrl?: string;
    accountType?: 'free' | 'pro' | 'paid';
    contextWindow?: number;
    maxFileTokens?: number;
    maxTotalTokens?: number;
    [key: string]: any;
};

export type AppsConfig = Record<string, string>;

export type AIRequestMessage = {
    role: 'system' | 'user' | 'assistant';
    content: string;
};

export type AIResponse = {
    choices?: Array<{
        message?: {
            content?: string;
        };
        delta?: {
            content?: string;
        };
    }>;
};

export const DEFAULT_AI_PROXY_URL = 'https://aiproxy.want.biz/v1/chat/completions';
export const DEFAULT_MODEL = 'Assistant';
export const DEFAULT_ACCOUNT_TYPE = 'free' as const;

export const DEFAULT_APPS = {
    shici: 'https://wealth.want.biz/shici/index.html',
    dict: 'https://wealth.want.biz/pages/dict.html',
    pong: 'https://wealth.want.biz/pages/pong.html'
} as const;

export const aiCommandPlanSchema = z.object({
    plan: z.string().describe('Explanation of the command'),
    command: z.string().optional().describe('The shell command to execute'),
    macro: z.string().optional().describe('Name of an existing macro to reuse'),
    risk: z.enum(['low', 'medium', 'high']).describe('Risk level assessment')
}).refine(data => data.command || data.macro, {
    message: 'Either command or macro must be provided'
});

export type AICommandPlan = z.infer<typeof aiCommandPlanSchema>;

export const aiFixPlanSchema = z.object({
    plan: z.string().describe('Fix explanation'),
    command: z.string().describe('The fixed shell command (always required for fixes)'),
    risk: z.enum(['low', 'medium', 'high']).describe('Risk level assessment')
});

export type AIFixPlan = z.infer<typeof aiFixPlanSchema>;

export const userConfigSchema = z.object({
    defaultModel: z.string().optional(),
    aiProxyUrl: z.string().url().optional(),
    accountType: z.enum(['free', 'pro', 'paid']).optional(),
    contextWindow: z.number().optional(),
    maxFileTokens: z.number().optional(),
    maxTotalTokens: z.number().optional()
}).passthrough();

export const appsConfigSchema = z.record(z.string(), z.string());

export const macroSchema = z.object({
    commands: z.string(),
    description: z.string(),
    createdAt: z.string()
});

export type Macro = z.infer<typeof macroSchema>;

export const historyEntrySchema = z.object({
    question: z.string(),
    command: z.string(),
    time: z.string()
});

export type HistoryEntry = z.infer<typeof historyEntrySchema>;

export function extractJSON(raw: string): string {
    let jsonContent = raw.trim();

    if (jsonContent.includes('```json')) {
        jsonContent = jsonContent.split('```json')[1].split('```')[0].trim();
    }
    else if (jsonContent.includes('```')) {
        jsonContent = jsonContent.split('```')[1].split('```')[0].trim();
    }

    const firstBrace = jsonContent.indexOf('{');
    const lastBrace = jsonContent.lastIndexOf('}');

    if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
        jsonContent = jsonContent.substring(firstBrace, lastBrace + 1);
    }

    return jsonContent;
}

export function safeParseJSON<T>(
    raw: string,
    schema: z.ZodSchema<T>,
    fallback: T
): { success: true; data: T } | { success: false; error: z.ZodError } {
    try {
        const jsonContent = extractJSON(raw);
        const result = schema.safeParse(JSON.parse(jsonContent));

        if (result.success) {
            return { success: true, data: result.data };
        } else {
            return { success: false, error: result.error };
        }
    } catch (error) {
        if (error instanceof z.ZodError) {
            return { success: false, error };
        }
        return {
            success: false,
            error: new z.ZodError([
                {
                    code: z.ZodIssueCode.custom,
                    message: `Failed to parse JSON: ${error instanceof Error ? error.message : String(error)}`,
                    path: []
                }
            ])
        };
    }
}

export function parseUserConfig(content: string): UserConfig {
    return userConfigSchema.parse(JSON.parse(content));
}

export function parseAppsConfig(content: string): AppsConfig {
    return appsConfigSchema.parse(JSON.parse(content)) as AppsConfig;
}

export function parseMacros(content: string): Record<string, Macro> {
    const parsed = JSON.parse(content);
    const macros: Record<string, Macro> = {};

    for (const [name, value] of Object.entries(parsed)) {
        macros[name] = macroSchema.parse(value);
    }

    return macros;
}

export function parseCommandHistory(content: string): HistoryEntry[] {
    const parsed = JSON.parse(content);
    return z.array(historyEntrySchema).parse(parsed);
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/governance/CausalTracker.ts

````typescript
import { getNode, recordEdge } from '../knowledgeGraph';
import { GovernanceError } from './errors';
import { KGEdgeType } from '../knowledgeGraph/types';

export class CausalTracker {
  static recordCausalLink(
    obsId: string,
    executionId: string,
    ackText: string
  ) {
    const obsNode = getNode<any>(obsId);

    if (!obsNode) {
      throw new GovernanceError(`Observation ${obsId} not found`);
    }

    if (!this.verifyAck(obsNode.payload.rawContent, ackText)) {
      throw new GovernanceError(
        'Causal Break: ACK does not match physical Observation'
      );
    }

    recordEdge({
      from: obsId,
      to: executionId,
      type: 'ACKNOWLEDGED_BY' as KGEdgeType,
      metadata: {
        verified: true,
        contentHash: obsNode.payload.contentHash
      }
    });
  }

  private static verifyAck(actual: string, acked: string): boolean {
    return actual.trim() === acked.trim();
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/governance/ObservationRegistry.ts

````typescript
import crypto from 'crypto';
import { recordNode, recordEdge } from '../knowledgeGraph';
import { ObservationNode } from '../knowledgeGraph/types';

export function recordObservationNode(input: {
  kind: ObservationNode['kind'];
  rawContent: string;
  originatingActionId?: string;
}): string {
  const id = `obs_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`;
  const contentHash = crypto
    .createHash('sha256')
    .update(input.rawContent)
    .digest('hex');

  recordNode<ObservationNode>({
    id,
    type: 'observation',
    timestamp: Date.now(),
    payload: {
      id,
      timestamp: Date.now(),
      kind: input.kind,
      contentHash,
      rawContent: input.rawContent,
      originatingActionId: input.originatingActionId
    }
  });

  if (input.originatingActionId) {
    recordEdge({
      from: input.originatingActionId,
      to: id,
      type: 'CAUSED_BY'
    });
  }

  return id;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/governance/errors.ts

````typescript
export class GovernanceError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'GovernanceError';
    Object.setPrototypeOf(this, GovernanceError.prototype);
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/knowledgeGraph/index.ts

````typescript
import fs from 'fs';
import path from 'path';
import os from 'os';
import { KGNode, KGEdge, KGEdgeType } from './types';

const KG_DIR = path.join(os.homedir(), '.yuangs', 'knowledge');
const NODE_FILE = path.join(KG_DIR, 'nodes.jsonl');
const EDGE_FILE = path.join(KG_DIR, 'edges.jsonl');

function ensureDir() {
  if (!fs.existsSync(KG_DIR)) {
    fs.mkdirSync(KG_DIR, { recursive: true });
  }
}

export function recordNode<T = any>(node: KGNode<T>) {
  ensureDir();
  const record = {
    ...node,
    timestamp: node.timestamp || Date.now()
  };
  fs.appendFileSync(NODE_FILE, JSON.stringify(record) + '\n');
}

export function recordEdge(edge: {
  from: string;
  to: string;
  type: KGEdgeType;
  metadata?: any;
}) {
  ensureDir();
  const record = {
    ...edge,
    timestamp: Date.now()
  };
  fs.appendFileSync(EDGE_FILE, JSON.stringify(record) + '\n');
}

export function getNode<T = any>(id: string): KGNode<T> | null {
  if (!fs.existsSync(NODE_FILE)) return null;

  const lines = fs.readFileSync(NODE_FILE, 'utf8').split('\n');
  for (const line of lines.reverse()) {
    if (!line.trim()) continue;
    const node = JSON.parse(line);
    if (node.id === id) return node;
  }
  return null;
}

export function getEdges(from?: string, to?: string, type?: KGEdgeType): KGEdge[] {
  if (!fs.existsSync(EDGE_FILE)) return [];

  const lines = fs.readFileSync(EDGE_FILE, 'utf8').split('\n');
  const result: KGEdge[] = [];

  for (const line of lines.reverse()) {
    if (!line.trim()) continue;
    const edge = JSON.parse(line);

    let match = true;
    if (from && edge.from !== from) match = false;
    if (to && edge.to !== to) match = false;
    if (type && edge.type !== type) match = false;

    if (match) {
      result.push(edge);
    }
  }

  return result;
}

export function getObservationNode(id: string): KGNode | null {
  return getNode(id);
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine/agent/knowledgeGraph/types.ts

````typescript
export type KGNodeType =
  | 'context'
  | 'execution'
  | 'skill'
  | 'observation';

export type KGEdgeType =
  | 'USED_IN'          // Context -> Execution
  | 'VALIDATED_BY'     // Execution -> Skill
  | 'PROMOTED_TO'      // Context -> Skill
  | 'CAUSED_BY'        // Action -> Observation
  | 'ACKNOWLEDGED_BY'; // Observation -> Execution â­æ ¸å¿ƒå› æœé”

export interface KGNode<T = any> {
  id: string;
  type: KGNodeType;
  payload: T;
  timestamp: number;
}

export interface KGEdge {
  from: string;
  to: string;
  type: KGEdgeType;
  metadata?: any;
  timestamp: number;
}

export interface ObservationNode {
  id: string;
  timestamp: number;
  kind: 'tool_result' | 'system_note' | 'manual_input';
  contentHash: string;
  rawContent: string;
  originatingActionId?: string;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ index.ts

````typescript
// This file is empty because yuangs is a CLI-first project.
// We don't expose any public library APIs to avoid breaking changes.
export { };

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ legacy/governance/GovernanceEngine.ts

````typescript
import { GovernedAction, ExecutionContext, ApprovalSource } from "./GovernedAction";

/**
 * Governance engine - single point of control for all governed actions
 * Enforces "No Diff Without Review. No Execution Without Approval."
 */
export class GovernanceEngine {
  private actions = new Map<string, GovernedAction>();
  private revokedActions = new Set<string>();

  register(action: GovernedAction): void {
    if (this.revokedActions.has(action.id)) {
      throw new Error(
        `Governance violation: action ${action.id} was revoked`
      );
    }
    this.actions.set(action.id, action);
  }

  getAction(id: string): GovernedAction | undefined {
    return this.actions.get(id);
  }

  listActions(): GovernedAction[] {
    return Array.from(this.actions.values());
  }

  requestApproval(id: string): void {
    const action = this.actions.get(id);

    if (!action) {
      throw new Error(`Action not found: ${id}`);
    }

    action.propose();

    console.log(`[PROPOSED] ${action.kind}:${id}`);
    console.log(`Rationale: ${action.rationale}`);
  }

  approve(id: string, by: ApprovalSource): void {
    const action = this.actions.get(id);

    if (!action) {
      throw new Error(`Action not found: ${id}`);
    }

    if (by !== "human") {
      throw new Error(`Governance violation: only human can approve`);
    }

    action.approve(by);

    console.log(`[APPROVED] ${action.kind}:${id} by ${by}`);
  }

  reject(id: string, reason: string): void {
    const action = this.actions.get(id);

    if (!action) {
      throw new Error(`Action not found: ${id}`);
    }

    action.reject(reason);

    console.log(`[REJECTED] ${action.kind}:${id}`);
    console.log(`Reason: ${reason}`);
  }

  async execute(id: string, ctx: ExecutionContext): Promise<void> {
    const action = this.actions.get(id);

    if (!action) {
      throw new Error(`Action not found: ${id}`);
    }

    if (action.state !== "APPROVED") {
      throw new Error(
        `Governance violation: execute() called on ${action.kind}:${id} in state ${action.state}, must be APPROVED`
      );
    }

    const result = await action.execute(ctx);

    if (!result.ok) {
      throw new Error(
        `Execution failed: ${result.error || "unknown error"}`
      );
    }

    console.log(`[EXECUTED] ${action.kind}:${id}`);
  }

  async observe(id: string): Promise<void> {
    const action = this.actions.get(id);

    if (!action) {
      throw new Error(`Action not found: ${id}`);
    }

    const obs = await action.observe();

    console.log(`[OBSERVED] ${action.kind}:${id}`);
    console.log(`Files changed: ${obs.changedFiles.length}`);
  }

  verify(id: string, obs: any): boolean {
    const action = this.actions.get(id);

    if (!action) {
      throw new Error(`Action not found: ${id}`);
    }

    const verified = action.verify(obs);

    if (verified) {
      console.log(`[VERIFIED] ${action.kind}:${id}`);
    }

    return verified;
  }

  revoke(id: string): void {
    this.actions.delete(id);
    this.revokedActions.add(id);
  }

  has(id: string): boolean {
    return this.actions.has(id) && !this.revokedActions.has(id);
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ legacy/governance/GovernedAction.ts

````typescript
/**
 * Core Governance Types and Interfaces
 *
 * This module defines the foundational types for the Code Change Governance System.
 * All actions must implement GovernedAction and follow strict state transitions.
 */

/**
 * Valid governance states for any action
 * No action can skip states or bypass approval
 */
export type GovernanceState =
  | "DRAFT"
  | "PROPOSED"
  | "APPROVED"
  | "EXECUTED"
  | "OBSERVED"
  | "VERIFIED"
  | "REJECTED";

/**
 * Approval can only come from humans - no auto-approval
 */
export type ApprovalSource = "human";

/**
 * Provenance tracking for reproducibility and audit
 */
export interface ActionProvenance {
  /** The agent that created this action */
  agentId: string;

  /** Hash of the plan that generated this action */
  planHash: string;

  /** Parent action if this is a fix/repair attempt */
  parentAction?: string;

  /** When this action was created */
  createdAt: number;
}

/**
 * Execution context for running actions
 */
export interface ExecutionContext {
  executor: ActionExecutor;
  snapshot?: string;
}

/**
 * Result from executing an action
 */
export interface ExecutionResult {
  ok: boolean;
  error?: string;
  executedAt?: number;
  snapshotAfter?: string;
}

/**
 * Observation data after execution
 */
export interface Observation {
  gitDiff: string;
  changedFiles: string[];
  executionTime: number;
}

/**
 * Action executor interface (filesystem operations)
 * This is the ONLY place where filesystem changes can happen
 */
export interface ActionExecutor {
  applyDiff(diff: string): Promise<void>;

  readFile(path: string): Promise<string>;

  writeFile(path: string, content: string): Promise<void>;

  deleteFile(path: string): Promise<void>;
}

/**
 * Core interface that ALL governed actions must implement
 * This enforces the constitutional constraints
 */
export interface GovernedAction<Payload = unknown> {
  /** Unique identifier for this action */
  readonly id: string;

  /** Type/kind of action (code_change, run_command, etc.) */
  readonly kind: string;

  /** The actual payload that will be executed */
  readonly payload: Payload;

  /** Current state of this action */
  state: GovernanceState;

  /** Why this action is being proposed (must be human-readable) */
  readonly rationale: string;

  /** Who created this action and when */
  readonly provenance: ActionProvenance;

  /** When was the state last updated */
  updatedAt: number;

  /** Transition from DRAFT to PROPOSED */
  propose(): void;

  /** Transition from PROPOSED to APPROVED (only human can approve) */
  approve(by: ApprovalSource): void;

  /** Transition from any state to REJECTED */
  reject(reason: string): void;

  /** Execute the action (only possible if APPROVED) */
  execute(ctx: ExecutionContext): Promise<ExecutionResult>;

  /** Observe the results of execution (only possible if EXECUTED) */
  observe(): Promise<Observation>;

  /** Verify the observation (only possible if OBSERVED) */
  verify(obs: Observation): boolean;

  /** Get a summary of this action for display */
  summarize(): ActionSummary;
}

/**
 * Human-readable summary of an action
 */
export interface ActionSummary {
  id: string;
  kind: string;
  state: GovernanceState;
  rationale: string;
  filesAffected?: string[];
  changeSize?: number;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ legacy/governance/actions/CodeChangeAction.ts

````typescript
import crypto from "crypto";

import {
  GovernedAction,
  GovernanceState,
  ExecutionContext,
  ExecutionResult,
  Observation,
  ActionExecutor,
  ActionSummary,
  ApprovalSource,
  ActionProvenance,
} from "../GovernedAction";

/**
 * Payload for code change actions
 * Contains unified diff and affected files
 */
export interface CodeChangePayload {
  files: string[];
  diff: string;
}

export class CodeChangeAction implements GovernedAction<CodeChangePayload> {
  readonly kind = "code_change";

  state: GovernanceState = "DRAFT";
  updatedAt: number = Date.now();

  constructor(
    public readonly id: string,
    public readonly payload: CodeChangePayload,
    public readonly rationale: string,
    public readonly provenance: ActionProvenance
  ) {
    this.updatedAt = provenance.createdAt;
  }

  propose(): void {
    if (this.state !== "DRAFT") {
      throw new Error(
        `Governance violation: propose() called from ${this.state}, must be DRAFT`
      );
    }
    this.state = "PROPOSED";
    this.updatedAt = Date.now();
  }

  approve(by: ApprovalSource): void {
    if (this.state !== "PROPOSED") {
      throw new Error(
        `Governance violation: approve() called from ${this.state}, must be PROPOSED`
      );
    }
    if (by !== "human") {
      throw new Error(
        `Governance violation: only human can approve, got ${by}`
      );
    }
    this.state = "APPROVED";
    this.updatedAt = Date.now();
  }

  reject(reason: string): void {
    if (this.state === "REJECTED") {
      throw new Error(
        `Governance violation: reject() called from ${this.state}, already rejected`
      );
    }
    this.state = "REJECTED";
    this.updatedAt = Date.now();
  }

  async execute(ctx: ExecutionContext): Promise<ExecutionResult> {
    if (this.state !== "APPROVED") {
      throw new Error(
        `Governance violation: execute() called from ${this.state}, must be APPROVED`
      );
    }

    const startTime = Date.now();

    try {
      await ctx.executor.applyDiff(this.payload.diff);

      this.state = "EXECUTED";
      this.updatedAt = Date.now();

      return {
        ok: true,
        executedAt: Date.now(),
        snapshotAfter: ctx.snapshot,
      };
    } catch (error) {
      this.state = "REJECTED";
      this.updatedAt = Date.now();

      return {
        ok: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  async observe(): Promise<Observation> {
    if (this.state !== "EXECUTED") {
      throw new Error(
        `Governance violation: observe() called from ${this.state}, must be EXECUTED`
      );
    }

    const { execSync } = require("child_process");

    const changedFiles = execSync("git diff --name-only", {
      encoding: "utf-8",
    })
      .trim()
      .split("\n")
      .filter((f: string) => f);

    const gitDiff = execSync("git diff", { encoding: "utf-8" });

    this.state = "OBSERVED";
    this.updatedAt = Date.now();

    return {
      gitDiff,
      changedFiles,
      executionTime: Date.now(),
    };
  }

  verify(obs: Observation): boolean {
    if (this.state !== "OBSERVED") {
      throw new Error(
        `Governance violation: verify() called from ${this.state}, must be OBSERVED`
      );
    }

    const changedFiles = new Set(obs.changedFiles);
    const declaredFiles = new Set(this.payload.files);

    const extraFiles = obs.changedFiles.filter((f) => !declaredFiles.has(f));

    if (extraFiles.length > 0) {
      throw new Error(
        `Governance violation: execution modified undeclared files: ${extraFiles.join(", ")}`
      );
    }

    this.state = "VERIFIED";
    this.updatedAt = Date.now();

    return true;
  }

  summarize(): ActionSummary {
    const changeSize = this.calculateChangeSize();

    return {
      id: this.id,
      kind: this.kind,
      state: this.state,
      rationale: this.rationale,
      filesAffected: this.payload.files,
      changeSize,
    };
  }

  private calculateChangeSize(): number {
    let additions = 0;
    let deletions = 0;

    for (const line of this.payload.diff.split("\n")) {
      if (line.startsWith("+") && !line.startsWith("+++")) additions++;
      if (line.startsWith("-") && !line.startsWith("---")) deletions++;
    }

    return additions + deletions;
  }

  static create(
    payload: CodeChangePayload,
    rationale: string,
    agentId: string,
    planHash: string,
    parentAction?: string
  ): CodeChangeAction {
    const id = crypto.randomUUID();
    const provenance: ActionProvenance = {
      agentId,
      planHash,
      parentAction,
      createdAt: Date.now(),
    };

    return new CodeChangeAction(id, payload, rationale, provenance);
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ legacy/governance/capability/token.ts

````typescript
import crypto from "crypto";
import { execSync } from "child_process";

const SECRET = process.env.CAP_SECRET || "default-secret-change-in-production";

export type Right =
  | { type: "APPLY_DIFF" }
  | { type: "READ_FILE"; path: string }
  | { type: "EXECUTE_ACTION"; actionId: string };

export type Scope =
  | { type: "ACTION"; id: string }
  | { type: "PATH_PREFIX"; prefix: string }
  | { type: "REPO" };

export interface Capability {
  id: string;
  subject: string;
  rights: Right[];
  scope: Scope;
  issuedAt: number;
  expiresAt: number;
  maxUses: number;
  used: number;
  signature: string;
}

export function sign(data: string): string {
  return crypto
    .createHmac("sha256", SECRET)
    .update(data)
    .digest("hex");
}

export function verify(cap: Capability): boolean {
  const { signature, ...rest } = cap;
  const payload = JSON.stringify(rest);
  const computed = sign(payload);

  return computed === signature;
}

export function issue(input: {
  subject: string;
  rights: Right[];
  scope: Scope;
  ttlMs: number;
  maxUses?: number;
}): Capability {
  const base = {
    id: crypto.randomUUID(),
    subject: input.subject,
    rights: input.rights,
    scope: input.scope,
    issuedAt: Date.now(),
    expiresAt: Date.now() + input.ttlMs,
    maxUses: input.maxUses ?? 1,
    used: 0,
  };

  const payload = JSON.stringify(base);

  return {
    ...base,
    signature: sign(payload),
  };
}

export function checkCapability(
  cap: Capability,
  want: Right,
  context: { actionId?: string; path?: string }
): void {
  if (!verify(cap)) {
    throw new Error("Invalid capability: signature verification failed");
  }

  if (Date.now() > cap.expiresAt) {
    throw new Error("Capability expired");
  }

  if (cap.used >= cap.maxUses) {
    throw new Error("Capability exhausted (max uses reached)");
  }

  const rightMatch = cap.rights.some(
    (r) => JSON.stringify(r) === JSON.stringify(want)
  );

  if (!rightMatch) {
    throw new Error(
      `Capability does not grant right: ${JSON.stringify(want)}`
    );
  }

  if (cap.scope.type === "ACTION" && context.actionId !== cap.scope.id) {
    throw new Error(
      `Scope violation: capability scoped to action ${cap.scope.id}, used on ${context.actionId}`
    );
  }

  if (
    cap.scope.type === "PATH_PREFIX" &&
    context.path &&
    !context.path.startsWith(cap.scope.prefix)
  ) {
    throw new Error(
      `Scope violation: capability scoped to ${cap.scope.prefix}, used on ${context.path}`
    );
  }

  cap.used++;
}

export function attenuate(
  cap: Capability,
  limits: Partial<Pick<Capability, "expiresAt" | "maxUses">>
): Capability {
  if (!verify(cap)) {
    throw new Error("Cannot attenuate invalid capability");
  }

  const reduced = {
    ...cap,
    expiresAt: Math.min(
      cap.expiresAt,
      limits.expiresAt ?? cap.expiresAt
    ),
    maxUses: Math.min(cap.maxUses, limits.maxUses ?? cap.maxUses),
    used: 0,
    signature: "",
  };

  const payload = JSON.stringify({
    id: reduced.id,
    subject: reduced.subject,
    rights: reduced.rights,
    scope: reduced.scope,
    issuedAt: reduced.issuedAt,
    expiresAt: reduced.expiresAt,
    maxUses: reduced.maxUses,
    used: 0,
  });

  return {
    ...reduced,
    signature: sign(payload),
  };
}

const revokedCaps = new Set<string>();

export function revoke(capId: string): void {
  revokedCaps.add(capId);
}

export function checkRevoked(cap: Capability): void {
  if (revokedCaps.has(cap.id)) {
    throw new Error(`Capability ${cap.id} has been revoked`);
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ legacy/governance/commands/diffEdit.ts

````typescript
import { Command } from "commander";
import chalk from "chalk";
import fs from "fs";
import { execSync } from "child_process";

import { GovernanceEngine } from "../GovernanceEngine";
import { CodeChangeAction, CodeChangePayload } from "../actions/CodeChangeAction";
import { ExecutionContext, ActionExecutor } from "../GovernedAction";
import { parseUnifiedDiff, extractFilesFromDiff, assessRisk } from "../review/diffParser";
import { renderSummary, renderDiffForReview, renderRiskAssessment, promptForApproval } from "../review/render";
import { createSnapshot, rollbackToSnapshot, commitChanges, assertNoExtraChanges, getChangedFiles } from "../execution/sandbox";
import { issue } from "../capability/token";
import { loadActions, saveActions, auditActions } from "../storage/store";

const engine = new GovernanceEngine();
auditActions(loadActions());


function collectGitResult(commitHash: string) {
  try {
    const output = execSync(`git show --stat --oneline ${commitHash}`, {
      encoding: "utf-8",
    });

    const files: string[] = [];
    let insertions = 0;
    let deletions = 0;

    for (const line of output.split("\n")) {
      const fileMatch = line.match(/^\s*(.+?)\s+\|\s+\d+/);
      if (fileMatch) {
        files.push(fileMatch[1].trim());
      }

      const insMatch = line.match(/(\d+)\s+insertions?\(\+\)/);
      const delMatch = line.match(/(\d+)\s+deletions?\(-\)/);
      if (insMatch) insertions = parseInt(insMatch[1], 10);
      if (delMatch) deletions = parseInt(delMatch[1], 10);
    }

    return {
      commits: commitHash ? 1 : 0,
      files,
      insertions,
      deletions,
    };
  } catch {
    return {
      commits: 1,
      files: [],
      insertions: 0,
      deletions: 0,
      warning: "Unable to derive git stats",
    };
  }
}



class GitExecutor implements ActionExecutor {
  async applyDiff(diff: string): Promise<void> {
    // execSync is imported at top level

    try {
      execSync("git apply --index", {
        input: diff,
        stdio: "pipe",
      });
    } catch (error) {
      throw new Error(`Failed to apply diff: ${error}`);
    }
  }

  async readFile(path: string): Promise<string> {
    return fs.promises.readFile(path, "utf-8");
  }

  async writeFile(path: string, content: string): Promise<void> {
    await fs.promises.writeFile(path, content, "utf-8");
  }

  async deleteFile(path: string): Promise<void> {
    await fs.promises.unlink(path);
  }
}

export function createDiffEditCommand(): Command {
  const program = new Command("diff-edit");

  program
    .description("Governed code change CLI - review before executing")
    .version("1.0.0");

  program
    .command("propose <diff-file>")
    .option("-r, --rationale <text>", "Why this change is needed")
    .action(async (diffFile, options) => {
      if (!fs.existsSync(diffFile)) {
        console.error(chalk.red(`Diff file not found: ${diffFile}`));
        process.exit(1);
      }

      const diff = fs.readFileSync(diffFile, "utf-8");
      const rationale = options.rationale || "Manual diff submission";

      const files = extractFilesFromDiff(diff);
      const payload: CodeChangePayload = { files, diff };

      const action = CodeChangeAction.create(
        payload,
        rationale,
        "cli",
        "manual-" + Date.now()
      );

      action.propose();

      const actions = loadActions();
      actions[action.id] = action as any;
      saveActions(actions);

      console.log(chalk.green(`[PROPOSED] ${action.id}`));
      console.log(chalk.cyan("Files:"));
      for (const f of files) {
        console.log(`  - ${chalk.yellow(f)}`);
      }

      console.log(`\n${chalk.bold("Rationale:")} ${rationale}`);
    });

  program
    .command("list")
    .description("List all proposed actions")
    .action(() => {
      const actions = loadActions();

      console.log(chalk.bold("\n" + "=".repeat(60)));
      console.log(chalk.bold("Actions"));
      console.log(chalk.bold("=".repeat(60)) + "\n");

      const table: Array<{
        id: string;
        kind: string;
        state: string;
        rationale: string;
      }> = [];

      for (const [id, a] of Object.entries(actions)) {
        table.push({
          id,
          kind: a.kind,
          state: a.state,
          rationale: a.rationale.substring(0, 50),
        });
      }

      console.table(table);
    });

  program
    .command("approve <id>")
    .description("Review and approve a proposed action")
    .action(async (id) => {
      const actions = loadActions();
      const action = actions[id];

      if (!action) {
        console.error(chalk.red(`Action not found: ${id}`));
        process.exit(1);
      }

      const files = parseUnifiedDiff(action.payload.diff);
      renderDiffForReview(files, action.rationale);

      const { level, warnings } = assessRisk(files);
      renderRiskAssessment(level, warnings);

      const approved = await promptForApproval();

      if (!approved) {
        console.log(chalk.red("\n[REJECTED] Approval aborted"));
        action.state = "REJECTED";
        saveActions(actions);
        return;
      }

      action.state = "APPROVED";
      saveActions(actions);

      console.log(chalk.green(`\n[APPROVED] ${id}`));
    });

  program
    .command("exec <id>")
    .description("Execute an approved action")
    .action(async (id) => {
      const actions = loadActions();
      const action = actions[id];

      if (!action) {
        console.error(chalk.red(`Action not found: ${id}`));
        process.exit(1);
      }

      if (action.state !== "APPROVED") {
        console.error(
          chalk.red(
            `Action not approved (state: ${action.state})`
          )
        );
        process.exit(1);
      }

      console.log(chalk.cyan(`\n[EXECUTING] ${id}...`));

      const snapshot = createSnapshot();
      const executor = new GitExecutor();
      const ctx: ExecutionContext = { executor, snapshot: snapshot.id };

      try {
        // === PRE-EXEC: Snapshot Validation ===
        await executor.applyDiff(action.payload.diff);

        const changedFiles = getChangedFiles();
        assertNoExtraChanges(action.payload.files, changedFiles);

        const snapshotResult = {
          changedFiles,
          unexpectedFiles: changedFiles.filter(
            (f) => !action.payload.files.includes(f)
          ),
          matchedBySandbox: changedFiles.length === action.payload.files.length,
        };

        // === EXEC: Commit ===
        commitChanges(`EXECUTED action ${id}`, snapshot.id);

        const commitHash = execSync("git rev-parse HEAD", {
          encoding: "utf-8",
        }).trim();

        action.state = "EXECUTED";
        action.executedAt = Date.now();
        saveActions(actions);

        // === POST-EXEC: Reporting ===
        const gitResult = collectGitResult(commitHash);

        console.log(chalk.green("\n[EXECUTED]"));
        console.log(chalk.green(`Action ID: ${id}`));

        console.log(chalk.cyan("\nSnapshot Verification (pre-commit):"));
        console.log(
          chalk.cyan(
            `  - Files changed: ${snapshotResult.changedFiles.length}`
          )
        );
        for (const f of snapshotResult.changedFiles) {
          console.log(chalk.cyan(`    - ${f}`));
        }
        if (snapshotResult.unexpectedFiles.length > 0) {
          console.log(chalk.yellow("  - Unexpected files:"));
          for (const f of snapshotResult.unexpectedFiles) {
            console.log(chalk.yellow(`    - ${f}`));
          }
        }
        console.log(
          chalk.cyan(
            `  - Status: ${snapshotResult.matchedBySandbox ? "âœ… MATCHED" : "âš ï¸ DEVIATION"
            }`
          )
        );

        console.log(chalk.cyan("\nGit Result:"));
        console.log(chalk.cyan(`  - Commit: ${commitHash.substring(0, 7)}`));
        console.log(chalk.cyan(`  - Files changed: ${gitResult.files.length}`));
        console.log(chalk.cyan(`  - Insertions: ${gitResult.insertions}`));
        console.log(chalk.cyan(`  - Deletions: ${gitResult.deletions}`));

        console.log(chalk.green("\nStatus:"));
        console.log(chalk.green("  âœ… EXECUTED (validated + committed)"));
      } catch (error) {
        console.error(chalk.red(`\n[FAILED] ${error}`));

        console.log(chalk.yellow("\nRolling back to snapshot..."));
        rollbackToSnapshot(snapshot.id);

        action.state = "REJECTED";
        saveActions(actions);

        console.log(chalk.cyan("\nRolled back successfully"));
        process.exit(1);
      }
    });

  program
    .command("status <id>")
    .description("Show status of an action")
    .action((id) => {
      const actions = loadActions();
      const action = actions[id];

      if (!action) {
        console.error(chalk.red(`Action not found: ${id}`));
        process.exit(1);
      }

      console.log(chalk.bold("\n" + "=".repeat(60)));
      console.log(chalk.bold(`Action: ${id}`));
      console.log(chalk.bold("=".repeat(60)) + "\n");

      console.log(`${chalk.bold("Kind:")} ${action.kind}`);
      console.log(`${chalk.bold("State:")} ${action.state}`);
      console.log(`${chalk.bold("Rationale:")} ${action.rationale}`);
      console.log(
        `${chalk.bold("Updated:")} ${new Date(
          action.updatedAt
        ).toLocaleString()}`
      );

      if (action.state === "EXECUTED" && action.executedAt) {
        console.log(
          `${chalk.bold("Executed:")} ${new Date(
            action.executedAt
          ).toLocaleString()}`
        );
      }
    });

  return program;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ legacy/governance/execution/sandbox.ts

````typescript
import { execSync } from "child_process";

export interface ExecutionSnapshot {
  id: string;
  commitHash: string;
  timestamp: number;
  isClean: boolean;
}

export function createSnapshot(): ExecutionSnapshot {
  const statusOutput = execSync("git status --porcelain", {
    encoding: "utf-8",
  }).trim();

  const isClean = statusOutput.length === 0;

  if (!isClean) {
    throw new Error(
      "Cannot create snapshot: working tree is dirty. Commit or stash changes first."
    );
  }

  const commitHash = execSync("git rev-parse HEAD", {
    encoding: "utf-8",
  }).trim();

  return {
    id: commitHash,
    commitHash,
    timestamp: Date.now(),
    isClean,
  };
}

export function verifySnapshot(snapshotId: string): boolean {
  try {
    const current = execSync("git rev-parse HEAD", {
      encoding: "utf-8",
    }).trim();

    return current === snapshotId;
  } catch {
    return false;
  }
}

export function rollbackToSnapshot(snapshotId: string): void {
  try {
    execSync(`git reset --hard ${snapshotId}`, {
      stdio: "inherit",
    });
    console.log(`Rolled back to snapshot ${snapshotId}`);
  } catch (error) {
    throw new Error(
      `Failed to rollback to snapshot ${snapshotId}: ${error}`
    );
  }
}

export function commitChanges(message: string, snapshotId: string): void {
  try {
    execSync(`git commit -am "${message}"`, {
      stdio: "inherit",
    });
  } catch (error) {
    throw new Error(`Failed to commit changes: ${error}`);
  }
}

export function getChangedFiles(): string[] {
  const output = execSync("git diff --name-only HEAD", {
    encoding: "utf-8",
  });

  return output
    .trim()
    .split("\n")
    .filter((f) => f.length > 0);
}

export function assertNoExtraChanges(
  approvedFiles: string[],
  actualFiles: string[]
): void {
  const approvedSet = new Set(approvedFiles);
  const extraFiles = actualFiles.filter((f) => !approvedSet.has(f));

  if (extraFiles.length > 0) {
    throw new Error(
      `Governance violation: execution modified undeclared files:\n${extraFiles.join("\n")}`
    );
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ legacy/governance/fsm/stateMachine.ts

````typescript
import { GovernanceState } from "../GovernedAction";

/**
 * Only these state transitions are legally permitted
 * Any other transition is a governance violation
 */
const ALLOWED_TRANSITIONS: Record<GovernanceState, GovernanceState[]> = {
  DRAFT: ["PROPOSED"],
  PROPOSED: ["APPROVED", "REJECTED"],
  APPROVED: ["EXECUTED"],
  EXECUTED: ["OBSERVED"],
  OBSERVED: ["VERIFIED"],
  VERIFIED: [],
  REJECTED: [],
};

/**
 * Throw governance violation if transition is not permitted
 */
export function assertTransition(
  from: GovernanceState,
  to: GovernanceState
): void {
  const allowed = ALLOWED_TRANSITIONS[from].includes(to);

  if (!allowed) {
    throw new Error(
      `Governance violation: illegal state transition ${from} â†’ ${to}`
    );
  }
}

/**
 * Check if a transition is valid (without throwing)
 */
export function canTransition(
  from: GovernanceState,
  to: GovernanceState
): boolean {
  return ALLOWED_TRANSITIONS[from].includes(to);
}

/**
 * Get all possible next states from current state
 */
export function getNextStates(from: GovernanceState): GovernanceState[] {
  return [...ALLOWED_TRANSITIONS[from]];
}

/**
 * Validate that a state is valid
 */
export function isValidState(state: string): state is GovernanceState {
  return [
    "DRAFT",
    "PROPOSED",
    "APPROVED",
    "EXECUTED",
    "OBSERVED",
    "VERIFIED",
    "REJECTED",
  ].includes(state);
}

/**
 * State machine transition history entry
 */
export interface TransitionHistoryEntry {
  from: GovernanceState;
  to: GovernanceState;
  timestamp: number;
  reason?: string;
}

/**
 * State machine for tracking governance state transitions
 * Enforces constitutional invariants
 */
export class GovernanceStateMachine {
  private currentState: GovernanceState;
  private history: TransitionHistoryEntry[] = [];

  constructor(initialState: GovernanceState) {
    if (!isValidState(initialState)) {
      throw new Error(`Invalid initial state: ${initialState}`);
    }
    this.currentState = initialState;
  }

  get current(): GovernanceState {
    return this.currentState;
  }

  get transitionHistory(): TransitionHistoryEntry[] {
    return [...this.history];
  }

  transition(to: GovernanceState, reason?: string): void {
    assertTransition(this.currentState, to);

    this.history.push({
      from: this.currentState,
      to,
      timestamp: Date.now(),
      reason,
    });

    this.currentState = to;
  }

  isTerminal(): boolean {
    return this.currentState === "VERIFIED" || this.currentState === "REJECTED";
  }

  canProceedTo(state: GovernanceState): boolean {
    return canTransition(this.currentState, state);
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ legacy/governance/index.ts

````typescript
export * from "./GovernedAction";
export * from "./GovernanceEngine";
export * from "./actions/CodeChangeAction";
export * from "./fsm/stateMachine";
export * from "./review/diffParser";
export * from "./review/render";
export * from "./execution/sandbox";
export * from "./capability/token";
export * from "./storage/store";

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ legacy/governance/review/diffParser.ts

````typescript
export interface DiffFile {
  file: string;
  additions: number;
  deletions: number;
  hunks: string[];
}

export function parseUnifiedDiff(diff: string): DiffFile[] {
  const files: DiffFile[] = [];
  let current: DiffFile | null = null;

  for (const line of diff.split("\n")) {
    if (line.startsWith("diff --git")) {
      if (current) {
        files.push(current);
      }
      const match = line.match(/b\/(.+)$/);
      const file = match ? match[1] : "unknown";
      current = { file, additions: 0, deletions: 0, hunks: [] };
    } else if (!current) {
      continue;
    } else if (line.startsWith("+") && !line.startsWith("+++")) {
      current.additions++;
    } else if (line.startsWith("-") && !line.startsWith("---")) {
      current.deletions++;
    } else if (line.startsWith("@@")) {
      current.hunks.push(line);
    }
  }

  if (current) {
    files.push(current);
  }

  return files;
}

export function extractFilesFromDiff(diff: string): string[] {
  const files: string[] = [];
  const filePattern = /^\+\+\+ b\/(.+)$/gm;

  for (const match of diff.matchAll(filePattern)) {
    files.push(match[1]);
  }

  return files;
}

export function assessRisk(files: DiffFile[]): {
  level: "low" | "medium" | "high";
  warnings: string[];
} {
  const warnings: string[] = [];
  const totalLines = files.reduce(
    (sum, f) => sum + f.additions + f.deletions,
    0
  );

  if (totalLines > 300) {
    warnings.push(`Large changeset: ${totalLines} lines`);
  }

  if (files.length > 10) {
    warnings.push(`Many files touched: ${files.length}`);
  }

  if (totalLines > 1000) {
    return { level: "high", warnings };
  }

  if (totalLines > 300 || files.length > 10) {
    return { level: "medium", warnings };
  }

  return { level: "low", warnings };
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ legacy/governance/review/render.ts

````typescript
import chalk from "chalk";
import { DiffFile } from "./diffParser";

export function renderSummary(files: DiffFile[]): void {
  console.log(chalk.bold("\nDiff Summary\n"));

  for (const f of files) {
    console.log(
      `${chalk.cyan(f.file)}  ` +
      chalk.green(`+${f.additions}`) +
      " " +
      chalk.red(`-${f.deletions}`)
    );
  }
}

export function renderDiffForReview(
  files: DiffFile[],
  rationale: string
): void {
  console.log(
    chalk.bold.cyan("=".repeat(60))
  );
  console.log(chalk.bold.blue("Proposed Code Change"));
  console.log(
    chalk.bold.cyan("=".repeat(60))
  );

  console.log(`${chalk.bold("Rationale:")} ${rationale}\n`);

  for (const f of files) {
    console.log(chalk.yellow(`\nğŸ“„ ${f.file}`));
    console.log(
      `   ${chalk.green("+")} ${f.additions} lines added`
    );
    console.log(
      `   ${chalk.red("-")} ${f.deletions} lines deleted`
    );
  }

  console.log(
    chalk.bold.cyan("\n" + "=".repeat(60))
  );
}

export function renderRiskAssessment(
  level: "low" | "medium" | "high",
  warnings: string[]
): void {
  const levelColor = {
    low: chalk.green,
    medium: chalk.yellow,
    high: chalk.red,
  };

  console.log(
    chalk.bold(
      `\n${levelColor[level]}(\u26a0\ufe0f  Risk Level: ${level.toUpperCase()})`
    )
  );

  if (warnings.length > 0) {
    for (const w of warnings) {
      console.log(chalk.yellow(`   - ${w}`));
    }
  }
}

export function promptForApproval(): Promise<boolean> {
  const readline = require("readline");
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  return new Promise((resolve) => {
    rl.question(
      chalk.bold.yellow('\nType "YES" to approve, anything else to reject: '),
      (answer: string) => {
        rl.close();
        resolve(answer.trim() === "YES");
      }
    );
  });
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ legacy/governance/storage/store.ts

````typescript
import fs from "fs";
import path from "path";
import os from "os";

const DATA_DIR = path.join(os.homedir(), ".yuangs");
const STORE_PATH = path.join(DATA_DIR, "actions.json");

export interface SerializedAction {
  id: string;
  kind: string;
  state: string;
  payload: any;
  rationale: string;
  provenance: any;
  updatedAt: number;
  executedAt?: number;
}

export function ensureDataDir(): void {
  if (!fs.existsSync(DATA_DIR)) {
    fs.mkdirSync(DATA_DIR, { recursive: true });
  }
}

export function atomicWrite(filePath: string, data: string): void {
  const tmpPath = `${filePath}.tmp.${Date.now()}`;

  try {
    fs.writeFileSync(tmpPath, data, "utf-8");
    fs.renameSync(tmpPath, filePath);
  } catch (error) {
    if (fs.existsSync(tmpPath)) {
      fs.unlinkSync(tmpPath);
    }
    throw error;
  }
}

export function loadActions(): Record<string, SerializedAction> {
  ensureDataDir();

  if (!fs.existsSync(STORE_PATH)) {
    return {};
  }

  try {
    const content = fs.readFileSync(STORE_PATH, "utf-8");
    const data = JSON.parse(content);
    return deserializeActions(data);
  } catch (error) {
    console.error(`Failed to load actions: ${error}`);
    return {};
  }
}

export function saveActions(actions: Record<string, SerializedAction>): void {
  ensureDataDir();

  try {
    const content = JSON.stringify(actions, null, 2);
    atomicWrite(STORE_PATH, content);
  } catch (error) {
    console.error(`Failed to save actions: ${error}`);
    throw error;
  }
}

export function deserializeActions(
  data: Record<string, any>
): Record<string, SerializedAction> {
  const result: Record<string, SerializedAction> = {};

  for (const [id, raw] of Object.entries(data)) {
    try {
      result[id] = validateAction(raw);
    } catch (error) {
      console.warn(`Invalid action ${id}, skipping: ${error}`);
    }
  }

  return result;
}

function validateAction(raw: any): SerializedAction {
  if (typeof raw.id !== "string" || !raw.id) {
    throw new Error("Action missing valid id");
  }

  const validStates = [
    "DRAFT",
    "PROPOSED",
    "APPROVED",
    "EXECUTED",
    "OBSERVED",
    "VERIFIED",
    "REJECTED",
  ];

  if (!validStates.includes(raw.state)) {
    throw new Error(`Invalid state: ${raw.state}`);
  }

  if (typeof raw.rationale !== "string") {
    throw new Error("Rationale must be a string");
  }

  if (typeof raw.updatedAt !== "number") {
    throw new Error("UpdatedAt must be a number");
  }

  if (raw.state === "EXECUTED" && !raw.executedAt) {
    throw new Error("EXECUTED actions must have executedAt");
  }

  return raw as SerializedAction;
}

export function auditActions(actions: Record<string, SerializedAction>): void {
  for (const [id, action] of Object.entries(actions)) {
    try {
      validateAction(action);
    } catch (error) {
      throw new Error(`Audit failed for action ${id}: ${error}`);
    }
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ legacy/governance/verification/CodeChangeGovernance.tla

````text
---------------------------- MODULE CodeChangeGovernance --------------------
EXTENDS Naturals

CONSTANTS
  ACTIONS = {a1, a2}
  STATES = {DRAFT, PROPOSED, APPROVED, EXECUTED, OBSERVED, VERIFIED, REJECTED}

VARIABLES
  actionState \in [ACTIONS -> STATES]
  worldState
  snapshot
  caps

----------------------------------------------------------------------------
TYPE DEFINITION
----------------------------------------------------------------------------

ValidState == STATES

LegalTransition(from, to) ==
  /\ (from = DRAFT /\ to = PROPOSED)
  \/ (from = PROPOSED /\ (to = APPROVED \/ to = REJECTED))
  \/ (from = APPROVED /\ to = EXECUTED)
  \/ (from = EXECUTED /\ to = OBSERVED)
  \/ (from = OBSERVED /\ to = VERIFIED)

----------------------------------------------------------------------------
INITIAL STATE
----------------------------------------------------------------------------

Init ==
  /\ actionState = [a \in ACTIONS |-> DRAFT]
  /\ worldState = Empty
  /\ snapshot = 0
  /\ caps = Empty

----------------------------------------------------------------------------
INVARIANTS
----------------------------------------------------------------------------

StateInvariant ==
  /\A a \in ACTIONS : ValidState(actionState[a])

ApprovalInvariant ==
  /\A a \in ACTIONS :
      actionState[a] = APPROVED =>
        \/ \E t \in TIMES :
            /\ actionState[a] # t = PROPOSED
            /\ HumanApproved(t, a)

ExecutionInvariant ==
  /\A a \in ACTIONS :
      actionState[a] = EXECUTED =>
        \/ \E t \in TIMES :
            /\ actionState[a] # t = APPROVED
            /\ SnapshotCreated(t)
            /\ SnapshotValid(t)

NoExtraChangesInvariant ==
  /\A a \in ACTIONS :
      actionState[a] = EXECUTED =>
        WorldChanges \subseteq DeclaredChanges(a)

RevocableInvariant ==
  /\A a \in ACTIONS :
      actionState[a] = REJECTED =>
        /\A t' > t :
            actionState[a] # t' = REJECTED

CapabilityInvariant ==
  /\A a \in ACTIONS :
      actionState[a] = EXECUTED =>
        \/ \E c \in caps :
            CapabilityValid(c) /\
            CapabilitySubject(c) = a /\
            CapabilityGrantExecute(c, a)

----------------------------------------------------------------------------
TRANSITION ACTIONS
----------------------------------------------------------------------------

Propose(a) ==
  /\ actionState[a] = DRAFT
  /\ actionState' = [actionState EXCEPT ![a -> PROPOSED]]

Approve(a) ==
  /\ actionState[a] = PROPOSED
  /\ HumanApprovalPresent(a)
  /\ actionState' = [actionState EXCEPT ![a -> APPROVED]]

Reject(a) ==
  /\ actionState[a] \in {PROPOSED, APPROVED, EXECUTED, OBSERVED}
  /\ actionState' = [actionState EXCEPT ![a -> REJECTED]]

Execute(a, s) ==
  /\ actionState[a] = APPROVED
  /\ SnapshotExists(s)
  /\ snapshot = s
  /\ worldState' = ApplyDiff(worldState, a)
  /\ actionState' = [actionState EXCEPT ![a -> EXECUTED]]

Observe(a) ==
  /\ actionState[a] = EXECUTED
  /\ WorldChanges = GetGitDiff(worldState')
  /\ actionState' = [actionState EXCEPT ![a -> OBSERVED]]

Verify(a) ==
  /\ actionState[a] = OBSERVED
  /\ VerifyNoExtraChanges(a, worldState')
  /\ actionState' = [actionState EXCEPT ![a -> OBSERVED]]

Rollback(a, s) ==
  /\ actionState[a] = EXECUTED
  /\ SnapshotExists(s)
  /\ worldState' = s
  /\ actionState' = [actionState EXCEPT ![a -> REJECTED]]

IssueCap(c, agent, rights, scope) ==
  /\ c \notin caps
  /\ caps' = caps \cup {c}
  /\ CapabilitySignatureValid(c)

RevokeCap(c) ==
  /\ c \in caps
  /\ caps' = caps \ {c}

----------------------------------------------------------------------------
NEXT STATE RELATION
----------------------------------------------------------------------------

Next ==
  \/ \E a \in ACTIONS : Propose(a)
  \/ \E a \in ACTIONS : Approve(a)
  \/ \E a \in ACTIONS : Reject(a)
  \/ \E a \in ACTIONS, s \in Snapshot : Execute(a, s)
  \/ \E a \in ACTIONS : Observe(a)
  \/ \E a \in ACTIONS : Verify(a)
  \/ \E a \in ACTIONS, s \in Snapshot : Rollback(a, s)
  \/ \E c \in Cap, agent \in Agent, rights \in Rights, scope \in Scope : IssueCap(c, agent, rights, scope)
  \/ \E c \in Cap : RevokeCap(c)

----------------------------------------------------------------------------
THEOREMS
----------------------------------------------------------------------------

THEOREM NoSkippedStates ==
  ASSUMING Init /\ [][Next]_actionState
  PROVE  \A a \in ACTIONS :
              actionState[a] = EXECUTED =>
                \/ \E t1, t2, t3 \in TIMES :
                    actionState[a] # t1 = PROPOSED /\
                    actionState[a] # t2 = APPROVED /\
                    actionState[a] # t3 = EXECUTED

THEOREM NoUnauthorizedExecution ==
  ASSUMING Init /\ [][Next]_actionState
  PROVE  \A a \in ACTIONS :
              actionState[a] = EXECUTED =>
                HumanApprovedBeforeExecution(a)

THEOREM RollbackSafety ==
  ASSUMING Init /\ Execute(a, s) /\ Rollback(a, s)
  PROVE  worldState = s

THEOREM CapabilityEnforcement ==
  ASSUMING Init /\ [][Next]_caps
  PROVE  \A a \in ACTIONS, c \in caps :
              (c \in caps /\ CapabilitySubject(c) = a /\ CapabilityGrantExecute(c, a)) =>
                actionState[a] = EXECUTED

=============================================================================

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ policy/model/ModelRegistry.ts

````typescript
import { ModelCapabilities } from '../../core/modelMatcher';
import { AtomicCapability } from '../../core/capabilities';
import { ModelSpec } from '../token/types';

/**
 * ModelRegistry - æ¨¡å‹è§„æ ¼æ³¨å†Œè¡¨
 *
 * å°†ç°æœ‰çš„ ModelCapabilities æ‰©å±•ä¸º ModelSpecï¼Œ
 * æä¾›ç»Ÿä¸€çš„æ¨¡å‹ä¿¡æ¯æŸ¥è¯¢æ¥å£ã€‚
 */
export class ModelRegistry {
    private models: Map<string, ModelSpec> = new Map();

    constructor(baseCapabilities: ModelCapabilities[]) {
        baseCapabilities.forEach(cap => this.register(cap));
    }

    /**
     * æ³¨å†Œæ¨¡å‹è§„æ ¼
     */
    private register(cap: ModelCapabilities): void {
        const spec: ModelSpec = {
            name: cap.name,
            contextWindow: cap.contextWindow ?? 32768,
            costTier: cap.costProfile ?? 'medium',
            longContextCapable: cap.atomicCapabilities.includes(
                AtomicCapability.LONG_CONTEXT
            )
        };
        this.models.set(cap.name, spec);
    }

    /**
     * æ ¹æ®åç§°è·å–æ¨¡å‹è§„æ ¼
     */
    get(name: string): ModelSpec | undefined {
        return this.models.get(name);
    }

    /**
     * è·å–é»˜è®¤æ¨¡å‹
     */
    getDefault(): ModelSpec {
        const defaultModel = this.get('gemini-2.5-flash-lite');
        if (!defaultModel) {
            throw new Error('Default model not found in registry');
        }
        return defaultModel;
    }

    /**
     * æŸ¥æ‰¾æ‰€æœ‰æ”¯æŒé•¿æ–‡æœ¬çš„æ¨¡å‹
     * æŒ‰ä¸Šä¸‹æ–‡çª—å£å¤§å°é™åºæ’åˆ—
     */
    findLongContextCapable(): ModelSpec[] {
        return Array.from(this.models.values())
            .filter(m => m.longContextCapable)
            .sort((a, b) => b.contextWindow - a.contextWindow);
    }

    /**
     * æŸ¥æ‰¾æœ€ä½³é•¿æ–‡æœ¬æ¨¡å‹
     * è¿”å›ä¸Šä¸‹æ–‡çª—å£æœ€å¤§çš„æ¨¡å‹
     */
    findBestLongContextModel(): ModelSpec | undefined {
        const longContextModels = this.findLongContextCapable();
        return longContextModels.length > 0 ? longContextModels[0] : undefined;
    }

    /**
     * åˆ—å‡ºæ‰€æœ‰å·²æ³¨å†Œçš„æ¨¡å‹
     */
    listModels(): ModelSpec[] {
        return Array.from(this.models.values());
    }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ policy/sampler.ts

````typescript
import { PendingContextItem, SamplingStrategy } from '../policy/token/types';

/**
 * ContextSampler - ä¸Šä¸‹æ–‡é‡‡æ ·å™¨
 *
 * èŒè´£ï¼š
 * - å®ç° head_tail é‡‡æ ·ç­–ç•¥
 * - ä¿ç•™æ–‡ä»¶å¤´éƒ¨å’Œå°¾éƒ¨ï¼Œä¸¢å¼ƒä¸­é—´éƒ¨åˆ†
 */
export class ContextSampler {
    /**
     * å¯¹ PendingContextItem åº”ç”¨é‡‡æ ·ç­–ç•¥
     */
    static async applySampling(
        item: PendingContextItem,
        strategy: SamplingStrategy
    ): Promise<PendingContextItem> {
        if (strategy === 'none' || item.samplingStrategy === 'none') {
            return item;
        }

        if (strategy === 'head_tail' || item.samplingStrategy === 'head_tail') {
            return this.applyHeadTail(item);
        }

        if (strategy === 'random') {
            return this.applyRandom(item);
        }

        return item;
    }

    /**
     * Head-Tail é‡‡æ ·ï¼šä¿ç•™å¤´éƒ¨å’Œå°¾éƒ¨å„ 30 è¡Œ
     */
    private static async applyHeadTail(
        item: PendingContextItem
    ): Promise<PendingContextItem> {
        const resolved = await item.resolve();
        const lines = resolved.content.split('\n');

        const keepLines = 60;
        const headLines = Math.min(30, Math.floor(lines.length / 2));
        const tailLines = Math.min(30, Math.floor(lines.length / 2));

        const sampledLines = [
            ...lines.slice(0, headLines),
            // ...lines.slice(headLines, lines.length - tailLines), // è·³è¿‡ä¸­é—´éƒ¨åˆ†
            ...lines.slice(-tailLines)
        ];

        return {
            ...item,
            id: `${item.id} (sampled)`,
            resolve: async () => ({
                content: sampledLines.join('\n'),
                byteSize: Buffer.byteLength(sampledLines.join('\n'), 'utf-8'),
                lineCount: sampledLines.length
            })
        };
    }

    /**
     * Random é‡‡æ ·ï¼šéšæœºä¿ç•™ 50% çš„è¡Œ
     */
    private static async applyRandom(
        item: PendingContextItem
    ): Promise<PendingContextItem> {
        const resolved = await item.resolve();
        const lines = resolved.content.split('\n');

        const sampledLines = lines.filter((_, index) => Math.random() > 0.5);

        return {
            ...item,
            id: `${item.id} (random)`,
            resolve: async () => ({
                content: sampledLines.join('\n'),
                byteSize: Buffer.byteLength(sampledLines.join('\n'), 'utf-8'),
                lineCount: sampledLines.length
            })
        };
    }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ policy/syntaxHandler.ts

````typescript
import fs from 'fs/promises';
import path from 'path';
import { PendingContextItem, SamplingStrategy } from '../policy/token/types';

/**
 * SyntaxHandler - è¯­æ³•è§£æå™¨å’Œå»¶è¿ŸåŠ è½½ç”Ÿæˆå™¨
 *
 * èŒè´£ï¼š
 * - è§£æ @file å’Œ #dir è¯­æ³•
 * - è¿”å› PendingContextItem[]ï¼ˆä¸è¯»å–å†…å®¹ï¼‰
 * - æä¾› estimate() å’Œ resolve() æ–¹æ³•
 */
export class SyntaxHandler {
    static parse(tokens: string[]): PendingContextItem[] {
        const items: PendingContextItem[] = [];

        for (const token of tokens) {
            if (token.startsWith('@')) {
                const item = this.parseFileToken(token);
                if (item) items.push(item);
            } else if (token.startsWith('#')) {
                const item = this.parseDirToken(token);
                if (item) items.push(item);
            }
        }

        return items;
    }

    /**
     * è§£ææ–‡ä»¶å¼•ç”¨ @file:path:start-end
     */
    private static parseFileToken(token: string): PendingContextItem | null {
        const raw = token.slice(1);
        const { filePath, range } = this.parsePathAndRange(raw);

        if (!filePath) return null;

        const absPath = path.resolve(filePath);

        return {
            id: absPath,
            type: 'file',
            originalToken: token,
            samplingStrategy: 'head_tail',

            estimate: async () => {
                try {
                    const stat = await fs.stat(absPath);
                    return { byteSize: stat.size };
                } catch (error: any) {
                    throw error;
                }
            },

            resolve: async () => {
                let content = await fs.readFile(absPath, 'utf-8');

                if (range) {
                    content = this.applyRange(content, range);
                }

                return {
                    content,
                    byteSize: Buffer.byteLength(content, 'utf-8'),
                    lineCount: content.split('\n').length
                };
            }
        };
    }

    /**
     * è§£æç›®å½•å¼•ç”¨ #dir
     */
    private static parseDirToken(token: string): PendingContextItem | null {
        const dir = token.slice(1);
        const absPath = path.resolve(dir);

        return {
            id: absPath,
            type: 'dir',
            originalToken: token,
            samplingStrategy: 'head_tail',

            estimate: async () => {
                try {
                    const files = await this.scanDir(absPath);
                    let total = 0;
                    for (const f of files) {
                        const stat = await fs.stat(f);
                        total += stat.size;
                    }
                    return { byteSize: total };
                } catch (error: any) {
                    throw error;
                }
            },

            resolve: async () => {
                const files = await this.scanDir(absPath);
                let content = '';
                for (const f of files) {
                    content += `\n// ===== ${f} =====\n`;
                    content += await fs.readFile(f, 'utf-8');
                }
                return {
                    content,
                    byteSize: Buffer.byteLength(content, 'utf-8')
                };
            }
        };
    }

    /**
     * è§£æè·¯å¾„å’Œè¡Œå·èŒƒå›´
     */
    private static parsePathAndRange(raw: string): {
        filePath: string;
        range?: { start: number; end: number };
    } {
        const match = raw.match(/^(.*?)(?::(\d+)-(\d+))?$/);
        if (!match) return { filePath: raw };

        const [, filePath, start, end] = match;
        if (!start || !end) return { filePath };

        return {
            filePath,
            range: { start: Number(start), end: Number(end) }
        };
    }

    /**
     * åº”ç”¨è¡Œå·èŒƒå›´
     */
    private static applyRange(
        content: string,
        range?: { start: number; end: number }
    ): string {
        if (!range) return content;
        const lines = content.split('\n');
        return lines.slice(range.start - 1, range.end).join('\n');
    }

    /**
     * æ‰«æç›®å½•ï¼ˆé€’å½’ï¼‰
     */
    private static async scanDir(dirPath: string): Promise<string[]> {
        const files: string[] = [];

        async function scan(dirPath: string) {
            const entries = await fs.readdir(dirPath, { withFileTypes: true });

            for (const entry of entries) {
                const fullPath = path.join(dirPath, entry.name);

                if (entry.isDirectory()) {
                    await scan(fullPath);
                } else if (entry.isFile()) {
                    files.push(fullPath);
                }
            }
        }

        await scan(dirPath);
        return files;
    }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ policy/token/DefaultTokenPolicy.ts

````typescript
import { TokenPolicy, TokenPolicyInput, TokenPolicyResult, TokenAction } from './types';
import { TokenEstimator } from './TokenEstimator';

/**
 * DefaultTokenPolicy - é»˜è®¤çš„ 4 å±‚ Token æ²»ç†ç­–ç•¥
 *
 * ç­–ç•¥åˆ†å±‚ï¼š
 * - å®‰å…¨åŒº (â‰¤70%): ç›´æ¥æ”¾è¡Œ
 * - é¢„è­¦åŒº (70-80%): æ”¾è¡Œä½†è®°å½•è­¦å‘Š
 * - è­¦å‘ŠåŒº (80-100%): éœ€è¦ç”¨æˆ·ç¡®è®¤ï¼Œæä¾›å¤šç§è§£å†³æ–¹æ¡ˆ
 * - é˜»æ–­åŒº (>100%): å¼ºåˆ¶é˜»æ–­ï¼Œå¿…é¡»ä¿®æ”¹å†…å®¹æˆ–åˆ‡æ¢æ¨¡å‹
 */
export class DefaultTokenPolicy implements TokenPolicy {
    /**
     * è¯„ä¼° Token ä½¿ç”¨å¹¶è¿”å›å†³ç­–ç»“æœ
     */
    async evaluate(input: TokenPolicyInput): Promise<TokenPolicyResult> {
        const { model, contextItems, mode } = input;

        // 1. å¼‚æ­¥ä¼°ç®— Token æ¶ˆè€—ï¼ˆå…³é”®ï¼šæ­¤æ—¶æ–‡ä»¶å°šæœªè¯»å…¥å†…å­˜ï¼‰
        const summary = await TokenEstimator.estimate(contextItems);
        const limit = model.contextWindow;
        const ratio = summary.estimatedTokens / limit;

        // 2. æ£€æŸ¥é˜»å¡é”™è¯¯ï¼ˆæƒé™é—®é¢˜ç­‰ï¼‰
        if (summary.blockingError) {
            return this.createBlockResult(
                summary.estimatedTokens,
                limit,
                ratio,
                summary.blockingError,
                model
            );
        }

        // 3. æ‰§è¡Œ 4 å±‚ç­–ç•¥åˆ†æ”¯
        if (ratio <= 0.7 && summary.warnings.length === 0) {
            return this.createOkResult(
                summary.estimatedTokens,
                limit,
                ratio
            );
        }

        if (ratio <= 0.8) {
            return this.createWarnResult(
                summary.estimatedTokens,
                limit,
                ratio,
                summary.warnings,
                false
            );
        }

        if (ratio <= 1.0) {
            return this.createWarnResult(
                summary.estimatedTokens,
                limit,
                ratio,
                summary.warnings,
                true
            );
        }

        // > 100% - é˜»æ–­
        return this.createBlockResult(
            summary.estimatedTokens,
            limit,
            ratio,
            undefined,
            model
        );
    }

    /**
     * OK ç»“æœï¼ˆå®‰å…¨åŒºæˆ–é¢„è­¦åŒºï¼‰
     */
    private createOkResult(
        estimatedTokens: number,
        limit: number,
        ratio: number,
        message?: string
    ): TokenPolicyResult {
        return {
            status: 'ok',
            estimatedTokens,
            limit,
            ratio,
            message
        };
    }

    /**
     * Warn ç»“æœï¼ˆè­¦å‘ŠåŒºï¼Œæä¾›å¤šç§è§£å†³æ–¹æ¡ˆï¼‰
     */
    private createWarnResult(
        estimatedTokens: number,
        limit: number,
        ratio: number,
        warnings: Array<{ item: string; message: string }>,
        isDanger: boolean
    ): TokenPolicyResult {
        const actions: TokenAction[] = [
            {
                type: 'confirm_continue',
                label: 'ç»§ç»­æ‰§è¡Œ',
                desc: 'å¿½ç•¥é£é™©æŒ‰åŸæ ·å‘é€'
            }
        ];

        // å¦‚æœæ¨¡å‹ä¸æ”¯æŒé•¿æ–‡æœ¬ï¼Œæä¾›åˆ‡æ¢é€‰é¡¹
        if (isDanger) {
            actions.push({
                type: 'suggest_model_switch',
                label: 'åˆ‡æ¢è‡³é•¿æ–‡æœ¬æ¨¡å‹',
                desc: 'ä½¿ç”¨æ”¯æŒæ›´å¤§ä¸Šä¸‹æ–‡çš„æ¨¡å‹',
                targetModel: 'gemini-2.0-flash-exp'
            });
        }

        // Pipe æ¨¡å¼ä¸“å±ï¼šè‡ªåŠ¨é‡‡æ ·
        // æ³¨æ„ï¼šè¿™é‡Œåªæ˜¯å£°æ˜èƒ½åŠ›ï¼Œä¸å®é™…é‡‡æ ·
        actions.push({
            type: 'auto_sample_pipe',
            label: 'è‡ªåŠ¨é‡‡æ ·',
            desc: 'ä»…ä¿ç•™å¤´éƒ¨å’Œå°¾éƒ¨ä¿¡æ¯',
            strategy: 'head_tail'
        });

        actions.push({
            type: 'abort',
            label: 'ç»ˆæ­¢ä»»åŠ¡',
            desc: 'é€€å‡ºå½“å‰æ“ä½œ'
        });

        const baseMessage = isDanger
            ? `âš ï¸ ä¸Šä¸‹æ–‡å ç”¨ç‡ ${(ratio * 100).toFixed(1)}%ï¼Œæ¥è¿‘æ¨¡å‹é™åˆ¶ã€‚`
            : `â„¹ï¸  ä¸Šä¸‹æ–‡å ç”¨ç‡ ${(ratio * 100).toFixed(1)}%ã€‚`;

        const warningMessages = warnings.length > 0
            ? warnings.map(w => `  - ${w.message}`).join('\n')
            : '';

        return {
            status: 'warn',
            estimatedTokens,
            limit,
            ratio,
            message: `${baseMessage}${warningMessages ? '\n\nâš ï¸ è­¦å‘Š:\n' + warningMessages : ''}`,
            actions,
            warnings: warnings.map(w => w.message)
        };
    }

    /**
     * Block ç»“æœï¼ˆé˜»æ–­åŒºï¼‰
     */
    private createBlockResult(
        estimatedTokens: number,
        limit: number,
        ratio: number,
        blockingError: string | undefined,
        model: any
    ): TokenPolicyResult {
        const errorMessage = blockingError
            ? `â›” ${blockingError}`
            : `â›” ä¸Šä¸‹æ–‡è¶…é™ (${(ratio * 100).toFixed(1)}% / 100%)`;

        const actions: TokenAction[] = [];

        // å¦‚æœæ˜¯å› ä¸ºè¶…é™ï¼Œæä¾›æ¨¡å‹åˆ‡æ¢é€‰é¡¹
        if (!blockingError && model.longContextCapable === false) {
            actions.push({
                type: 'suggest_model_switch',
                label: 'åˆ‡æ¢è‡³é•¿æ–‡æœ¬æ¨¡å‹',
                desc: 'ä½¿ç”¨æ”¯æŒæ›´å¤§ä¸Šä¸‹æ–‡çš„æ¨¡å‹',
                targetModel: 'gemini-2.0-flash-exp'
            });
        }

        actions.push({
            type: 'abort',
            label: 'ç»ˆæ­¢ä»»åŠ¡',
            desc: 'é€€å‡ºå½“å‰æ“ä½œ'
        });

        return {
            status: 'block',
            estimatedTokens,
            limit,
            ratio,
            message: `${errorMessage}\n\nå¿…é¡»ç¼©å‡å†…å®¹æˆ–åˆ‡æ¢æ¨¡å‹æ‰èƒ½ç»§ç»­ã€‚`,
            actions,
            warnings: blockingError ? [blockingError] : undefined
        };
    }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ policy/token/TokenEstimator.ts

````typescript
import { PendingContextItem, EstimateSummary } from './types';

// é»˜è®¤å¹¶å‘é™åˆ¶
const DEFAULT_CONCURRENCY = 50;

/**
 * TokenEstimator - è½»é‡çº§ã€é›¶å‰¯ä½œç”¨çš„ Token é¢„ä¼°
 *
 * è®¾è®¡åŸåˆ™ï¼š
 * 1. åªè°ƒç”¨ estimate()ï¼Œä»ä¸è°ƒç”¨ resolve()
 * 2. æ”¯æŒå¹¶å‘æ§åˆ¶ï¼Œé¿å… EMFILE é”™è¯¯
 * 3. é”™è¯¯åˆ†ç±»ï¼šEACCES â†’ block, ENOENT â†’ warn
 */
export class TokenEstimator {
    /**
     * åŸºäº Promise.allSettled å¹¶å‘é¢„ä¼° Token æ¶ˆè€—
     *
     * @param items - å¾…ä¼°ç®—çš„ä¸Šä¸‹æ–‡é¡¹
     * @param concurrency - æœ€å¤§å¹¶å‘æ•°ï¼ˆé»˜è®¤ 50ï¼‰
     * @returns ä¼°ç®—æ‘˜è¦ï¼ŒåŒ…å« token æ•°ã€è­¦å‘Šå’Œé˜»å¡é”™è¯¯
     */
    static async estimate(
        items: PendingContextItem[],
        concurrency: number = DEFAULT_CONCURRENCY
    ): Promise<EstimateSummary> {
        const summary: EstimateSummary = {
            totalBytes: 0,
            estimatedTokens: 0,
            warnings: [],
            blockingError: undefined
        };

        if (items.length === 0) {
            return summary;
        }

        // ä½¿ç”¨å¹¶å‘æ§åˆ¶æ¥é¿å…æ–‡ä»¶æè¿°ç¬¦è€—å°½
        const batchResults = await this.batchEstimate(items, concurrency);

        // å¤„ç†ç»“æœ
        batchResults.forEach((result, idx) => {
            if (result.success) {
                const value = result.value;
                if (value) {
                    summary.totalBytes += value.byteSize;
                }
            } else {
                this.handleError(items[idx], result.error, summary);
            }
        });

        // è½¬æ¢å­—èŠ‚åˆ° Tokenï¼ˆç»éªŒå…¬å¼ï¼š1 token â‰ˆ 4 bytesï¼‰
        summary.estimatedTokens = Math.ceil(summary.totalBytes / 4);

        return summary;
    }

    /**
     * æ‰¹é‡ä¼°ç®—ï¼Œé™åˆ¶å¹¶å‘æ•°
     */
    private static async batchEstimate(
        items: PendingContextItem[],
        concurrency: number
    ): Promise<Array<{ success: boolean; value?: { byteSize: number }; error?: any }>> {
        const results: Array<{ success: boolean; value?: { byteSize: number }; error?: any }> = [];

        for (let i = 0; i < items.length; i += concurrency) {
            const batch = items.slice(i, i + concurrency);
            const batchPromises = batch.map(async (item, batchIdx) => {
                try {
                    const estimate = await item.estimate?.();
                    return { success: true, value: estimate || { byteSize: 0 } };
                } catch (error: any) {
                    return { success: false, error };
                }
            });

            const batchResults = await Promise.all(batchPromises);
            results.push(...batchResults);
        }

        return results;
    }

    /**
     * é”™è¯¯åˆ†ç±»å¤„ç†

    /**
     * é”™è¯¯åˆ†ç±»å¤„ç†
     *
     * è¯­ä¹‰å®šä¹‰ï¼š
     * - EACCES (æƒé™æ‹’ç») â†’ å¿…é¡»é˜»å¡ï¼Œæ— æ³•æ¢å¤
     * - ENOENT (æ–‡ä»¶ä¸å­˜åœ¨) â†’ è­¦å‘Šï¼Œæ–‡ä»¶å¯èƒ½è¢«åˆ é™¤
     * - EMFILE (æ–‡ä»¶æè¿°ç¬¦è¿‡å¤š) â†’ è­¦å‘Šï¼Œä¸´æ—¶ç³»ç»ŸçŠ¶æ€
     * - å…¶ä»–é”™è¯¯ â†’ è­¦å‘Šï¼Œé™çº§è¡Œä¸º
     */
    private static handleError(
        item: PendingContextItem,
        error: any,
        summary: EstimateSummary
    ): void {
        const errorCode = error?.code || 'UNKNOWN';

        switch (errorCode) {
            case 'EACCES':
                summary.blockingError = `Permission denied: ${item.id}`;
                break;

            case 'ENOENT':
                summary.warnings.push({
                    item: item.id,
                    message: `ENOENT: ${error.message || `File not found: ${item.id}`}`
                });
                break;

            case 'EMFILE':
                summary.warnings.push({
                    item: item.id,
                    message: `Too many open files: ${item.id}`
                });
                break;

            default:
                summary.warnings.push({
                    item: item.id,
                    message: `Estimate failed for ${item.id}: ${error.message || String(error)}`
                });
        }
    }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ registry/errors.ts

````typescript
export enum RegistryErrorCode {
  INIT_FAILED = 'INIT_FAILED',
  INVALID_MANIFEST = 'INVALID_MANIFEST',
  CHECKSUM_MISMATCH = 'CHECKSUM_MISMATCH',
  NOT_FOUND = 'NOT_FOUND',
  INVALID_STATE = 'INVALID_STATE',
  CAPABILITY_DENIED = 'CAPABILITY_DENIED',
  DEPENDENCY_CYCLE = 'DEPENDENCY_CYCLE',
  VERSION_CONFLICT = 'VERSION_CONFLICT'
}

export class RegistryError extends Error {
  readonly code: RegistryErrorCode;
  readonly details?: any;

  constructor(code: RegistryErrorCode, message: string, details?: any) {
    super(message);
    this.name = 'RegistryError';
    this.code = code;
    this.details = details;
    Error.captureStackTrace(this, this.constructor);
  }

  toJSON() {
    return {
      name: this.name,
      code: this.code,
      message: this.message,
      details: this.details
    };
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ registry/index.ts

````typescript
export * from './manifest';
export * from './registry';
export * from './errors';

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ registry/manifest.ts

````typescript
import { randomUUID } from 'crypto';
import { createHash } from 'crypto';

export type Capability = 
  | 'read:workspace'
  | 'write:workspace'
  | 'run:shell'
  | 'read:config'
  | 'write:config'
  | 'network:http'
  | 'secret:use'
  | 'secret:read'
  | string;

export type MacroState = 'draft' | 'approved' | 'deprecated';

export interface MacroDependency {
  macro: string;
  version: string;
  mode: 'inline' | 'isolated';
}

export interface MacroManifest {
  id: string;
  version: string;
  description: string;

  author: string;
  createdAt: number;
  updatedAt?: number;

  requires: Capability[];
  inputs?: Record<string, any>;

  checksum: string;
  state: MacroState;

  dependsOn?: MacroDependency[];
  tags?: string[];
  previousChecksum?: string;
}

export interface MacroPublishOptions {
  autoApprove?: boolean;
  skipCapabilityCheck?: boolean;
}

export interface MacroDiffResult {
  hasChanges: boolean;
  capabilityDiff: {
    added: Capability[];
    removed: Capability[];
    unchanged: Capability[];
  };
  requiresApproval: boolean;
  reason?: string;
}

export interface MacroRegistryConfig {
  storagePath: string;
  autoApproveSafe: boolean;
  maxRiskLevel: 'low' | 'medium' | 'high';
}

export function calculateChecksum(manifest: Omit<MacroManifest, 'checksum'>): string {
  const data = JSON.stringify({
    id: manifest.id,
    version: manifest.version,
    requires: manifest.requires.sort(),
    dependsOn: manifest.dependsOn
  });
  return createHash('sha256').update(data).digest('hex');
}

export function validateManifest(manifest: any): manifest is MacroManifest {
  if (!manifest.id || typeof manifest.id !== 'string') return false;
  if (!manifest.version || typeof manifest.version !== 'string') return false;
  if (!manifest.state || !['draft', 'approved', 'deprecated'].includes(manifest.state)) return false;
  if (!Array.isArray(manifest.requires)) return false;
  if (!manifest.checksum || typeof manifest.checksum !== 'string') return false;
  if (!manifest.author || typeof manifest.author !== 'string') return false;
  if (!manifest.createdAt || typeof manifest.createdAt !== 'number') return false;

  return true;
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ registry/registry.ts

````typescript
import fs from 'fs/promises';
import path from 'path';
import type {
  MacroManifest,
  MacroState,
  MacroPublishOptions,
  MacroDiffResult,
  MacroRegistryConfig,
  Capability
} from './manifest';
import { calculateChecksum, validateManifest } from './manifest';
import { RegistryError, RegistryErrorCode } from './errors';

export class MacroRegistry {
  private config: MacroRegistryConfig;
  private manifests: Map<string, MacroManifest[]> = new Map();

  constructor(config: Partial<MacroRegistryConfig> = {}) {
    this.config = {
      storagePath: config.storagePath || path.join(process.cwd(), '.yuangs_registry'),
      autoApproveSafe: config.autoApproveSafe ?? false,
      maxRiskLevel: config.maxRiskLevel || 'medium'
    };
  }

  async initialize(): Promise<void> {
    try {
      await fs.mkdir(this.config.storagePath, { recursive: true });
      await this.loadFromDisk();
    } catch (error) {
      throw new RegistryError(
        RegistryErrorCode.INIT_FAILED,
        `Failed to initialize registry: ${error}`
      );
    }
  }

  async publish(
    manifest: Omit<MacroManifest, 'checksum'>,
    options: MacroPublishOptions = {}
  ): Promise<MacroManifest> {
    const { autoApprove = this.config.autoApproveSafe, skipCapabilityCheck = false } = options;

    const newManifest: MacroManifest = {
      ...manifest,
      createdAt: manifest.createdAt || Date.now(),
      state: manifest.state || 'draft',
      checksum: calculateChecksum(manifest)
    };

    if (!validateManifest(newManifest)) {
      throw new RegistryError(
        RegistryErrorCode.INVALID_MANIFEST,
        'Invalid manifest structure'
      );
    }

    const existingVersions = this.manifests.get(manifest.id) || [];
    const existing = existingVersions.find(v => v.version === manifest.version);

    if (existing) {
      if (existing.checksum !== newManifest.checksum) {
        throw new RegistryError(
          RegistryErrorCode.CHECKSUM_MISMATCH,
          `Version ${manifest.version} already exists with different checksum`
        );
      }
      return existing;
    }

    if (existingVersions.length > 0) {
      const diff = this.compareCapabilities(existingVersions[existingVersions.length - 1], newManifest);

      if (!skipCapabilityCheck && diff.requiresApproval) {
        newManifest.state = 'draft';
        newManifest.previousChecksum = existingVersions[existingVersions.length - 1].checksum;
      } else if (autoApprove) {
        newManifest.state = 'approved';
      }
    } else if (autoApprove) {
      newManifest.state = 'approved';
    }

    existingVersions.push(newManifest);
    this.manifests.set(manifest.id, existingVersions);

    await this.saveToDisk();

    return newManifest;
  }

  async get(macroId: string, version?: string): Promise<MacroManifest | null> {
    const versions = this.manifests.get(macroId);
    if (!versions || versions.length === 0) {
      return null;
    }

    if (version) {
      return versions.find(v => v.version === version) || null;
    }

    return versions[versions.length - 1];
  }

  async list(filters?: {
    state?: MacroState;
    author?: string;
    tags?: string[];
  }): Promise<MacroManifest[]> {
    let results: MacroManifest[] = [];

    for (const versions of this.manifests.values()) {
      const latest = versions[versions.length - 1];
      results.push(latest);
    }

    if (filters) {
      results = results.filter(m => {
        if (filters.state && m.state !== filters.state) return false;
        if (filters.author && m.author !== filters.author) return false;
        if (filters.tags && filters.tags.length > 0) {
          const hasAllTags = filters.tags.every(tag => m.tags?.includes(tag));
          if (!hasAllTags) return false;
        }
        return true;
      });
    }

    return results.sort((a, b) => b.createdAt - a.createdAt);
  }

  async approve(macroId: string, version: string, approvedBy: string): Promise<MacroManifest> {
    const versions = this.manifests.get(macroId);
    if (!versions) {
      throw new RegistryError(
        RegistryErrorCode.NOT_FOUND,
        `Macro ${macroId} not found`
      );
    }

    const manifest = versions.find(v => v.version === version);
    if (!manifest) {
      throw new RegistryError(
        RegistryErrorCode.NOT_FOUND,
        `Version ${version} of macro ${macroId} not found`
      );
    }

    if (manifest.state !== 'draft') {
      throw new RegistryError(
        RegistryErrorCode.INVALID_STATE,
        `Macro ${macroId}@${version} is not in draft state`
      );
    }

    manifest.state = 'approved';
    manifest.updatedAt = Date.now();

    await this.saveToDisk();

    return manifest;
  }

  async deprecate(macroId: string, version?: string): Promise<MacroManifest> {
    const versions = this.manifests.get(macroId);
    if (!versions) {
      throw new RegistryError(
        RegistryErrorCode.NOT_FOUND,
        `Macro ${macroId} not found`
      );
    }

    if (version) {
      const manifest = versions.find(v => v.version === version);
      if (!manifest) {
        throw new RegistryError(
          RegistryErrorCode.NOT_FOUND,
          `Version ${version} of macro ${macroId} not found`
        );
      }

      if (manifest.state !== 'approved') {
        throw new RegistryError(
          RegistryErrorCode.INVALID_STATE,
          `Cannot deprecate macro in ${manifest.state} state`
        );
      }

      manifest.state = 'deprecated';
      manifest.updatedAt = Date.now();
    } else {
      for (const manifest of versions) {
        if (manifest.state === 'approved') {
          manifest.state = 'deprecated';
          manifest.updatedAt = Date.now();
        }
      }
    }

    await this.saveToDisk();

    return version ? versions.find(v => v.version === version)! : versions[versions.length - 1];
  }

  compareCapabilities(
    oldManifest: MacroManifest,
    newManifest: MacroManifest
  ): MacroDiffResult {
    const oldSet = new Set(oldManifest.requires);
    const newSet = new Set(newManifest.requires);

    const added: string[] = [];
    const removed: string[] = [];
    const unchanged: string[] = [];

    for (const cap of newManifest.requires) {
      if (!oldSet.has(cap)) {
        added.push(cap);
      } else {
        unchanged.push(cap);
      }
    }

    for (const cap of oldManifest.requires) {
      if (!newSet.has(cap)) {
        removed.push(cap);
      }
    }

    const highRiskAdded = added.some(cap => cap.includes('shell') || cap.includes('write') || cap.includes('delete'));
    const hasNewCapabilities = added.length > 0;
    const requiresApproval = highRiskAdded || (hasNewCapabilities && !this.config.autoApproveSafe);

    return {
      hasChanges: added.length > 0 || removed.length > 0,
      capabilityDiff: {
        added,
        removed,
        unchanged
      },
      requiresApproval,
      reason: requiresApproval ? 'New capabilities require approval' : undefined
    };
  }

  async getVersions(macroId: string): Promise<MacroManifest[]> {
    return this.manifests.get(macroId) || [];
  }

  private async loadFromDisk(): Promise<void> {
    try {
      const indexPath = path.join(this.config.storagePath, 'index.json');
      const data = await fs.readFile(indexPath, 'utf-8');
      const loaded = JSON.parse(data) as Record<string, MacroManifest[]>;

      for (const [id, versions] of Object.entries(loaded)) {
        this.manifests.set(id, versions);
      }
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
        console.warn(`Warning: Failed to load registry from disk: ${error}`);
      }
    }
  }

  private async saveToDisk(): Promise<void> {
    const indexPath = path.join(this.config.storagePath, 'index.json');
    const data = Object.fromEntries(this.manifests);
    await fs.writeFile(indexPath, JSON.stringify(data, null, 2), 'utf-8');
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ risk/explainer.ts

````typescript
import type { Capability, MacroManifest } from '../registry/manifest';

export type RiskLevel = 'low' | 'medium' | 'high';

export interface RiskAssessment {
  overallRisk: RiskLevel;
  score: number;
  factors: RiskFactor[];
  requiresApproval: boolean;
  explanation: string;
}

export interface RiskFactor {
  type: 'capability' | 'destructive' | 'dependency' | 'network' | 'secret';
  severity: RiskLevel;
  description: string;
  capability?: string;
  suggestion?: string;
}

export interface CapabilityNode {
  id: Capability;
  risk: RiskLevel;
  description: string;
  implies?: Capability[];
}

export interface CapabilityGraph {
  nodes: Map<Capability, CapabilityNode>;
  version: string;
}

export function createCapabilityGraph(): CapabilityGraph {
  const nodes = new Map<Capability, CapabilityNode>();

  nodes.set('read:workspace', {
    id: 'read:workspace',
    risk: 'low',
    description: 'Read files from the workspace',
    implies: ['read:config']
  });

  nodes.set('write:workspace', {
    id: 'write:workspace',
    risk: 'high',
    description: 'Write files to the workspace',
    implies: ['read:workspace', 'write:config']
  });

  nodes.set('run:shell', {
    id: 'run:shell',
    risk: 'high',
    description: 'Execute shell commands',
    implies: ['read:workspace', 'write:workspace']
  });

  nodes.set('read:config', {
    id: 'read:config',
    risk: 'low',
    description: 'Read configuration files'
  });

  nodes.set('write:config', {
    id: 'write:config',
    risk: 'medium',
    description: 'Write configuration files'
  });

  nodes.set('network:http', {
    id: 'network:http',
    risk: 'medium',
    description: 'Make HTTP requests'
  });

  nodes.set('secret:use', {
    id: 'secret:use',
    risk: 'high',
    description: 'Access secrets (without reading values)'
  });

  nodes.set('secret:read', {
    id: 'secret:read',
    risk: 'high',
    description: 'Read secret values'
  });

  return {
    nodes,
    version: '1.0.0'
  };
}

export class RiskExplainer {
  private graph: CapabilityGraph;
  private highRiskPatterns: RegExp[];

  constructor(graph?: CapabilityGraph) {
    this.graph = graph || createCapabilityGraph();
    this.highRiskPatterns = [
      /rm\s+-rf/i,
      />\s*\/dev\/null/,
      /dd\s+if=/,
      /sudo\s+rm/
    ];
  }

  explainRisk(manifest: MacroManifest): RiskAssessment {
    const factors: RiskFactor[] = [];

    for (const cap of manifest.requires) {
      const capRisk = this.assessCapability(cap);
      factors.push(...capRisk);
    }

    if (manifest.tags?.includes('destructive')) {
      factors.push({
        type: 'destructive',
        severity: 'high',
        description: 'Macro is tagged as destructive',
        suggestion: 'Requires manual approval from a senior developer'
      });
    }

    if (manifest.dependsOn && manifest.dependsOn.length > 0) {
      factors.push({
        type: 'dependency',
        severity: 'medium',
        description: `Depends on ${manifest.dependsOn.length} external macro(s)`,
        suggestion: 'Review dependency chain for transitive capabilities'
      });
    }

    const overallRisk = this.calculateOverallRisk(factors);
    const score = this.riskToScore(overallRisk);
    const requiresApproval = overallRisk !== 'low';

    return {
      overallRisk,
      score,
      factors,
      requiresApproval,
      explanation: this.generateExplanation(manifest, overallRisk, factors)
    };
  }

  expandCapabilities(capabilities: Capability[]): Capability[] {
    const expanded = new Set<Capability>();

    const stack = [...capabilities];

    while (stack.length > 0) {
      const cap = stack.pop()!;
      if (expanded.has(cap)) continue;

      expanded.add(cap);

      const node = this.graph.nodes.get(cap);
      if (node?.implies) {
        stack.push(...node.implies);
      }
    }

    return Array.from(expanded);
  }

  explainCapability(capability: Capability): string {
    const node = this.graph.nodes.get(capability);

    if (!node) {
      return `Unknown capability: ${capability}`;
    }

    let explanation = `${node.description} (Risk: ${node.risk.toUpperCase()})`;

    if (node.implies && node.implies.length > 0) {
      explanation += `\n  Implies: ${node.implies.join(', ')}`;
    }

    return explanation;
  }

  private assessCapability(capability: Capability): RiskFactor[] {
    const factors: RiskFactor[] = [];
    const node = this.graph.nodes.get(capability);

    if (!node) {
      factors.push({
        type: 'capability',
        severity: 'medium',
        description: `Unknown capability: ${capability}`,
        capability,
        suggestion: 'Define this capability in the graph'
      });
      return factors;
    }

    if (node.risk === 'high') {
      factors.push({
        type: 'capability',
        severity: 'high',
        description: `High-risk capability: ${capability}`,
        capability,
        suggestion: 'Ensure this capability is absolutely necessary'
      });
    }

    if (capability.includes('shell')) {
      factors.push({
        type: 'capability',
        severity: 'high',
        description: 'Shell execution capability - can run arbitrary commands',
        capability,
        suggestion: 'Review all shell commands carefully'
      });
    }

    if (capability.includes('secret')) {
      factors.push({
        type: 'secret',
        severity: 'high',
        description: 'Access to secrets',
        capability,
        suggestion: 'Ensure secrets are scoped properly'
      });
    }

    return factors;
  }

  private calculateOverallRisk(factors: RiskFactor[]): RiskLevel {
    if (factors.some(f => f.severity === 'high')) {
      return 'high';
    }
    if (factors.some(f => f.severity === 'medium')) {
      return 'medium';
    }
    return 'low';
  }

  private riskToScore(risk: RiskLevel): number {
    switch (risk) {
      case 'low': return 1;
      case 'medium': return 5;
      case 'high': return 10;
    }
  }

  private generateExplanation(
    manifest: MacroManifest,
    risk: RiskLevel,
    factors: RiskFactor[]
  ): string {
    let explanation = `Macro "${manifest.id}@${manifest.version}" has ${risk.toUpperCase()} risk.\n\n`;

    explanation += `Required capabilities (${manifest.requires.length}):\n`;
    for (const cap of manifest.requires) {
      explanation += `  - ${this.explainCapability(cap)}\n`;
    }

    if (factors.length > 0) {
      explanation += `\nRisk factors:\n`;
      for (const factor of factors) {
        explanation += `  [${factor.severity.toUpperCase()}] ${factor.description}\n`;
        if (factor.suggestion) {
          explanation += `      â†’ ${factor.suggestion}\n`;
        }
      }
    }

    explanation += `\n`;
    if (risk === 'high') {
      explanation += 'âš ï¸  This macro requires manual approval before execution.\n';
      explanation += 'Review the capabilities and ensure you understand the impact.\n';
    } else if (risk === 'medium') {
      explanation += 'âš ï¸  This macro has moderate risk. Consider the implications carefully.\n';
    } else {
      explanation += 'âœ… This macro has low risk and can be auto-approved.\n';
    }

    return explanation;
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ risk/index.ts

````typescript
export * from './explainer';

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ ssh/GovernedExecutor.ts

````typescript
import { SSHSession } from './SSHSession';
import { Recorder } from '../audit/Recorder';

/**
 * æ‰§è¡Œå†³ç­–
 */
export type ExecDecision =
  | { allowed: true; normalizedCmd: string; reasoning?: string }
  | { allowed: false; reason: string; riskLevel?: string; disclosure?: RiskDisclosure };

/**
 * é£é™©æŠ«éœ²ä¿¡æ¯
 */
export interface RiskDisclosure {
  command: string;
  riskLevel: string;
  impact: string;
  alternatives?: string[];
  requiresConfirmation: boolean;
}

/**
 * æ‰§è¡Œä¸Šä¸‹æ–‡
 */
export interface ExecutionContext {
  kind: 'ssh_cmd' | 'local_shell' | 'batch' | 'plan';
  command: string;
  host?: string;
  user?: string;
  cwd?: string;
  environment?: string;
}

/**
 * æ²»ç†æœåŠ¡æ¥å£
 */
export interface GovernanceService {
  evaluate(ctx: ExecutionContext): Promise<ExecDecision>;
}

/**
 * ææƒçŠ¶æ€
 */
export enum ElevationState {
  USER = 'USER',                     // æ™®é€šç”¨æˆ·
  AWAITING_APPROVAL = 'AWAITING_APPROVAL', // ç­‰å¾…å®¡æ‰¹
  PENDING_PWD = 'PENDING_PWD',       // æ­£åœ¨è¾“å…¥å¯†ç 
  ROOT = 'ROOT'                      // å·²è·å¾— Root æƒé™
}

/**
 * æ•æ„Ÿæµæ‹¦æˆªå™¨ (å¯†ç ä¿æŠ¤)
 */
export class SensitiveStreamInterceptor {
  private active = false;

  enter(): void {
    this.active = true;
  }

  exit(): void {
    this.active = false;
  }

  isActive(): boolean {
    return this.active;
  }

  /**
   * è¿”å› false è¡¨ç¤º: ä¸å…è®¸è¿›å…¥ AI / Audit
   */
  shouldRecord(): boolean {
    return !this.active;
  }
}

/**
 * SSH æ²»ç†æ‰§è¡Œå™¨
 * 
 * è¿™æ˜¯æ•´ä¸ªç³»ç»Ÿæœ€å€¼é’±çš„ç±»
 * 
 * èŒè´£:
 * - æ‹¦æˆª SSH å‘½ä»¤
 * - è°ƒç”¨æ²»ç†æœåŠ¡
 * - å¤„ç† sudo/su ææƒ
 * - ä¿æŠ¤å¯†ç æµ
 */
export class SSHGovernedExecutor {
  private elevation = ElevationState.USER;
  private sensitive = new SensitiveStreamInterceptor();

  // Prompt è¯†åˆ«æ­£åˆ™
  private static readonly SUDO_PASSWORD_PROMPT = /(\[sudo\] password for .+:|Password:)/i;
  private static readonly SUDO_FAILURE = /(sorry, try again|authentication failure)/i;
  private static readonly ROOT_PROMPT = /(^|\n).*#\s?$/;

  constructor(
    private session: SSHSession,
    private governance: GovernanceService,
    private recorder?: Recorder
  ) {
    // ç›‘å¬ PTY è¾“å‡º,è¿›è¡ŒçŠ¶æ€è·ƒè¿
    this.session.on('data', (buf: Buffer) => {
      this.handlePTYOutput(buf);
    });
  }

  /**
   * å¤„ç†å‘½ä»¤ (Enter é”®è§¦å‘)
   */
  /**
   * å¤„ç†å‘½ä»¤ (Enter é”®è§¦å‘)
   * @param unsentCommand å°šæœªå‘é€ç»™æœåŠ¡å™¨çš„å‘½ä»¤éƒ¨åˆ† (ç”¨äºè§£å†³æ‰“å­—å›æ˜¾é‡å¤é—®é¢˜)
   */
  async handleCommand(cmd: string, host?: string, user?: string, unsentCommand: string = cmd): Promise<void> {
    // å¯†ç è¾“å…¥é˜¶æ®µ: ç»ä¸æ²»ç†,ç›´æ¥é€ä¼ 
    if (this.elevation === ElevationState.PENDING_PWD) {
      // å¯†ç ä¹Ÿä¸è®°å½•åˆ°å®¡è®¡æ—¥å¿—
      // æ³¨æ„ï¼šè¿™é‡Œæˆ‘ä»¬åªå‘é€ unsent éƒ¨åˆ† + å›è½¦
      this.session.write(unsentCommand + '\n');
      return;
    }

    const isSudo = cmd.trim().startsWith('sudo ');
    const isSu = cmd.trim().startsWith('su ');

    // sudo å‘½ä»¤å¤„ç†
    if ((isSudo || isSu) && this.elevation === ElevationState.USER) {
      // é€ä¼  unsentCommand ç»™ sudo å¤„ç†é€»è¾‘
      await this.handleElevationRequest(cmd, host, user, unsentCommand);
      return;
    }

    // æ™®é€šå‘½ä»¤: è°ƒç”¨æ²»ç†æœåŠ¡
    const decision = await this.governance.evaluate({
      kind: 'ssh_cmd',
      command: cmd,
      host,
      user,
    });

    if (!decision.allowed) {
      this.renderBlock(decision);
      // è®°å½•æ‹¦æˆªäº‹ä»¶
      if (this.recorder && this.sensitive.shouldRecord()) {
        this.recorder.recordGovernance('blocked', {
          command: cmd,
          reason: decision.reason,
          risk: decision.riskLevel
        });
      }

      // å‘é€ Ctrl+C (\x03) ç»™æœåŠ¡å™¨ä»¥æ¸…é™¤å·²è¾“å…¥çš„ç¼“å†²å­—ç¬¦
      this.session.write('\x03');
      return;
    }

    // è®°å½•å®¡è®¡ (å¦‚æœä¸åœ¨æ•æ„Ÿé˜¶æ®µ)
    if (this.recorder && this.sensitive.shouldRecord()) {
      // è®°å½•æ²»ç†æ‰¹å‡†äº‹ä»¶
      if (decision.reasoning) {
        this.recorder.recordGovernance('allowed', {
          command: cmd,
          reasoning: decision.reasoning
        });
      }

      // è®°å½•è¾“å…¥
      this.recorder.recordInput(cmd + '\n', {
        elevation: this.elevation,
      });
    }

    // æ‰§è¡Œå‘½ä»¤
    // æ™ºèƒ½è¡¥å‘: å¦‚æœå‘½ä»¤æ²¡æœ‰è¢«æ²»ç†å±‚ä¿®æ”¹ï¼Œæˆ‘ä»¬åªéœ€è¦å‘é€æœªå‘é€çš„éƒ¨åˆ† + å›è½¦
    if (decision.normalizedCmd === cmd) {
      if (unsentCommand) {
        this.session.write(unsentCommand + '\r');
      } else {
        // å¦‚æœæ²¡æœ‰æœªå‘é€éƒ¨åˆ†ï¼Œåªå‘å›è½¦
        this.session.write('\r');
      }
    } else {
      // å¦‚æœå‘½ä»¤è¢«ä¿®æ”¹äº† (ä¾‹å¦‚è‡ªåŠ¨çº é”™)ï¼Œæˆ‘ä»¬éœ€è¦å…ˆæ¸…é™¤å·²æœ‰è¾“å…¥
      // å‘é€ Ctrl+C (æ¸…é™¤è¡Œ) + æ–°å‘½ä»¤ + å›è½¦
      this.session.write('\x03' + decision.normalizedCmd + '\r');
    }
  }

  /**
   * å¤„ç†ææƒè¯·æ±‚ (sudo/su)
   */
  private async handleElevationRequest(cmd: string, host?: string, user?: string, unsentCommand: string = cmd): Promise<void> {
    this.elevation = ElevationState.AWAITING_APPROVAL;

    const decision = await this.governance.evaluate({
      kind: 'ssh_cmd',
      command: cmd,
      host,
      user,
    });

    if (!decision.allowed) {
      this.elevation = ElevationState.USER;
      this.renderBlock(decision);
      // è®°å½•æ‹¦æˆª
      if (this.recorder && this.sensitive.shouldRecord()) {
        this.recorder.recordGovernance('elevation_blocked', {
          command: cmd,
          reason: decision.reason
        });
      }
      // æ¸…é™¤å·²è¾“å…¥çš„ sudo å‘½ä»¤
      this.session.write('\x03');
      return;
    }

    // å®¡æ‰¹é€šè¿‡,å…è®¸è¿›å…¥å¯†ç é˜¶æ®µ
    this.elevation = ElevationState.PENDING_PWD;
    this.sensitive.enter();

    // è®°å½•ææƒè¯·æ±‚è¢«æ‰¹å‡† (åœ¨è¿›å…¥æ•æ„Ÿæ¨¡å¼å‰è®°å½•)
    if (this.recorder) {
      this.recorder.recordGovernance('elevation_started', {
        command: cmd
      });
    }

    // åªå‘é€ unsent éƒ¨åˆ† + å›è½¦
    this.session.write(unsentCommand + '\r');
  }

  /**
   * å¤„ç† PTY è¾“å‡º (çŠ¶æ€è·ƒè¿)
   */
  private handlePTYOutput(buf: Buffer): void {
    const text = buf.toString('utf8');

    // sudo å¯†ç æç¤ºå‡ºç°
    if (
      this.elevation === ElevationState.PENDING_PWD &&
      SSHGovernedExecutor.SUDO_PASSWORD_PROMPT.test(text)
    ) {
      // ä¸è®°å½•ã€ä¸åˆ†æ,ç›´æ¥é€ä¼ 
      // ä½†éœ€è¦åœ¨æ²»ç†æ—¥å¿—ä¸­æ ‡è®°è¿™æ˜¯ä¸€ä¸ªæ•æ„Ÿæç¤º
      if (this.recorder) {
        // ä¸è¦è®°å½•å…·ä½“ textï¼Œåªè®°å½•äº‹ä»¶
        this.recorder.recordGovernance('sensitive_prompt_displayed');
      }
      // process.stdout.write(text);
      return;
    }

    // sudo å¤±è´¥
    if (
      this.elevation === ElevationState.PENDING_PWD &&
      SSHGovernedExecutor.SUDO_FAILURE.test(text)
    ) {
      this.elevation = ElevationState.USER;
      this.sensitive.exit();
      if (this.recorder) {
        this.recorder.recordGovernance('elevation_failed');
      }
    }

    // root shell æˆåŠŸ
    if (SSHGovernedExecutor.ROOT_PROMPT.test(text)) {
      this.elevation = ElevationState.ROOT;
      this.sensitive.exit();
      if (this.recorder) {
        this.recorder.recordGovernance('elevation_success_root');
      }
    }

    // å®¡è®¡æ§åˆ¶
    if (this.recorder && this.sensitive.shouldRecord()) {
      this.recorder.recordOutput(buf);
    }

    // process.stdout.write(buf);
  }

  /**
   * æ¸²æŸ“æ‹¦æˆªä¿¡æ¯
   */
  private renderBlock(decision: ExecDecision & { allowed: false }): void {
    console.error('\nğŸš« [GOVERNANCE BLOCK]');
    console.error(`   Reason: ${decision.reason}`);
    if (decision.riskLevel) {
      console.error(`   Risk Level: ${decision.riskLevel}`);
    }
    if (decision.disclosure) {
      console.error(`   Impact: ${decision.disclosure.impact}`);
      if (decision.disclosure.alternatives && decision.disclosure.alternatives.length > 0) {
        console.error(`   Alternatives:`);
        decision.disclosure.alternatives.forEach((alt) => {
          console.error(`     - ${alt}`);
        });
      }
    }
    console.error('');
  }

  /**
   * è·å–å½“å‰ææƒçŠ¶æ€
   */
  getElevationState(): ElevationState {
    return this.elevation;
  }

  /**
   * æ£€æŸ¥æ˜¯å¦åœ¨æ•æ„Ÿé˜¶æ®µ
   */
  isSensitive(): boolean {
    return this.sensitive.isActive();
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ ssh/InputBuffer.ts

````typescript
/**
 * å‘½ä»¤è¾¹ç•Œæ¢æµ‹å™¨
 * 
 * èŒè´£:
 * - ä»å­—ç¬¦æµä¸­æå–å®Œæ•´å‘½ä»¤
 * - åªåœ¨ Enter é”®æ—¶è§¦å‘æ²»ç†
 * 
 * è®¾è®¡åŸåˆ™:
 * - ä¸åˆ†æå­—ç¬¦
 * - ä¸åˆ†æ stdout
 * - åªåœ¨æ¢è¡Œç¬¦æ—¶æ²»ç†
 */
export class InputBuffer {
  private buffer = '';

  /**
   * æ¨å…¥å­—ç¬¦å—
   * 
   * @param chunk è¾“å…¥å­—ç¬¦
   * @returns å¦‚æœæ£€æµ‹åˆ°å®Œæ•´å‘½ä»¤,è¿”å›å‘½ä»¤å­—ç¬¦ä¸²;å¦åˆ™è¿”å› null
   */
  push(chunk: string): string | null {
    this.buffer += chunk;

    // å”¯ä¸€æ²»ç†è§¦å‘ç‚¹: æ£€æµ‹åˆ°æ¢è¡Œç¬¦
    if (chunk.includes('\n') || chunk.includes('\r')) {
      // ä¿ç•™åŸå§‹å‘½ä»¤ (åŒ…æ‹¬ç©ºæ ¼å’Œå¯èƒ½çš„æ§åˆ¶å­—ç¬¦), åªå»æ‰æœ«å°¾çš„æ¢è¡Œç¬¦
      const rawCmd = this.buffer.replace(/[\r\n]+$/, '');
      const cmd = InputBuffer.processBackspace(rawCmd);
      this.buffer = '';
      
      return cmd; 
    }

    return null;
  }

  /**
   * å¤„ç†æ§åˆ¶å­—ç¬¦ (å¦‚ Backspace)
   * æ¨¡æ‹Ÿç»ˆç«¯è¡Œä¸º: \x7f (DEL) æˆ– \b (BS) åˆ é™¤å‰ä¸€ä¸ªå­—ç¬¦
   */
  static processBackspace(input: string): string {
    const chars: string[] = [];
    for (const char of input) {
      if (char === '\x7f' || char === '\b') {
        if (chars.length > 0) {
          chars.pop();
        }
      } else {
        chars.push(char);
      }
    }
    return chars.join('');
  }

  /**
   * æ¸…ç©ºç¼“å†²åŒº
   */
  clear(): void {
    this.buffer = '';
  }

  /**
   * è·å–å½“å‰ç¼“å†²åŒºå†…å®¹ (ç”¨äºè°ƒè¯•)
   */
  peek(): string {
    return this.buffer;
  }

  /**
   * æ£€æŸ¥æ˜¯å¦æœ‰æœªå¤„ç†çš„å†…å®¹
   */
  hasContent(): boolean {
    return this.buffer.length > 0;
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ ssh/SSHSession.ts

````typescript
import { Client, ClientChannel, ConnectConfig } from 'ssh2';
import { EventEmitter } from 'events';

/**
 * SSH ä¼šè¯é…ç½®
 */
export interface SSHSessionOptions {
  host: string;
  port?: number;
  username: string;
  privateKey?: Buffer | string;
  password?: string;
  passphrase?: string;
}

/**
 * SSH ä¼šè¯ç®¡ç†å™¨
 * 
 * èŒè´£:
 * - ç®¡ç† SSH ç”Ÿå‘½å‘¨æœŸ
 * - ç®¡ç† PTY (ä¼ªç»ˆç«¯)
 * - å¤„ç† resize / signal
 * 
 * ä¸è´Ÿè´£:
 * - æ²»ç†é€»è¾‘
 * - å‘½ä»¤ç†è§£
 * - stdout è§£æ
 */
export class SSHSession extends EventEmitter {
  private conn = new Client();
  private channel?: ClientChannel;
  private cols = 80;
  private rows = 24;
  private connected = false;

  /**
   * å»ºç«‹ SSH è¿æ¥å¹¶æ‰“å¼€ shell
   */
  async connect(opts: SSHSessionOptions): Promise<void> {
    return new Promise((resolve, reject) => {
      const config: ConnectConfig = {
        host: opts.host,
        port: opts.port ?? 22,
        username: opts.username,
        readyTimeout: 60000, // Increase timeout to 60 seconds
      };

      if (opts.privateKey) {
        config.privateKey = opts.privateKey;
        if (opts.passphrase) {
          config.passphrase = opts.passphrase;
        }
      } else if (opts.password) {
        config.password = opts.password;
      }

      this.conn
        .on('ready', () => {
          this.connected = true;
          this.openShell()
            .then(resolve)
            .catch(reject);
        })
        .on('error', (err) => {
          this.connected = false;
          reject(err);
        })
        .on('close', () => {
          this.connected = false;
          this.emit('close');
        })
        .connect(config);
    });
  }

  /**
   * æ‰“å¼€ shell (PTY æ¨¡å¼)
   * 
   * å…³é”®: ä½¿ç”¨ shell() è€Œä¸æ˜¯ exec()
   * - sudo/su/vim/less éƒ½éœ€è¦ PTY
   * - è¿™æ˜¯"æ´»ç»ˆç«¯",ä¸æ˜¯ RPC
   */
  private openShell(): Promise<void> {
    return new Promise((resolve, reject) => {
      this.conn.shell(
        {
          term: 'xterm-256color',
          cols: this.cols,
          rows: this.rows,
        },
        (err, stream) => {
          if (err) return reject(err);

          this.channel = stream;

          // stdout/stderr åœ¨ PTY æ¨¡å¼ä¸‹æ˜¯åŒä¸€æ¡æµ
          // è¿™æ˜¯æ­£ç¡®è¡Œä¸º,ä¸è¦å°è¯•åŒºåˆ†
          stream.on('data', (data: Buffer) => {
            this.emit('data', data);
          });

          stream.on('close', () => {
            this.emit('close');
            this.conn.end();
          });

          stream.stderr?.on('data', (data: Buffer) => {
            this.emit('data', data);
          });

          resolve();
        }
      );
    });
  }

  /**
   * å†™å…¥è¿œç¨‹ PTY
   */
  write(data: string | Buffer): void {
    if (!this.channel) {
      throw new Error('SSH channel not ready');
    }
    this.channel.write(data);
  }

  /**
   * çª—å£å°ºå¯¸å˜æ›´ (xterm / terminal resize)
   * 
   * å…³é”®: å¦‚æœä¸å¤„ç† resize
   * - vim ä¼šé”™ä½
   * - tmux ä¼šå´©
   * - å›æ”¾ç”»é¢ä¼šé”™ä¹±
   */
  resize(cols: number, rows: number): void {
    this.cols = cols;
    this.rows = rows;
    if (this.channel) {
      this.channel.setWindow(rows, cols, 0, 0);
    }
  }

  /**
   * å‘é€æ§åˆ¶ä¿¡å· (Ctrl+C ç­‰)
   * 
   * æ³¨æ„: ssh2 ä¸ä¼šè‡ªåŠ¨å¤„ç†ä¿¡å·,å¿…é¡»æ‰‹å†™
   */
  sendSignal(signal: 'SIGINT' | 'SIGTERM' | 'SIGKILL'): void {
    if (!this.channel) return;

    switch (signal) {
      case 'SIGINT':
        // Ctrl+C - ASCII ETX (End of Text)
        this.channel.write('\x03');
        break;
      case 'SIGTERM':
        this.channel.signal('TERM');
        break;
      case 'SIGKILL':
        this.channel.signal('KILL');
        break;
    }
  }

  /**
   * æ£€æŸ¥è¿æ¥çŠ¶æ€
   */
  isConnected(): boolean {
    return this.connected;
  }

  /**
   * å…³é—­è¿æ¥
   */
  close(): void {
    if (this.channel) {
      this.channel.close();
    }
    this.conn.end();
    this.connected = false;
  }

  /**
   * è·å–å½“å‰ç»ˆç«¯å°ºå¯¸
   */
  getSize(): { cols: number; rows: number } {
    return { cols: this.cols, rows: this.rows };
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ types.d.ts

````typescript
declare module 'marked-terminal' {
    import { Renderer } from 'marked';
    export default class TerminalRenderer extends Renderer {
        constructor(options?: any);
    }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ utils/confirm.ts

````typescript
import * as readline from 'node:readline/promises';
import chalk from 'chalk';

export async function confirm(message: string): Promise<boolean> {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
    });

    try {
        const answer = await rl.question(chalk.yellow(`\nâš ï¸  ${message} (y/N) `));
        return answer.toLowerCase() === 'y';
    } finally {
        rl.close();
    }
}


````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ utils/globDetector.ts

````typescript
import fs from 'fs';
import path from 'path';

/**
 * Detects if the given pattern would expand to files/directories in the current directory
 * This is particularly important for patterns like '??' which could match 2-character filenames
 */
export function detectGlobExpansion(pattern: string, cwd: string = process.cwd()): string[] {
  try {
    // Handle common glob patterns that could be dangerous
    const matches: string[] = [];
    
    if (pattern === '??') {
      // Look for all 2-character filenames in the current directory
      const items = fs.readdirSync(cwd);
      for (const item of items) {
        if (item.length === 2) {
          const fullPath = path.join(cwd, item);
          const stat = fs.statSync(fullPath);
          matches.push(stat.isDirectory() ? `${item}/` : item);
        }
      }
    } else if (pattern === '?') {
      // Look for all 1-character filenames in the current directory
      const items = fs.readdirSync(cwd);
      for (const item of items) {
        if (item.length === 1) {
          const fullPath = path.join(cwd, item);
          const stat = fs.statSync(fullPath);
          matches.push(stat.isDirectory() ? `${item}/` : item);
        }
      }
    } else if (pattern === '*') {
      // Look for all items in the current directory
      const items = fs.readdirSync(cwd);
      for (const item of items) {
        const fullPath = path.join(cwd, item);
        const stat = fs.statSync(fullPath);
        matches.push(stat.isDirectory() ? `${item}/` : item);
      }
    } else if (pattern.endsWith('?')) {
      // Pattern like 'abc?' - look for files with one additional character
      const prefix = pattern.slice(0, -1);
      const items = fs.readdirSync(cwd);
      for (const item of items) {
        if (item.startsWith(prefix) && item.length === prefix.length + 1) {
          const fullPath = path.join(cwd, item);
          const stat = fs.statSync(fullPath);
          matches.push(stat.isDirectory() ? `${item}/` : item);
        }
      }
    } else if (pattern.endsWith('*')) {
      // Pattern like 'abc*' - look for files with that prefix
      const prefix = pattern.slice(0, -1);
      const items = fs.readdirSync(cwd);
      for (const item of items) {
        if (item.startsWith(prefix)) {
          const fullPath = path.join(cwd, item);
          const stat = fs.statSync(fullPath);
          matches.push(stat.isDirectory() ? `${item}/` : item);
        }
      }
    }
    
    return matches;
  } catch (error) {
    // If there's an error reading the directory, return empty array
    console.warn(`Warning: Could not read directory ${cwd} for glob detection:`, error);
    return [];
  }
}

/**
 * Checks if a raw input might be subject to shell glob expansion
 * Returns true if the input contains glob patterns that would match files
 */
export function wouldExpandAsGlob(rawInput: string, cwd: string = process.cwd()): { wouldExpand: boolean; matches: string[] } {
  const trimmed = rawInput.trim();
  
  // Check for common glob patterns
  if (trimmed === '??' || trimmed === '?' || trimmed === '*') {
    const matches = detectGlobExpansion(trimmed, cwd);
    return {
      wouldExpand: matches.length > 0,
      matches
    };
  }
  
  // Check for other patterns ending with ? or *
  if (trimmed.endsWith('?') || trimmed.endsWith('*')) {
    const matches = detectGlobExpansion(trimmed, cwd);
    return {
      wouldExpand: matches.length > 0,
      matches
    };
  }
  
  // Check if the input starts with a glob pattern followed by space and other content
  // e.g., "?? explain this command"
  const parts = trimmed.split(/\s+/);
  if (parts.length > 0) {
    const firstPart = parts[0];
    if (firstPart === '??' || firstPart === '?' || firstPart === '*') {
      const matches = detectGlobExpansion(firstPart, cwd);
      return {
        wouldExpand: matches.length > 0,
        matches
      };
    }
  }
  
  return {
    wouldExpand: false,
    matches: []
  };
}
````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ utils/history.ts

````typescript
import fs from 'fs';
import path from 'path';
import os from 'os';
import { parseCommandHistory, type HistoryEntry } from '../core/validation';

const HISTORY_FILE = path.join(os.homedir(), '.yuangs_cmd_history.json');

export type { HistoryEntry };

export function getCommandHistory(): HistoryEntry[] {
    if (fs.existsSync(HISTORY_FILE)) {
        try {
            return parseCommandHistory(fs.readFileSync(HISTORY_FILE, 'utf8'));
        } catch (e) { }
    }
    return [];
}

export function saveHistory(entry: { question: string; command: string }) {
    let history = getCommandHistory();
    const newEntry: HistoryEntry = {
        ...entry,
        time: new Date().toLocaleString()
    };
    // Keep last 1000, unique commands
    history = [newEntry, ...history.filter(item => item.command !== entry.command)].slice(0, 1000);
    fs.writeFileSync(HISTORY_FILE, JSON.stringify(history, null, 2));
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ utils/renderer.ts

````typescript
import chalk from 'chalk';
import MarkdownIt from 'markdown-it';
import ora, { Ora } from 'ora';
import Table from 'cli-table3';

/**
 * ç»ˆç«¯ Markdown åŸç”Ÿæ¸²æŸ“å™¨
 * 
 * æ ¸å¿ƒæ€æƒ³ï¼š
 * - ç›´æ¥ä½¿ç”¨ markdown-it çš„ md.parse() è§£æä¸º Tokens
 * - éå† Tokens å¹¶ç›´æ¥æ˜ å°„ä¸º ANSI æ ·å¼
 * - æ— éœ€ HTML ä¸­è½¬ï¼Œæ€§èƒ½æœ€ä¼˜
 * 
 * è¿™æ˜¯ ChatGPT CLI / Warp / Claude CLI çš„åšæ³•
 */

// å®šä¹‰ç»ˆç«¯æ ·å¼é…ç½®
const STYLES = {
  h1: (t: string) => chalk.bold.hex('#FF6B6B')(`# ${t}`),
  h2: (t: string) => chalk.bold.hex('#4ECDC4')(`## ${t}`),
  h3: (t: string) => chalk.bold.hex('#45B7D1')(`### ${t}`),
  h4: (t: string) => chalk.bold.hex('#96E6A1')(`#### ${t}`),
  h5: (t: string) => chalk.bold.hex('#DDA0DD')(`##### ${t}`),
  h6: (t: string) => chalk.bold.hex('#87CEEB')(`###### ${t}`),
  code: (t: string) => chalk.bgHex('#2D3748').hex('#CBD5E0')(` ${t} `),
  code_block: (t: string) => chalk.gray('â”‚ ') + chalk.yellowBright(t),
  bold: (t: string) => chalk.hex('#F06560')(t),
  italic: (t: string) => chalk.italic.hex('#C7B8EA')(t),
  link: (t: string) => chalk.underline.hex('#63B3ED')(t),
  list_item: (t: string) => `  ${chalk.yellow('â€¢')} ${t}`,
  ordered_item: (t: string, index: number) => `  ${chalk.cyan(`${index}.`)} ${t}`,
  blockquote: (t: string) => chalk.hex('#A0AEC0')(`> ${t}`),
};

interface RendererOptions {
  prefix?: string;
  autoFinish?: boolean;
  onChunkCallback?: (chunk: string) => void;
  quietMode?: boolean;
}

export class StreamMarkdownRenderer {
  private md: MarkdownIt;
  private prefix: string;
  private buffer: string = '';
  private isFirstOutput: boolean = true;
  private spinner: Ora | null = null;
  private startTime: number;
  private quietMode: boolean;
  private autoFinish: boolean;
  private onChunkCallback: ((chunk: string) => void) | null;

  constructor(prefix: string = chalk.bold.blue('ğŸ¤– AIï¼š'), spinner?: Ora, options?: RendererOptions | boolean) {
    this.prefix = prefix;
    this.spinner = spinner || null;
    this.startTime = Date.now();

    // Support both old boolean quietMode and new options object
    if (typeof options === 'boolean') {
      this.quietMode = options;
      this.autoFinish = false;
      this.onChunkCallback = null;
    } else {
      this.quietMode = options?.quietMode ?? false;
      this.autoFinish = options?.autoFinish ?? false;
      this.onChunkCallback = options?.onChunkCallback || null;
    }

    // åˆå§‹åŒ– markdown-itï¼ˆç¦ç”¨ HTMLï¼‰
    this.md = new MarkdownIt({
      html: false,
      xhtmlOut: false,
      breaks: true,
      langPrefix: 'language-',
      linkify: true,
      typographer: true,
      quotes: '""\'\''
    });
  }

  /**
   * å¤„ç†æµå¼ chunk
   * 
   * ç­–ç•¥ï¼š
   * 1. ç´¯ç§¯åˆ° buffer
   * 2. å®æ—¶è¾“å‡ºçº¯æ–‡æœ¬ï¼ˆä¸è§£æ Markdownï¼‰
   * 3. finish() æ—¶é‡æ–°æ¸²æŸ“å®Œæ•´å†…å®¹
   */
  public onChunk(chunk: string): void {
    if (this.spinner && this.spinner.isSpinning) {
      this.spinner.stop();
    }

    if (!this.quietMode) {
      if (this.isFirstOutput) {
        process.stdout.write(this.prefix);
        this.isFirstOutput = false;
      }

      // å®æ—¶è¾“å‡ºçº¯æ–‡æœ¬
      process.stdout.write(chunk);
    }

    this.buffer += chunk;

    // Call external callback if provided
    if (this.onChunkCallback) {
      this.onChunkCallback(chunk);
    }
  }

  /**
   * æµç»“æŸï¼Œæ¸²æŸ“å®Œæ•´ Markdown
   * 
   * ä½¿ç”¨ md.parse() è§£æ Tokensï¼Œç›´æ¥æ˜ å°„ä¸º ANSI
   */
  public finish(): string {
    // å¦‚æœ Spinner è¿˜åœ¨è½¬ï¼ˆè¯´æ˜æ²¡æœ‰ä»»ä½•è¾“å‡ºï¼‰ï¼Œå…ˆåœæ‰
    if (this.spinner && this.spinner.isSpinning) {
      this.spinner.stop();
    }

    // ä½¿ç”¨ Token éå†æ¸²æŸ“
    const rendered = this.render(this.buffer);

    if (this.quietMode) {
      if (this.buffer.trim()) {
        process.stdout.write(this.prefix + rendered + '\n');
      }
    } else if (this.buffer.trim()) {
      if (process.stdout.isTTY) {
        // TTY æ¨¡å¼ï¼šå›æ»šå¹¶æ¸²æŸ“æ ¼å¼åŒ–å†…å®¹
        const screenWidth = process.stdout.columns || 80;
        const totalContent = this.prefix + this.buffer;

        // è®¡ç®—åŸå§‹æ–‡æœ¬å ç”¨çš„å¯è§†è¡Œæ•°
        const lineCount = this.getVisualLineCount(totalContent, screenWidth);

        // 1. æ¸…é™¤å½“å‰è¡Œå‰©ä½™å†…å®¹
        process.stdout.write('\r\x1b[K');
        // 2. å‘ä¸Šå›æ»šå¹¶æ¸…é™¤ä¹‹å‰çš„è¡Œ
        for (let i = 0; i < lineCount - 1; i++) {
          process.stdout.write('\x1b[A\x1b[K');
        }

        // 3. è¾“å‡ºæ ¼å¼åŒ–åçš„ Markdown
        process.stdout.write(this.prefix + rendered + '\n');
      } else {
        // é TTY æ¨¡å¼ï¼ˆå¦‚ç®¡é“ï¼‰ï¼šè¾“å‡ºæ ¼å¼åŒ–å†…å®¹ï¼Œä¸å›æ»š
        process.stdout.write(this.prefix + rendered + '\n');
      }
    }

    const elapsed = (Date.now() - this.startTime) / 1000;
    const separator = 'â”€'.repeat(20);
    process.stdout.write(`\n${chalk.gray(separator)} (è€—æ—¶: ${elapsed.toFixed(2)}s) ${separator}\n\n`);

    return this.buffer;
  }

  /**
   * ä½¿ç”¨ markdown-it çš„ Token æ¸²æŸ“ Markdown
   * 
   * è¿™æ˜¯æ ¸å¿ƒå‡½æ•°ï¼šToken -> ANSI ç›´æ¥æ˜ å°„
   */
  private render(markdown: string): string {
    const tokens = this.md.parse(markdown, {});
    return this.traverse(tokens);
  }

  /**
   * éå† Tokens å¹¶è½¬æ¢ä¸º ANSI
   */
  private traverse(tokens: any[]): string {
    let output = '';
    let i = 0;
    let orderedListIndex = 1;
    let tableData: string[][] = [];
    let currentRow: string[] = [];
    let inTable = false;
    
    while (i < tokens.length) {
      const token = tokens[i];

      // å¤„ç†è¡¨æ ¼
      if (token.type === 'table_open') {
        inTable = true;
        tableData = [];
        i += 1;
        continue;
      }
      
      if (token.type === 'table_close') {
        inTable = false;
        if (tableData.length > 0) {
          output += this.renderTable(tableData) + '\n\n';
        }
        tableData = [];
        i += 1;
        continue;
      }
      
      if (inTable) {
        // æ”¶é›†è¡¨æ ¼å•å…ƒæ ¼å†…å®¹
        if (token.type === 'tr_open') {
          currentRow = [];
          i += 1;
          continue;
        }
        
        if (token.type === 'tr_close') {
          if (currentRow.length > 0) {
            tableData.push([...currentRow]);
          }
          currentRow = [];
          i += 1;
          continue;
        }
        
        if (token.type === 'th_open' || token.type === 'td_open') {
          const inlineToken = tokens[i + 1];
          if (inlineToken?.type === 'inline') {
            const content = this.renderInline(inlineToken.children || []);
            currentRow.push(content);
          }
          i += 3; // è·³è¿‡ inline å’Œ close
          continue;
        }
      }

      // å¤„ç†æ ‡é¢˜
      if (token.type === 'heading_open') {
        const level = token.tag as 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';
        // æŸ¥æ‰¾ inline token
        const inlineToken = tokens[i + 1];
        const content = inlineToken?.type === 'inline' 
          ? this.renderInline(inlineToken.children || [])
          : '';
        output += (STYLES[level] || STYLES.h6)(content) + '\n\n';
        i += 3; // è·³è¿‡ inline å’Œ close token
        continue;
      }

      // å¤„ç†æ®µè½
      if (token.type === 'paragraph_open') {
        // æŸ¥æ‰¾ inline token
        const inlineToken = tokens[i + 1];
        if (inlineToken?.type === 'inline') {
          output += this.renderInline(inlineToken.children || []) + '\n\n';
        }
        i += 3; // è·³è¿‡ inline å’Œ close token
        continue;
      }

      // å¤„ç†ä»£ç å—
      if (token.type === 'fence') {
        const code = token.content.trim();
        const lines = code.split('\n').map((l: string) => STYLES.code_block(l));
        output += chalk.gray('â•­' + 'â”€'.repeat(30)) + '\n';
        output += lines.join('\n') + '\n';
        output += chalk.gray('â•°' + 'â”€'.repeat(30)) + '\n\n';
        i += 1;
        continue;
      }

      if (token.type === 'code_block') {
        const code = token.content.trim();
        const lines = code.split('\n').map((l: string) => STYLES.code_block(l));
        output += lines.join('\n') + '\n\n';
        i += 1;
        continue;
      }

      // å¤„ç†æ— åºåˆ—è¡¨
      if (token.type === 'bullet_list_open') {
        i += 1;
        continue;
      }
      if (token.type === 'bullet_list_close') {
        output += '\n';
        i += 1;
        continue;
      }
      if (token.type === 'list_item_open') {
        // list_item å¯èƒ½åŒ…å«å¤šä¸ª tokenï¼Œæˆ‘ä»¬éœ€è¦æ”¶é›†æ‰€æœ‰æ–‡æœ¬
        let content = '';
        let j = i + 1;
        let depth = 1;
        
        while (j < tokens.length && depth > 0) {
          const t = tokens[j];
          if (t.type === 'list_item_open') depth++;
          if (t.type === 'list_item_close') depth--;
          
          if (depth === 1 && t.type === 'inline') {
            content += this.renderInline(t.children || []) + ' ';
          }
          j++;
        }
        
        output += STYLES.list_item(content.trim()) + '\n';
        i = j;
        continue;
      }

      // å¤„ç†æœ‰åºåˆ—è¡¨
      if (token.type === 'ordered_list_open') {
        i += 1;
        continue;
      }
      if (token.type === 'ordered_list_close') {
        output += '\n';
        orderedListIndex = 1;
        i += 1;
        continue;
      }
      // æœ‰åºåˆ—è¡¨çš„ list_item_open
      if (token.type === 'list_item_open' && i > 0 && tokens[i - 1]?.type === 'ordered_list_open') {
        let content = '';
        let j = i + 1;
        let depth = 1;
        
        while (j < tokens.length && depth > 0) {
          const t = tokens[j];
          if (t.type === 'list_item_open') depth++;
          if (t.type === 'list_item_close') depth--;
          
          if (depth === 1 && t.type === 'inline') {
            content += this.renderInline(t.children || []) + ' ';
          }
          j++;
        }
        
        output += STYLES.ordered_item(content.trim(), orderedListIndex++) + '\n';
        i = j;
        continue;
      }

      // å¤„ç†å¼•ç”¨å—
      if (token.type === 'blockquote_open') {
        let content = '';
        let j = i + 1;
        let depth = 1;
        
        while (j < tokens.length && depth > 0) {
          const t = tokens[j];
          if (t.type === 'blockquote_open') depth++;
          if (t.type === 'blockquote_close') depth--;
          
          if (depth === 1 && t.type === 'inline') {
            content += this.renderInline(t.children || []) + ' ';
          } else if (depth === 1 && t.type === 'softbreak') {
            content += '\n> ';
          }
          j++;
        }
        
        output += STYLES.blockquote(content.trim()) + '\n\n';
        i = j;
        continue;
      }

      // å¤„ç†æ°´å¹³çº¿
      if (token.type === 'hr') {
        output += chalk.gray('â”€'.repeat(40)) + '\n\n';
        i += 1;
        continue;
      }

      // å¤„ç†ç¡¬æ¢è¡Œå’Œè½¯æ¢è¡Œ
      if (token.type === 'hardbreak' || token.type === 'softbreak') {
        output += '\n';
        i += 1;
        continue;
      }

      // è·³è¿‡å…¶ä»– token
      i += 1;
    }

    return output.trim();
  }

  /**
   * æå– inline token çš„æ–‡æœ¬å†…å®¹
   */
  private extractInlineText(tokens: any[], index: number): string {
    const token = tokens[index];
    if (!token || token.type !== 'inline') {
      return '';
    }
    return this.renderInline(token.children || []);
  }

  /**
   * æ¸²æŸ“å†…è”æ ·å¼
   * 
   * è¿™æ˜¯æœ€å…³é”®çš„éƒ¨åˆ†ï¼šåŠ ç²—ã€æ–œä½“ã€å†…è”ä»£ç ã€é“¾æ¥
   */
  private renderInline(children: any[]): string {
    let result = '';
    
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      
      switch (child.type) {
        case 'text':
          result += child.content;
          break;
          
        case 'strong_open':
          result += STYLES.bold(children[++i].content);
          i++; // skip close
          break;
          
        case 'em_open':
        case 'italic_open':
          result += STYLES.italic(children[++i].content);
          i++;
          break;
          
        case 'code_inline':
          result += STYLES.code(child.content);
          break;
          
        case 'link_open':
          result += STYLES.link(children[++i].content);
          i++; // skip close
          break;
          
        case 'softbreak':
        case 'hardbreak':
          result += '\n';
          break;
          
        default:
          result += child.content || '';
      }
    }
    
    return result;
  }

  /**
   * è®¡ç®—æ–‡æœ¬åœ¨ç»ˆç«¯çš„å¯è§†è¡Œæ•°
   */
  private getVisualLineCount(text: string, screenWidth: number): number {
    const stripAnsi = (str: string) => str.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, '');

    const lines = text.split('\n');
    let totalLines = 0;

    for (const line of lines) {
      const expandedLine = line.replace(/\t/g, '        ');
      const cleanLine = stripAnsi(expandedLine);

      let lineWidth = 0;
      for (const char of cleanLine) {
        const code = char.codePointAt(0) || 0;
        lineWidth += code > 255 ? 2 : 1;
      }

      if (lineWidth === 0) {
        totalLines += 1;
      } else {
        totalLines += Math.ceil(lineWidth / screenWidth);
      }
    }

    return totalLines;
  }

  /**
   * Start chunking mode for Agent Runtime
   */
  public startChunking(): (chunk: string) => void {
    return (chunk: string) => {
      this.onChunk(chunk);
      
      if (this.autoFinish && this.isComplete()) {
        this.finish();
      }
    };
  }

  /**
   * æ¸²æŸ“è¡¨æ ¼ï¼ˆä½¿ç”¨ cli-table3ï¼‰
   */
  private renderTable(tableData: string[][]): string {
    if (tableData.length === 0) return '';

    const headers = tableData[0];
    const rows = tableData.slice(1);

    const table = new Table({
      head: headers,
      style: {
        head: ['cyan', 'bold'],
        border: ['gray'],
      },
      wordWrap: true,
      // ç®€åŒ–è¾¹æ¡†ï¼šåªä¿ç•™è¡¨å¤´ä¸‹çš„åˆ†éš”çº¿
      chars: {
        'top': 'â”€',
        'top-mid': 'â”¬',
        'top-left': 'â”Œ',
        'top-right': 'â”',
        'bottom': 'â”€',
        'bottom-mid': 'â”´',
        'bottom-left': 'â””',
        'bottom-right': 'â”˜',
        'left': 'â”‚',
        'left-mid': '',
        'mid': '',
        'mid-mid': '',
        'right': 'â”‚',
        'right-mid': '',
        'middle': 'â”‚'
      }
    });

    rows.forEach(row => {
      table.push(row);
    });

    return table.toString() + '\n';
  }

  /**
   * Check if response appears complete
   */
  private isComplete(): boolean {
    const trimmed = this.buffer.trim();
    return trimmed.endsWith('```') ||
           trimmed.endsWith('.') ||
           (trimmed.length > 50 && trimmed.endsWith('\n'));
  }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ utils/syntaxHandler.ts

````typescript
import fs from 'fs';
import chalk from 'chalk';
import path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';
import { buildPromptWithFileContent, readFilesContent } from '../core/fileReader';
import { ContextBuffer } from '../commands/contextBuffer';
import { loadContext, saveContext } from '../commands/contextStorage';

const execAsync = promisify(exec);

/**
 * è§£æå¹¶å¤„ç†ç‰¹æ®Šè¯­æ³•ï¼ˆ@ã€#ã€:ls ç­‰ï¼‰
 */
export async function handleSpecialSyntax(input: string, stdinData?: string): Promise<{ processed: boolean; result?: string }> {
    const trimmed = input.trim();

    // å¤„ç† @ æ–‡ä»¶å¼•ç”¨è¯­æ³•
    if (trimmed.startsWith('@')) {
        // æ£€æŸ¥æ˜¯å¦æ˜¯ @! ç«‹å³æ‰§è¡Œè¯­æ³•
        const immediateExecMatch = trimmed.match(/^@\s*!\s*(.+?)$/);
        if (immediateExecMatch) {
            const filePath = immediateExecMatch[1].trim();
            return await handleImmediateExec(filePath);
        }

        // æ£€æŸ¥æ˜¯å¦æ˜¯å¸¦è¡Œå·çš„è¯­æ³• @file:start-end
        const lineRangeMatch = trimmed.match(/^@\s*(.+?)(?::(\d+)(?:-(\d+))?)?\s*(?:\n(.*))?$/s);
        if (lineRangeMatch) {
            const filePath = lineRangeMatch[1];
            const startLine = lineRangeMatch[2] ? parseInt(lineRangeMatch[2]) : null;
            const endLine = lineRangeMatch[3] ? parseInt(lineRangeMatch[3]) : null;
            const question = lineRangeMatch[4] || (stdinData ? `åˆ†æä»¥ä¸‹æ–‡ä»¶å†…å®¹ï¼š\n\n${stdinData}` : 'è¯·åˆ†æè¿™ä¸ªæ–‡ä»¶');

            return await handleFileReference(filePath.trim(), startLine, endLine, question);
        }
    }

    // å¤„ç† # ç›®å½•å¼•ç”¨è¯­æ³•
    if (trimmed.startsWith('#')) {
        const dirMatch = trimmed.match(/^#\s*(.+?)\s*(?:\n(.*))?$/s);
        if (dirMatch) {
            const dirPath = dirMatch[1].trim();
            const question = dirMatch[2] || (stdinData ? `åˆ†æä»¥ä¸‹ç›®å½•å†…å®¹ï¼š\n\n${stdinData}` : 'è¯·åˆ†æè¿™ä¸ªç›®å½•');
            return await handleDirectoryReference(dirPath, question);
        }
    }

    // å¤„ç† :ls å‘½ä»¤
    if (trimmed === ':ls') {
        return await handleListContext();
    }

    // åœºæ™¯ 5.1: :exec åŸå­æ‰§è¡Œ
    if (trimmed.startsWith(':exec ')) {
        const command = trimmed.slice(6).trim();
        return await handleAtomicExec(command);
    }

    // å¤„ç† :cat [index] å‘½ä»¤
    if (trimmed === ':cat' || trimmed.startsWith(':cat ')) {
        const parts = trimmed.split(' ');
        const index = parts.length > 1 ? parseInt(parts[1]) : null;
        return await handleCatContext(index);
    }

    // å¤„ç† :clear å‘½ä»¤
    if (trimmed === ':clear') {
        return await handleClearContext();
    }

    // å¦‚æœä¸æ˜¯ç‰¹æ®Šè¯­æ³•ï¼Œè¿”å›æœªå¤„ç†
    return { processed: false };
}

async function handleFileReference(filePath: string, startLine: number | null = null, endLine: number | null = null, question?: string): Promise<{ processed: boolean; result: string }> {
    const fullPath = path.resolve(filePath);

    if (!fs.existsSync(fullPath) || !fs.statSync(fullPath).isFile()) {
        return { 
            processed: true, 
            result: `é”™è¯¯: æ–‡ä»¶ "${filePath}" ä¸å­˜åœ¨æˆ–ä¸æ˜¯ä¸€ä¸ªæ–‡ä»¶` 
        };
    }

    try {
        let content = fs.readFileSync(fullPath, 'utf-8');
        
        // å¦‚æœæŒ‡å®šäº†è¡Œå·èŒƒå›´ï¼Œåˆ™æå–ç›¸åº”è¡Œ
        if (startLine !== null) {
            const lines = content.split('\n');
            
            // éªŒè¯è¡Œå·èŒƒå›´
            if (startLine < 1 || startLine > lines.length) {
                return { 
                    processed: true, 
                    result: `é”™è¯¯: èµ·å§‹è¡Œå· ${startLine} è¶…å‡ºæ–‡ä»¶èŒƒå›´ (æ–‡ä»¶å…±æœ‰ ${lines.length} è¡Œ)` 
                };
            }

            const startIdx = startLine - 1; // è½¬æ¢ä¸ºæ•°ç»„ç´¢å¼•ï¼ˆä»0å¼€å§‹ï¼‰
            let endIdx = endLine ? Math.min(endLine, lines.length) : lines.length; // å¦‚æœæœªæŒ‡å®šç»“æŸè¡Œï¼Œåˆ™åˆ°æ–‡ä»¶æœ«å°¾

            if (endLine && (endLine < startLine || endLine > lines.length)) {
                return { 
                    processed: true, 
                    result: `é”™è¯¯: ç»“æŸè¡Œå· ${endLine} è¶…å‡ºæœ‰æ•ˆèŒƒå›´ (åº”åœ¨ ${startLine}-${lines.length} ä¹‹é—´)` 
                };
            }

            // æå–æŒ‡å®šèŒƒå›´çš„è¡Œ
            content = lines.slice(startIdx, endIdx).join('\n');
        }

        const contentMap = new Map<string, string>();
        contentMap.set(filePath, content);

        // æŒä¹…åŒ–åˆ°ä¸Šä¸‹æ–‡
        const contextBuffer = new ContextBuffer();
        const persisted = await loadContext();
        contextBuffer.import(persisted);

        contextBuffer.add({
            type: 'file',
            path: filePath + (startLine !== null ? `:${startLine}${endLine ? `-${endLine}` : ''}` : ''),
            content: content
        });

        await saveContext(contextBuffer.export());

        const prompt = buildPromptWithFileContent(
            `æ–‡ä»¶: ${filePath}${startLine !== null ? `:${startLine}${endLine ? `-${endLine}` : ''}` : ''}`,
            [filePath],
            contentMap,
            question || `è¯·åˆ†ææ–‡ä»¶: ${filePath}`
        );

        return { processed: true, result: prompt };
    } catch (error) {
        return { 
            processed: true, 
            result: `è¯»å–æ–‡ä»¶å¤±è´¥: ${error}` 
        };
    }
}

async function handleDirectoryReference(dirPath: string, question?: string): Promise<{ processed: boolean; result: string }> {
    const fullPath = path.resolve(dirPath);

    if (!fs.existsSync(fullPath) || !fs.statSync(fullPath).isDirectory()) {
        return { 
            processed: true, 
            result: `é”™è¯¯: ç›®å½• "${dirPath}" ä¸å­˜åœ¨æˆ–ä¸æ˜¯ä¸€ä¸ªç›®å½•` 
        };
    }

    try {
        const findCommand = process.platform === 'darwin' || process.platform === 'linux'
            ? `find "${fullPath}" -type f`
            : `dir /s /b "${fullPath}"`;

        const { stdout } = await execAsync(findCommand);
        const filePaths = stdout.trim().split('\n').filter(f => f);

        if (filePaths.length === 0) {
            return { 
                processed: true, 
                result: `ç›®å½• "${dirPath}" ä¸‹æ²¡æœ‰æ–‡ä»¶` 
            };
        }

        const contentMap = readFilesContent(filePaths);

        // æŒä¹…åŒ–åˆ°ä¸Šä¸‹æ–‡
        const contextBuffer = new ContextBuffer();
        const persisted = await loadContext();
        contextBuffer.import(persisted);

        contextBuffer.add({
            type: 'directory',
            path: dirPath,
            content: Array.from(contentMap.entries()).map(([p, c]) => `--- ${p} ---\n${c}`).join('\n\n')
        });

        await saveContext(contextBuffer.export());

        const prompt = buildPromptWithFileContent(
            `ç›®å½•: ${dirPath}\næ‰¾åˆ° ${filePaths.length} ä¸ªæ–‡ä»¶`,
            filePaths.map(p => path.relative(process.cwd(), p)),
            contentMap,
            question
        );

        return { processed: true, result: prompt };
    } catch (error) {
        return { 
            processed: true, 
            result: `è¯»å–ç›®å½•å¤±è´¥: ${error}` 
        };
    }
}

async function handleImmediateExec(filePath: string): Promise<{ processed: boolean; result: string }> {
    const fullPath = path.resolve(filePath);

    if (!fs.existsSync(fullPath)) {
        return { 
            processed: true, 
            result: `é”™è¯¯: æ–‡ä»¶ "${filePath}" ä¸å­˜åœ¨` 
        };
    }

    try {
        // 1. è¯»å–è„šæœ¬å†…å®¹
        const content = fs.readFileSync(fullPath, 'utf-8');
        
        console.log(chalk.gray(`æ­£åœ¨æ‰§è¡Œ ${filePath} å¹¶æ•è·è¾“å‡º...`));
        
        // 2. æ‰§è¡Œè„šæœ¬
        // æ³¨æ„ï¼šè¿™é‡Œä½¿ç”¨ execAsync æ•è·è¾“å‡º
        const { stdout, stderr } = await execAsync(`chmod +x "${fullPath}" && "${fullPath}"`, { cwd: process.cwd() });
        
        // 3. æ„é€ ç»„åˆä¸Šä¸‹æ–‡ (å¥‘çº¦è¦æ±‚ï¼šå‘½ä»¤å†…å®¹ + å®é™…è¾“å‡º)
        const combinedContext = `
=== è„šæœ¬å†…å®¹ (${filePath}) ===
\`\`\`bash
${content}
\`\`\`

=== æ‰§è¡Œæ ‡å‡†è¾“å‡º (stdout) ===
\`\`\`
${stdout}
\`\`\`

=== æ‰§è¡Œæ ‡å‡†é”™è¯¯ (stderr) ===
\`\`\`
${stderr}
\`\`\`
`;

        // æŒä¹…åŒ–åˆ°ä¸Šä¸‹æ–‡
        const contextBuffer = new ContextBuffer();
        const persisted = await loadContext();
        contextBuffer.import(persisted);

        contextBuffer.add({
            type: 'file',
            path: `${filePath} (Runtime Log)`,
            content: combinedContext,
            summary: 'åŒ…å«è„šæœ¬æºç å’Œæ‰§è¡Œåçš„è¾“å‡ºæ—¥å¿—'
        });

        await saveContext(contextBuffer.export());

        // è¿”å›ç»™ AI çš„ Prompt
        const result = `æˆ‘æ‰§è¡Œäº†è„šæœ¬ ${filePath}ã€‚\nä»¥ä¸‹æ˜¯è„šæœ¬æºç å’Œæ‰§è¡Œè¾“å‡ºï¼š\n${combinedContext}\n\nè¯·åˆ†æä¸ºä½•ä¼šå‡ºç°ä¸Šè¿°è¾“å‡ºï¼ˆç‰¹åˆ«æ˜¯é”™è¯¯ä¿¡æ¯ï¼‰ï¼Ÿ`;
        return { processed: true, result };
    } catch (error: any) {
        const errorMsg = error.message || String(error);
        const result = `æ‰§è¡Œè„šæœ¬ ${filePath} æ—¶å‘ç”Ÿé”™è¯¯ï¼š\n${errorMsg}\n\nè¯·åˆ†æåŸå› ã€‚`;
        return { processed: true, result };
    }
}

async function handleAtomicExec(command: string): Promise<{ processed: boolean; result: string }> {
    console.log(chalk.cyan(`\nâš¡ï¸ [Atomic Exec] æ‰§è¡Œå‘½ä»¤: ${command}\n`));
    
    try {
        // å¯¹äºåŸå­æ‰§è¡Œï¼Œæˆ‘ä»¬å¸Œæœ›ç”¨æˆ·èƒ½å®æ—¶çœ‹åˆ°è¾“å‡ºï¼Œæ‰€ä»¥ç”¨ inherit
        const { spawn } = require('child_process');
        const child = spawn(command, { 
            shell: true, 
            stdio: 'inherit' 
        });

        await new Promise<void>((resolve, reject) => {
            child.on('close', (code: number) => {
                if (code === 0) resolve();
                else reject(new Error(`Exit code ${code}`));
            });
            child.on('error', reject);
        });
        
        // åŸå­æ‰§è¡Œä¸å°†ç»“æœä¼ ç»™ AIï¼Œç›´æ¥è¿”å›ç©ºç»“æœè¡¨ç¤ºå¤„ç†å®Œæˆ
        return { processed: true, result: '' }; 
    } catch (error) {
        console.error(chalk.red(`æ‰§è¡Œå¤±è´¥: ${error}`));
        return { processed: true, result: '' };
    }
}

async function handleListContext(): Promise<{ processed: boolean; result: string }> {
    try {
        const persisted = await loadContext();
        const contextBuffer = new ContextBuffer();
        contextBuffer.import(persisted);

        if (contextBuffer.isEmpty()) {
            return { processed: true, result: 'å½“å‰æ²¡æœ‰ä¸Šä¸‹æ–‡' };
        }

        const list = contextBuffer.list();
        let result = 'å½“å‰ä¸Šä¸‹æ–‡åˆ—è¡¨ï¼š\n';
        list.forEach((item, index) => {
            result += `${index + 1}. ${item.type}: ${item.path} (${item.tokens} tokens)\n`;
        });

        return { processed: true, result };
    } catch (error) {
        return { 
            processed: true, 
            result: `è¯»å–ä¸Šä¸‹æ–‡å¤±è´¥: ${error}` 
        };
    }
}

async function handleCatContext(index: number | null): Promise<{ processed: boolean; result: string }> {
    try {
        const persisted = await loadContext();
        const contextBuffer = new ContextBuffer();
        contextBuffer.import(persisted);

        if (contextBuffer.isEmpty()) {
            return { processed: true, result: 'å½“å‰æ²¡æœ‰ä¸Šä¸‹æ–‡' };
        }

        const items = contextBuffer.export();

        if (index !== null) {
            // æŸ¥çœ‹æŒ‡å®šç´¢å¼•
            if (index < 1 || index > items.length) {
                return { processed: true, result: `é”™è¯¯: ç´¢å¼• ${index} è¶…å‡ºèŒƒå›´ (å…±æœ‰ ${items.length} ä¸ªé¡¹ç›®)` };
            }
            const item = items[index - 1];
            return { 
                processed: true, 
                result: `--- [${index}] ${item.type}: ${item.path} ---\n${item.content}\n--- End ---` 
            };
        } else {
            // æŸ¥çœ‹å…¨éƒ¨
            let result = '=== å½“å‰å®Œæ•´ä¸Šä¸‹æ–‡å†…å®¹ ===\n\n';
            items.forEach((item, i) => {
                result += `--- [${i + 1}] ${item.type}: ${item.path} ---\n${item.content}\n\n`;
            });
            result += '==========================';
            return { processed: true, result };
        }
    } catch (error) {
        return { 
            processed: true, 
            result: `è¯»å–ä¸Šä¸‹æ–‡å¤±è´¥: ${error}` 
        };
    }
}

async function handleClearContext(): Promise<{ processed: boolean; result: string }> {
    try {
        // æ¸…é™¤æŒä¹…åŒ–å­˜å‚¨
        await saveContext([]);
        
        return { processed: true, result: 'ä¸Šä¸‹æ–‡å·²æ¸…ç©ºï¼ˆå«æŒä¹…åŒ–ï¼‰' };
    } catch (error) {
        return { 
            processed: true, 
            result: `æ¸…é™¤ä¸Šä¸‹æ–‡å¤±è´¥: ${error}` 
        };
    }
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

---
### ğŸ“Š æœ€ç»ˆç»Ÿè®¡æ±‡æ€»
- **æ–‡ä»¶æ€»æ•°:** 152
- **ä»£ç æ€»è¡Œæ•°:** 21213
- **ç‰©ç†æ€»å¤§å°:** 617.83 KB
