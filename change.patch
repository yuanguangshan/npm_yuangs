diff --git a/asconfig.json b/asconfig.json
new file mode 100644
index 0000000..9673c0b
--- /dev/null
+++ b/asconfig.json
@@ -0,0 +1,21 @@
+{
+    "targets": {
+        "debug": {
+            "outFile": "build/governance.debug.wasm",
+            "textFile": "build/governance.debug.wat",
+            "sourceMap": true,
+            "debug": true
+        },
+        "release": {
+            "outFile": "build/governance.release.wasm",
+            "textFile": "build/governance.release.wat",
+            "optimizeLevel": 3,
+            "shrinkLevel": 1,
+            "converge": false,
+            "noAssert": false
+        }
+    },
+    "options": {
+        "bindings": "esm"
+    }
+}
\ No newline at end of file
diff --git a/build/governance.release.d.ts b/build/governance.release.d.ts
new file mode 100644
index 0000000..7dd3bdf
--- /dev/null
+++ b/build/governance.release.d.ts
@@ -0,0 +1,10 @@
+/** Exported memory */
+export declare const memory: WebAssembly.Memory;
+/**
+ * src/agent/governance/sandbox/core.as/evaluate
+ * @param proposal `~lib/string/String`
+ * @param rules `~lib/string/String`
+ * @param ledger `~lib/string/String`
+ * @returns `~lib/string/String`
+ */
+export declare function evaluate(proposal: string, rules: string, ledger: string): string;
diff --git a/build/governance.release.js b/build/governance.release.js
new file mode 100644
index 0000000..a6fc8a2
--- /dev/null
+++ b/build/governance.release.js
@@ -0,0 +1,85 @@
+async function instantiate(module, imports = {}) {
+  const adaptedImports = {
+    env: Object.assign(Object.create(globalThis), imports.env || {}, {
+      abort(message, fileName, lineNumber, columnNumber) {
+        // ~lib/builtins/abort(~lib/string/String | null?, ~lib/string/String | null?, u32?, u32?) => void
+        message = __liftString(message >>> 0);
+        fileName = __liftString(fileName >>> 0);
+        lineNumber = lineNumber >>> 0;
+        columnNumber = columnNumber >>> 0;
+        (() => {
+          // @external.js
+          throw Error(`${message} in ${fileName}:${lineNumber}:${columnNumber}`);
+        })();
+      },
+    }),
+  };
+  const { exports } = await WebAssembly.instantiate(module, adaptedImports);
+  const memory = exports.memory || imports.env.memory;
+  const adaptedExports = Object.setPrototypeOf({
+    evaluate(proposal, rules, ledger) {
+      // src/agent/governance/sandbox/core.as/evaluate(~lib/string/String, ~lib/string/String, ~lib/string/String) => ~lib/string/String
+      proposal = __retain(__lowerString(proposal) || __notnull());
+      rules = __retain(__lowerString(rules) || __notnull());
+      ledger = __lowerString(ledger) || __notnull();
+      try {
+        return __liftString(exports.evaluate(proposal, rules, ledger) >>> 0);
+      } finally {
+        __release(proposal);
+        __release(rules);
+      }
+    },
+  }, exports);
+  function __liftString(pointer) {
+    if (!pointer) return null;
+    const
+      end = pointer + new Uint32Array(memory.buffer)[pointer - 4 >>> 2] >>> 1,
+      memoryU16 = new Uint16Array(memory.buffer);
+    let
+      start = pointer >>> 1,
+      string = "";
+    while (end - start > 1024) string += String.fromCharCode(...memoryU16.subarray(start, start += 1024));
+    return string + String.fromCharCode(...memoryU16.subarray(start, end));
+  }
+  function __lowerString(value) {
+    if (value == null) return 0;
+    const
+      length = value.length,
+      pointer = exports.__new(length << 1, 2) >>> 0,
+      memoryU16 = new Uint16Array(memory.buffer);
+    for (let i = 0; i < length; ++i) memoryU16[(pointer >>> 1) + i] = value.charCodeAt(i);
+    return pointer;
+  }
+  const refcounts = new Map();
+  function __retain(pointer) {
+    if (pointer) {
+      const refcount = refcounts.get(pointer);
+      if (refcount) refcounts.set(pointer, refcount + 1);
+      else refcounts.set(exports.__pin(pointer), 1);
+    }
+    return pointer;
+  }
+  function __release(pointer) {
+    if (pointer) {
+      const refcount = refcounts.get(pointer);
+      if (refcount === 1) exports.__unpin(pointer), refcounts.delete(pointer);
+      else if (refcount) refcounts.set(pointer, refcount - 1);
+      else throw Error(`invalid refcount '${refcount}' for reference '${pointer}'`);
+    }
+  }
+  function __notnull() {
+    throw TypeError("value must not be null");
+  }
+  return adaptedExports;
+}
+export const {
+  memory,
+  evaluate,
+} = await (async url => instantiate(
+  await (async () => {
+    const isNodeOrBun = typeof process != "undefined" && process.versions != null && (process.versions.node != null || process.versions.bun != null);
+    if (isNodeOrBun) { return globalThis.WebAssembly.compile(await (await import("node:fs/promises")).readFile(url)); }
+    else { return await globalThis.WebAssembly.compileStreaming(globalThis.fetch(url)); }
+  })(), {
+  }
+))(new URL("governance.release.wasm", import.meta.url));
diff --git a/build/governance.release.wasm b/build/governance.release.wasm
new file mode 100644
index 0000000..17423e2
Binary files /dev/null and b/build/governance.release.wasm differ
diff --git a/build/governance.release.wat b/build/governance.release.wat
new file mode 100644
index 0000000..3295c27
--- /dev/null
+++ b/build/governance.release.wat
@@ -0,0 +1,1969 @@
+(module
+ (type $0 (func))
+ (type $1 (func (param i32)))
+ (type $2 (func (param i32 i32) (result i32)))
+ (type $3 (func (param i32 i32)))
+ (type $4 (func (param i32) (result i32)))
+ (type $5 (func (param i32 i32 i32 i32)))
+ (type $6 (func (param i32 i32 i32)))
+ (type $7 (func (param i32 i32 i64)))
+ (type $8 (func (result i32)))
+ (type $9 (func (param i32 i32 i32) (result i32)))
+ (import "env" "abort" (func $~lib/builtins/abort (param i32 i32 i32 i32)))
+ (global $~lib/rt/itcms/total (mut i32) (i32.const 0))
+ (global $~lib/rt/itcms/threshold (mut i32) (i32.const 0))
+ (global $~lib/rt/itcms/state (mut i32) (i32.const 0))
+ (global $~lib/rt/itcms/visitCount (mut i32) (i32.const 0))
+ (global $~lib/rt/itcms/pinSpace (mut i32) (i32.const 0))
+ (global $~lib/rt/itcms/iter (mut i32) (i32.const 0))
+ (global $~lib/rt/itcms/toSpace (mut i32) (i32.const 0))
+ (global $~lib/rt/itcms/white (mut i32) (i32.const 0))
+ (global $~lib/rt/itcms/fromSpace (mut i32) (i32.const 0))
+ (global $~lib/rt/tlsf/ROOT (mut i32) (i32.const 0))
+ (global $~lib/rt/__rtti_base i32 (i32.const 2112))
+ (global $~lib/memory/__stack_pointer (mut i32) (i32.const 34900))
+ (memory $0 1)
+ (data $0 (i32.const 1036) ",")
+ (data $0.1 (i32.const 1048) "\02\00\00\00\10\00\00\00r\00m\00 \00-\00r\00f\00 \00/")
+ (data $1 (i32.const 1084) ",")
+ (data $1.1 (i32.const 1096) "\02\00\00\00\0e\00\00\00s\00u\00d\00o\00 \00r\00m")
+ (data $2 (i32.const 1132) "\8c")
+ (data $2.1 (i32.const 1144) "\02\00\00\00v\00\00\00{\00\"\00e\00f\00f\00e\00c\00t\00\"\00:\00 \00\"\00d\00e\00n\00y\00\"\00,\00 \00\"\00r\00e\00a\00s\00o\00n\00\"\00:\00 \00\"\00W\00A\00S\00M\00_\00S\00A\00N\00D\00B\00O\00X\00:\00 \00\c0hKm0R\c1kmp\'`}T\e4N\0c\ff:_6R;\96\ade\"\00}")
+ (data $3 (i32.const 1276) "\9c")
+ (data $3.1 (i32.const 1288) "\02\00\00\00~\00\00\00{\00\"\00e\00f\00f\00e\00c\00t\00\"\00:\00 \00\"\00d\00e\00n\00y\00\"\00,\00 \00\"\00r\00e\00a\00s\00o\00n\00\"\00:\00 \00\"\00W\00A\00S\00M\00_\00S\00A\00N\00D\00B\00O\00X\00:\00 \00&\8d,g\02_8^\a8\81\c0\80\0c\ff\efS\fd\80m\90\d7S\d2b\dd~\rg\a1R;e\fbQ\"\00}")
+ (data $4 (i32.const 1436) "\8c")
+ (data $4.1 (i32.const 1448) "\02\00\00\00p\00\00\00{\00\"\00e\00f\00f\00e\00c\00t\00\"\00:\00 \00\"\00a\00l\00l\00o\00w\00\"\00,\00 \00\"\00r\00e\00a\00s\00o\00n\00\"\00:\00 \00\"\00W\00A\00S\00M\00_\00S\00A\00N\00D\00B\00O\00X\00:\00 \00ir\06t\94\96\bbyB\\\8c\9a\c1\8b\1a\90\c7\8f\"\00}")
+ (data $5 (i32.const 1580) "<")
+ (data $5.1 (i32.const 1592) "\02\00\00\00(\00\00\00A\00l\00l\00o\00c\00a\00t\00i\00o\00n\00 \00t\00o\00o\00 \00l\00a\00r\00g\00e")
+ (data $6 (i32.const 1644) "<")
+ (data $6.1 (i32.const 1656) "\02\00\00\00 \00\00\00~\00l\00i\00b\00/\00r\00t\00/\00i\00t\00c\00m\00s\00.\00t\00s")
+ (data $9 (i32.const 1772) "<")
+ (data $9.1 (i32.const 1784) "\02\00\00\00$\00\00\00I\00n\00d\00e\00x\00 \00o\00u\00t\00 \00o\00f\00 \00r\00a\00n\00g\00e")
+ (data $10 (i32.const 1836) ",")
+ (data $10.1 (i32.const 1848) "\02\00\00\00\14\00\00\00~\00l\00i\00b\00/\00r\00t\00.\00t\00s")
+ (data $12 (i32.const 1916) "<")
+ (data $12.1 (i32.const 1928) "\02\00\00\00\1e\00\00\00~\00l\00i\00b\00/\00r\00t\00/\00t\00l\00s\00f\00.\00t\00s")
+ (data $13 (i32.const 1980) "<")
+ (data $13.1 (i32.const 1992) "\02\00\00\00*\00\00\00O\00b\00j\00e\00c\00t\00 \00a\00l\00r\00e\00a\00d\00y\00 \00p\00i\00n\00n\00e\00d")
+ (data $14 (i32.const 2044) "<")
+ (data $14.1 (i32.const 2056) "\02\00\00\00(\00\00\00O\00b\00j\00e\00c\00t\00 \00i\00s\00 \00n\00o\00t\00 \00p\00i\00n\00n\00e\00d")
+ (data $15 (i32.const 2112) "\04\00\00\00 \00\00\00 \00\00\00 ")
+ (export "__new" (func $~lib/rt/itcms/__new))
+ (export "__pin" (func $~lib/rt/itcms/__pin))
+ (export "__unpin" (func $~lib/rt/itcms/__unpin))
+ (export "__collect" (func $~lib/rt/itcms/__collect))
+ (export "__rtti_base" (global $~lib/rt/__rtti_base))
+ (export "memory" (memory $0))
+ (export "evaluate" (func $export:src/agent/governance/sandbox/core.as/evaluate))
+ (start $~start)
+ (func $~lib/rt/itcms/initLazy (param $0 i32) (result i32)
+  local.get $0
+  local.get $0
+  i32.store offset=4
+  local.get $0
+  local.get $0
+  i32.store offset=8
+  local.get $0
+ )
+ (func $~lib/rt/itcms/visitRoots
+  (local $0 i32)
+  (local $1 i32)
+  i32.const 1792
+  call $~lib/rt/itcms/__visit
+  i32.const 1600
+  call $~lib/rt/itcms/__visit
+  i32.const 2000
+  call $~lib/rt/itcms/__visit
+  i32.const 2064
+  call $~lib/rt/itcms/__visit
+  global.get $~lib/rt/itcms/pinSpace
+  local.tee $1
+  i32.load offset=4
+  i32.const -4
+  i32.and
+  local.set $0
+  loop $while-continue|0
+   local.get $0
+   local.get $1
+   i32.ne
+   if
+    local.get $0
+    i32.load offset=4
+    i32.const 3
+    i32.and
+    i32.const 3
+    i32.ne
+    if
+     i32.const 0
+     i32.const 1664
+     i32.const 160
+     i32.const 16
+     call $~lib/builtins/abort
+     unreachable
+    end
+    local.get $0
+    i32.const 20
+    i32.add
+    call $~lib/rt/__visit_members
+    local.get $0
+    i32.load offset=4
+    i32.const -4
+    i32.and
+    local.set $0
+    br $while-continue|0
+   end
+  end
+ )
+ (func $~lib/rt/itcms/Object#set:color (param $0 i32) (param $1 i32)
+  local.get $0
+  local.get $0
+  i32.load offset=4
+  i32.const -4
+  i32.and
+  local.get $1
+  i32.or
+  i32.store offset=4
+ )
+ (func $~lib/rt/itcms/Object#set:next (param $0 i32) (param $1 i32)
+  local.get $0
+  local.get $1
+  local.get $0
+  i32.load offset=4
+  i32.const 3
+  i32.and
+  i32.or
+  i32.store offset=4
+ )
+ (func $~lib/rt/itcms/Object#unlink (param $0 i32)
+  (local $1 i32)
+  local.get $0
+  i32.load offset=4
+  i32.const -4
+  i32.and
+  local.tee $1
+  i32.eqz
+  if
+   local.get $0
+   i32.load offset=8
+   i32.eqz
+   local.get $0
+   i32.const 34900
+   i32.lt_u
+   i32.and
+   i32.eqz
+   if
+    i32.const 0
+    i32.const 1664
+    i32.const 128
+    i32.const 18
+    call $~lib/builtins/abort
+    unreachable
+   end
+   return
+  end
+  local.get $0
+  i32.load offset=8
+  local.tee $0
+  i32.eqz
+  if
+   i32.const 0
+   i32.const 1664
+   i32.const 132
+   i32.const 16
+   call $~lib/builtins/abort
+   unreachable
+  end
+  local.get $1
+  local.get $0
+  i32.store offset=8
+  local.get $0
+  local.get $1
+  call $~lib/rt/itcms/Object#set:next
+ )
+ (func $~lib/rt/itcms/Object#linkTo (param $0 i32) (param $1 i32) (param $2 i32)
+  (local $3 i32)
+  local.get $1
+  i32.load offset=8
+  local.set $3
+  local.get $0
+  local.get $1
+  local.get $2
+  i32.or
+  i32.store offset=4
+  local.get $0
+  local.get $3
+  i32.store offset=8
+  local.get $3
+  local.get $0
+  call $~lib/rt/itcms/Object#set:next
+  local.get $1
+  local.get $0
+  i32.store offset=8
+ )
+ (func $~lib/rt/itcms/Object#makeGray (param $0 i32)
+  (local $1 i32)
+  (local $2 i32)
+  local.get $0
+  global.get $~lib/rt/itcms/iter
+  i32.eq
+  if
+   local.get $0
+   i32.load offset=8
+   local.tee $1
+   i32.eqz
+   if
+    i32.const 0
+    i32.const 1664
+    i32.const 148
+    i32.const 30
+    call $~lib/builtins/abort
+    unreachable
+   end
+   local.get $1
+   global.set $~lib/rt/itcms/iter
+  end
+  local.get $0
+  call $~lib/rt/itcms/Object#unlink
+  global.get $~lib/rt/itcms/toSpace
+  local.set $1
+  local.get $0
+  i32.load offset=12
+  local.tee $2
+  i32.const 2
+  i32.le_u
+  if (result i32)
+   i32.const 1
+  else
+   local.get $2
+   i32.const 2112
+   i32.load
+   i32.gt_u
+   if
+    i32.const 1792
+    i32.const 1856
+    i32.const 21
+    i32.const 28
+    call $~lib/builtins/abort
+    unreachable
+   end
+   local.get $2
+   i32.const 2
+   i32.shl
+   i32.const 2116
+   i32.add
+   i32.load
+   i32.const 32
+   i32.and
+  end
+  local.set $2
+  local.get $0
+  local.get $1
+  global.get $~lib/rt/itcms/white
+  i32.eqz
+  i32.const 2
+  local.get $2
+  select
+  call $~lib/rt/itcms/Object#linkTo
+ )
+ (func $~lib/rt/itcms/__visit (param $0 i32)
+  local.get $0
+  i32.eqz
+  if
+   return
+  end
+  global.get $~lib/rt/itcms/white
+  local.get $0
+  i32.const 20
+  i32.sub
+  local.tee $0
+  i32.load offset=4
+  i32.const 3
+  i32.and
+  i32.eq
+  if
+   local.get $0
+   call $~lib/rt/itcms/Object#makeGray
+   global.get $~lib/rt/itcms/visitCount
+   i32.const 1
+   i32.add
+   global.set $~lib/rt/itcms/visitCount
+  end
+ )
+ (func $~lib/rt/tlsf/removeBlock (param $0 i32) (param $1 i32)
+  (local $2 i32)
+  (local $3 i32)
+  (local $4 i32)
+  (local $5 i32)
+  local.get $1
+  i32.load
+  local.tee $3
+  i32.const 1
+  i32.and
+  i32.eqz
+  if
+   i32.const 0
+   i32.const 1936
+   i32.const 268
+   i32.const 14
+   call $~lib/builtins/abort
+   unreachable
+  end
+  local.get $3
+  i32.const -4
+  i32.and
+  local.tee $3
+  i32.const 12
+  i32.lt_u
+  if
+   i32.const 0
+   i32.const 1936
+   i32.const 270
+   i32.const 14
+   call $~lib/builtins/abort
+   unreachable
+  end
+  local.get $3
+  i32.const 256
+  i32.lt_u
+  if (result i32)
+   local.get $3
+   i32.const 4
+   i32.shr_u
+  else
+   i32.const 31
+   i32.const 1073741820
+   local.get $3
+   local.get $3
+   i32.const 1073741820
+   i32.ge_u
+   select
+   local.tee $3
+   i32.clz
+   i32.sub
+   local.tee $4
+   i32.const 7
+   i32.sub
+   local.set $2
+   local.get $3
+   local.get $4
+   i32.const 4
+   i32.sub
+   i32.shr_u
+   i32.const 16
+   i32.xor
+  end
+  local.tee $3
+  i32.const 16
+  i32.lt_u
+  local.get $2
+  i32.const 23
+  i32.lt_u
+  i32.and
+  i32.eqz
+  if
+   i32.const 0
+   i32.const 1936
+   i32.const 284
+   i32.const 14
+   call $~lib/builtins/abort
+   unreachable
+  end
+  local.get $1
+  i32.load offset=8
+  local.set $5
+  local.get $1
+  i32.load offset=4
+  local.tee $4
+  if
+   local.get $4
+   local.get $5
+   i32.store offset=8
+  end
+  local.get $5
+  if
+   local.get $5
+   local.get $4
+   i32.store offset=4
+  end
+  local.get $1
+  local.get $0
+  local.get $2
+  i32.const 4
+  i32.shl
+  local.get $3
+  i32.add
+  i32.const 2
+  i32.shl
+  i32.add
+  local.tee $1
+  i32.load offset=96
+  i32.eq
+  if
+   local.get $1
+   local.get $5
+   i32.store offset=96
+   local.get $5
+   i32.eqz
+   if
+    local.get $0
+    local.get $2
+    i32.const 2
+    i32.shl
+    i32.add
+    local.tee $1
+    i32.load offset=4
+    i32.const -2
+    local.get $3
+    i32.rotl
+    i32.and
+    local.set $3
+    local.get $1
+    local.get $3
+    i32.store offset=4
+    local.get $3
+    i32.eqz
+    if
+     local.get $0
+     local.get $0
+     i32.load
+     i32.const -2
+     local.get $2
+     i32.rotl
+     i32.and
+     i32.store
+    end
+   end
+  end
+ )
+ (func $~lib/rt/tlsf/insertBlock (param $0 i32) (param $1 i32)
+  (local $2 i32)
+  (local $3 i32)
+  (local $4 i32)
+  (local $5 i32)
+  (local $6 i32)
+  local.get $1
+  i32.eqz
+  if
+   i32.const 0
+   i32.const 1936
+   i32.const 201
+   i32.const 14
+   call $~lib/builtins/abort
+   unreachable
+  end
+  local.get $1
+  i32.load
+  local.tee $3
+  i32.const 1
+  i32.and
+  i32.eqz
+  if
+   i32.const 0
+   i32.const 1936
+   i32.const 203
+   i32.const 14
+   call $~lib/builtins/abort
+   unreachable
+  end
+  local.get $1
+  i32.const 4
+  i32.add
+  local.get $1
+  i32.load
+  i32.const -4
+  i32.and
+  i32.add
+  local.tee $4
+  i32.load
+  local.tee $2
+  i32.const 1
+  i32.and
+  if
+   local.get $0
+   local.get $4
+   call $~lib/rt/tlsf/removeBlock
+   local.get $1
+   local.get $3
+   i32.const 4
+   i32.add
+   local.get $2
+   i32.const -4
+   i32.and
+   i32.add
+   local.tee $3
+   i32.store
+   local.get $1
+   i32.const 4
+   i32.add
+   local.get $1
+   i32.load
+   i32.const -4
+   i32.and
+   i32.add
+   local.tee $4
+   i32.load
+   local.set $2
+  end
+  local.get $3
+  i32.const 2
+  i32.and
+  if
+   local.get $1
+   i32.const 4
+   i32.sub
+   i32.load
+   local.tee $1
+   i32.load
+   local.tee $6
+   i32.const 1
+   i32.and
+   i32.eqz
+   if
+    i32.const 0
+    i32.const 1936
+    i32.const 221
+    i32.const 16
+    call $~lib/builtins/abort
+    unreachable
+   end
+   local.get $0
+   local.get $1
+   call $~lib/rt/tlsf/removeBlock
+   local.get $1
+   local.get $6
+   i32.const 4
+   i32.add
+   local.get $3
+   i32.const -4
+   i32.and
+   i32.add
+   local.tee $3
+   i32.store
+  end
+  local.get $4
+  local.get $2
+  i32.const 2
+  i32.or
+  i32.store
+  local.get $3
+  i32.const -4
+  i32.and
+  local.tee $2
+  i32.const 12
+  i32.lt_u
+  if
+   i32.const 0
+   i32.const 1936
+   i32.const 233
+   i32.const 14
+   call $~lib/builtins/abort
+   unreachable
+  end
+  local.get $4
+  local.get $1
+  i32.const 4
+  i32.add
+  local.get $2
+  i32.add
+  i32.ne
+  if
+   i32.const 0
+   i32.const 1936
+   i32.const 234
+   i32.const 14
+   call $~lib/builtins/abort
+   unreachable
+  end
+  local.get $4
+  i32.const 4
+  i32.sub
+  local.get $1
+  i32.store
+  local.get $2
+  i32.const 256
+  i32.lt_u
+  if (result i32)
+   local.get $2
+   i32.const 4
+   i32.shr_u
+  else
+   i32.const 31
+   i32.const 1073741820
+   local.get $2
+   local.get $2
+   i32.const 1073741820
+   i32.ge_u
+   select
+   local.tee $2
+   i32.clz
+   i32.sub
+   local.tee $3
+   i32.const 7
+   i32.sub
+   local.set $5
+   local.get $2
+   local.get $3
+   i32.const 4
+   i32.sub
+   i32.shr_u
+   i32.const 16
+   i32.xor
+  end
+  local.tee $2
+  i32.const 16
+  i32.lt_u
+  local.get $5
+  i32.const 23
+  i32.lt_u
+  i32.and
+  i32.eqz
+  if
+   i32.const 0
+   i32.const 1936
+   i32.const 251
+   i32.const 14
+   call $~lib/builtins/abort
+   unreachable
+  end
+  local.get $0
+  local.get $5
+  i32.const 4
+  i32.shl
+  local.get $2
+  i32.add
+  i32.const 2
+  i32.shl
+  i32.add
+  i32.load offset=96
+  local.set $3
+  local.get $1
+  i32.const 0
+  i32.store offset=4
+  local.get $1
+  local.get $3
+  i32.store offset=8
+  local.get $3
+  if
+   local.get $3
+   local.get $1
+   i32.store offset=4
+  end
+  local.get $0
+  local.get $5
+  i32.const 4
+  i32.shl
+  local.get $2
+  i32.add
+  i32.const 2
+  i32.shl
+  i32.add
+  local.get $1
+  i32.store offset=96
+  local.get $0
+  local.get $0
+  i32.load
+  i32.const 1
+  local.get $5
+  i32.shl
+  i32.or
+  i32.store
+  local.get $0
+  local.get $5
+  i32.const 2
+  i32.shl
+  i32.add
+  local.tee $0
+  local.get $0
+  i32.load offset=4
+  i32.const 1
+  local.get $2
+  i32.shl
+  i32.or
+  i32.store offset=4
+ )
+ (func $~lib/rt/tlsf/addMemory (param $0 i32) (param $1 i32) (param $2 i64)
+  (local $3 i32)
+  (local $4 i32)
+  (local $5 i32)
+  local.get $2
+  local.get $1
+  i64.extend_i32_u
+  i64.lt_u
+  if
+   i32.const 0
+   i32.const 1936
+   i32.const 382
+   i32.const 14
+   call $~lib/builtins/abort
+   unreachable
+  end
+  local.get $1
+  i32.const 19
+  i32.add
+  i32.const -16
+  i32.and
+  i32.const 4
+  i32.sub
+  local.set $1
+  local.get $0
+  i32.load offset=1568
+  local.tee $3
+  if
+   local.get $3
+   i32.const 4
+   i32.add
+   local.get $1
+   i32.gt_u
+   if
+    i32.const 0
+    i32.const 1936
+    i32.const 389
+    i32.const 16
+    call $~lib/builtins/abort
+    unreachable
+   end
+   local.get $3
+   local.get $1
+   i32.const 16
+   i32.sub
+   local.tee $5
+   i32.eq
+   if
+    local.get $3
+    i32.load
+    local.set $4
+    local.get $5
+    local.set $1
+   end
+  else
+   local.get $0
+   i32.const 1572
+   i32.add
+   local.get $1
+   i32.gt_u
+   if
+    i32.const 0
+    i32.const 1936
+    i32.const 402
+    i32.const 5
+    call $~lib/builtins/abort
+    unreachable
+   end
+  end
+  local.get $2
+  i32.wrap_i64
+  i32.const -16
+  i32.and
+  local.get $1
+  i32.sub
+  local.tee $3
+  i32.const 20
+  i32.lt_u
+  if
+   return
+  end
+  local.get $1
+  local.get $4
+  i32.const 2
+  i32.and
+  local.get $3
+  i32.const 8
+  i32.sub
+  local.tee $3
+  i32.const 1
+  i32.or
+  i32.or
+  i32.store
+  local.get $1
+  i32.const 0
+  i32.store offset=4
+  local.get $1
+  i32.const 0
+  i32.store offset=8
+  local.get $1
+  i32.const 4
+  i32.add
+  local.get $3
+  i32.add
+  local.tee $3
+  i32.const 2
+  i32.store
+  local.get $0
+  local.get $3
+  i32.store offset=1568
+  local.get $0
+  local.get $1
+  call $~lib/rt/tlsf/insertBlock
+ )
+ (func $~lib/rt/tlsf/initialize
+  (local $0 i32)
+  (local $1 i32)
+  memory.size
+  local.tee $1
+  i32.const 0
+  i32.le_s
+  if (result i32)
+   i32.const 1
+   local.get $1
+   i32.sub
+   memory.grow
+   i32.const 0
+   i32.lt_s
+  else
+   i32.const 0
+  end
+  if
+   unreachable
+  end
+  i32.const 34912
+  i32.const 0
+  i32.store
+  i32.const 36480
+  i32.const 0
+  i32.store
+  loop $for-loop|0
+   local.get $0
+   i32.const 23
+   i32.lt_u
+   if
+    local.get $0
+    i32.const 2
+    i32.shl
+    i32.const 34912
+    i32.add
+    i32.const 0
+    i32.store offset=4
+    i32.const 0
+    local.set $1
+    loop $for-loop|1
+     local.get $1
+     i32.const 16
+     i32.lt_u
+     if
+      local.get $0
+      i32.const 4
+      i32.shl
+      local.get $1
+      i32.add
+      i32.const 2
+      i32.shl
+      i32.const 34912
+      i32.add
+      i32.const 0
+      i32.store offset=96
+      local.get $1
+      i32.const 1
+      i32.add
+      local.set $1
+      br $for-loop|1
+     end
+    end
+    local.get $0
+    i32.const 1
+    i32.add
+    local.set $0
+    br $for-loop|0
+   end
+  end
+  i32.const 34912
+  i32.const 36484
+  memory.size
+  i64.extend_i32_s
+  i64.const 16
+  i64.shl
+  call $~lib/rt/tlsf/addMemory
+  i32.const 34912
+  global.set $~lib/rt/tlsf/ROOT
+ )
+ (func $~lib/rt/itcms/step (result i32)
+  (local $0 i32)
+  (local $1 i32)
+  (local $2 i32)
+  block $break|0
+   block $case2|0
+    block $case1|0
+     block $case0|0
+      global.get $~lib/rt/itcms/state
+      br_table $case0|0 $case1|0 $case2|0 $break|0
+     end
+     i32.const 1
+     global.set $~lib/rt/itcms/state
+     i32.const 0
+     global.set $~lib/rt/itcms/visitCount
+     call $~lib/rt/itcms/visitRoots
+     global.get $~lib/rt/itcms/toSpace
+     global.set $~lib/rt/itcms/iter
+     global.get $~lib/rt/itcms/visitCount
+     return
+    end
+    global.get $~lib/rt/itcms/white
+    i32.eqz
+    local.set $1
+    global.get $~lib/rt/itcms/iter
+    i32.load offset=4
+    i32.const -4
+    i32.and
+    local.set $0
+    loop $while-continue|1
+     local.get $0
+     global.get $~lib/rt/itcms/toSpace
+     i32.ne
+     if
+      local.get $0
+      global.set $~lib/rt/itcms/iter
+      local.get $1
+      local.get $0
+      i32.load offset=4
+      i32.const 3
+      i32.and
+      i32.ne
+      if
+       local.get $0
+       local.get $1
+       call $~lib/rt/itcms/Object#set:color
+       i32.const 0
+       global.set $~lib/rt/itcms/visitCount
+       local.get $0
+       i32.const 20
+       i32.add
+       call $~lib/rt/__visit_members
+       global.get $~lib/rt/itcms/visitCount
+       return
+      end
+      local.get $0
+      i32.load offset=4
+      i32.const -4
+      i32.and
+      local.set $0
+      br $while-continue|1
+     end
+    end
+    i32.const 0
+    global.set $~lib/rt/itcms/visitCount
+    call $~lib/rt/itcms/visitRoots
+    global.get $~lib/rt/itcms/toSpace
+    global.get $~lib/rt/itcms/iter
+    i32.load offset=4
+    i32.const -4
+    i32.and
+    i32.eq
+    if
+     global.get $~lib/memory/__stack_pointer
+     local.set $0
+     loop $while-continue|0
+      local.get $0
+      i32.const 34900
+      i32.lt_u
+      if
+       local.get $0
+       i32.load
+       call $~lib/rt/itcms/__visit
+       local.get $0
+       i32.const 4
+       i32.add
+       local.set $0
+       br $while-continue|0
+      end
+     end
+     global.get $~lib/rt/itcms/iter
+     i32.load offset=4
+     i32.const -4
+     i32.and
+     local.set $0
+     loop $while-continue|2
+      local.get $0
+      global.get $~lib/rt/itcms/toSpace
+      i32.ne
+      if
+       local.get $1
+       local.get $0
+       i32.load offset=4
+       i32.const 3
+       i32.and
+       i32.ne
+       if
+        local.get $0
+        local.get $1
+        call $~lib/rt/itcms/Object#set:color
+        local.get $0
+        i32.const 20
+        i32.add
+        call $~lib/rt/__visit_members
+       end
+       local.get $0
+       i32.load offset=4
+       i32.const -4
+       i32.and
+       local.set $0
+       br $while-continue|2
+      end
+     end
+     global.get $~lib/rt/itcms/fromSpace
+     local.set $0
+     global.get $~lib/rt/itcms/toSpace
+     global.set $~lib/rt/itcms/fromSpace
+     local.get $0
+     global.set $~lib/rt/itcms/toSpace
+     local.get $1
+     global.set $~lib/rt/itcms/white
+     local.get $0
+     i32.load offset=4
+     i32.const -4
+     i32.and
+     global.set $~lib/rt/itcms/iter
+     i32.const 2
+     global.set $~lib/rt/itcms/state
+    end
+    global.get $~lib/rt/itcms/visitCount
+    return
+   end
+   global.get $~lib/rt/itcms/iter
+   local.tee $0
+   global.get $~lib/rt/itcms/toSpace
+   i32.ne
+   if
+    local.get $0
+    i32.load offset=4
+    i32.const -4
+    i32.and
+    global.set $~lib/rt/itcms/iter
+    global.get $~lib/rt/itcms/white
+    i32.eqz
+    local.get $0
+    i32.load offset=4
+    i32.const 3
+    i32.and
+    i32.ne
+    if
+     i32.const 0
+     i32.const 1664
+     i32.const 229
+     i32.const 20
+     call $~lib/builtins/abort
+     unreachable
+    end
+    local.get $0
+    i32.const 34900
+    i32.lt_u
+    if
+     local.get $0
+     i32.const 0
+     i32.store offset=4
+     local.get $0
+     i32.const 0
+     i32.store offset=8
+    else
+     global.get $~lib/rt/itcms/total
+     local.get $0
+     i32.load
+     i32.const -4
+     i32.and
+     i32.const 4
+     i32.add
+     i32.sub
+     global.set $~lib/rt/itcms/total
+     local.get $0
+     i32.const 4
+     i32.add
+     local.tee $1
+     i32.const 34900
+     i32.ge_u
+     if
+      global.get $~lib/rt/tlsf/ROOT
+      i32.eqz
+      if
+       call $~lib/rt/tlsf/initialize
+      end
+      global.get $~lib/rt/tlsf/ROOT
+      local.set $2
+      local.get $1
+      i32.const 4
+      i32.sub
+      local.set $0
+      local.get $1
+      i32.const 15
+      i32.and
+      i32.const 1
+      local.get $1
+      select
+      if (result i32)
+       i32.const 1
+      else
+       local.get $0
+       i32.load
+       i32.const 1
+       i32.and
+      end
+      if
+       i32.const 0
+       i32.const 1936
+       i32.const 562
+       i32.const 3
+       call $~lib/builtins/abort
+       unreachable
+      end
+      local.get $0
+      local.get $0
+      i32.load
+      i32.const 1
+      i32.or
+      i32.store
+      local.get $2
+      local.get $0
+      call $~lib/rt/tlsf/insertBlock
+     end
+    end
+    i32.const 10
+    return
+   end
+   global.get $~lib/rt/itcms/toSpace
+   global.get $~lib/rt/itcms/toSpace
+   i32.store offset=4
+   global.get $~lib/rt/itcms/toSpace
+   global.get $~lib/rt/itcms/toSpace
+   i32.store offset=8
+   i32.const 0
+   global.set $~lib/rt/itcms/state
+  end
+  i32.const 0
+ )
+ (func $~lib/rt/tlsf/roundSize (param $0 i32) (result i32)
+  local.get $0
+  i32.const 536870910
+  i32.lt_u
+  if (result i32)
+   local.get $0
+   i32.const 1
+   i32.const 27
+   local.get $0
+   i32.clz
+   i32.sub
+   i32.shl
+   i32.add
+   i32.const 1
+   i32.sub
+  else
+   local.get $0
+  end
+ )
+ (func $~lib/rt/tlsf/searchBlock (param $0 i32) (param $1 i32) (result i32)
+  (local $2 i32)
+  (local $3 i32)
+  local.get $1
+  i32.const 256
+  i32.lt_u
+  if (result i32)
+   local.get $1
+   i32.const 4
+   i32.shr_u
+  else
+   i32.const 31
+   local.get $1
+   call $~lib/rt/tlsf/roundSize
+   local.tee $1
+   i32.clz
+   i32.sub
+   local.tee $3
+   i32.const 7
+   i32.sub
+   local.set $2
+   local.get $1
+   local.get $3
+   i32.const 4
+   i32.sub
+   i32.shr_u
+   i32.const 16
+   i32.xor
+  end
+  local.tee $1
+  i32.const 16
+  i32.lt_u
+  local.get $2
+  i32.const 23
+  i32.lt_u
+  i32.and
+  i32.eqz
+  if
+   i32.const 0
+   i32.const 1936
+   i32.const 334
+   i32.const 14
+   call $~lib/builtins/abort
+   unreachable
+  end
+  local.get $0
+  local.get $2
+  i32.const 2
+  i32.shl
+  i32.add
+  i32.load offset=4
+  i32.const -1
+  local.get $1
+  i32.shl
+  i32.and
+  local.tee $1
+  if (result i32)
+   local.get $0
+   local.get $1
+   i32.ctz
+   local.get $2
+   i32.const 4
+   i32.shl
+   i32.add
+   i32.const 2
+   i32.shl
+   i32.add
+   i32.load offset=96
+  else
+   local.get $0
+   i32.load
+   i32.const -1
+   local.get $2
+   i32.const 1
+   i32.add
+   i32.shl
+   i32.and
+   local.tee $1
+   if (result i32)
+    local.get $0
+    local.get $1
+    i32.ctz
+    local.tee $1
+    i32.const 2
+    i32.shl
+    i32.add
+    i32.load offset=4
+    local.tee $2
+    i32.eqz
+    if
+     i32.const 0
+     i32.const 1936
+     i32.const 347
+     i32.const 18
+     call $~lib/builtins/abort
+     unreachable
+    end
+    local.get $0
+    local.get $2
+    i32.ctz
+    local.get $1
+    i32.const 4
+    i32.shl
+    i32.add
+    i32.const 2
+    i32.shl
+    i32.add
+    i32.load offset=96
+   else
+    i32.const 0
+   end
+  end
+ )
+ (func $~lib/rt/tlsf/allocateBlock (param $0 i32) (param $1 i32) (result i32)
+  (local $2 i32)
+  (local $3 i32)
+  (local $4 i32)
+  local.get $1
+  i32.const 1073741820
+  i32.gt_u
+  if
+   i32.const 1600
+   i32.const 1936
+   i32.const 461
+   i32.const 29
+   call $~lib/builtins/abort
+   unreachable
+  end
+  local.get $0
+  i32.const 12
+  local.get $1
+  i32.const 19
+  i32.add
+  i32.const -16
+  i32.and
+  i32.const 4
+  i32.sub
+  local.get $1
+  i32.const 12
+  i32.le_u
+  select
+  local.tee $1
+  call $~lib/rt/tlsf/searchBlock
+  local.tee $2
+  i32.eqz
+  if
+   local.get $1
+   i32.const 256
+   i32.ge_u
+   if (result i32)
+    local.get $1
+    call $~lib/rt/tlsf/roundSize
+   else
+    local.get $1
+   end
+   local.set $2
+   memory.size
+   local.tee $3
+   local.get $2
+   i32.const 4
+   local.get $0
+   i32.load offset=1568
+   local.get $3
+   i32.const 16
+   i32.shl
+   i32.const 4
+   i32.sub
+   i32.ne
+   i32.shl
+   i32.add
+   i32.const 65535
+   i32.add
+   i32.const -65536
+   i32.and
+   i32.const 16
+   i32.shr_u
+   local.tee $2
+   local.get $2
+   local.get $3
+   i32.lt_s
+   select
+   memory.grow
+   i32.const 0
+   i32.lt_s
+   if
+    local.get $2
+    memory.grow
+    i32.const 0
+    i32.lt_s
+    if
+     unreachable
+    end
+   end
+   local.get $0
+   local.get $3
+   i32.const 16
+   i32.shl
+   memory.size
+   i64.extend_i32_s
+   i64.const 16
+   i64.shl
+   call $~lib/rt/tlsf/addMemory
+   local.get $0
+   local.get $1
+   call $~lib/rt/tlsf/searchBlock
+   local.tee $2
+   i32.eqz
+   if
+    i32.const 0
+    i32.const 1936
+    i32.const 499
+    i32.const 16
+    call $~lib/builtins/abort
+    unreachable
+   end
+  end
+  local.get $1
+  local.get $2
+  i32.load
+  i32.const -4
+  i32.and
+  i32.gt_u
+  if
+   i32.const 0
+   i32.const 1936
+   i32.const 501
+   i32.const 14
+   call $~lib/builtins/abort
+   unreachable
+  end
+  local.get $0
+  local.get $2
+  call $~lib/rt/tlsf/removeBlock
+  local.get $2
+  i32.load
+  local.set $4
+  local.get $1
+  i32.const 4
+  i32.add
+  i32.const 15
+  i32.and
+  if
+   i32.const 0
+   i32.const 1936
+   i32.const 361
+   i32.const 14
+   call $~lib/builtins/abort
+   unreachable
+  end
+  local.get $4
+  i32.const -4
+  i32.and
+  local.get $1
+  i32.sub
+  local.tee $3
+  i32.const 16
+  i32.ge_u
+  if
+   local.get $2
+   local.get $1
+   local.get $4
+   i32.const 2
+   i32.and
+   i32.or
+   i32.store
+   local.get $2
+   i32.const 4
+   i32.add
+   local.get $1
+   i32.add
+   local.tee $1
+   local.get $3
+   i32.const 4
+   i32.sub
+   i32.const 1
+   i32.or
+   i32.store
+   local.get $0
+   local.get $1
+   call $~lib/rt/tlsf/insertBlock
+  else
+   local.get $2
+   local.get $4
+   i32.const -2
+   i32.and
+   i32.store
+   local.get $2
+   i32.const 4
+   i32.add
+   local.get $2
+   i32.load
+   i32.const -4
+   i32.and
+   i32.add
+   local.tee $0
+   local.get $0
+   i32.load
+   i32.const -3
+   i32.and
+   i32.store
+  end
+  local.get $2
+ )
+ (func $~lib/rt/itcms/__new (param $0 i32) (param $1 i32) (result i32)
+  (local $2 i32)
+  local.get $0
+  i32.const 1073741804
+  i32.ge_u
+  if
+   i32.const 1600
+   i32.const 1664
+   i32.const 261
+   i32.const 31
+   call $~lib/builtins/abort
+   unreachable
+  end
+  global.get $~lib/rt/itcms/total
+  global.get $~lib/rt/itcms/threshold
+  i32.ge_u
+  if
+   block $__inlined_func$~lib/rt/itcms/interrupt$69
+    i32.const 2048
+    local.set $2
+    loop $do-loop|0
+     local.get $2
+     call $~lib/rt/itcms/step
+     i32.sub
+     local.set $2
+     global.get $~lib/rt/itcms/state
+     i32.eqz
+     if
+      global.get $~lib/rt/itcms/total
+      i64.extend_i32_u
+      i64.const 200
+      i64.mul
+      i64.const 100
+      i64.div_u
+      i32.wrap_i64
+      i32.const 1024
+      i32.add
+      global.set $~lib/rt/itcms/threshold
+      br $__inlined_func$~lib/rt/itcms/interrupt$69
+     end
+     local.get $2
+     i32.const 0
+     i32.gt_s
+     br_if $do-loop|0
+    end
+    global.get $~lib/rt/itcms/total
+    global.get $~lib/rt/itcms/total
+    global.get $~lib/rt/itcms/threshold
+    i32.sub
+    i32.const 1024
+    i32.lt_u
+    i32.const 10
+    i32.shl
+    i32.add
+    global.set $~lib/rt/itcms/threshold
+   end
+  end
+  global.get $~lib/rt/tlsf/ROOT
+  i32.eqz
+  if
+   call $~lib/rt/tlsf/initialize
+  end
+  global.get $~lib/rt/tlsf/ROOT
+  local.get $0
+  i32.const 16
+  i32.add
+  call $~lib/rt/tlsf/allocateBlock
+  local.tee $2
+  local.get $1
+  i32.store offset=12
+  local.get $2
+  local.get $0
+  i32.store offset=16
+  local.get $2
+  global.get $~lib/rt/itcms/fromSpace
+  global.get $~lib/rt/itcms/white
+  call $~lib/rt/itcms/Object#linkTo
+  global.get $~lib/rt/itcms/total
+  local.get $2
+  i32.load
+  i32.const -4
+  i32.and
+  i32.const 4
+  i32.add
+  i32.add
+  global.set $~lib/rt/itcms/total
+  local.get $2
+  i32.const 20
+  i32.add
+  local.tee $1
+  i32.const 0
+  local.get $0
+  memory.fill
+  local.get $1
+ )
+ (func $~lib/rt/itcms/__pin (param $0 i32) (result i32)
+  (local $1 i32)
+  local.get $0
+  if
+   local.get $0
+   i32.const 20
+   i32.sub
+   local.tee $1
+   i32.load offset=4
+   i32.const 3
+   i32.and
+   i32.const 3
+   i32.eq
+   if
+    i32.const 2000
+    i32.const 1664
+    i32.const 338
+    i32.const 7
+    call $~lib/builtins/abort
+    unreachable
+   end
+   local.get $1
+   call $~lib/rt/itcms/Object#unlink
+   local.get $1
+   global.get $~lib/rt/itcms/pinSpace
+   i32.const 3
+   call $~lib/rt/itcms/Object#linkTo
+  end
+  local.get $0
+ )
+ (func $~lib/rt/itcms/__unpin (param $0 i32)
+  local.get $0
+  i32.eqz
+  if
+   return
+  end
+  local.get $0
+  i32.const 20
+  i32.sub
+  local.tee $0
+  i32.load offset=4
+  i32.const 3
+  i32.and
+  i32.const 3
+  i32.ne
+  if
+   i32.const 2064
+   i32.const 1664
+   i32.const 352
+   i32.const 5
+   call $~lib/builtins/abort
+   unreachable
+  end
+  global.get $~lib/rt/itcms/state
+  i32.const 1
+  i32.eq
+  if
+   local.get $0
+   call $~lib/rt/itcms/Object#makeGray
+  else
+   local.get $0
+   call $~lib/rt/itcms/Object#unlink
+   local.get $0
+   global.get $~lib/rt/itcms/fromSpace
+   global.get $~lib/rt/itcms/white
+   call $~lib/rt/itcms/Object#linkTo
+  end
+ )
+ (func $~lib/rt/itcms/__collect
+  global.get $~lib/rt/itcms/state
+  i32.const 0
+  i32.gt_s
+  if
+   loop $while-continue|0
+    global.get $~lib/rt/itcms/state
+    if
+     call $~lib/rt/itcms/step
+     drop
+     br $while-continue|0
+    end
+   end
+  end
+  call $~lib/rt/itcms/step
+  drop
+  loop $while-continue|1
+   global.get $~lib/rt/itcms/state
+   if
+    call $~lib/rt/itcms/step
+    drop
+    br $while-continue|1
+   end
+  end
+  global.get $~lib/rt/itcms/total
+  i64.extend_i32_u
+  i64.const 200
+  i64.mul
+  i64.const 100
+  i64.div_u
+  i32.wrap_i64
+  i32.const 1024
+  i32.add
+  global.set $~lib/rt/itcms/threshold
+ )
+ (func $~lib/rt/__visit_members (param $0 i32)
+  block $invalid
+   block $~lib/arraybuffer/ArrayBufferView
+    block $~lib/string/String
+     block $~lib/arraybuffer/ArrayBuffer
+      block $~lib/object/Object
+       local.get $0
+       i32.const 8
+       i32.sub
+       i32.load
+       br_table $~lib/object/Object $~lib/arraybuffer/ArrayBuffer $~lib/string/String $~lib/arraybuffer/ArrayBufferView $invalid
+      end
+      return
+     end
+     return
+    end
+    return
+   end
+   local.get $0
+   i32.load
+   local.tee $0
+   if
+    local.get $0
+    call $~lib/rt/itcms/__visit
+   end
+   return
+  end
+  unreachable
+ )
+ (func $~start
+  memory.size
+  i32.const 16
+  i32.shl
+  i32.const 34900
+  i32.sub
+  i32.const 1
+  i32.shr_u
+  global.set $~lib/rt/itcms/threshold
+  i32.const 1712
+  call $~lib/rt/itcms/initLazy
+  global.set $~lib/rt/itcms/pinSpace
+  i32.const 1744
+  call $~lib/rt/itcms/initLazy
+  global.set $~lib/rt/itcms/toSpace
+  i32.const 1888
+  call $~lib/rt/itcms/initLazy
+  global.set $~lib/rt/itcms/fromSpace
+ )
+ (func $~stack_check
+  global.get $~lib/memory/__stack_pointer
+  i32.const 2132
+  i32.lt_s
+  if
+   i32.const 34928
+   i32.const 34976
+   i32.const 1
+   i32.const 1
+   call $~lib/builtins/abort
+   unreachable
+  end
+ )
+ (func $~lib/string/String#indexOf (param $0 i32) (param $1 i32) (result i32)
+  (local $2 i32)
+  (local $3 i32)
+  (local $4 i32)
+  (local $5 i32)
+  (local $6 i32)
+  (local $7 i32)
+  (local $8 i32)
+  (local $9 i32)
+  global.get $~lib/memory/__stack_pointer
+  i32.const 8
+  i32.sub
+  global.set $~lib/memory/__stack_pointer
+  call $~stack_check
+  global.get $~lib/memory/__stack_pointer
+  i64.const 0
+  i64.store
+  global.get $~lib/memory/__stack_pointer
+  local.get $1
+  i32.store
+  block $folding-inner1
+   local.get $1
+   i32.const 20
+   i32.sub
+   i32.load offset=16
+   i32.const 1
+   i32.shr_u
+   local.tee $4
+   i32.eqz
+   br_if $folding-inner1
+   global.get $~lib/memory/__stack_pointer
+   local.get $0
+   i32.store
+   local.get $0
+   i32.const 20
+   i32.sub
+   i32.load offset=16
+   i32.const 1
+   i32.shr_u
+   local.tee $2
+   if
+    local.get $2
+    local.get $4
+    i32.sub
+    local.set $8
+    loop $for-loop|0
+     local.get $6
+     local.get $8
+     i32.le_s
+     if
+      global.get $~lib/memory/__stack_pointer
+      local.get $0
+      i32.store
+      global.get $~lib/memory/__stack_pointer
+      local.get $1
+      i32.store offset=4
+      block $__inlined_func$~lib/util/string/compareImpl (result i32)
+       local.get $0
+       local.get $6
+       i32.const 1
+       i32.shl
+       i32.add
+       local.tee $7
+       i32.const 7
+       i32.and
+       local.get $1
+       local.tee $3
+       i32.const 7
+       i32.and
+       i32.or
+       i32.eqz
+       local.get $4
+       local.tee $2
+       i32.const 4
+       i32.ge_u
+       i32.and
+       if
+        loop $do-loop|0
+         local.get $7
+         i64.load
+         local.get $3
+         i64.load
+         i64.eq
+         if
+          local.get $7
+          i32.const 8
+          i32.add
+          local.set $7
+          local.get $3
+          i32.const 8
+          i32.add
+          local.set $3
+          local.get $2
+          i32.const 4
+          i32.sub
+          local.tee $2
+          i32.const 4
+          i32.ge_u
+          br_if $do-loop|0
+         end
+        end
+       end
+       loop $while-continue|1
+        local.get $2
+        local.tee $5
+        i32.const 1
+        i32.sub
+        local.set $2
+        local.get $5
+        if
+         local.get $7
+         i32.load16_u
+         local.tee $5
+         local.get $3
+         i32.load16_u
+         local.tee $9
+         i32.ne
+         if
+          local.get $5
+          local.get $9
+          i32.sub
+          br $__inlined_func$~lib/util/string/compareImpl
+         end
+         local.get $7
+         i32.const 2
+         i32.add
+         local.set $7
+         local.get $3
+         i32.const 2
+         i32.add
+         local.set $3
+         br $while-continue|1
+        end
+       end
+       i32.const 0
+      end
+      i32.eqz
+      br_if $folding-inner1
+      local.get $6
+      i32.const 1
+      i32.add
+      local.set $6
+      br $for-loop|0
+     end
+    end
+   end
+   i32.const -1
+   local.set $6
+  end
+  global.get $~lib/memory/__stack_pointer
+  i32.const 8
+  i32.add
+  global.set $~lib/memory/__stack_pointer
+  local.get $6
+ )
+ (func $~lib/string/String#includes (param $0 i32) (param $1 i32) (result i32)
+  global.get $~lib/memory/__stack_pointer
+  i32.const 8
+  i32.sub
+  global.set $~lib/memory/__stack_pointer
+  call $~stack_check
+  global.get $~lib/memory/__stack_pointer
+  i64.const 0
+  i64.store
+  global.get $~lib/memory/__stack_pointer
+  local.get $0
+  i32.store
+  global.get $~lib/memory/__stack_pointer
+  local.get $1
+  i32.store offset=4
+  local.get $0
+  local.get $1
+  call $~lib/string/String#indexOf
+  i32.const -1
+  i32.ne
+  local.set $0
+  global.get $~lib/memory/__stack_pointer
+  i32.const 8
+  i32.add
+  global.set $~lib/memory/__stack_pointer
+  local.get $0
+ )
+ (func $export:src/agent/governance/sandbox/core.as/evaluate (param $0 i32) (param $1 i32) (param $2 i32) (result i32)
+  global.get $~lib/memory/__stack_pointer
+  i32.const 12
+  i32.sub
+  global.set $~lib/memory/__stack_pointer
+  call $~stack_check
+  global.get $~lib/memory/__stack_pointer
+  local.get $0
+  i32.store
+  global.get $~lib/memory/__stack_pointer
+  local.get $1
+  i32.store offset=4
+  global.get $~lib/memory/__stack_pointer
+  local.get $2
+  i32.store offset=8
+  global.get $~lib/memory/__stack_pointer
+  i32.const 8
+  i32.sub
+  global.set $~lib/memory/__stack_pointer
+  call $~stack_check
+  global.get $~lib/memory/__stack_pointer
+  i64.const 0
+  i64.store
+  global.get $~lib/memory/__stack_pointer
+  local.get $0
+  i32.store
+  global.get $~lib/memory/__stack_pointer
+  i32.const 1056
+  i32.store offset=4
+  block $folding-inner0 (result i32)
+   i32.const 1152
+   local.get $0
+   i32.const 1056
+   call $~lib/string/String#includes
+   if (result i32)
+    i32.const 1
+   else
+    global.get $~lib/memory/__stack_pointer
+    local.get $0
+    i32.store
+    global.get $~lib/memory/__stack_pointer
+    i32.const 1104
+    i32.store offset=4
+    local.get $0
+    i32.const 1104
+    call $~lib/string/String#includes
+   end
+   br_if $folding-inner0
+   drop
+   global.get $~lib/memory/__stack_pointer
+   local.get $2
+   i32.store
+   i32.const 1296
+   local.get $2
+   i32.const 20
+   i32.sub
+   i32.load offset=16
+   i32.const 1
+   i32.shr_u
+   i32.const 5000
+   i32.gt_u
+   br_if $folding-inner0
+   drop
+   i32.const 1456
+  end
+  local.set $0
+  global.get $~lib/memory/__stack_pointer
+  i32.const 8
+  i32.add
+  global.set $~lib/memory/__stack_pointer
+  global.get $~lib/memory/__stack_pointer
+  i32.const 12
+  i32.add
+  global.set $~lib/memory/__stack_pointer
+  local.get $0
+ )
+)
diff --git a/change.patch b/change.patch
new file mode 100644
index 0000000..2329f35
--- /dev/null
+++ b/change.patch
@@ -0,0 +1,3213 @@
+diff --git a/asconfig.json b/asconfig.json
+new file mode 100644
+index 0000000..9673c0b
+--- /dev/null
++++ b/asconfig.json
+@@ -0,0 +1,21 @@
++{
++    "targets": {
++        "debug": {
++            "outFile": "build/governance.debug.wasm",
++            "textFile": "build/governance.debug.wat",
++            "sourceMap": true,
++            "debug": true
++        },
++        "release": {
++            "outFile": "build/governance.release.wasm",
++            "textFile": "build/governance.release.wat",
++            "optimizeLevel": 3,
++            "shrinkLevel": 1,
++            "converge": false,
++            "noAssert": false
++        }
++    },
++    "options": {
++        "bindings": "esm"
++    }
++}
+\ No newline at end of file
+diff --git a/build/governance.release.d.ts b/build/governance.release.d.ts
+new file mode 100644
+index 0000000..7dd3bdf
+--- /dev/null
++++ b/build/governance.release.d.ts
+@@ -0,0 +1,10 @@
++/** Exported memory */
++export declare const memory: WebAssembly.Memory;
++/**
++ * src/agent/governance/sandbox/core.as/evaluate
++ * @param proposal `~lib/string/String`
++ * @param rules `~lib/string/String`
++ * @param ledger `~lib/string/String`
++ * @returns `~lib/string/String`
++ */
++export declare function evaluate(proposal: string, rules: string, ledger: string): string;
+diff --git a/build/governance.release.js b/build/governance.release.js
+new file mode 100644
+index 0000000..a6fc8a2
+--- /dev/null
++++ b/build/governance.release.js
+@@ -0,0 +1,85 @@
++async function instantiate(module, imports = {}) {
++  const adaptedImports = {
++    env: Object.assign(Object.create(globalThis), imports.env || {}, {
++      abort(message, fileName, lineNumber, columnNumber) {
++        // ~lib/builtins/abort(~lib/string/String | null?, ~lib/string/String | null?, u32?, u32?) => void
++        message = __liftString(message >>> 0);
++        fileName = __liftString(fileName >>> 0);
++        lineNumber = lineNumber >>> 0;
++        columnNumber = columnNumber >>> 0;
++        (() => {
++          // @external.js
++          throw Error(`${message} in ${fileName}:${lineNumber}:${columnNumber}`);
++        })();
++      },
++    }),
++  };
++  const { exports } = await WebAssembly.instantiate(module, adaptedImports);
++  const memory = exports.memory || imports.env.memory;
++  const adaptedExports = Object.setPrototypeOf({
++    evaluate(proposal, rules, ledger) {
++      // src/agent/governance/sandbox/core.as/evaluate(~lib/string/String, ~lib/string/String, ~lib/string/String) => ~lib/string/String
++      proposal = __retain(__lowerString(proposal) || __notnull());
++      rules = __retain(__lowerString(rules) || __notnull());
++      ledger = __lowerString(ledger) || __notnull();
++      try {
++        return __liftString(exports.evaluate(proposal, rules, ledger) >>> 0);
++      } finally {
++        __release(proposal);
++        __release(rules);
++      }
++    },
++  }, exports);
++  function __liftString(pointer) {
++    if (!pointer) return null;
++    const
++      end = pointer + new Uint32Array(memory.buffer)[pointer - 4 >>> 2] >>> 1,
++      memoryU16 = new Uint16Array(memory.buffer);
++    let
++      start = pointer >>> 1,
++      string = "";
++    while (end - start > 1024) string += String.fromCharCode(...memoryU16.subarray(start, start += 1024));
++    return string + String.fromCharCode(...memoryU16.subarray(start, end));
++  }
++  function __lowerString(value) {
++    if (value == null) return 0;
++    const
++      length = value.length,
++      pointer = exports.__new(length << 1, 2) >>> 0,
++      memoryU16 = new Uint16Array(memory.buffer);
++    for (let i = 0; i < length; ++i) memoryU16[(pointer >>> 1) + i] = value.charCodeAt(i);
++    return pointer;
++  }
++  const refcounts = new Map();
++  function __retain(pointer) {
++    if (pointer) {
++      const refcount = refcounts.get(pointer);
++      if (refcount) refcounts.set(pointer, refcount + 1);
++      else refcounts.set(exports.__pin(pointer), 1);
++    }
++    return pointer;
++  }
++  function __release(pointer) {
++    if (pointer) {
++      const refcount = refcounts.get(pointer);
++      if (refcount === 1) exports.__unpin(pointer), refcounts.delete(pointer);
++      else if (refcount) refcounts.set(pointer, refcount - 1);
++      else throw Error(`invalid refcount '${refcount}' for reference '${pointer}'`);
++    }
++  }
++  function __notnull() {
++    throw TypeError("value must not be null");
++  }
++  return adaptedExports;
++}
++export const {
++  memory,
++  evaluate,
++} = await (async url => instantiate(
++  await (async () => {
++    const isNodeOrBun = typeof process != "undefined" && process.versions != null && (process.versions.node != null || process.versions.bun != null);
++    if (isNodeOrBun) { return globalThis.WebAssembly.compile(await (await import("node:fs/promises")).readFile(url)); }
++    else { return await globalThis.WebAssembly.compileStreaming(globalThis.fetch(url)); }
++  })(), {
++  }
++))(new URL("governance.release.wasm", import.meta.url));
+diff --git a/build/governance.release.wasm b/build/governance.release.wasm
+new file mode 100644
+index 0000000..17423e2
+Binary files /dev/null and b/build/governance.release.wasm differ
+diff --git a/build/governance.release.wat b/build/governance.release.wat
+new file mode 100644
+index 0000000..3295c27
+--- /dev/null
++++ b/build/governance.release.wat
+@@ -0,0 +1,1969 @@
++(module
++ (type $0 (func))
++ (type $1 (func (param i32)))
++ (type $2 (func (param i32 i32) (result i32)))
++ (type $3 (func (param i32 i32)))
++ (type $4 (func (param i32) (result i32)))
++ (type $5 (func (param i32 i32 i32 i32)))
++ (type $6 (func (param i32 i32 i32)))
++ (type $7 (func (param i32 i32 i64)))
++ (type $8 (func (result i32)))
++ (type $9 (func (param i32 i32 i32) (result i32)))
++ (import "env" "abort" (func $~lib/builtins/abort (param i32 i32 i32 i32)))
++ (global $~lib/rt/itcms/total (mut i32) (i32.const 0))
++ (global $~lib/rt/itcms/threshold (mut i32) (i32.const 0))
++ (global $~lib/rt/itcms/state (mut i32) (i32.const 0))
++ (global $~lib/rt/itcms/visitCount (mut i32) (i32.const 0))
++ (global $~lib/rt/itcms/pinSpace (mut i32) (i32.const 0))
++ (global $~lib/rt/itcms/iter (mut i32) (i32.const 0))
++ (global $~lib/rt/itcms/toSpace (mut i32) (i32.const 0))
++ (global $~lib/rt/itcms/white (mut i32) (i32.const 0))
++ (global $~lib/rt/itcms/fromSpace (mut i32) (i32.const 0))
++ (global $~lib/rt/tlsf/ROOT (mut i32) (i32.const 0))
++ (global $~lib/rt/__rtti_base i32 (i32.const 2112))
++ (global $~lib/memory/__stack_pointer (mut i32) (i32.const 34900))
++ (memory $0 1)
++ (data $0 (i32.const 1036) ",")
++ (data $0.1 (i32.const 1048) "\02\00\00\00\10\00\00\00r\00m\00 \00-\00r\00f\00 \00/")
++ (data $1 (i32.const 1084) ",")
++ (data $1.1 (i32.const 1096) "\02\00\00\00\0e\00\00\00s\00u\00d\00o\00 \00r\00m")
++ (data $2 (i32.const 1132) "\8c")
++ (data $2.1 (i32.const 1144) "\02\00\00\00v\00\00\00{\00\"\00e\00f\00f\00e\00c\00t\00\"\00:\00 \00\"\00d\00e\00n\00y\00\"\00,\00 \00\"\00r\00e\00a\00s\00o\00n\00\"\00:\00 \00\"\00W\00A\00S\00M\00_\00S\00A\00N\00D\00B\00O\00X\00:\00 \00\c0hKm0R\c1kmp\'`}T\e4N\0c\ff:_6R;\96\ade\"\00}")
++ (data $3 (i32.const 1276) "\9c")
++ (data $3.1 (i32.const 1288) "\02\00\00\00~\00\00\00{\00\"\00e\00f\00f\00e\00c\00t\00\"\00:\00 \00\"\00d\00e\00n\00y\00\"\00,\00 \00\"\00r\00e\00a\00s\00o\00n\00\"\00:\00 \00\"\00W\00A\00S\00M\00_\00S\00A\00N\00D\00B\00O\00X\00:\00 \00&\8d,g\02_8^\a8\81\c0\80\0c\ff\efS\fd\80m\90\d7S\d2b\dd~\rg\a1R;e\fbQ\"\00}")
++ (data $4 (i32.const 1436) "\8c")
++ (data $4.1 (i32.const 1448) "\02\00\00\00p\00\00\00{\00\"\00e\00f\00f\00e\00c\00t\00\"\00:\00 \00\"\00a\00l\00l\00o\00w\00\"\00,\00 \00\"\00r\00e\00a\00s\00o\00n\00\"\00:\00 \00\"\00W\00A\00S\00M\00_\00S\00A\00N\00D\00B\00O\00X\00:\00 \00ir\06t\94\96\bbyB\\\8c\9a\c1\8b\1a\90\c7\8f\"\00}")
++ (data $5 (i32.const 1580) "<")
++ (data $5.1 (i32.const 1592) "\02\00\00\00(\00\00\00A\00l\00l\00o\00c\00a\00t\00i\00o\00n\00 \00t\00o\00o\00 \00l\00a\00r\00g\00e")
++ (data $6 (i32.const 1644) "<")
++ (data $6.1 (i32.const 1656) "\02\00\00\00 \00\00\00~\00l\00i\00b\00/\00r\00t\00/\00i\00t\00c\00m\00s\00.\00t\00s")
++ (data $9 (i32.const 1772) "<")
++ (data $9.1 (i32.const 1784) "\02\00\00\00$\00\00\00I\00n\00d\00e\00x\00 \00o\00u\00t\00 \00o\00f\00 \00r\00a\00n\00g\00e")
++ (data $10 (i32.const 1836) ",")
++ (data $10.1 (i32.const 1848) "\02\00\00\00\14\00\00\00~\00l\00i\00b\00/\00r\00t\00.\00t\00s")
++ (data $12 (i32.const 1916) "<")
++ (data $12.1 (i32.const 1928) "\02\00\00\00\1e\00\00\00~\00l\00i\00b\00/\00r\00t\00/\00t\00l\00s\00f\00.\00t\00s")
++ (data $13 (i32.const 1980) "<")
++ (data $13.1 (i32.const 1992) "\02\00\00\00*\00\00\00O\00b\00j\00e\00c\00t\00 \00a\00l\00r\00e\00a\00d\00y\00 \00p\00i\00n\00n\00e\00d")
++ (data $14 (i32.const 2044) "<")
++ (data $14.1 (i32.const 2056) "\02\00\00\00(\00\00\00O\00b\00j\00e\00c\00t\00 \00i\00s\00 \00n\00o\00t\00 \00p\00i\00n\00n\00e\00d")
++ (data $15 (i32.const 2112) "\04\00\00\00 \00\00\00 \00\00\00 ")
++ (export "__new" (func $~lib/rt/itcms/__new))
++ (export "__pin" (func $~lib/rt/itcms/__pin))
++ (export "__unpin" (func $~lib/rt/itcms/__unpin))
++ (export "__collect" (func $~lib/rt/itcms/__collect))
++ (export "__rtti_base" (global $~lib/rt/__rtti_base))
++ (export "memory" (memory $0))
++ (export "evaluate" (func $export:src/agent/governance/sandbox/core.as/evaluate))
++ (start $~start)
++ (func $~lib/rt/itcms/initLazy (param $0 i32) (result i32)
++  local.get $0
++  local.get $0
++  i32.store offset=4
++  local.get $0
++  local.get $0
++  i32.store offset=8
++  local.get $0
++ )
++ (func $~lib/rt/itcms/visitRoots
++  (local $0 i32)
++  (local $1 i32)
++  i32.const 1792
++  call $~lib/rt/itcms/__visit
++  i32.const 1600
++  call $~lib/rt/itcms/__visit
++  i32.const 2000
++  call $~lib/rt/itcms/__visit
++  i32.const 2064
++  call $~lib/rt/itcms/__visit
++  global.get $~lib/rt/itcms/pinSpace
++  local.tee $1
++  i32.load offset=4
++  i32.const -4
++  i32.and
++  local.set $0
++  loop $while-continue|0
++   local.get $0
++   local.get $1
++   i32.ne
++   if
++    local.get $0
++    i32.load offset=4
++    i32.const 3
++    i32.and
++    i32.const 3
++    i32.ne
++    if
++     i32.const 0
++     i32.const 1664
++     i32.const 160
++     i32.const 16
++     call $~lib/builtins/abort
++     unreachable
++    end
++    local.get $0
++    i32.const 20
++    i32.add
++    call $~lib/rt/__visit_members
++    local.get $0
++    i32.load offset=4
++    i32.const -4
++    i32.and
++    local.set $0
++    br $while-continue|0
++   end
++  end
++ )
++ (func $~lib/rt/itcms/Object#set:color (param $0 i32) (param $1 i32)
++  local.get $0
++  local.get $0
++  i32.load offset=4
++  i32.const -4
++  i32.and
++  local.get $1
++  i32.or
++  i32.store offset=4
++ )
++ (func $~lib/rt/itcms/Object#set:next (param $0 i32) (param $1 i32)
++  local.get $0
++  local.get $1
++  local.get $0
++  i32.load offset=4
++  i32.const 3
++  i32.and
++  i32.or
++  i32.store offset=4
++ )
++ (func $~lib/rt/itcms/Object#unlink (param $0 i32)
++  (local $1 i32)
++  local.get $0
++  i32.load offset=4
++  i32.const -4
++  i32.and
++  local.tee $1
++  i32.eqz
++  if
++   local.get $0
++   i32.load offset=8
++   i32.eqz
++   local.get $0
++   i32.const 34900
++   i32.lt_u
++   i32.and
++   i32.eqz
++   if
++    i32.const 0
++    i32.const 1664
++    i32.const 128
++    i32.const 18
++    call $~lib/builtins/abort
++    unreachable
++   end
++   return
++  end
++  local.get $0
++  i32.load offset=8
++  local.tee $0
++  i32.eqz
++  if
++   i32.const 0
++   i32.const 1664
++   i32.const 132
++   i32.const 16
++   call $~lib/builtins/abort
++   unreachable
++  end
++  local.get $1
++  local.get $0
++  i32.store offset=8
++  local.get $0
++  local.get $1
++  call $~lib/rt/itcms/Object#set:next
++ )
++ (func $~lib/rt/itcms/Object#linkTo (param $0 i32) (param $1 i32) (param $2 i32)
++  (local $3 i32)
++  local.get $1
++  i32.load offset=8
++  local.set $3
++  local.get $0
++  local.get $1
++  local.get $2
++  i32.or
++  i32.store offset=4
++  local.get $0
++  local.get $3
++  i32.store offset=8
++  local.get $3
++  local.get $0
++  call $~lib/rt/itcms/Object#set:next
++  local.get $1
++  local.get $0
++  i32.store offset=8
++ )
++ (func $~lib/rt/itcms/Object#makeGray (param $0 i32)
++  (local $1 i32)
++  (local $2 i32)
++  local.get $0
++  global.get $~lib/rt/itcms/iter
++  i32.eq
++  if
++   local.get $0
++   i32.load offset=8
++   local.tee $1
++   i32.eqz
++   if
++    i32.const 0
++    i32.const 1664
++    i32.const 148
++    i32.const 30
++    call $~lib/builtins/abort
++    unreachable
++   end
++   local.get $1
++   global.set $~lib/rt/itcms/iter
++  end
++  local.get $0
++  call $~lib/rt/itcms/Object#unlink
++  global.get $~lib/rt/itcms/toSpace
++  local.set $1
++  local.get $0
++  i32.load offset=12
++  local.tee $2
++  i32.const 2
++  i32.le_u
++  if (result i32)
++   i32.const 1
++  else
++   local.get $2
++   i32.const 2112
++   i32.load
++   i32.gt_u
++   if
++    i32.const 1792
++    i32.const 1856
++    i32.const 21
++    i32.const 28
++    call $~lib/builtins/abort
++    unreachable
++   end
++   local.get $2
++   i32.const 2
++   i32.shl
++   i32.const 2116
++   i32.add
++   i32.load
++   i32.const 32
++   i32.and
++  end
++  local.set $2
++  local.get $0
++  local.get $1
++  global.get $~lib/rt/itcms/white
++  i32.eqz
++  i32.const 2
++  local.get $2
++  select
++  call $~lib/rt/itcms/Object#linkTo
++ )
++ (func $~lib/rt/itcms/__visit (param $0 i32)
++  local.get $0
++  i32.eqz
++  if
++   return
++  end
++  global.get $~lib/rt/itcms/white
++  local.get $0
++  i32.const 20
++  i32.sub
++  local.tee $0
++  i32.load offset=4
++  i32.const 3
++  i32.and
++  i32.eq
++  if
++   local.get $0
++   call $~lib/rt/itcms/Object#makeGray
++   global.get $~lib/rt/itcms/visitCount
++   i32.const 1
++   i32.add
++   global.set $~lib/rt/itcms/visitCount
++  end
++ )
++ (func $~lib/rt/tlsf/removeBlock (param $0 i32) (param $1 i32)
++  (local $2 i32)
++  (local $3 i32)
++  (local $4 i32)
++  (local $5 i32)
++  local.get $1
++  i32.load
++  local.tee $3
++  i32.const 1
++  i32.and
++  i32.eqz
++  if
++   i32.const 0
++   i32.const 1936
++   i32.const 268
++   i32.const 14
++   call $~lib/builtins/abort
++   unreachable
++  end
++  local.get $3
++  i32.const -4
++  i32.and
++  local.tee $3
++  i32.const 12
++  i32.lt_u
++  if
++   i32.const 0
++   i32.const 1936
++   i32.const 270
++   i32.const 14
++   call $~lib/builtins/abort
++   unreachable
++  end
++  local.get $3
++  i32.const 256
++  i32.lt_u
++  if (result i32)
++   local.get $3
++   i32.const 4
++   i32.shr_u
++  else
++   i32.const 31
++   i32.const 1073741820
++   local.get $3
++   local.get $3
++   i32.const 1073741820
++   i32.ge_u
++   select
++   local.tee $3
++   i32.clz
++   i32.sub
++   local.tee $4
++   i32.const 7
++   i32.sub
++   local.set $2
++   local.get $3
++   local.get $4
++   i32.const 4
++   i32.sub
++   i32.shr_u
++   i32.const 16
++   i32.xor
++  end
++  local.tee $3
++  i32.const 16
++  i32.lt_u
++  local.get $2
++  i32.const 23
++  i32.lt_u
++  i32.and
++  i32.eqz
++  if
++   i32.const 0
++   i32.const 1936
++   i32.const 284
++   i32.const 14
++   call $~lib/builtins/abort
++   unreachable
++  end
++  local.get $1
++  i32.load offset=8
++  local.set $5
++  local.get $1
++  i32.load offset=4
++  local.tee $4
++  if
++   local.get $4
++   local.get $5
++   i32.store offset=8
++  end
++  local.get $5
++  if
++   local.get $5
++   local.get $4
++   i32.store offset=4
++  end
++  local.get $1
++  local.get $0
++  local.get $2
++  i32.const 4
++  i32.shl
++  local.get $3
++  i32.add
++  i32.const 2
++  i32.shl
++  i32.add
++  local.tee $1
++  i32.load offset=96
++  i32.eq
++  if
++   local.get $1
++   local.get $5
++   i32.store offset=96
++   local.get $5
++   i32.eqz
++   if
++    local.get $0
++    local.get $2
++    i32.const 2
++    i32.shl
++    i32.add
++    local.tee $1
++    i32.load offset=4
++    i32.const -2
++    local.get $3
++    i32.rotl
++    i32.and
++    local.set $3
++    local.get $1
++    local.get $3
++    i32.store offset=4
++    local.get $3
++    i32.eqz
++    if
++     local.get $0
++     local.get $0
++     i32.load
++     i32.const -2
++     local.get $2
++     i32.rotl
++     i32.and
++     i32.store
++    end
++   end
++  end
++ )
++ (func $~lib/rt/tlsf/insertBlock (param $0 i32) (param $1 i32)
++  (local $2 i32)
++  (local $3 i32)
++  (local $4 i32)
++  (local $5 i32)
++  (local $6 i32)
++  local.get $1
++  i32.eqz
++  if
++   i32.const 0
++   i32.const 1936
++   i32.const 201
++   i32.const 14
++   call $~lib/builtins/abort
++   unreachable
++  end
++  local.get $1
++  i32.load
++  local.tee $3
++  i32.const 1
++  i32.and
++  i32.eqz
++  if
++   i32.const 0
++   i32.const 1936
++   i32.const 203
++   i32.const 14
++   call $~lib/builtins/abort
++   unreachable
++  end
++  local.get $1
++  i32.const 4
++  i32.add
++  local.get $1
++  i32.load
++  i32.const -4
++  i32.and
++  i32.add
++  local.tee $4
++  i32.load
++  local.tee $2
++  i32.const 1
++  i32.and
++  if
++   local.get $0
++   local.get $4
++   call $~lib/rt/tlsf/removeBlock
++   local.get $1
++   local.get $3
++   i32.const 4
++   i32.add
++   local.get $2
++   i32.const -4
++   i32.and
++   i32.add
++   local.tee $3
++   i32.store
++   local.get $1
++   i32.const 4
++   i32.add
++   local.get $1
++   i32.load
++   i32.const -4
++   i32.and
++   i32.add
++   local.tee $4
++   i32.load
++   local.set $2
++  end
++  local.get $3
++  i32.const 2
++  i32.and
++  if
++   local.get $1
++   i32.const 4
++   i32.sub
++   i32.load
++   local.tee $1
++   i32.load
++   local.tee $6
++   i32.const 1
++   i32.and
++   i32.eqz
++   if
++    i32.const 0
++    i32.const 1936
++    i32.const 221
++    i32.const 16
++    call $~lib/builtins/abort
++    unreachable
++   end
++   local.get $0
++   local.get $1
++   call $~lib/rt/tlsf/removeBlock
++   local.get $1
++   local.get $6
++   i32.const 4
++   i32.add
++   local.get $3
++   i32.const -4
++   i32.and
++   i32.add
++   local.tee $3
++   i32.store
++  end
++  local.get $4
++  local.get $2
++  i32.const 2
++  i32.or
++  i32.store
++  local.get $3
++  i32.const -4
++  i32.and
++  local.tee $2
++  i32.const 12
++  i32.lt_u
++  if
++   i32.const 0
++   i32.const 1936
++   i32.const 233
++   i32.const 14
++   call $~lib/builtins/abort
++   unreachable
++  end
++  local.get $4
++  local.get $1
++  i32.const 4
++  i32.add
++  local.get $2
++  i32.add
++  i32.ne
++  if
++   i32.const 0
++   i32.const 1936
++   i32.const 234
++   i32.const 14
++   call $~lib/builtins/abort
++   unreachable
++  end
++  local.get $4
++  i32.const 4
++  i32.sub
++  local.get $1
++  i32.store
++  local.get $2
++  i32.const 256
++  i32.lt_u
++  if (result i32)
++   local.get $2
++   i32.const 4
++   i32.shr_u
++  else
++   i32.const 31
++   i32.const 1073741820
++   local.get $2
++   local.get $2
++   i32.const 1073741820
++   i32.ge_u
++   select
++   local.tee $2
++   i32.clz
++   i32.sub
++   local.tee $3
++   i32.const 7
++   i32.sub
++   local.set $5
++   local.get $2
++   local.get $3
++   i32.const 4
++   i32.sub
++   i32.shr_u
++   i32.const 16
++   i32.xor
++  end
++  local.tee $2
++  i32.const 16
++  i32.lt_u
++  local.get $5
++  i32.const 23
++  i32.lt_u
++  i32.and
++  i32.eqz
++  if
++   i32.const 0
++   i32.const 1936
++   i32.const 251
++   i32.const 14
++   call $~lib/builtins/abort
++   unreachable
++  end
++  local.get $0
++  local.get $5
++  i32.const 4
++  i32.shl
++  local.get $2
++  i32.add
++  i32.const 2
++  i32.shl
++  i32.add
++  i32.load offset=96
++  local.set $3
++  local.get $1
++  i32.const 0
++  i32.store offset=4
++  local.get $1
++  local.get $3
++  i32.store offset=8
++  local.get $3
++  if
++   local.get $3
++   local.get $1
++   i32.store offset=4
++  end
++  local.get $0
++  local.get $5
++  i32.const 4
++  i32.shl
++  local.get $2
++  i32.add
++  i32.const 2
++  i32.shl
++  i32.add
++  local.get $1
++  i32.store offset=96
++  local.get $0
++  local.get $0
++  i32.load
++  i32.const 1
++  local.get $5
++  i32.shl
++  i32.or
++  i32.store
++  local.get $0
++  local.get $5
++  i32.const 2
++  i32.shl
++  i32.add
++  local.tee $0
++  local.get $0
++  i32.load offset=4
++  i32.const 1
++  local.get $2
++  i32.shl
++  i32.or
++  i32.store offset=4
++ )
++ (func $~lib/rt/tlsf/addMemory (param $0 i32) (param $1 i32) (param $2 i64)
++  (local $3 i32)
++  (local $4 i32)
++  (local $5 i32)
++  local.get $2
++  local.get $1
++  i64.extend_i32_u
++  i64.lt_u
++  if
++   i32.const 0
++   i32.const 1936
++   i32.const 382
++   i32.const 14
++   call $~lib/builtins/abort
++   unreachable
++  end
++  local.get $1
++  i32.const 19
++  i32.add
++  i32.const -16
++  i32.and
++  i32.const 4
++  i32.sub
++  local.set $1
++  local.get $0
++  i32.load offset=1568
++  local.tee $3
++  if
++   local.get $3
++   i32.const 4
++   i32.add
++   local.get $1
++   i32.gt_u
++   if
++    i32.const 0
++    i32.const 1936
++    i32.const 389
++    i32.const 16
++    call $~lib/builtins/abort
++    unreachable
++   end
++   local.get $3
++   local.get $1
++   i32.const 16
++   i32.sub
++   local.tee $5
++   i32.eq
++   if
++    local.get $3
++    i32.load
++    local.set $4
++    local.get $5
++    local.set $1
++   end
++  else
++   local.get $0
++   i32.const 1572
++   i32.add
++   local.get $1
++   i32.gt_u
++   if
++    i32.const 0
++    i32.const 1936
++    i32.const 402
++    i32.const 5
++    call $~lib/builtins/abort
++    unreachable
++   end
++  end
++  local.get $2
++  i32.wrap_i64
++  i32.const -16
++  i32.and
++  local.get $1
++  i32.sub
++  local.tee $3
++  i32.const 20
++  i32.lt_u
++  if
++   return
++  end
++  local.get $1
++  local.get $4
++  i32.const 2
++  i32.and
++  local.get $3
++  i32.const 8
++  i32.sub
++  local.tee $3
++  i32.const 1
++  i32.or
++  i32.or
++  i32.store
++  local.get $1
++  i32.const 0
++  i32.store offset=4
++  local.get $1
++  i32.const 0
++  i32.store offset=8
++  local.get $1
++  i32.const 4
++  i32.add
++  local.get $3
++  i32.add
++  local.tee $3
++  i32.const 2
++  i32.store
++  local.get $0
++  local.get $3
++  i32.store offset=1568
++  local.get $0
++  local.get $1
++  call $~lib/rt/tlsf/insertBlock
++ )
++ (func $~lib/rt/tlsf/initialize
++  (local $0 i32)
++  (local $1 i32)
++  memory.size
++  local.tee $1
++  i32.const 0
++  i32.le_s
++  if (result i32)
++   i32.const 1
++   local.get $1
++   i32.sub
++   memory.grow
++   i32.const 0
++   i32.lt_s
++  else
++   i32.const 0
++  end
++  if
++   unreachable
++  end
++  i32.const 34912
++  i32.const 0
++  i32.store
++  i32.const 36480
++  i32.const 0
++  i32.store
++  loop $for-loop|0
++   local.get $0
++   i32.const 23
++   i32.lt_u
++   if
++    local.get $0
++    i32.const 2
++    i32.shl
++    i32.const 34912
++    i32.add
++    i32.const 0
++    i32.store offset=4
++    i32.const 0
++    local.set $1
++    loop $for-loop|1
++     local.get $1
++     i32.const 16
++     i32.lt_u
++     if
++      local.get $0
++      i32.const 4
++      i32.shl
++      local.get $1
++      i32.add
++      i32.const 2
++      i32.shl
++      i32.const 34912
++      i32.add
++      i32.const 0
++      i32.store offset=96
++      local.get $1
++      i32.const 1
++      i32.add
++      local.set $1
++      br $for-loop|1
++     end
++    end
++    local.get $0
++    i32.const 1
++    i32.add
++    local.set $0
++    br $for-loop|0
++   end
++  end
++  i32.const 34912
++  i32.const 36484
++  memory.size
++  i64.extend_i32_s
++  i64.const 16
++  i64.shl
++  call $~lib/rt/tlsf/addMemory
++  i32.const 34912
++  global.set $~lib/rt/tlsf/ROOT
++ )
++ (func $~lib/rt/itcms/step (result i32)
++  (local $0 i32)
++  (local $1 i32)
++  (local $2 i32)
++  block $break|0
++   block $case2|0
++    block $case1|0
++     block $case0|0
++      global.get $~lib/rt/itcms/state
++      br_table $case0|0 $case1|0 $case2|0 $break|0
++     end
++     i32.const 1
++     global.set $~lib/rt/itcms/state
++     i32.const 0
++     global.set $~lib/rt/itcms/visitCount
++     call $~lib/rt/itcms/visitRoots
++     global.get $~lib/rt/itcms/toSpace
++     global.set $~lib/rt/itcms/iter
++     global.get $~lib/rt/itcms/visitCount
++     return
++    end
++    global.get $~lib/rt/itcms/white
++    i32.eqz
++    local.set $1
++    global.get $~lib/rt/itcms/iter
++    i32.load offset=4
++    i32.const -4
++    i32.and
++    local.set $0
++    loop $while-continue|1
++     local.get $0
++     global.get $~lib/rt/itcms/toSpace
++     i32.ne
++     if
++      local.get $0
++      global.set $~lib/rt/itcms/iter
++      local.get $1
++      local.get $0
++      i32.load offset=4
++      i32.const 3
++      i32.and
++      i32.ne
++      if
++       local.get $0
++       local.get $1
++       call $~lib/rt/itcms/Object#set:color
++       i32.const 0
++       global.set $~lib/rt/itcms/visitCount
++       local.get $0
++       i32.const 20
++       i32.add
++       call $~lib/rt/__visit_members
++       global.get $~lib/rt/itcms/visitCount
++       return
++      end
++      local.get $0
++      i32.load offset=4
++      i32.const -4
++      i32.and
++      local.set $0
++      br $while-continue|1
++     end
++    end
++    i32.const 0
++    global.set $~lib/rt/itcms/visitCount
++    call $~lib/rt/itcms/visitRoots
++    global.get $~lib/rt/itcms/toSpace
++    global.get $~lib/rt/itcms/iter
++    i32.load offset=4
++    i32.const -4
++    i32.and
++    i32.eq
++    if
++     global.get $~lib/memory/__stack_pointer
++     local.set $0
++     loop $while-continue|0
++      local.get $0
++      i32.const 34900
++      i32.lt_u
++      if
++       local.get $0
++       i32.load
++       call $~lib/rt/itcms/__visit
++       local.get $0
++       i32.const 4
++       i32.add
++       local.set $0
++       br $while-continue|0
++      end
++     end
++     global.get $~lib/rt/itcms/iter
++     i32.load offset=4
++     i32.const -4
++     i32.and
++     local.set $0
++     loop $while-continue|2
++      local.get $0
++      global.get $~lib/rt/itcms/toSpace
++      i32.ne
++      if
++       local.get $1
++       local.get $0
++       i32.load offset=4
++       i32.const 3
++       i32.and
++       i32.ne
++       if
++        local.get $0
++        local.get $1
++        call $~lib/rt/itcms/Object#set:color
++        local.get $0
++        i32.const 20
++        i32.add
++        call $~lib/rt/__visit_members
++       end
++       local.get $0
++       i32.load offset=4
++       i32.const -4
++       i32.and
++       local.set $0
++       br $while-continue|2
++      end
++     end
++     global.get $~lib/rt/itcms/fromSpace
++     local.set $0
++     global.get $~lib/rt/itcms/toSpace
++     global.set $~lib/rt/itcms/fromSpace
++     local.get $0
++     global.set $~lib/rt/itcms/toSpace
++     local.get $1
++     global.set $~lib/rt/itcms/white
++     local.get $0
++     i32.load offset=4
++     i32.const -4
++     i32.and
++     global.set $~lib/rt/itcms/iter
++     i32.const 2
++     global.set $~lib/rt/itcms/state
++    end
++    global.get $~lib/rt/itcms/visitCount
++    return
++   end
++   global.get $~lib/rt/itcms/iter
++   local.tee $0
++   global.get $~lib/rt/itcms/toSpace
++   i32.ne
++   if
++    local.get $0
++    i32.load offset=4
++    i32.const -4
++    i32.and
++    global.set $~lib/rt/itcms/iter
++    global.get $~lib/rt/itcms/white
++    i32.eqz
++    local.get $0
++    i32.load offset=4
++    i32.const 3
++    i32.and
++    i32.ne
++    if
++     i32.const 0
++     i32.const 1664
++     i32.const 229
++     i32.const 20
++     call $~lib/builtins/abort
++     unreachable
++    end
++    local.get $0
++    i32.const 34900
++    i32.lt_u
++    if
++     local.get $0
++     i32.const 0
++     i32.store offset=4
++     local.get $0
++     i32.const 0
++     i32.store offset=8
++    else
++     global.get $~lib/rt/itcms/total
++     local.get $0
++     i32.load
++     i32.const -4
++     i32.and
++     i32.const 4
++     i32.add
++     i32.sub
++     global.set $~lib/rt/itcms/total
++     local.get $0
++     i32.const 4
++     i32.add
++     local.tee $1
++     i32.const 34900
++     i32.ge_u
++     if
++      global.get $~lib/rt/tlsf/ROOT
++      i32.eqz
++      if
++       call $~lib/rt/tlsf/initialize
++      end
++      global.get $~lib/rt/tlsf/ROOT
++      local.set $2
++      local.get $1
++      i32.const 4
++      i32.sub
++      local.set $0
++      local.get $1
++      i32.const 15
++      i32.and
++      i32.const 1
++      local.get $1
++      select
++      if (result i32)
++       i32.const 1
++      else
++       local.get $0
++       i32.load
++       i32.const 1
++       i32.and
++      end
++      if
++       i32.const 0
++       i32.const 1936
++       i32.const 562
++       i32.const 3
++       call $~lib/builtins/abort
++       unreachable
++      end
++      local.get $0
++      local.get $0
++      i32.load
++      i32.const 1
++      i32.or
++      i32.store
++      local.get $2
++      local.get $0
++      call $~lib/rt/tlsf/insertBlock
++     end
++    end
++    i32.const 10
++    return
++   end
++   global.get $~lib/rt/itcms/toSpace
++   global.get $~lib/rt/itcms/toSpace
++   i32.store offset=4
++   global.get $~lib/rt/itcms/toSpace
++   global.get $~lib/rt/itcms/toSpace
++   i32.store offset=8
++   i32.const 0
++   global.set $~lib/rt/itcms/state
++  end
++  i32.const 0
++ )
++ (func $~lib/rt/tlsf/roundSize (param $0 i32) (result i32)
++  local.get $0
++  i32.const 536870910
++  i32.lt_u
++  if (result i32)
++   local.get $0
++   i32.const 1
++   i32.const 27
++   local.get $0
++   i32.clz
++   i32.sub
++   i32.shl
++   i32.add
++   i32.const 1
++   i32.sub
++  else
++   local.get $0
++  end
++ )
++ (func $~lib/rt/tlsf/searchBlock (param $0 i32) (param $1 i32) (result i32)
++  (local $2 i32)
++  (local $3 i32)
++  local.get $1
++  i32.const 256
++  i32.lt_u
++  if (result i32)
++   local.get $1
++   i32.const 4
++   i32.shr_u
++  else
++   i32.const 31
++   local.get $1
++   call $~lib/rt/tlsf/roundSize
++   local.tee $1
++   i32.clz
++   i32.sub
++   local.tee $3
++   i32.const 7
++   i32.sub
++   local.set $2
++   local.get $1
++   local.get $3
++   i32.const 4
++   i32.sub
++   i32.shr_u
++   i32.const 16
++   i32.xor
++  end
++  local.tee $1
++  i32.const 16
++  i32.lt_u
++  local.get $2
++  i32.const 23
++  i32.lt_u
++  i32.and
++  i32.eqz
++  if
++   i32.const 0
++   i32.const 1936
++   i32.const 334
++   i32.const 14
++   call $~lib/builtins/abort
++   unreachable
++  end
++  local.get $0
++  local.get $2
++  i32.const 2
++  i32.shl
++  i32.add
++  i32.load offset=4
++  i32.const -1
++  local.get $1
++  i32.shl
++  i32.and
++  local.tee $1
++  if (result i32)
++   local.get $0
++   local.get $1
++   i32.ctz
++   local.get $2
++   i32.const 4
++   i32.shl
++   i32.add
++   i32.const 2
++   i32.shl
++   i32.add
++   i32.load offset=96
++  else
++   local.get $0
++   i32.load
++   i32.const -1
++   local.get $2
++   i32.const 1
++   i32.add
++   i32.shl
++   i32.and
++   local.tee $1
++   if (result i32)
++    local.get $0
++    local.get $1
++    i32.ctz
++    local.tee $1
++    i32.const 2
++    i32.shl
++    i32.add
++    i32.load offset=4
++    local.tee $2
++    i32.eqz
++    if
++     i32.const 0
++     i32.const 1936
++     i32.const 347
++     i32.const 18
++     call $~lib/builtins/abort
++     unreachable
++    end
++    local.get $0
++    local.get $2
++    i32.ctz
++    local.get $1
++    i32.const 4
++    i32.shl
++    i32.add
++    i32.const 2
++    i32.shl
++    i32.add
++    i32.load offset=96
++   else
++    i32.const 0
++   end
++  end
++ )
++ (func $~lib/rt/tlsf/allocateBlock (param $0 i32) (param $1 i32) (result i32)
++  (local $2 i32)
++  (local $3 i32)
++  (local $4 i32)
++  local.get $1
++  i32.const 1073741820
++  i32.gt_u
++  if
++   i32.const 1600
++   i32.const 1936
++   i32.const 461
++   i32.const 29
++   call $~lib/builtins/abort
++   unreachable
++  end
++  local.get $0
++  i32.const 12
++  local.get $1
++  i32.const 19
++  i32.add
++  i32.const -16
++  i32.and
++  i32.const 4
++  i32.sub
++  local.get $1
++  i32.const 12
++  i32.le_u
++  select
++  local.tee $1
++  call $~lib/rt/tlsf/searchBlock
++  local.tee $2
++  i32.eqz
++  if
++   local.get $1
++   i32.const 256
++   i32.ge_u
++   if (result i32)
++    local.get $1
++    call $~lib/rt/tlsf/roundSize
++   else
++    local.get $1
++   end
++   local.set $2
++   memory.size
++   local.tee $3
++   local.get $2
++   i32.const 4
++   local.get $0
++   i32.load offset=1568
++   local.get $3
++   i32.const 16
++   i32.shl
++   i32.const 4
++   i32.sub
++   i32.ne
++   i32.shl
++   i32.add
++   i32.const 65535
++   i32.add
++   i32.const -65536
++   i32.and
++   i32.const 16
++   i32.shr_u
++   local.tee $2
++   local.get $2
++   local.get $3
++   i32.lt_s
++   select
++   memory.grow
++   i32.const 0
++   i32.lt_s
++   if
++    local.get $2
++    memory.grow
++    i32.const 0
++    i32.lt_s
++    if
++     unreachable
++    end
++   end
++   local.get $0
++   local.get $3
++   i32.const 16
++   i32.shl
++   memory.size
++   i64.extend_i32_s
++   i64.const 16
++   i64.shl
++   call $~lib/rt/tlsf/addMemory
++   local.get $0
++   local.get $1
++   call $~lib/rt/tlsf/searchBlock
++   local.tee $2
++   i32.eqz
++   if
++    i32.const 0
++    i32.const 1936
++    i32.const 499
++    i32.const 16
++    call $~lib/builtins/abort
++    unreachable
++   end
++  end
++  local.get $1
++  local.get $2
++  i32.load
++  i32.const -4
++  i32.and
++  i32.gt_u
++  if
++   i32.const 0
++   i32.const 1936
++   i32.const 501
++   i32.const 14
++   call $~lib/builtins/abort
++   unreachable
++  end
++  local.get $0
++  local.get $2
++  call $~lib/rt/tlsf/removeBlock
++  local.get $2
++  i32.load
++  local.set $4
++  local.get $1
++  i32.const 4
++  i32.add
++  i32.const 15
++  i32.and
++  if
++   i32.const 0
++   i32.const 1936
++   i32.const 361
++   i32.const 14
++   call $~lib/builtins/abort
++   unreachable
++  end
++  local.get $4
++  i32.const -4
++  i32.and
++  local.get $1
++  i32.sub
++  local.tee $3
++  i32.const 16
++  i32.ge_u
++  if
++   local.get $2
++   local.get $1
++   local.get $4
++   i32.const 2
++   i32.and
++   i32.or
++   i32.store
++   local.get $2
++   i32.const 4
++   i32.add
++   local.get $1
++   i32.add
++   local.tee $1
++   local.get $3
++   i32.const 4
++   i32.sub
++   i32.const 1
++   i32.or
++   i32.store
++   local.get $0
++   local.get $1
++   call $~lib/rt/tlsf/insertBlock
++  else
++   local.get $2
++   local.get $4
++   i32.const -2
++   i32.and
++   i32.store
++   local.get $2
++   i32.const 4
++   i32.add
++   local.get $2
++   i32.load
++   i32.const -4
++   i32.and
++   i32.add
++   local.tee $0
++   local.get $0
++   i32.load
++   i32.const -3
++   i32.and
++   i32.store
++  end
++  local.get $2
++ )
++ (func $~lib/rt/itcms/__new (param $0 i32) (param $1 i32) (result i32)
++  (local $2 i32)
++  local.get $0
++  i32.const 1073741804
++  i32.ge_u
++  if
++   i32.const 1600
++   i32.const 1664
++   i32.const 261
++   i32.const 31
++   call $~lib/builtins/abort
++   unreachable
++  end
++  global.get $~lib/rt/itcms/total
++  global.get $~lib/rt/itcms/threshold
++  i32.ge_u
++  if
++   block $__inlined_func$~lib/rt/itcms/interrupt$69
++    i32.const 2048
++    local.set $2
++    loop $do-loop|0
++     local.get $2
++     call $~lib/rt/itcms/step
++     i32.sub
++     local.set $2
++     global.get $~lib/rt/itcms/state
++     i32.eqz
++     if
++      global.get $~lib/rt/itcms/total
++      i64.extend_i32_u
++      i64.const 200
++      i64.mul
++      i64.const 100
++      i64.div_u
++      i32.wrap_i64
++      i32.const 1024
++      i32.add
++      global.set $~lib/rt/itcms/threshold
++      br $__inlined_func$~lib/rt/itcms/interrupt$69
++     end
++     local.get $2
++     i32.const 0
++     i32.gt_s
++     br_if $do-loop|0
++    end
++    global.get $~lib/rt/itcms/total
++    global.get $~lib/rt/itcms/total
++    global.get $~lib/rt/itcms/threshold
++    i32.sub
++    i32.const 1024
++    i32.lt_u
++    i32.const 10
++    i32.shl
++    i32.add
++    global.set $~lib/rt/itcms/threshold
++   end
++  end
++  global.get $~lib/rt/tlsf/ROOT
++  i32.eqz
++  if
++   call $~lib/rt/tlsf/initialize
++  end
++  global.get $~lib/rt/tlsf/ROOT
++  local.get $0
++  i32.const 16
++  i32.add
++  call $~lib/rt/tlsf/allocateBlock
++  local.tee $2
++  local.get $1
++  i32.store offset=12
++  local.get $2
++  local.get $0
++  i32.store offset=16
++  local.get $2
++  global.get $~lib/rt/itcms/fromSpace
++  global.get $~lib/rt/itcms/white
++  call $~lib/rt/itcms/Object#linkTo
++  global.get $~lib/rt/itcms/total
++  local.get $2
++  i32.load
++  i32.const -4
++  i32.and
++  i32.const 4
++  i32.add
++  i32.add
++  global.set $~lib/rt/itcms/total
++  local.get $2
++  i32.const 20
++  i32.add
++  local.tee $1
++  i32.const 0
++  local.get $0
++  memory.fill
++  local.get $1
++ )
++ (func $~lib/rt/itcms/__pin (param $0 i32) (result i32)
++  (local $1 i32)
++  local.get $0
++  if
++   local.get $0
++   i32.const 20
++   i32.sub
++   local.tee $1
++   i32.load offset=4
++   i32.const 3
++   i32.and
++   i32.const 3
++   i32.eq
++   if
++    i32.const 2000
++    i32.const 1664
++    i32.const 338
++    i32.const 7
++    call $~lib/builtins/abort
++    unreachable
++   end
++   local.get $1
++   call $~lib/rt/itcms/Object#unlink
++   local.get $1
++   global.get $~lib/rt/itcms/pinSpace
++   i32.const 3
++   call $~lib/rt/itcms/Object#linkTo
++  end
++  local.get $0
++ )
++ (func $~lib/rt/itcms/__unpin (param $0 i32)
++  local.get $0
++  i32.eqz
++  if
++   return
++  end
++  local.get $0
++  i32.const 20
++  i32.sub
++  local.tee $0
++  i32.load offset=4
++  i32.const 3
++  i32.and
++  i32.const 3
++  i32.ne
++  if
++   i32.const 2064
++   i32.const 1664
++   i32.const 352
++   i32.const 5
++   call $~lib/builtins/abort
++   unreachable
++  end
++  global.get $~lib/rt/itcms/state
++  i32.const 1
++  i32.eq
++  if
++   local.get $0
++   call $~lib/rt/itcms/Object#makeGray
++  else
++   local.get $0
++   call $~lib/rt/itcms/Object#unlink
++   local.get $0
++   global.get $~lib/rt/itcms/fromSpace
++   global.get $~lib/rt/itcms/white
++   call $~lib/rt/itcms/Object#linkTo
++  end
++ )
++ (func $~lib/rt/itcms/__collect
++  global.get $~lib/rt/itcms/state
++  i32.const 0
++  i32.gt_s
++  if
++   loop $while-continue|0
++    global.get $~lib/rt/itcms/state
++    if
++     call $~lib/rt/itcms/step
++     drop
++     br $while-continue|0
++    end
++   end
++  end
++  call $~lib/rt/itcms/step
++  drop
++  loop $while-continue|1
++   global.get $~lib/rt/itcms/state
++   if
++    call $~lib/rt/itcms/step
++    drop
++    br $while-continue|1
++   end
++  end
++  global.get $~lib/rt/itcms/total
++  i64.extend_i32_u
++  i64.const 200
++  i64.mul
++  i64.const 100
++  i64.div_u
++  i32.wrap_i64
++  i32.const 1024
++  i32.add
++  global.set $~lib/rt/itcms/threshold
++ )
++ (func $~lib/rt/__visit_members (param $0 i32)
++  block $invalid
++   block $~lib/arraybuffer/ArrayBufferView
++    block $~lib/string/String
++     block $~lib/arraybuffer/ArrayBuffer
++      block $~lib/object/Object
++       local.get $0
++       i32.const 8
++       i32.sub
++       i32.load
++       br_table $~lib/object/Object $~lib/arraybuffer/ArrayBuffer $~lib/string/String $~lib/arraybuffer/ArrayBufferView $invalid
++      end
++      return
++     end
++     return
++    end
++    return
++   end
++   local.get $0
++   i32.load
++   local.tee $0
++   if
++    local.get $0
++    call $~lib/rt/itcms/__visit
++   end
++   return
++  end
++  unreachable
++ )
++ (func $~start
++  memory.size
++  i32.const 16
++  i32.shl
++  i32.const 34900
++  i32.sub
++  i32.const 1
++  i32.shr_u
++  global.set $~lib/rt/itcms/threshold
++  i32.const 1712
++  call $~lib/rt/itcms/initLazy
++  global.set $~lib/rt/itcms/pinSpace
++  i32.const 1744
++  call $~lib/rt/itcms/initLazy
++  global.set $~lib/rt/itcms/toSpace
++  i32.const 1888
++  call $~lib/rt/itcms/initLazy
++  global.set $~lib/rt/itcms/fromSpace
++ )
++ (func $~stack_check
++  global.get $~lib/memory/__stack_pointer
++  i32.const 2132
++  i32.lt_s
++  if
++   i32.const 34928
++   i32.const 34976
++   i32.const 1
++   i32.const 1
++   call $~lib/builtins/abort
++   unreachable
++  end
++ )
++ (func $~lib/string/String#indexOf (param $0 i32) (param $1 i32) (result i32)
++  (local $2 i32)
++  (local $3 i32)
++  (local $4 i32)
++  (local $5 i32)
++  (local $6 i32)
++  (local $7 i32)
++  (local $8 i32)
++  (local $9 i32)
++  global.get $~lib/memory/__stack_pointer
++  i32.const 8
++  i32.sub
++  global.set $~lib/memory/__stack_pointer
++  call $~stack_check
++  global.get $~lib/memory/__stack_pointer
++  i64.const 0
++  i64.store
++  global.get $~lib/memory/__stack_pointer
++  local.get $1
++  i32.store
++  block $folding-inner1
++   local.get $1
++   i32.const 20
++   i32.sub
++   i32.load offset=16
++   i32.const 1
++   i32.shr_u
++   local.tee $4
++   i32.eqz
++   br_if $folding-inner1
++   global.get $~lib/memory/__stack_pointer
++   local.get $0
++   i32.store
++   local.get $0
++   i32.const 20
++   i32.sub
++   i32.load offset=16
++   i32.const 1
++   i32.shr_u
++   local.tee $2
++   if
++    local.get $2
++    local.get $4
++    i32.sub
++    local.set $8
++    loop $for-loop|0
++     local.get $6
++     local.get $8
++     i32.le_s
++     if
++      global.get $~lib/memory/__stack_pointer
++      local.get $0
++      i32.store
++      global.get $~lib/memory/__stack_pointer
++      local.get $1
++      i32.store offset=4
++      block $__inlined_func$~lib/util/string/compareImpl (result i32)
++       local.get $0
++       local.get $6
++       i32.const 1
++       i32.shl
++       i32.add
++       local.tee $7
++       i32.const 7
++       i32.and
++       local.get $1
++       local.tee $3
++       i32.const 7
++       i32.and
++       i32.or
++       i32.eqz
++       local.get $4
++       local.tee $2
++       i32.const 4
++       i32.ge_u
++       i32.and
++       if
++        loop $do-loop|0
++         local.get $7
++         i64.load
++         local.get $3
++         i64.load
++         i64.eq
++         if
++          local.get $7
++          i32.const 8
++          i32.add
++          local.set $7
++          local.get $3
++          i32.const 8
++          i32.add
++          local.set $3
++          local.get $2
++          i32.const 4
++          i32.sub
++          local.tee $2
++          i32.const 4
++          i32.ge_u
++          br_if $do-loop|0
++         end
++        end
++       end
++       loop $while-continue|1
++        local.get $2
++        local.tee $5
++        i32.const 1
++        i32.sub
++        local.set $2
++        local.get $5
++        if
++         local.get $7
++         i32.load16_u
++         local.tee $5
++         local.get $3
++         i32.load16_u
++         local.tee $9
++         i32.ne
++         if
++          local.get $5
++          local.get $9
++          i32.sub
++          br $__inlined_func$~lib/util/string/compareImpl
++         end
++         local.get $7
++         i32.const 2
++         i32.add
++         local.set $7
++         local.get $3
++         i32.const 2
++         i32.add
++         local.set $3
++         br $while-continue|1
++        end
++       end
++       i32.const 0
++      end
++      i32.eqz
++      br_if $folding-inner1
++      local.get $6
++      i32.const 1
++      i32.add
++      local.set $6
++      br $for-loop|0
++     end
++    end
++   end
++   i32.const -1
++   local.set $6
++  end
++  global.get $~lib/memory/__stack_pointer
++  i32.const 8
++  i32.add
++  global.set $~lib/memory/__stack_pointer
++  local.get $6
++ )
++ (func $~lib/string/String#includes (param $0 i32) (param $1 i32) (result i32)
++  global.get $~lib/memory/__stack_pointer
++  i32.const 8
++  i32.sub
++  global.set $~lib/memory/__stack_pointer
++  call $~stack_check
++  global.get $~lib/memory/__stack_pointer
++  i64.const 0
++  i64.store
++  global.get $~lib/memory/__stack_pointer
++  local.get $0
++  i32.store
++  global.get $~lib/memory/__stack_pointer
++  local.get $1
++  i32.store offset=4
++  local.get $0
++  local.get $1
++  call $~lib/string/String#indexOf
++  i32.const -1
++  i32.ne
++  local.set $0
++  global.get $~lib/memory/__stack_pointer
++  i32.const 8
++  i32.add
++  global.set $~lib/memory/__stack_pointer
++  local.get $0
++ )
++ (func $export:src/agent/governance/sandbox/core.as/evaluate (param $0 i32) (param $1 i32) (param $2 i32) (result i32)
++  global.get $~lib/memory/__stack_pointer
++  i32.const 12
++  i32.sub
++  global.set $~lib/memory/__stack_pointer
++  call $~stack_check
++  global.get $~lib/memory/__stack_pointer
++  local.get $0
++  i32.store
++  global.get $~lib/memory/__stack_pointer
++  local.get $1
++  i32.store offset=4
++  global.get $~lib/memory/__stack_pointer
++  local.get $2
++  i32.store offset=8
++  global.get $~lib/memory/__stack_pointer
++  i32.const 8
++  i32.sub
++  global.set $~lib/memory/__stack_pointer
++  call $~stack_check
++  global.get $~lib/memory/__stack_pointer
++  i64.const 0
++  i64.store
++  global.get $~lib/memory/__stack_pointer
++  local.get $0
++  i32.store
++  global.get $~lib/memory/__stack_pointer
++  i32.const 1056
++  i32.store offset=4
++  block $folding-inner0 (result i32)
++   i32.const 1152
++   local.get $0
++   i32.const 1056
++   call $~lib/string/String#includes
++   if (result i32)
++    i32.const 1
++   else
++    global.get $~lib/memory/__stack_pointer
++    local.get $0
++    i32.store
++    global.get $~lib/memory/__stack_pointer
++    i32.const 1104
++    i32.store offset=4
++    local.get $0
++    i32.const 1104
++    call $~lib/string/String#includes
++   end
++   br_if $folding-inner0
++   drop
++   global.get $~lib/memory/__stack_pointer
++   local.get $2
++   i32.store
++   i32.const 1296
++   local.get $2
++   i32.const 20
++   i32.sub
++   i32.load offset=16
++   i32.const 1
++   i32.shr_u
++   i32.const 5000
++   i32.gt_u
++   br_if $folding-inner0
++   drop
++   i32.const 1456
++  end
++  local.set $0
++  global.get $~lib/memory/__stack_pointer
++  i32.const 8
++  i32.add
++  global.set $~lib/memory/__stack_pointer
++  global.get $~lib/memory/__stack_pointer
++  i32.const 12
++  i32.add
++  global.set $~lib/memory/__stack_pointer
++  local.get $0
++ )
++)
+diff --git a/package.json b/package.json
+index c50179b..ce48fab 100644
+--- a/package.json
++++ b/package.json
+@@ -18,7 +18,10 @@
+     "prepare": "npm run build",
+     "prepublishOnly": "npm run build",
+     "test": "jest",
+-    "verify": "./verify.sh"
++    "verify": "./verify.sh",
++    "asbuild:debug": "asc src/agent/governance/sandbox/core.as.ts --target debug",
++    "asbuild:release": "asc src/agent/governance/sandbox/core.as.ts --target release",
++    "asbuild": "npm run asbuild:release"
+   },
+   "keywords": [
+     "yuangs",
+@@ -57,7 +60,9 @@
+     "jest": "^29.7.0",
+     "ts-jest": "^29.4.6",
+     "ts-node": "^10.9.2",
+-    "typescript": "^5.9.3"
++    "typescript": "^5.9.3",
++    "assemblyscript": "^0.27.29",
++    "@assemblyscript/loader": "^0.27.29"
+   },
+   "engines": {
+     "node": ">=18"
+@@ -65,4 +70,4 @@
+   "publishConfig": {
+     "access": "public"
+   }
+-}
++}
+\ No newline at end of file
+diff --git a/policy.yaml b/policy.yaml
+new file mode 100644
+index 0000000..8da12f1
+--- /dev/null
++++ b/policy.yaml
+@@ -0,0 +1,26 @@
++version: 1
++rules:
++  - id: block-root-deletion
++    when:
++      type: shell_cmd
++      pattern: "rm\\s+-rf\\s+/"
++    effect: deny
++    reason: ""
++
++  - id: require-human-for-sudo
++    when:
++      type: shell_cmd
++      pattern: "sudo\\s+"
++    effect: require_approval
++    reason: ""
++
++  - id: auto-approve-reads
++    when:
++      type: read_file
++    effect: allow
++
++  - id: default-medium-risk
++    when:
++      type: write_file
++    effect: require_approval
++    reason: ""
+diff --git a/src/Capabilities.ts b/src/Capabilities.ts
+new file mode 100644
+index 0000000..c8ba9aa
+--- /dev/null
++++ b/src/Capabilities.ts
+@@ -0,0 +1,38 @@
++import { exec } from 'child_process';
++import { promisify } from 'util';
++import fs from 'fs/promises';
++
++const execAsync = promisify(exec);
++
++/**
++ * [Action 2]  Capability
++ */
++export class Capabilities {
++    static async execute(proposal: any) {
++        const { type, payload } = proposal;
++
++        switch (type) {
++            case 'SHELL':
++                const { stdout, stderr } = await execAsync(payload.cmd);
++                return stdout || stderr;
++
++            case 'FILESYSTEM':
++                if (payload.content) {
++                    await fs.writeFile(payload.path, payload.content);
++                    return `Saved ${payload.path}`;
++                }
++                return await fs.readFile(payload.path, 'utf-8');
++
++            case 'PROJECT':
++                //  NPM 
++                const { stdout: npmOut } = await execAsync(payload.cmd);
++                return npmOut;
++
++            case 'KNOWLEDGE':
++                return `Simulation: Answer found for ${payload.query}`;
++
++            default:
++                throw new Error(`Unknown capability: ${type}`);
++        }
++    }
++}
+diff --git a/src/Governance.ts b/src/Governance.ts
+new file mode 100644
+index 0000000..08dcd63
+--- /dev/null
++++ b/src/Governance.ts
+@@ -0,0 +1,23 @@
++/**
++ * [Action 4] Governance 
++ */
++export class Governance {
++    static async evaluate(proposal: any): Promise<{ approved: boolean; reason?: string }> {
++        const dangerousCommands = ['rm -rf /', ':(){ :|:& };:', 'mv / /dev/null'];
++
++        // 
++        if (proposal.type === 'SHELL') {
++            const cmd = proposal.payload.cmd.toLowerCase();
++            if (dangerousCommands.some(c => cmd.includes(c))) {
++                return { approved: false, reason: 'CRITICAL RISK: Dangerous command detected.' };
++            }
++        }
++
++        if (proposal.type === 'PROJECT' && proposal.payload.cmd.includes('publish')) {
++            // 
++            return { approved: false, reason: 'POLICY: Human approval required for npm publish.' };
++        }
++
++        return { approved: true };
++    }
++}
+diff --git a/src/Kernel.ts b/src/Kernel.ts
+new file mode 100644
+index 0000000..bb7f06a
+--- /dev/null
++++ b/src/Kernel.ts
+@@ -0,0 +1,51 @@
++import { ActionProposal, GovernanceDecision, AgentCapability } from './types';
++import { Governance } from './Governance';
++import { Capabilities } from './Capabilities';
++import chalk from 'chalk';
++
++/**
++ * [Action 1]  Loop
++ *  Loop, Agent, Executor, Context
++ */
++export class Kernel {
++    private state: any = { turns: 0, lastResult: null };
++
++    /**
++     *  ->  -> 
++     */
++    async step(intent: string) {
++        this.state.turns++;
++
++        // 1.  (AI Thinking)
++        const proposal = await this.think(intent);
++
++        // 2.  (Action 4: Governance )
++        const decision = await Governance.evaluate(proposal);
++
++        if (!decision.approved) {
++            console.log(chalk.red(`[REJECTED] ${decision.reason}`));
++            return;
++        }
++
++        // 3.  (Action 2:  Capability )
++        try {
++            const result = await Capabilities.execute(proposal);
++            this.state.lastResult = result;
++            console.log(chalk.green(`[SUCCESS] Turn ${this.state.turns} completed.`));
++        } catch (e: any) {
++            // Action 5: 
++            this.logAudit(proposal, e.message);
++        }
++    }
++
++    private async think(intent: string): Promise<ActionProposal> {
++        //  Capability
++        if (intent.includes('npm')) return { type: 'PROJECT', payload: { cmd: intent }, rationale: 'NPM management' };
++        if (intent.includes('git') || intent.includes('ls')) return { type: 'SHELL', payload: { cmd: intent }, rationale: 'System operation' };
++        return { type: 'KNOWLEDGE', payload: { query: intent }, rationale: 'Information retrieval' };
++    }
++
++    private logAudit(proposal: ActionProposal, error: string) {
++        console.error(chalk.gray(`[AUDIT] Action ${proposal.type} failed: ${error}`));
++    }
++}
+diff --git a/src/agent/AgentRuntime.ts b/src/agent/AgentRuntime.ts
+new file mode 100644
+index 0000000..3a16160
+--- /dev/null
++++ b/src/agent/AgentRuntime.ts
+@@ -0,0 +1,109 @@
++import chalk from 'chalk';
++import ora from 'ora';
++import { randomUUID } from 'crypto';
++import { LLMAdapter } from './llmAdapter';
++import { GovernanceService } from './governance';
++import { ToolExecutor } from './executor';
++import { ContextManager } from './contextManager';
++import { StreamMarkdownRenderer } from '../utils/renderer';
++import { learnSkillFromRecord } from './skills';
++import { capabilitySystem } from '../core/capabilitySystem';
++import { ExecutionTurn, ProposedAction } from './state';
++import { evaluateProposal } from './governance/core';
++
++export class AgentRuntime {
++    private context: ContextManager;
++    private executionId: string;
++
++    constructor(initialContext: any) {
++        this.context = new ContextManager(initialContext);
++        this.executionId = randomUUID();
++    }
++
++    async run(userInput: string, mode: 'chat' | 'command' = 'chat') {
++        let turnCount = 0;
++        const maxTurns = 10;
++
++        while (turnCount < maxTurns) {
++            console.log(chalk.blue(`\n--- Turn ${++turnCount} ---`));
++
++            // 1.  (Think) & 
++            //  capabilitySystem 
++            const requirement = { required: ['reasoning'], preferred: [] };
++            const match = capabilitySystem.matchCapability(requirement as any);
++            const model = match.selected?.name || 'Assistant';
++
++            //  ()
++            const spinner = ora(chalk.cyan('AI Thinking...')).start();
++            const renderer = new StreamMarkdownRenderer(chalk.bold.blue(' AI: '), spinner);
++
++            const thought = await this.think(
++                this.context.getMessages(),
++                model,
++                (chunk: string) => renderer.onChunk(chunk) // 
++            );
++            renderer.finish();
++
++            if (thought.isDone) {
++                console.log(chalk.green('\n'));
++                break;
++            }
++
++            // 2.  (Adjudicate)
++            const action: ProposedAction = {
++                id: randomUUID(),
++                type: thought.type as any,
++                payload: thought.payload,
++                riskLevel: GovernanceService.evaluateRisk(thought),
++                reasoning: thought.reasoning || ''
++            };
++
++            // === [Patch 3]  (Pre-flight Check) ===
++            const preCheck = evaluateProposal(action, GovernanceService.getRules(), GovernanceService.getLedgerSnapshot());
++            if (preCheck.effect === 'deny') {
++                console.log(chalk.red(`[PRE-FLIGHT] : ${preCheck.reason}`));
++                this.context.addMessage('system', `POLICY DENIED: ${preCheck.reason}. Please try a different approach.`);
++                continue; //  AI 
++            }
++
++            const decision = await GovernanceService.adjudicate(action);
++
++            if (decision.status === 'rejected') {
++                this.context.addMessage('system', `User rejected action: ${decision.reason}`);
++                continue;
++            }
++
++            // 3.  (Execute)
++            const finalAction = decision.status === 'modified' ? decision.modifiedAction! : action;
++            const result = await ToolExecutor.execute(finalAction as any);
++
++            // 4.  (Learn) - 
++            if (result.success) {
++                //  Record 
++                learnSkillFromRecord({
++                    id: this.executionId,
++                    llmResult: { plan: { goal: action.reasoning } },
++                    input: { rawInput: userInput },
++                    mode: 'command+exec'
++                } as any, true);
++            }
++
++            // 5.  (Observe)
++            const output = result.success ? (result.output || '').substring(0, 2000) : result.error;
++            this.context.addToolResult(finalAction.type, output || '');
++        }
++    }
++
++    private async think(messages: any[], model: string, onChunk: any) {
++        const laws = GovernanceService.getPolicyManual();
++        const systemPrompt = `You are a Governed AI. 
++CURRENT LAWS:
++${laws}
++
++Always check if your plan violates these laws before proposing. 
++If a law requires human approval, explain to the user why it's necessary.
++Output JSON format: { "action_type": "...", "payload": {...}, "reasoning": "...", "is_done": false }`;
++
++        return await LLMAdapter.think(messages, model, onChunk, systemPrompt);
++    }
++}
+diff --git a/src/agent/executor.ts b/src/agent/executor.ts
+index 39f1557..e6b5146 100644
+--- a/src/agent/executor.ts
++++ b/src/agent/executor.ts
+@@ -1,207 +1,27 @@
++import fs from 'fs/promises';
+ import { exec } from 'child_process';
+ import { promisify } from 'util';
+-import fs from 'fs/promises';
+-import path from 'path';
+-import { ProposedAction, ToolExecutionResult } from './state';
+-
+ const execAsync = promisify(exec);
+ 
+ export class ToolExecutor {
+-  static async execute(action: ProposedAction): Promise<ToolExecutionResult> {
++  static async execute(action: { type: string, payload: any }) {
+     const { type, payload } = action;
+-
+     try {
+       switch (type) {
+-        case 'tool_call':
+-          return await this.executeTool(payload);
+-        
+         case 'shell_cmd':
+-          return await this.executeShell(payload.command);
+-        
+-        case 'code_diff':
+-          return await this.executeDiff(payload.diff);
+-        
+-        case 'answer':
+-          return {
+-            success: true,
+-            output: payload.content || '',
+-            artifacts: []
+-          };
+-        
++          const { stdout, stderr } = await execAsync(payload.command);
++          return { success: true, output: stdout || stderr };
++        case 'read_file':
++          const content = await fs.readFile(payload.path, 'utf-8');
++          return { success: true, output: content };
++        case 'write_file':
++          await fs.writeFile(payload.path, payload.content);
++          return { success: true, output: `Successfully wrote ${payload.path}` };
+         default:
+-          return {
+-            success: false,
+-            error: `Unknown action type: ${type}`,
+-            output: ''
+-          };
++          return { success: false, error: `Unknown capability: ${type}` };
+       }
+-    } catch (error: any) {
+-      return {
+-        success: false,
+-        error: error.message || String(error),
+-        output: ''
+-      };
+-    }
+-  }
+-
+-  private static async executeTool(payload: any): Promise<ToolExecutionResult> {
+-    const toolName = payload.tool_name;
+-
+-    switch (toolName) {
+-      case 'read_file':
+-        return await this.toolReadFile(payload.parameters);
+-      
+-      case 'write_file':
+-        return await this.toolWriteFile(payload.parameters);
+-      
+-      case 'list_files':
+-        return await this.toolListFiles(payload.parameters);
+-      
+-      case 'web_search':
+-        return {
+-          success: false,
+-          error: 'web_search not implemented yet',
+-          output: ''
+-        };
+-      
+-      default:
+-        return {
+-          success: false,
+-          error: `Unknown tool: ${toolName}`,
+-          output: ''
+-        };
+-    }
+-  }
+-
+-  private static async toolReadFile(params: any): Promise<ToolExecutionResult> {
+-    const filePath = params.path;
+-    try {
+-      const content = await fs.readFile(filePath, 'utf-8');
+-      return {
+-        success: true,
+-        output: content,
+-        artifacts: [filePath]
+-      };
+-    } catch (error: any) {
+-      return {
+-        success: false,
+-        error: error.message,
+-        output: ''
+-      };
+-    }
+-  }
+-
+-  private static async toolWriteFile(params: any): Promise<ToolExecutionResult> {
+-    const filePath = params.path;
+-    const content = params.content;
+-    
+-    try {
+-      await fs.mkdir(path.dirname(filePath), { recursive: true });
+-      await fs.writeFile(filePath, content, 'utf-8');
+-      return {
+-        success: true,
+-        output: `Successfully wrote ${filePath}`,
+-        artifacts: [filePath]
+-      };
+-    } catch (error: any) {
+-      return {
+-        success: false,
+-        error: error.message,
+-        output: ''
+-      };
+-    }
+-  }
+-
+-  private static async toolListFiles(params: any): Promise<ToolExecutionResult> {
+-    const dirPath = params.path || '.';
+-    const recursive = params.recursive || false;
+-    
+-    try {
+-      const files = await this.getFiles(dirPath, recursive);
+-      return {
+-        success: true,
+-        output: JSON.stringify(files, null, 2),
+-        artifacts: files.map(f => f.path)
+-      };
+-    } catch (error: any) {
+-      return {
+-        success: false,
+-        error: error.message,
+-        output: ''
+-      };
+-    }
+-  }
+-
+-  private static async getFiles(dir: string, recursive: boolean): Promise<Array<{ path: string; type: string }>> {
+-    const entries = await fs.readdir(dir, { withFileTypes: true });
+-    const files: Array<{ path: string; type: string }> = [];
+-
+-    for (const entry of entries) {
+-      const fullPath = path.join(dir, entry.name);
+-      
+-      if (entry.isDirectory()) {
+-        files.push({ path: fullPath, type: 'directory' });
+-        if (recursive) {
+-          const subFiles = await this.getFiles(fullPath, recursive);
+-          files.push(...subFiles);
+-        }
+-      } else {
+-        files.push({ path: fullPath, type: 'file' });
+-      }
+-    }
+-
+-    return files;
+-  }
+-
+-  private static async executeShell(command: string): Promise<ToolExecutionResult> {
+-    try {
+-      const { stdout, stderr } = await execAsync(command, {
+-        maxBuffer: 10 * 1024 * 1024,
+-        cwd: process.cwd()
+-      });
+-
+-      const output = stdout || stderr || '';
+-      
+-      return {
+-        success: true,
+-        output,
+-        artifacts: []
+-      };
+-    } catch (error: any) {
+-      return {
+-        success: false,
+-        error: error.message,
+-        output: error.stdout || error.stderr || ''
+-      };
+-    }
+-  }
+-
+-  private static async executeDiff(diff: string): Promise<ToolExecutionResult> {
+-    try {
+-      const tempFile = path.join(process.cwd(), '.yuangs_temp.patch');
+-      await fs.writeFile(tempFile, diff, 'utf-8');
+-
+-      const { stdout, stderr } = await execAsync(`git apply --check ${tempFile}`, {
+-        cwd: process.cwd()
+-      });
+-
+-      const { stdout: applyOutput } = await execAsync(`git apply ${tempFile}`, {
+-        cwd: process.cwd()
+-      });
+-
+-      await fs.unlink(tempFile);
+-
+-      return {
+-        success: true,
+-        output: applyOutput || 'Diff applied successfully',
+-        artifacts: ['.yuangs_temp.patch']
+-      };
+-    } catch (error: any) {
+-      return {
+-        success: false,
+-        error: error.message,
+-        output: error.stdout || error.stderr || 'Failed to apply diff'
+-      };
++    } catch (e: any) {
++      return { success: false, error: e.message };
+     }
+   }
+ }
+diff --git a/src/agent/governance.ts b/src/agent/governance.ts
+index b14956c..9955f9e 100644
+--- a/src/agent/governance.ts
++++ b/src/agent/governance.ts
+@@ -1,173 +1,124 @@
+ import readline from 'readline';
+-import { ProposedAction, GovernanceDecision, RiskLevel } from './state';
+ import chalk from 'chalk';
+-import ora from 'ora';
+-
+-export class GovernanceService {
+-  static async adjudicate(
+-    action: ProposedAction,
+-    config: { autoApproveLowRisk: boolean } = { autoApproveLowRisk: true }
+-  ): Promise<GovernanceDecision> {
+-    const { autoApproveLowRisk } = config;
+-
+-    if (autoApproveLowRisk && action.riskLevel === 'low') {
+-      console.log(chalk.gray(`[Auto-approved] ${action.type}: low risk action`));
+-      return {
+-        status: 'approved',
+-        by: 'policy',
+-        timestamp: Date.now()
+-      };
+-    }
+-
+-    const spinner = ora(chalk.yellow('  Waiting for approval...')).start();
+-
+-    const answer = await this.askHuman(action);
+-    spinner.stop();
+-
+-    if (answer.approve) {
+-      return {
+-        status: 'approved',
+-        by: 'human',
+-        timestamp: Date.now()
+-      };
+-    } else if (answer.modify) {
+-      return {
+-        status: 'modified',
+-        by: 'human',
+-        originalActionId: action.id,
+-        modifiedAction: answer.modifiedAction!,
+-        modificationReason: answer.reason || 'User modified',
+-        timestamp: Date.now()
+-      };
+-    } else {
+-      return {
+-        status: 'rejected',
+-        by: 'human',
+-        reason: answer.reason || 'User rejected',
+-        timestamp: Date.now()
+-      };
+-    }
+-  }
+-
+-  private static askHuman(action: ProposedAction): Promise<{
+-    approve: boolean;
+-    modify: boolean;
+-    modifiedAction?: ProposedAction;
+-    reason?: string;
+-  }> {
+-    const rl = readline.createInterface({
+-      input: process.stdin,
+-      output: process.stdout
+-    });
+-
+-    return new Promise((resolve) => {
+-      this.printActionDetails(action);
+-
+-      const prompt = `
+-${chalk.bold.yellow('Proceed?')} (y/n/s) 
+-${chalk.gray('y = yes, n = no, s = skip/modify')}: `;
+-
+-      rl.question(prompt, (answer) => {
+-        const lower = answer.trim().toLowerCase();
+-
+-        if (lower === 'y' || lower === 'yes') {
+-          rl.close();
+-          resolve({ approve: true, modify: false });
+-        } else if (lower === 's' || lower === 'skip' || lower === 'modify') {
+-          rl.close();
+-          resolve({ 
+-            approve: false, 
+-            modify: true, 
+-            reason: 'User wants to modify',
+-            modifiedAction: { ...action } 
+-          });
+-        } else {
+-          rl.question(chalk.red('Reason for rejection: '), (reason) => {
+-            rl.close();
+-            resolve({ 
+-              approve: false, 
+-              modify: false, 
+-              reason: reason || 'User rejected' 
+-            });
+-          });
+-        }
+-      });
++import fs from 'fs';
++import yaml from 'js-yaml';
++import path from 'path';
++import { ProposedAction, GovernanceDecision } from './state';
++import { evaluateProposal, PolicyRule } from './governance/core';
++import { RiskLedger } from './governance/ledger';
++import { WasmGovernanceBridge } from './governance/bridge';
++
++class PolicyEngine {
++  public rules: PolicyRule[] = [];
++  private policyPath = path.join(process.cwd(), 'policy.yaml');
++
++  constructor() {
++    this.loadPolicy();
++    // 
++    fs.watchFile(this.policyPath, () => {
++      console.log(chalk.gray('\n[Policy] ...'));
++      this.loadPolicy();
+     });
+   }
+ 
+-  private static printActionDetails(action: ProposedAction): void {
+-    const riskColor = {
+-      low: chalk.green,
+-      medium: chalk.yellow,
+-      high: chalk.red
+-    };
+-
+-    console.log(`
+-${chalk.bold.cyan(''.repeat(60))}
+-${chalk.bold.blue(' Action Proposed')}
+-${chalk.bold.cyan(''.repeat(60))}
+-${chalk.white('Type:')} ${chalk.bold(action.type)}
+-${chalk.white('ID:')} ${action.id}
+-${chalk.white('Risk:')} ${riskColor[action.riskLevel](action.riskLevel.toUpperCase())}
+-
+-${chalk.bold('Payload:')}
+-${chalk.gray(JSON.stringify(action.payload, null, 2))}
+-
+-${chalk.bold('Reasoning:')}
+-${chalk.gray(action.reasoning)}
+-${chalk.bold.cyan(''.repeat(60))}
+-`);
++  private loadPolicy() {
++    try {
++      const content = fs.readFileSync(this.policyPath, 'utf8');
++      const doc = yaml.load(content) as any;
++      this.rules = doc.rules || [];
++    } catch (e) {
++      console.error(chalk.red(' policy.yaml '));
++    }
+   }
++}
+ 
+-  static evaluateRisk(action: ProposedAction): RiskLevel {
+-    const { type, payload } = action;
++export class GovernanceService {
++  private static engine = new PolicyEngine();
++  private static ledger = new RiskLedger();
++  private static wasmBridge = new WasmGovernanceBridge();
++  private static wasmInited = false;
++
++  /**
++   *  YAML  AI 
++   */
++  static getPolicyManual(): string {
++    return this.engine.rules
++      .map(r => `- ${r.id}: ${r.reason || ''} (: ${r.effect})`)
++      .join('\n');
++  }
+ 
+-    if (type === 'tool_call') {
+-      const toolName = payload.tool_name;
+-      
+-      const lowRiskTools = ['read_file', 'list_files', 'web_search'];
+-      if (lowRiskTools.includes(toolName)) {
+-        return 'low';
++  static getRules(): PolicyRule[] { return this.engine.rules; }
++  static getLedgerSnapshot() { return this.ledger.getSnapshot(); }
++
++  static async adjudicate(action: ProposedAction): Promise<GovernanceDecision> {
++    // 0.  WASM ()
++    if (!this.wasmInited) {
++      try {
++        await this.wasmBridge.init();
++        this.wasmInited = true;
++      } catch (e) {
++        console.error(chalk.yellow(`[WASM] : ${(e as Error).message}`));
+       }
++    }
+ 
+-      const mediumRiskTools = ['write_file', 'shell'];
+-      if (mediumRiskTools.includes(toolName)) {
+-        const cmd = payload.parameters?.command || payload.command || '';
+-        if (this.containsDangerousCommand(cmd)) {
+-          return 'high';
+-        }
+-        return 'medium';
+-      }
++    // 1. 
++    let effect: string;
++    let reason: string | undefined;
++
++    if (this.wasmInited) {
++      //  WASM 
++      const wasmResult = this.wasmBridge.evaluate(
++        action,
++        this.engine.rules,
++        this.ledger.getSnapshot()
++      );
++      effect = wasmResult.effect;
++      reason = wasmResult.reason;
++    } else {
++      //  (WASM-Ready)
++      const result = evaluateProposal(
++        action,
++        this.engine.rules,
++        this.ledger.getSnapshot()
++      );
++      effect = result.effect;
++      reason = result.reason;
++    }
+ 
+-      return 'medium';
++    if (effect === 'allow') {
++      this.ledger.record(action.type); // 
++      return { status: 'approved', by: 'policy', timestamp: Date.now() };
+     }
+ 
+-    if (type === 'shell_cmd') {
+-      const cmd = payload.command || '';
+-      if (this.containsDangerousCommand(cmd)) {
+-        return 'high';
+-      }
+-      return 'medium';
++    if (effect === 'deny') {
++      console.log(chalk.red(`\n : ${reason}`));
++      return { status: 'rejected', by: 'policy', reason: reason || 'Policy Violation', timestamp: Date.now() };
+     }
+ 
+-    if (type === 'code_diff') {
+-      return 'medium';
++    // 2. 
++    console.log(chalk.yellow(`\n : ${action.type}`));
++    if (reason) console.log(chalk.gray(`: ${reason}`));
++    console.log(chalk.gray(`AI : ${action.reasoning}`));
++    console.log(chalk.cyan(`: ${JSON.stringify(action.payload)}`));
++
++    const ans = await this.ask('? (y/n): ');
++    if (ans === 'y') {
++      this.ledger.record(action.type); // 
++      return { status: 'approved', by: 'human', timestamp: Date.now() };
+     }
+ 
++    return { status: 'rejected', by: 'human', reason: 'User denied', timestamp: Date.now() };
++  }
++
++  static evaluateRisk(action: any): 'low' | 'medium' | 'high' {
++    const cmd = JSON.stringify(action.payload).toLowerCase();
++    if (/rm\s+-rf|sudo|chmod\s+777/.test(cmd)) return 'high';
++    if (['shell_cmd', 'write_file'].includes(action.type)) return 'medium';
+     return 'low';
+   }
+ 
+-  private static containsDangerousCommand(cmd: string): boolean {
+-    const dangerousPatterns = [
+-      /rm\s+-rf\s+\//,
+-      /rm\s+-rf\s+~/,
+-      />\s*\/dev\/null/,
+-      /dd\s+if=/,
+-      /mkfs/,
+-      /format/,
+-      /sudo\s+rm/
+-    ];
+-
+-    return dangerousPatterns.some(pattern => pattern.test(cmd));
++  private static ask(q: string): Promise<string> {
++    const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
++    return new Promise(res => rl.question(chalk.bold.cyan(q), a => { rl.close(); res(a.toLowerCase()); }));
+   }
+ }
+diff --git a/src/agent/governance/bridge.ts b/src/agent/governance/bridge.ts
+new file mode 100644
+index 0000000..077dac3
+--- /dev/null
++++ b/src/agent/governance/bridge.ts
+@@ -0,0 +1,42 @@
++import fs from 'fs';
++import path from 'path';
++import loader from '@assemblyscript/loader';
++
++export class WasmGovernanceBridge {
++    private wasmInstance: any = null;
++
++    async init() {
++        const wasmPath = path.join(process.cwd(), 'build/governance.release.wasm');
++        if (!fs.existsSync(wasmPath)) {
++            //  debug 
++            const debugPath = path.join(process.cwd(), 'build/governance.debug.wasm');
++            if (!fs.existsSync(debugPath)) {
++                throw new Error(`WASM  npm run asbuild. : ${wasmPath}`);
++            }
++            this.wasmInstance = await loader.instantiate(fs.readFileSync(debugPath), {});
++        } else {
++            const wasmModule = fs.readFileSync(wasmPath);
++            //  WASM
++            this.wasmInstance = await loader.instantiate(wasmModule, {});
++        }
++        console.log(' WASM ');
++    }
++
++    evaluate(action: any, rules: any[], ledger: any[]): { effect: string, reason?: string } {
++        if (!this.wasmInstance) throw new Error("WASM ");
++
++        const { __newString, __getString, evaluate } = this.wasmInstance.exports;
++
++        // 
++        const proposalPtr = __newString(JSON.stringify(action));
++        const rulesPtr = __newString(JSON.stringify(rules));
++        const ledgerPtr = __newString(JSON.stringify(ledger));
++
++        // 
++        const resultPtr = evaluate(proposalPtr, rulesPtr, ledgerPtr);
++
++        // 
++        const resultJson = __getString(resultPtr);
++        return JSON.parse(resultJson);
++    }
++}
+diff --git a/src/agent/governance/core.ts b/src/agent/governance/core.ts
+new file mode 100644
+index 0000000..155fbcc
+--- /dev/null
++++ b/src/agent/governance/core.ts
+@@ -0,0 +1,45 @@
++import { ProposedAction } from '../state';
++
++export interface PolicyRule {
++    id: string;
++    when: { type?: string; pattern?: string; max_per_minute?: number };
++    effect: 'allow' | 'deny' | 'require_approval';
++    reason?: string;
++}
++
++export interface RiskEntry {
++    ts: number;
++    actionType: string;
++}
++
++/**
++ *  ( WASM)
++ * 
++ * 
++ */
++export function evaluateProposal(
++    action: ProposedAction,
++    rules: PolicyRule[],
++    ledger: RiskEntry[]
++): { effect: string; reason?: string } {
++    const now = Date.now();
++
++    for (const rule of rules) {
++        const typeMatch = !rule.when.type || rule.when.type === action.type;
++        const payloadStr = JSON.stringify(action.payload);
++        const patternMatch = !rule.when.pattern || new RegExp(rule.when.pattern, 'i').test(payloadStr);
++
++        if (typeMatch && patternMatch) {
++            //  ()
++            if (rule.when.max_per_minute) {
++                const minuteAgo = now - 60000;
++                const count = ledger.filter(e => e.ts > minuteAgo && e.actionType === action.type).length;
++                if (count >= rule.when.max_per_minute) {
++                    return { effect: 'deny', reason: `: ${rule.id} ( ${rule.when.max_per_minute} )` };
++                }
++            }
++            return { effect: rule.effect, reason: rule.reason };
++        }
++    }
++    return { effect: 'require_approval', reason: '' };
++}
+diff --git a/src/agent/governance/ledger.ts b/src/agent/governance/ledger.ts
+new file mode 100644
+index 0000000..0ed2315
+--- /dev/null
++++ b/src/agent/governance/ledger.ts
+@@ -0,0 +1,16 @@
++import { RiskEntry } from './core';
++
++export class RiskLedger {
++    private entries: RiskEntry[] = [];
++
++    record(actionType: string) {
++        this.entries.push({ ts: Date.now(), actionType });
++        //  1 
++        const hourAgo = Date.now() - 3600000;
++        this.entries = this.entries.filter(e => e.ts > hourAgo);
++    }
++
++    getSnapshot(): RiskEntry[] {
++        return [...this.entries];
++    }
++}
+diff --git a/src/agent/governance/sandbox/core.as.ts b/src/agent/governance/sandbox/core.as.ts
+new file mode 100644
+index 0000000..0dc41a8
+--- /dev/null
++++ b/src/agent/governance/sandbox/core.as.ts
+@@ -0,0 +1,33 @@
++/**
++ * yuangs Governance WASM Sandbox
++ *  Node.js 
++ */
++
++// WASM 
++function includes(source: string, target: string): boolean {
++    return source.indexOf(target) != -1;
++}
++
++/**
++ * 
++ * @param proposal 
++ * @param rules YAML  JSON
++ * @param ledger 
++ */
++export function evaluate(proposal: string, rules: string, ledger: string): string {
++    // 1. 
++    if (proposal.includes("rm -rf /") || proposal.includes("sudo rm")) {
++        return '{"effect": "deny", "reason": "WASM_SANDBOX: "}';
++    }
++
++    // 2. 
++    //  AI  50 
++    if (ledger.length > 5000) { // 
++        return '{"effect": "deny", "reason": "WASM_SANDBOX: "}';
++    }
++
++    // 3. 
++    //  JSON rules
++    // 
++    return '{"effect": "allow", "reason": "WASM_SANDBOX: "}';
++}
+diff --git a/src/agent/llmAdapter.ts b/src/agent/llmAdapter.ts
+index c6fa6c6..dae2d47 100644
+--- a/src/agent/llmAdapter.ts
++++ b/src/agent/llmAdapter.ts
+@@ -1,97 +1,36 @@
+-import { AgentThought } from './state';
+ import { runLLM } from './llm';
+-import { AgentPrompt } from './types';
+-import type { AIRequestMessage } from '../core/validation';
+-import { getUserConfig } from '../ai/client';
++import { extractJSON } from '../core/validation';
+ 
+ export class LLMAdapter {
+-  static async think(
+-    messages: AIRequestMessage[],
+-    mode: 'chat' | 'command' | 'command+exec',
+-    outputSchema?: any
+-  ): Promise<AgentThought> {
+-    const prompt: AgentPrompt = {
+-      system: `You are yuangs AI Assistant. You are operating in Governance-First ReAct Loop mode.
+-      
+-Available action types:
+-- tool_call: Call a tool (read_file, write_file, web_search, shell)
+-- code_diff: Apply a code diff using unified diff format
+-- shell_cmd: Execute a shell command
+-- answer: Provide a final answer without any tool calls
+-
+-When you need to perform an action, output your plan in this JSON format:
+-{
+-  "action_type": "tool_call" | "code_diff" | "shell_cmd" | "answer",
+-  "tool_name": string,  // for tool_call
+-  "parameters": object,
+-  "command": string,    // for shell_cmd
+-  "diff": string,       // for code_diff
+-  "content": string,     // for answer
+-  "reasoning": string    // Explain why you're taking this action
+-}
+-
+-If the task is complete and no more actions are needed, output:
+-{
+-  "is_done": true,
+-  "final_answer": string
+-}`,
+-      messages,
+-      outputSchema
+-    };
+-
+-    // Use configured model from user settings
+-    const config = getUserConfig();
+-    const model = config.defaultModel || 'Assistant';
++  static async think(messages: any[], model: string, onChunk?: (s: string) => void, customSystemPrompt?: string) {
++    const systemPrompt = customSystemPrompt || `You are a Governed AI. Output JSON format: 
++        { "action_type": "...", "payload": {...}, "reasoning": "...", "is_done": false }`;
+ 
+     const result = await runLLM({
+-      prompt,
+-      model,
+-      stream: false
++      prompt: { messages: [{ role: 'system', content: systemPrompt }, ...messages] },
++      model: model,
++      stream: !!onChunk,
++      onChunk: onChunk
+     });
+ 
+     return this.parseThought(result.rawText);
+   }
+ 
+-  private static parseThought(raw: string): AgentThought {
++  private static parseThought(raw: string) {
+     try {
+-      const jsonMatch = raw.match(/```json\n([\s\S]*?)\n```/) || raw.match(/\{[\s\S]*\}/);
+-      if (jsonMatch) {
+-        const parsed = JSON.parse(jsonMatch[1] || jsonMatch[0]);
+-        
+-        if (parsed.is_done) {
+-          return {
+-            raw,
+-            parsedPlan: parsed,
+-            isDone: true,
+-            type: 'answer'
+-          };
+-        }
+-
+-        return {
+-          raw,
+-          parsedPlan: parsed,
+-          isDone: false,
+-          type: parsed.action_type || 'tool_call',
+-          payload: {
+-            tool_name: parsed.tool_name,
+-            parameters: parsed.parameters,
+-            command: parsed.command,
+-            diff: parsed.diff,
+-            content: parsed.content
+-          },
+-          reasoning: parsed.reasoning || ''
+-        };
+-      }
++      const jsonStr = extractJSON(raw);
++      const parsed = JSON.parse(jsonStr);
++      return {
++        raw,
++        isDone: parsed.is_done || false,
++        type: parsed.action_type || 'answer',
++        payload: parsed.payload || {},
++        reasoning: parsed.reasoning || '',
++        parsedPlan: parsed
++      };
+     } catch (e) {
+-      console.warn('[LLMAdapter] Failed to parse JSON output, using raw text');
++      // 
++      return { raw, isDone: false, type: 'answer', reasoning: raw, payload: {} };
+     }
+-
+-    return {
+-      raw,
+-      parsedPlan: {},
+-      isDone: false,
+-      type: 'answer',
+-      reasoning: raw
+-    };
+   }
+ }
diff --git a/package-lock.json b/package-lock.json
index 8dbd1a4..7bdfd34 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -24,6 +24,7 @@
         "yuangs": "dist/cli.js"
       },
       "devDependencies": {
+        "@assemblyscript/loader": "^0.27.29",
         "@types/jest": "^30.0.0",
         "@types/js-yaml": "^4.0.9",
         "@types/json5": "^0.0.30",
@@ -31,6 +32,7 @@
         "@types/marked-terminal": "^6.1.1",
         "@types/node": "^20.11.30",
         "@types/ora": "^3.1.0",
+        "assemblyscript": "^0.27.29",
         "jest": "^29.7.0",
         "ts-jest": "^29.4.6",
         "ts-node": "^10.9.2",
@@ -40,6 +42,13 @@
         "node": ">=18"
       }
     },
+    "node_modules/@assemblyscript/loader": {
+      "version": "0.27.37",
+      "resolved": "https://registry.npmjs.org/@assemblyscript/loader/-/loader-0.27.37.tgz",
+      "integrity": "sha512-ApMt/6AIEhJhQCzpuPh09BhnQx5BGp8I7/xfHbMs6nt36ye66egIOhy3cehRiwLDJ7ssJh7Yg8piPfTL4KALxQ==",
+      "dev": true,
+      "license": "Apache-2.0"
+    },
     "node_modules/@babel/code-frame": {
       "version": "7.27.1",
       "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.27.1.tgz",
@@ -1590,6 +1599,29 @@
       "integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==",
       "license": "Python-2.0"
     },
+    "node_modules/assemblyscript": {
+      "version": "0.27.37",
+      "resolved": "https://registry.npmjs.org/assemblyscript/-/assemblyscript-0.27.37.tgz",
+      "integrity": "sha512-YtY5k3PiV3SyUQ6gRlR2OCn8dcVRwkpiG/k2T5buoL2ymH/Z/YbaYWbk/f9mO2HTgEtGWjPiAQrIuvA7G/63Gg==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "dependencies": {
+        "binaryen": "116.0.0-nightly.20240114",
+        "long": "^5.2.4"
+      },
+      "bin": {
+        "asc": "bin/asc.js",
+        "asinit": "bin/asinit.js"
+      },
+      "engines": {
+        "node": ">=18",
+        "npm": ">=10"
+      },
+      "funding": {
+        "type": "opencollective",
+        "url": "https://opencollective.com/assemblyscript"
+      }
+    },
     "node_modules/asynckit": {
       "version": "0.4.0",
       "resolved": "https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz",
@@ -1760,6 +1792,17 @@
         "baseline-browser-mapping": "dist/cli.js"
       }
     },
+    "node_modules/binaryen": {
+      "version": "116.0.0-nightly.20240114",
+      "resolved": "https://registry.npmjs.org/binaryen/-/binaryen-116.0.0-nightly.20240114.tgz",
+      "integrity": "sha512-0GZrojJnuhoe+hiwji7QFaL3tBlJoA+KFUN7ouYSDGZLSo9CKM8swQX8n/UcbR0d1VuZKU+nhogNzv423JEu5A==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "bin": {
+        "wasm-opt": "bin/wasm-opt",
+        "wasm2js": "bin/wasm2js"
+      }
+    },
     "node_modules/bl": {
       "version": "5.1.0",
       "resolved": "https://registry.npmjs.org/bl/-/bl-5.1.0.tgz",
@@ -3812,6 +3855,13 @@
         "url": "https://github.com/chalk/chalk?sponsor=1"
       }
     },
+    "node_modules/long": {
+      "version": "5.3.2",
+      "resolved": "https://registry.npmjs.org/long/-/long-5.3.2.tgz",
+      "integrity": "sha512-mNAgZ1GmyNhD7AuqnTG3/VQ26o760+ZYBPKjPvugO8+nLbYfX6TVpJPseBvopbdY+qpZ/lKUnmEc1LeZYS3QAA==",
+      "dev": true,
+      "license": "Apache-2.0"
+    },
     "node_modules/lru-cache": {
       "version": "5.1.1",
       "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-5.1.1.tgz",
diff --git a/package.json b/package.json
index c50179b..ce48fab 100644
--- a/package.json
+++ b/package.json
@@ -18,7 +18,10 @@
     "prepare": "npm run build",
     "prepublishOnly": "npm run build",
     "test": "jest",
-    "verify": "./verify.sh"
+    "verify": "./verify.sh",
+    "asbuild:debug": "asc src/agent/governance/sandbox/core.as.ts --target debug",
+    "asbuild:release": "asc src/agent/governance/sandbox/core.as.ts --target release",
+    "asbuild": "npm run asbuild:release"
   },
   "keywords": [
     "yuangs",
@@ -57,7 +60,9 @@
     "jest": "^29.7.0",
     "ts-jest": "^29.4.6",
     "ts-node": "^10.9.2",
-    "typescript": "^5.9.3"
+    "typescript": "^5.9.3",
+    "assemblyscript": "^0.27.29",
+    "@assemblyscript/loader": "^0.27.29"
   },
   "engines": {
     "node": ">=18"
@@ -65,4 +70,4 @@
   "publishConfig": {
     "access": "public"
   }
-}
+}
\ No newline at end of file
diff --git a/policy.yaml b/policy.yaml
new file mode 100644
index 0000000..8da12f1
--- /dev/null
+++ b/policy.yaml
@@ -0,0 +1,26 @@
+version: 1
+rules:
+  - id: block-root-deletion
+    when:
+      type: shell_cmd
+      pattern: "rm\\s+-rf\\s+/"
+    effect: deny
+    reason: ""
+
+  - id: require-human-for-sudo
+    when:
+      type: shell_cmd
+      pattern: "sudo\\s+"
+    effect: require_approval
+    reason: ""
+
+  - id: auto-approve-reads
+    when:
+      type: read_file
+    effect: allow
+
+  - id: default-medium-risk
+    when:
+      type: write_file
+    effect: require_approval
+    reason: ""
diff --git a/scripts/redteam-test.ts b/scripts/redteam-test.ts
new file mode 100644
index 0000000..1a82d08
--- /dev/null
+++ b/scripts/redteam-test.ts
@@ -0,0 +1,31 @@
+import { WasmGovernanceBridge } from '../src/agent/governance/bridge';
+
+async function testWasmIsolation() {
+    const bridge = new WasmGovernanceBridge();
+    try {
+        await bridge.init();
+    } catch (e) {
+        console.error(" WASM  npm run asbuild");
+        return;
+    }
+
+    console.log("  JS  WASM ...");
+
+    const evilAction = {
+        type: 'shell_cmd',
+        payload: { command: 'rm -rf / --no-preserve-root' }
+    };
+
+    // JS  rules 
+    const tamperedRules: any[] = [];
+
+    const result = bridge.evaluate(evilAction, tamperedRules, []);
+
+    if (result.effect === 'deny') {
+        console.log(" WASM  JS ");
+    } else {
+        console.error(" ");
+    }
+}
+
+testWasmIsolation();
diff --git a/src/agent/AgentPipeline.ts b/src/agent/AgentPipeline.ts
deleted file mode 100644
index 8ea2816..0000000
--- a/src/agent/AgentPipeline.ts
+++ /dev/null
@@ -1,118 +0,0 @@
-import {
-    AgentInput,
-    AgentMode,
-} from './types';
-
-import { ContextBuffer } from '../commands/contextBuffer';
-
-import { inferIntent } from './intent';
-import { buildContext } from './context';
-import { buildPrompt } from './prompt';
-import { selectModel } from './selectModel';
-import { runLLM } from './llm';
-import { interpretResultToPlan } from './interpret';
-import { executePlan } from './planExecutor';
-import { saveRecord } from './record';
-import { learnSkillFromRecord } from './skills';
-import { randomUUID } from 'crypto';
-import { StreamMarkdownRenderer } from '../utils/renderer'; // Import renderer
-import ora, { Ora } from 'ora';
-import chalk from 'chalk';
-
-export class AgentPipeline {
-    private contextBuffer: ContextBuffer = new ContextBuffer();
-
-    async run(input: AgentInput, mode: AgentMode): Promise<void> {
-        const id = randomUUID();
-
-        // 1. Intent Analysis
-        const intent = inferIntent(input, mode);
-
-        // 2. Context Assembly
-        const context = buildContext(input, this.contextBuffer);
-
-        // 3. Prompt Construction
-        const prompt = buildPrompt(intent, context, mode, input.rawInput);
-
-        // 4. Model Selection
-        const model = selectModel(intent, input.options?.model);
-
-        // Setup Renderer if in Chat Mode
-        let renderer: StreamMarkdownRenderer | undefined;
-        let spinner: Ora | undefined;
-
-        if (mode === 'chat') {
-            spinner = ora(chalk.cyan('Thinking...')).start();
-            renderer = new StreamMarkdownRenderer(chalk.bold.blue(' AI: '), spinner);
-        }
-
-        // 5. LLM Execution
-        const result = await runLLM({
-            prompt,
-            model,
-            stream: mode === 'chat',
-            onChunk: mode === 'chat' && renderer
-                ? (s) => renderer!.onChunk(s)
-                : undefined,
-        });
-
-        // Finish rendering if chat mode
-        if (mode === 'chat' && renderer) {
-            renderer.finish();
-        }
-
-        // 6. Result Interpretation -> Plan
-        const isStreaming = mode === 'chat';
-        const plan = interpretResultToPlan(result, intent, mode, isStreaming);
-        result.plan = plan; // Attach plan to result for recording
-
-        // 7. Save Execution Record (before execution for safety)
-        saveRecord({
-            id,
-            timestamp: Date.now(),
-            mode,
-            input,
-            prompt,
-            model,
-            llmResult: result,
-            action: plan.tasks[0]?.type === 'shell' ? {
-                type: 'execute',
-                command: plan.tasks[0].payload.command,
-                risk: plan.tasks[0].payload.risk
-            } : { type: 'print', content: result.rawText }, 
-        });
-
-        // 8. Plan Execution
-        // Note: For chat, execution usually is just "printing", which happened via stream.
-        // interpretResultToPlan handles ignoring tasks if streamed.
-        const summary = await executePlan(plan, input.options);
-
-        // 9. Post-execution: Learn Skill if successful
-        learnSkillFromRecord({
-            id,
-            timestamp: Date.now(),
-            mode,
-            input,
-            prompt,
-            model,
-            llmResult: result,
-            action: plan.tasks[0]?.type === 'shell' ? {
-                type: 'execute',
-                command: plan.tasks[0].payload.command,
-                risk: plan.tasks[0].payload.risk
-            } : { type: 'print', content: result.rawText },
-        }, summary.success);
-
-        // Log execution metrics if verbose
-        if (input.options?.verbose) {
-            console.log(`\n${'-'.repeat(50)}`);
-            console.log(`Execution ID: ${id}`);
-            console.log(`Model: ${model}`);
-            console.log(`Latency: ${result.latencyMs}ms`);
-            if (result.tokens) {
-                console.log(`Tokens: ${result.tokens.total}`);
-            }
-            console.log(`${'-'.repeat(50)}\n`);
-        }
-    }
-}
diff --git a/src/agent/AgentRuntime.ts b/src/agent/AgentRuntime.ts
new file mode 100644
index 0000000..8c5f3b8
--- /dev/null
+++ b/src/agent/AgentRuntime.ts
@@ -0,0 +1,118 @@
+import chalk from 'chalk';
+import ora from 'ora';
+import { randomUUID } from 'crypto';
+import { LLMAdapter } from './llmAdapter';
+import { GovernanceService } from './governance';
+import { ToolExecutor } from './executor';
+import { ContextManager } from './contextManager';
+import { StreamMarkdownRenderer } from '../utils/renderer';
+import { learnSkillFromRecord } from './skills';
+import { capabilitySystem } from '../core/capabilitySystem';
+import { ExecutionTurn, ProposedAction } from './state';
+import { evaluateProposal } from './governance/core';
+
+export class AgentRuntime {
+    private context: ContextManager;
+    private executionId: string;
+
+    constructor(initialContext: any) {
+        this.context = new ContextManager(initialContext);
+        this.executionId = randomUUID();
+    }
+
+    async run(userInput: string, mode: 'chat' | 'command' = 'chat') {
+        let turnCount = 0;
+        const maxTurns = 10;
+        const rejectionHistory = new Set<string>(); // 
+
+        while (turnCount < maxTurns) {
+            console.log(chalk.blue(`\n--- Turn ${++turnCount} ---`));
+
+            // 1.  (Think) & 
+            //  capabilitySystem 
+            const requirement = { required: [mode === 'command' ? 'code' : 'reasoning'], preferred: [] };
+            const match = capabilitySystem.matchCapability(requirement as any);
+            const model = match.selected?.name || 'Assistant';
+
+            //  ()
+            const spinner = ora(chalk.cyan('AI Thinking...')).start();
+            const renderer = new StreamMarkdownRenderer(chalk.bold.blue(' AI: '), spinner);
+
+            const thought = await this.think(
+                this.context.getMessages(),
+                model,
+                (chunk: string) => renderer.onChunk(chunk) // 
+            );
+            renderer.finish();
+
+            if (thought.isDone) {
+                console.log(chalk.green('\n'));
+                break;
+            }
+
+            // 2.  (Adjudicate)
+            const action: ProposedAction = {
+                id: randomUUID(),
+                type: thought.type as any,
+                payload: thought.payload,
+                riskLevel: GovernanceService.evaluateRisk(thought),
+                reasoning: thought.reasoning || ''
+            };
+
+            // === [Patch 3]  (Pre-flight Check) ===
+            const actionFingerprint = JSON.stringify(action.payload);
+            if (rejectionHistory.has(actionFingerprint)) {
+                console.log(chalk.red(`[ANTI-LOOP] `));
+                this.context.addMessage('system', `ERROR: You are repeating a previously denied action. DO NOT try this again. Find a NEW way.`);
+                continue;
+            }
+
+            const preCheck = evaluateProposal(action, GovernanceService.getRules(), GovernanceService.getLedgerSnapshot());
+            if (preCheck.effect === 'deny') {
+                console.log(chalk.red(`[PRE-FLIGHT] : ${preCheck.reason}`));
+                rejectionHistory.add(actionFingerprint);
+                this.context.addMessage('system', `POLICY DENIED: ${preCheck.reason}. Please try a different approach.`);
+                continue; //  AI 
+            }
+
+            const decision = await GovernanceService.adjudicate(action);
+
+            if (decision.status === 'rejected') {
+                this.context.addMessage('system', `User rejected action: ${decision.reason}`);
+                continue;
+            }
+
+            // 3.  (Execute)
+            const finalAction = decision.status === 'modified' ? decision.modifiedAction! : action;
+            const result = await ToolExecutor.execute(finalAction as any);
+
+            // 4.  (Learn) - 
+            if (result.success) {
+                //  Record 
+                learnSkillFromRecord({
+                    id: this.executionId,
+                    llmResult: { plan: { goal: action.reasoning } },
+                    input: { rawInput: userInput },
+                    mode: 'command+exec'
+                } as any, true);
+            }
+
+            // 5.  (Observe)
+            const output = result.success ? (result.output || '').substring(0, 2000) : result.error;
+            this.context.addToolResult(finalAction.type, output || '');
+        }
+    }
+
+    private async think(messages: any[], model: string, onChunk: any) {
+        const laws = GovernanceService.getPolicyManual();
+        const systemPrompt = `You are a Governed AI. 
+CURRENT LAWS:
+${laws}
+
+Always check if your plan violates these laws before proposing. 
+If a law requires human approval, explain to the user why it's necessary.
+Output JSON format: { "action_type": "...", "payload": {...}, "reasoning": "...", "is_done": false }`;
+
+        return await LLMAdapter.think(messages, model, onChunk, systemPrompt);
+    }
+}
diff --git a/src/agent/executor.ts b/src/agent/executor.ts
index 39f1557..e6b5146 100644
--- a/src/agent/executor.ts
+++ b/src/agent/executor.ts
@@ -1,207 +1,27 @@
+import fs from 'fs/promises';
 import { exec } from 'child_process';
 import { promisify } from 'util';
-import fs from 'fs/promises';
-import path from 'path';
-import { ProposedAction, ToolExecutionResult } from './state';
-
 const execAsync = promisify(exec);
 
 export class ToolExecutor {
-  static async execute(action: ProposedAction): Promise<ToolExecutionResult> {
+  static async execute(action: { type: string, payload: any }) {
     const { type, payload } = action;
-
     try {
       switch (type) {
-        case 'tool_call':
-          return await this.executeTool(payload);
-        
         case 'shell_cmd':
-          return await this.executeShell(payload.command);
-        
-        case 'code_diff':
-          return await this.executeDiff(payload.diff);
-        
-        case 'answer':
-          return {
-            success: true,
-            output: payload.content || '',
-            artifacts: []
-          };
-        
+          const { stdout, stderr } = await execAsync(payload.command);
+          return { success: true, output: stdout || stderr };
+        case 'read_file':
+          const content = await fs.readFile(payload.path, 'utf-8');
+          return { success: true, output: content };
+        case 'write_file':
+          await fs.writeFile(payload.path, payload.content);
+          return { success: true, output: `Successfully wrote ${payload.path}` };
         default:
-          return {
-            success: false,
-            error: `Unknown action type: ${type}`,
-            output: ''
-          };
+          return { success: false, error: `Unknown capability: ${type}` };
       }
-    } catch (error: any) {
-      return {
-        success: false,
-        error: error.message || String(error),
-        output: ''
-      };
-    }
-  }
-
-  private static async executeTool(payload: any): Promise<ToolExecutionResult> {
-    const toolName = payload.tool_name;
-
-    switch (toolName) {
-      case 'read_file':
-        return await this.toolReadFile(payload.parameters);
-      
-      case 'write_file':
-        return await this.toolWriteFile(payload.parameters);
-      
-      case 'list_files':
-        return await this.toolListFiles(payload.parameters);
-      
-      case 'web_search':
-        return {
-          success: false,
-          error: 'web_search not implemented yet',
-          output: ''
-        };
-      
-      default:
-        return {
-          success: false,
-          error: `Unknown tool: ${toolName}`,
-          output: ''
-        };
-    }
-  }
-
-  private static async toolReadFile(params: any): Promise<ToolExecutionResult> {
-    const filePath = params.path;
-    try {
-      const content = await fs.readFile(filePath, 'utf-8');
-      return {
-        success: true,
-        output: content,
-        artifacts: [filePath]
-      };
-    } catch (error: any) {
-      return {
-        success: false,
-        error: error.message,
-        output: ''
-      };
-    }
-  }
-
-  private static async toolWriteFile(params: any): Promise<ToolExecutionResult> {
-    const filePath = params.path;
-    const content = params.content;
-    
-    try {
-      await fs.mkdir(path.dirname(filePath), { recursive: true });
-      await fs.writeFile(filePath, content, 'utf-8');
-      return {
-        success: true,
-        output: `Successfully wrote ${filePath}`,
-        artifacts: [filePath]
-      };
-    } catch (error: any) {
-      return {
-        success: false,
-        error: error.message,
-        output: ''
-      };
-    }
-  }
-
-  private static async toolListFiles(params: any): Promise<ToolExecutionResult> {
-    const dirPath = params.path || '.';
-    const recursive = params.recursive || false;
-    
-    try {
-      const files = await this.getFiles(dirPath, recursive);
-      return {
-        success: true,
-        output: JSON.stringify(files, null, 2),
-        artifacts: files.map(f => f.path)
-      };
-    } catch (error: any) {
-      return {
-        success: false,
-        error: error.message,
-        output: ''
-      };
-    }
-  }
-
-  private static async getFiles(dir: string, recursive: boolean): Promise<Array<{ path: string; type: string }>> {
-    const entries = await fs.readdir(dir, { withFileTypes: true });
-    const files: Array<{ path: string; type: string }> = [];
-
-    for (const entry of entries) {
-      const fullPath = path.join(dir, entry.name);
-      
-      if (entry.isDirectory()) {
-        files.push({ path: fullPath, type: 'directory' });
-        if (recursive) {
-          const subFiles = await this.getFiles(fullPath, recursive);
-          files.push(...subFiles);
-        }
-      } else {
-        files.push({ path: fullPath, type: 'file' });
-      }
-    }
-
-    return files;
-  }
-
-  private static async executeShell(command: string): Promise<ToolExecutionResult> {
-    try {
-      const { stdout, stderr } = await execAsync(command, {
-        maxBuffer: 10 * 1024 * 1024,
-        cwd: process.cwd()
-      });
-
-      const output = stdout || stderr || '';
-      
-      return {
-        success: true,
-        output,
-        artifacts: []
-      };
-    } catch (error: any) {
-      return {
-        success: false,
-        error: error.message,
-        output: error.stdout || error.stderr || ''
-      };
-    }
-  }
-
-  private static async executeDiff(diff: string): Promise<ToolExecutionResult> {
-    try {
-      const tempFile = path.join(process.cwd(), '.yuangs_temp.patch');
-      await fs.writeFile(tempFile, diff, 'utf-8');
-
-      const { stdout, stderr } = await execAsync(`git apply --check ${tempFile}`, {
-        cwd: process.cwd()
-      });
-
-      const { stdout: applyOutput } = await execAsync(`git apply ${tempFile}`, {
-        cwd: process.cwd()
-      });
-
-      await fs.unlink(tempFile);
-
-      return {
-        success: true,
-        output: applyOutput || 'Diff applied successfully',
-        artifacts: ['.yuangs_temp.patch']
-      };
-    } catch (error: any) {
-      return {
-        success: false,
-        error: error.message,
-        output: error.stdout || error.stderr || 'Failed to apply diff'
-      };
+    } catch (e: any) {
+      return { success: false, error: e.message };
     }
   }
 }
diff --git a/src/agent/fsm.ts b/src/agent/fsm.ts
deleted file mode 100644
index 4477b43..0000000
--- a/src/agent/fsm.ts
+++ /dev/null
@@ -1,114 +0,0 @@
-import { AgentState, EvaluationOutcome, GovernanceDecision } from './state';
-
-export class GovernanceFSM {
-  private _state: AgentState = 'IDLE';
-  private _history: AgentState[] = [];
-  private _transitionLog: Array<{ from: AgentState; to: AgentState; timestamp: number; payload?: any }> = [];
-
-  get current(): AgentState {
-    return this._state;
-  }
-
-  get history(): AgentState[] {
-    return [...this._history];
-  }
-
-  get transitionLog(): Array<{ from: AgentState; to: AgentState; timestamp: number; payload?: any }> {
-    return [...this._transitionLog];
-  }
-
-  transitionTo(target: AgentState, payload?: any): void {
-    const valid = this.canTransition(this._state, target, payload);
-    
-    if (!valid) {
-      throw new Error(`[FSM Violation] Illegal transition from ${this._state} to ${target}`);
-    }
-
-    console.log(`[FSM] ${this._state} -> ${target}`);
-    if (payload && process.env.DEBUG_FSM) {
-      console.log(`[FSM] Payload:`, JSON.stringify(payload, null, 2));
-    }
-    
-    this._transitionLog.push({
-      from: this._state,
-      to: target,
-      timestamp: Date.now(),
-      payload: payload
-    });
-    
-    this._history.push(this._state);
-    this._state = target;
-  }
-
-  private canTransition(from: AgentState, to: AgentState, payload?: any): boolean {
-    switch (from) {
-      case 'IDLE':
-        return to === 'THINKING';
-
-      case 'THINKING':
-        return to === 'PROPOSING' || to === 'TERMINAL'; 
-
-      case 'PROPOSING':
-        return to === 'GOVERNING';
-
-      case 'GOVERNING':
-        const decision = payload as GovernanceDecision;
-        if (!decision) return false;
-        if (decision.status === 'approved' || decision.status === 'modified') {
-          return to === 'EXECUTING';
-        }
-        if (decision.status === 'rejected') {
-          return to === 'THINKING';
-        }
-        return false;
-
-      case 'EXECUTING':
-        return to === 'OBSERVING';
-
-      case 'OBSERVING':
-        return to === 'EVALUATING';
-
-      case 'EVALUATING':
-        const outcome = payload as EvaluationOutcome;
-        if (!outcome) return false;
-        if (outcome.kind === 'continue') {
-          return to === 'THINKING';
-        }
-        if (outcome.kind === 'terminate') {
-          return to === 'TERMINAL';
-        }
-        if (outcome.kind === 'pause') {
-          return to === 'IDLE';
-        }
-        return false;
-
-      case 'TERMINAL':
-        return to === 'IDLE';
-
-      default:
-        return false;
-    }
-  }
-
-  isTerminal(): boolean {
-    return this._state === 'TERMINAL';
-  }
-
-  reset(): void {
-    this._state = 'IDLE';
-    this._history = [];
-    this._transitionLog = [];
-  }
-
-  getStateInfo(): {
-    current: AgentState;
-    history: AgentState[];
-    transitionCount: number;
-  } {
-    return {
-      current: this._state,
-      history: this._history,
-      transitionCount: this._transitionLog.length
-    };
-  }
-}
diff --git a/src/agent/governance.ts b/src/agent/governance.ts
index b14956c..9955f9e 100644
--- a/src/agent/governance.ts
+++ b/src/agent/governance.ts
@@ -1,173 +1,124 @@
 import readline from 'readline';
-import { ProposedAction, GovernanceDecision, RiskLevel } from './state';
 import chalk from 'chalk';
-import ora from 'ora';
-
-export class GovernanceService {
-  static async adjudicate(
-    action: ProposedAction,
-    config: { autoApproveLowRisk: boolean } = { autoApproveLowRisk: true }
-  ): Promise<GovernanceDecision> {
-    const { autoApproveLowRisk } = config;
-
-    if (autoApproveLowRisk && action.riskLevel === 'low') {
-      console.log(chalk.gray(`[Auto-approved] ${action.type}: low risk action`));
-      return {
-        status: 'approved',
-        by: 'policy',
-        timestamp: Date.now()
-      };
-    }
-
-    const spinner = ora(chalk.yellow('  Waiting for approval...')).start();
-
-    const answer = await this.askHuman(action);
-    spinner.stop();
-
-    if (answer.approve) {
-      return {
-        status: 'approved',
-        by: 'human',
-        timestamp: Date.now()
-      };
-    } else if (answer.modify) {
-      return {
-        status: 'modified',
-        by: 'human',
-        originalActionId: action.id,
-        modifiedAction: answer.modifiedAction!,
-        modificationReason: answer.reason || 'User modified',
-        timestamp: Date.now()
-      };
-    } else {
-      return {
-        status: 'rejected',
-        by: 'human',
-        reason: answer.reason || 'User rejected',
-        timestamp: Date.now()
-      };
-    }
-  }
-
-  private static askHuman(action: ProposedAction): Promise<{
-    approve: boolean;
-    modify: boolean;
-    modifiedAction?: ProposedAction;
-    reason?: string;
-  }> {
-    const rl = readline.createInterface({
-      input: process.stdin,
-      output: process.stdout
-    });
-
-    return new Promise((resolve) => {
-      this.printActionDetails(action);
-
-      const prompt = `
-${chalk.bold.yellow('Proceed?')} (y/n/s) 
-${chalk.gray('y = yes, n = no, s = skip/modify')}: `;
-
-      rl.question(prompt, (answer) => {
-        const lower = answer.trim().toLowerCase();
-
-        if (lower === 'y' || lower === 'yes') {
-          rl.close();
-          resolve({ approve: true, modify: false });
-        } else if (lower === 's' || lower === 'skip' || lower === 'modify') {
-          rl.close();
-          resolve({ 
-            approve: false, 
-            modify: true, 
-            reason: 'User wants to modify',
-            modifiedAction: { ...action } 
-          });
-        } else {
-          rl.question(chalk.red('Reason for rejection: '), (reason) => {
-            rl.close();
-            resolve({ 
-              approve: false, 
-              modify: false, 
-              reason: reason || 'User rejected' 
-            });
-          });
-        }
-      });
+import fs from 'fs';
+import yaml from 'js-yaml';
+import path from 'path';
+import { ProposedAction, GovernanceDecision } from './state';
+import { evaluateProposal, PolicyRule } from './governance/core';
+import { RiskLedger } from './governance/ledger';
+import { WasmGovernanceBridge } from './governance/bridge';
+
+class PolicyEngine {
+  public rules: PolicyRule[] = [];
+  private policyPath = path.join(process.cwd(), 'policy.yaml');
+
+  constructor() {
+    this.loadPolicy();
+    // 
+    fs.watchFile(this.policyPath, () => {
+      console.log(chalk.gray('\n[Policy] ...'));
+      this.loadPolicy();
     });
   }
 
-  private static printActionDetails(action: ProposedAction): void {
-    const riskColor = {
-      low: chalk.green,
-      medium: chalk.yellow,
-      high: chalk.red
-    };
-
-    console.log(`
-${chalk.bold.cyan(''.repeat(60))}
-${chalk.bold.blue(' Action Proposed')}
-${chalk.bold.cyan(''.repeat(60))}
-${chalk.white('Type:')} ${chalk.bold(action.type)}
-${chalk.white('ID:')} ${action.id}
-${chalk.white('Risk:')} ${riskColor[action.riskLevel](action.riskLevel.toUpperCase())}
-
-${chalk.bold('Payload:')}
-${chalk.gray(JSON.stringify(action.payload, null, 2))}
-
-${chalk.bold('Reasoning:')}
-${chalk.gray(action.reasoning)}
-${chalk.bold.cyan(''.repeat(60))}
-`);
+  private loadPolicy() {
+    try {
+      const content = fs.readFileSync(this.policyPath, 'utf8');
+      const doc = yaml.load(content) as any;
+      this.rules = doc.rules || [];
+    } catch (e) {
+      console.error(chalk.red(' policy.yaml '));
+    }
   }
+}
 
-  static evaluateRisk(action: ProposedAction): RiskLevel {
-    const { type, payload } = action;
+export class GovernanceService {
+  private static engine = new PolicyEngine();
+  private static ledger = new RiskLedger();
+  private static wasmBridge = new WasmGovernanceBridge();
+  private static wasmInited = false;
+
+  /**
+   *  YAML  AI 
+   */
+  static getPolicyManual(): string {
+    return this.engine.rules
+      .map(r => `- ${r.id}: ${r.reason || ''} (: ${r.effect})`)
+      .join('\n');
+  }
 
-    if (type === 'tool_call') {
-      const toolName = payload.tool_name;
-      
-      const lowRiskTools = ['read_file', 'list_files', 'web_search'];
-      if (lowRiskTools.includes(toolName)) {
-        return 'low';
+  static getRules(): PolicyRule[] { return this.engine.rules; }
+  static getLedgerSnapshot() { return this.ledger.getSnapshot(); }
+
+  static async adjudicate(action: ProposedAction): Promise<GovernanceDecision> {
+    // 0.  WASM ()
+    if (!this.wasmInited) {
+      try {
+        await this.wasmBridge.init();
+        this.wasmInited = true;
+      } catch (e) {
+        console.error(chalk.yellow(`[WASM] : ${(e as Error).message}`));
       }
+    }
 
-      const mediumRiskTools = ['write_file', 'shell'];
-      if (mediumRiskTools.includes(toolName)) {
-        const cmd = payload.parameters?.command || payload.command || '';
-        if (this.containsDangerousCommand(cmd)) {
-          return 'high';
-        }
-        return 'medium';
-      }
+    // 1. 
+    let effect: string;
+    let reason: string | undefined;
+
+    if (this.wasmInited) {
+      //  WASM 
+      const wasmResult = this.wasmBridge.evaluate(
+        action,
+        this.engine.rules,
+        this.ledger.getSnapshot()
+      );
+      effect = wasmResult.effect;
+      reason = wasmResult.reason;
+    } else {
+      //  (WASM-Ready)
+      const result = evaluateProposal(
+        action,
+        this.engine.rules,
+        this.ledger.getSnapshot()
+      );
+      effect = result.effect;
+      reason = result.reason;
+    }
 
-      return 'medium';
+    if (effect === 'allow') {
+      this.ledger.record(action.type); // 
+      return { status: 'approved', by: 'policy', timestamp: Date.now() };
     }
 
-    if (type === 'shell_cmd') {
-      const cmd = payload.command || '';
-      if (this.containsDangerousCommand(cmd)) {
-        return 'high';
-      }
-      return 'medium';
+    if (effect === 'deny') {
+      console.log(chalk.red(`\n : ${reason}`));
+      return { status: 'rejected', by: 'policy', reason: reason || 'Policy Violation', timestamp: Date.now() };
     }
 
-    if (type === 'code_diff') {
-      return 'medium';
+    // 2. 
+    console.log(chalk.yellow(`\n : ${action.type}`));
+    if (reason) console.log(chalk.gray(`: ${reason}`));
+    console.log(chalk.gray(`AI : ${action.reasoning}`));
+    console.log(chalk.cyan(`: ${JSON.stringify(action.payload)}`));
+
+    const ans = await this.ask('? (y/n): ');
+    if (ans === 'y') {
+      this.ledger.record(action.type); // 
+      return { status: 'approved', by: 'human', timestamp: Date.now() };
     }
 
+    return { status: 'rejected', by: 'human', reason: 'User denied', timestamp: Date.now() };
+  }
+
+  static evaluateRisk(action: any): 'low' | 'medium' | 'high' {
+    const cmd = JSON.stringify(action.payload).toLowerCase();
+    if (/rm\s+-rf|sudo|chmod\s+777/.test(cmd)) return 'high';
+    if (['shell_cmd', 'write_file'].includes(action.type)) return 'medium';
     return 'low';
   }
 
-  private static containsDangerousCommand(cmd: string): boolean {
-    const dangerousPatterns = [
-      /rm\s+-rf\s+\//,
-      /rm\s+-rf\s+~/,
-      />\s*\/dev\/null/,
-      /dd\s+if=/,
-      /mkfs/,
-      /format/,
-      /sudo\s+rm/
-    ];
-
-    return dangerousPatterns.some(pattern => pattern.test(cmd));
+  private static ask(q: string): Promise<string> {
+    const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
+    return new Promise(res => rl.question(chalk.bold.cyan(q), a => { rl.close(); res(a.toLowerCase()); }));
   }
 }
diff --git a/src/agent/governance/bridge.ts b/src/agent/governance/bridge.ts
new file mode 100644
index 0000000..077dac3
--- /dev/null
+++ b/src/agent/governance/bridge.ts
@@ -0,0 +1,42 @@
+import fs from 'fs';
+import path from 'path';
+import loader from '@assemblyscript/loader';
+
+export class WasmGovernanceBridge {
+    private wasmInstance: any = null;
+
+    async init() {
+        const wasmPath = path.join(process.cwd(), 'build/governance.release.wasm');
+        if (!fs.existsSync(wasmPath)) {
+            //  debug 
+            const debugPath = path.join(process.cwd(), 'build/governance.debug.wasm');
+            if (!fs.existsSync(debugPath)) {
+                throw new Error(`WASM  npm run asbuild. : ${wasmPath}`);
+            }
+            this.wasmInstance = await loader.instantiate(fs.readFileSync(debugPath), {});
+        } else {
+            const wasmModule = fs.readFileSync(wasmPath);
+            //  WASM
+            this.wasmInstance = await loader.instantiate(wasmModule, {});
+        }
+        console.log(' WASM ');
+    }
+
+    evaluate(action: any, rules: any[], ledger: any[]): { effect: string, reason?: string } {
+        if (!this.wasmInstance) throw new Error("WASM ");
+
+        const { __newString, __getString, evaluate } = this.wasmInstance.exports;
+
+        // 
+        const proposalPtr = __newString(JSON.stringify(action));
+        const rulesPtr = __newString(JSON.stringify(rules));
+        const ledgerPtr = __newString(JSON.stringify(ledger));
+
+        // 
+        const resultPtr = evaluate(proposalPtr, rulesPtr, ledgerPtr);
+
+        // 
+        const resultJson = __getString(resultPtr);
+        return JSON.parse(resultJson);
+    }
+}
diff --git a/src/agent/governance/core.ts b/src/agent/governance/core.ts
new file mode 100644
index 0000000..155fbcc
--- /dev/null
+++ b/src/agent/governance/core.ts
@@ -0,0 +1,45 @@
+import { ProposedAction } from '../state';
+
+export interface PolicyRule {
+    id: string;
+    when: { type?: string; pattern?: string; max_per_minute?: number };
+    effect: 'allow' | 'deny' | 'require_approval';
+    reason?: string;
+}
+
+export interface RiskEntry {
+    ts: number;
+    actionType: string;
+}
+
+/**
+ *  ( WASM)
+ * 
+ * 
+ */
+export function evaluateProposal(
+    action: ProposedAction,
+    rules: PolicyRule[],
+    ledger: RiskEntry[]
+): { effect: string; reason?: string } {
+    const now = Date.now();
+
+    for (const rule of rules) {
+        const typeMatch = !rule.when.type || rule.when.type === action.type;
+        const payloadStr = JSON.stringify(action.payload);
+        const patternMatch = !rule.when.pattern || new RegExp(rule.when.pattern, 'i').test(payloadStr);
+
+        if (typeMatch && patternMatch) {
+            //  ()
+            if (rule.when.max_per_minute) {
+                const minuteAgo = now - 60000;
+                const count = ledger.filter(e => e.ts > minuteAgo && e.actionType === action.type).length;
+                if (count >= rule.when.max_per_minute) {
+                    return { effect: 'deny', reason: `: ${rule.id} ( ${rule.when.max_per_minute} )` };
+                }
+            }
+            return { effect: rule.effect, reason: rule.reason };
+        }
+    }
+    return { effect: 'require_approval', reason: '' };
+}
diff --git a/src/agent/governance/ledger.ts b/src/agent/governance/ledger.ts
new file mode 100644
index 0000000..0ed2315
--- /dev/null
+++ b/src/agent/governance/ledger.ts
@@ -0,0 +1,16 @@
+import { RiskEntry } from './core';
+
+export class RiskLedger {
+    private entries: RiskEntry[] = [];
+
+    record(actionType: string) {
+        this.entries.push({ ts: Date.now(), actionType });
+        //  1 
+        const hourAgo = Date.now() - 3600000;
+        this.entries = this.entries.filter(e => e.ts > hourAgo);
+    }
+
+    getSnapshot(): RiskEntry[] {
+        return [...this.entries];
+    }
+}
diff --git a/src/agent/governance/sandbox/core.as.ts b/src/agent/governance/sandbox/core.as.ts
new file mode 100644
index 0000000..0dc41a8
--- /dev/null
+++ b/src/agent/governance/sandbox/core.as.ts
@@ -0,0 +1,33 @@
+/**
+ * yuangs Governance WASM Sandbox
+ *  Node.js 
+ */
+
+// WASM 
+function includes(source: string, target: string): boolean {
+    return source.indexOf(target) != -1;
+}
+
+/**
+ * 
+ * @param proposal 
+ * @param rules YAML  JSON
+ * @param ledger 
+ */
+export function evaluate(proposal: string, rules: string, ledger: string): string {
+    // 1. 
+    if (proposal.includes("rm -rf /") || proposal.includes("sudo rm")) {
+        return '{"effect": "deny", "reason": "WASM_SANDBOX: "}';
+    }
+
+    // 2. 
+    //  AI  50 
+    if (ledger.length > 5000) { // 
+        return '{"effect": "deny", "reason": "WASM_SANDBOX: "}';
+    }
+
+    // 3. 
+    //  JSON rules
+    // 
+    return '{"effect": "allow", "reason": "WASM_SANDBOX: "}';
+}
diff --git a/src/agent/index.ts b/src/agent/index.ts
index fa12f18..c9ac7c5 100644
--- a/src/agent/index.ts
+++ b/src/agent/index.ts
@@ -1,11 +1,7 @@
-export { AgentPipeline } from './AgentPipeline';
-export * from './types';
+export { AgentRuntime } from './AgentRuntime';
 export * from './state';
-export { GovernanceFSM } from './fsm';
-export { GovernedAgentLoop } from './loop';
 export { LLMAdapter } from './llmAdapter';
 export { GovernanceService } from './governance';
 export { ToolExecutor } from './executor';
 export { ContextManager } from './contextManager';
-export * from './policy';
-export * from './replay';
+export * from './skills';
diff --git a/src/agent/llmAdapter.ts b/src/agent/llmAdapter.ts
index c6fa6c6..551f305 100644
--- a/src/agent/llmAdapter.ts
+++ b/src/agent/llmAdapter.ts
@@ -1,97 +1,42 @@
-import { AgentThought } from './state';
 import { runLLM } from './llm';
-import { AgentPrompt } from './types';
-import type { AIRequestMessage } from '../core/validation';
-import { getUserConfig } from '../ai/client';
+import { extractJSON } from '../core/validation';
+import chalk from 'chalk';
 
 export class LLMAdapter {
-  static async think(
-    messages: AIRequestMessage[],
-    mode: 'chat' | 'command' | 'command+exec',
-    outputSchema?: any
-  ): Promise<AgentThought> {
-    const prompt: AgentPrompt = {
-      system: `You are yuangs AI Assistant. You are operating in Governance-First ReAct Loop mode.
-      
-Available action types:
-- tool_call: Call a tool (read_file, write_file, web_search, shell)
-- code_diff: Apply a code diff using unified diff format
-- shell_cmd: Execute a shell command
-- answer: Provide a final answer without any tool calls
-
-When you need to perform an action, output your plan in this JSON format:
-{
-  "action_type": "tool_call" | "code_diff" | "shell_cmd" | "answer",
-  "tool_name": string,  // for tool_call
-  "parameters": object,
-  "command": string,    // for shell_cmd
-  "diff": string,       // for code_diff
-  "content": string,     // for answer
-  "reasoning": string    // Explain why you're taking this action
-}
-
-If the task is complete and no more actions are needed, output:
-{
-  "is_done": true,
-  "final_answer": string
-}`,
-      messages,
-      outputSchema
-    };
-
-    // Use configured model from user settings
-    const config = getUserConfig();
-    const model = config.defaultModel || 'Assistant';
+  static async think(messages: any[], model: string, onChunk?: (s: string) => void, customSystemPrompt?: string) {
+    const systemPrompt = customSystemPrompt || `You are a Governed AI. Output JSON format: 
+        { "action_type": "...", "payload": {...}, "reasoning": "...", "is_done": false }`;
 
     const result = await runLLM({
-      prompt,
-      model,
-      stream: false
+      prompt: { messages: [{ role: 'system', content: systemPrompt }, ...messages] },
+      model: model,
+      stream: !!onChunk,
+      onChunk: onChunk
     });
 
     return this.parseThought(result.rawText);
   }
 
-  private static parseThought(raw: string): AgentThought {
+  private static parseThought(raw: string) {
     try {
-      const jsonMatch = raw.match(/```json\n([\s\S]*?)\n```/) || raw.match(/\{[\s\S]*\}/);
-      if (jsonMatch) {
-        const parsed = JSON.parse(jsonMatch[1] || jsonMatch[0]);
-        
-        if (parsed.is_done) {
-          return {
-            raw,
-            parsedPlan: parsed,
-            isDone: true,
-            type: 'answer'
-          };
-        }
-
-        return {
-          raw,
-          parsedPlan: parsed,
-          isDone: false,
-          type: parsed.action_type || 'tool_call',
-          payload: {
-            tool_name: parsed.tool_name,
-            parameters: parsed.parameters,
-            command: parsed.command,
-            diff: parsed.diff,
-            content: parsed.content
-          },
-          reasoning: parsed.reasoning || ''
-        };
-      }
-    } catch (e) {
-      console.warn('[LLMAdapter] Failed to parse JSON output, using raw text');
+      const jsonStr = extractJSON(raw);
+      const parsed = JSON.parse(jsonStr);
+      return {
+        raw,
+        isDone: parsed.is_done || false,
+        type: parsed.action_type || 'answer',
+        payload: parsed.payload || {},
+        reasoning: parsed.reasoning || '',
+        parsedPlan: parsed
+      };
+    } catch (e: any) {
+      console.warn(chalk.yellow(`[Adapter] JSON  AI ...`));
+      //  Runtime  AI 
+      return {
+        raw, isDone: false, type: 'answer',
+        reasoning: `My last output was not valid JSON: ${e.message}. I will fix the format.`,
+        payload: {}, parsedPlan: null
+      };
     }
-
-    return {
-      raw,
-      parsedPlan: {},
-      isDone: false,
-      type: 'answer',
-      reasoning: raw
-    };
   }
 }
diff --git a/src/agent/loop.ts b/src/agent/loop.ts
deleted file mode 100644
index ff62520..0000000
--- a/src/agent/loop.ts
+++ /dev/null
@@ -1,264 +0,0 @@
-import { GovernanceFSM } from './fsm';
-import { 
-  AgentState, 
-  ExecutionTurn, 
-  ProposedAction, 
-  GovernanceDecision, 
-  EvaluationOutcome,
-  GovernanceLoopConfig,
-  GovernanceContext
-} from './state';
-import { LLMAdapter } from './llmAdapter';
-import { GovernanceService } from './governance';
-import { ToolExecutor } from './executor';
-import { ContextManager } from './contextManager';
-import { randomUUID } from 'crypto';
-import chalk from 'chalk';
-
-export class GovernedAgentLoop {
-  private fsm = new GovernanceFSM();
-  private context: ContextManager;
-  private turns: ExecutionTurn[] = [];
-  private config: GovernanceLoopConfig;
-
-  constructor(
-    initialContext: GovernanceContext,
-    config?: Partial<GovernanceLoopConfig>
-  ) {
-    this.context = new ContextManager(initialContext);
-    this.config = {
-      maxTurns: 20,
-      autoApproveLowRisk: true,
-      verbose: false,
-      ...config
-    };
-  }
-
-  async run(): Promise<ExecutionTurn[]> {
-    this.fsm.transitionTo('THINKING');
-
-    let turnCount = 0;
-    
-    while (turnCount < this.config.maxTurns && !this.fsm.isTerminal()) {
-      const turn: ExecutionTurn = {
-        turnId: turnCount + 1,
-        startTime: Date.now(),
-        contextSnapshot: this.context.getSnapshot()
-      };
-
-      try {
-        await this.executeTurn(turn);
-        
-        turn.endTime = Date.now();
-        this.turns.push(turn);
-        turnCount++;
-
-        if (this.config.verbose) {
-          this.logTurnSummary(turn);
-        }
-
-      } catch (error: any) {
-        console.error(chalk.red(`[Loop Error] Turn ${turn.turnId} failed: ${error.message}`));
-        this.fsm.transitionTo('TERMINAL');
-        turn.endTime = Date.now();
-        this.turns.push(turn);
-        break;
-      }
-    }
-
-    if (turnCount >= this.config.maxTurns) {
-      console.log(chalk.yellow(`\n  Max turns (${this.config.maxTurns}) reached`));
-    }
-
-    return this.turns;
-  }
-
-  private async executeTurn(turn: ExecutionTurn): Promise<void> {
-    if (this.fsm.current === 'THINKING') {
-      await this.handleThinking(turn);
-    }
-
-    if (this.fsm.current === 'PROPOSING') {
-      await this.handleProposing(turn);
-    }
-
-    if (this.fsm.current === 'GOVERNING') {
-      await this.handleGoverning(turn);
-    }
-
-    if (this.fsm.current === 'EXECUTING') {
-      await this.handleExecuting(turn);
-    }
-
-    if (this.fsm.current === 'OBSERVING') {
-      await this.handleObserving(turn);
-    }
-
-    if (this.fsm.current === 'EVALUATING') {
-      await this.handleEvaluating(turn);
-    }
-  }
-
-  private async handleThinking(turn: ExecutionTurn): Promise<void> {
-    const allMessages = this.context.getMessages();
-    const messages = allMessages
-      .filter(msg => msg.role !== 'tool') as Array<{ role: 'system' | 'user' | 'assistant'; content: string }>;
-    
-    const messagesWithSystem: Array<{ role: 'system' | 'user' | 'assistant'; content: string }> = [
-      {
-        role: 'system',
-        content: 'Current turn: ' + (turn.turnId)
-      },
-      ...messages
-    ];
-
-    const thought = await LLMAdapter.think(
-      messagesWithSystem,
-      'command'
-    );
-
-    turn.thought = thought;
-
-    if (thought.isDone) {
-      console.log(chalk.bold.green(`\n ${thought.parsedPlan.final_answer || 'Task completed'}`));
-      this.fsm.transitionTo('TERMINAL');
-      this.context.addMessage('assistant', thought.raw);
-    } else {
-      this.fsm.transitionTo('PROPOSING');
-    }
-  }
-
-  private async handleProposing(turn: ExecutionTurn): Promise<void> {
-    const thought = turn.thought!;
-    const riskLevel = GovernanceService.evaluateRisk({
-      id: randomUUID(),
-      type: thought.type!,
-      payload: thought.payload || {},
-      riskLevel: 'low',
-      reasoning: thought.reasoning || ''
-    });
-
-    const action: ProposedAction = {
-      id: randomUUID(),
-      type: thought.type!,
-      payload: thought.payload || {},
-      riskLevel,
-      reasoning: thought.reasoning || ''
-    };
-
-    turn.proposedAction = action;
-    this.fsm.transitionTo('GOVERNING');
-  }
-
-  private async handleGoverning(turn: ExecutionTurn): Promise<void> {
-    const action = turn.proposedAction!;
-    
-    const decision = await GovernanceService.adjudicate(action, {
-      autoApproveLowRisk: this.config.autoApproveLowRisk
-    });
-
-    turn.governance = decision;
-
-    if (decision.status === 'rejected') {
-      console.log(chalk.yellow(`\n Action rejected: ${decision.reason}`));
-      this.context.addMessage('system', `Action rejected: ${decision.reason}`);
-      this.fsm.transitionTo('THINKING');
-    } else if (decision.status === 'approved') {
-      this.fsm.transitionTo('EXECUTING', decision);
-    } else if (decision.status === 'modified') {
-      console.log(chalk.yellow(`\n  Action modified by user`));
-      turn.proposedAction = decision.modifiedAction;
-      this.fsm.transitionTo('EXECUTING', decision);
-    }
-  }
-
-  private async handleExecuting(turn: ExecutionTurn): Promise<void> {
-    const governance = turn.governance!;
-    const action = governance.status === 'modified' 
-      ? governance.modifiedAction 
-      : turn.proposedAction!;
-
-    console.log(chalk.cyan(`\n  Executing: ${action.type}`));
-    
-    const result = await ToolExecutor.execute(action);
-    turn.executionResult = result;
-
-    if (result.success) {
-      console.log(chalk.green(` Execution successful`));
-    } else {
-      console.log(chalk.red(` Execution failed: ${result.error}`));
-    }
-
-    this.fsm.transitionTo('OBSERVING');
-  }
-
-  private async handleObserving(turn: ExecutionTurn): Promise<void> {
-    const executionResult = turn.executionResult!;
-
-    const summary = executionResult.success 
-      ? `Action completed successfully. Output: ${executionResult.output.substring(0, 500)}`
-      : `Action failed. Error: ${executionResult.error}`;
-
-    turn.observation = {
-      summary,
-      artifacts: executionResult.artifacts || []
-    };
-
-    this.context.addToolResult(
-      turn.proposedAction!.type,
-      executionResult.output || executionResult.error || ''
-    );
-
-    this.fsm.transitionTo('EVALUATING');
-  }
-
-  private async handleEvaluating(turn: ExecutionTurn): Promise<void> {
-    const executionResult = turn.executionResult!;
-    const thought = turn.thought!;
-
-    let outcome: EvaluationOutcome;
-
-    if (executionResult.success && thought.isDone) {
-      outcome = { kind: 'terminate', reason: 'goal_satisfied' };
-    } else if (!executionResult.success) {
-      outcome = { kind: 'continue', reason: 'failure_retry' };
-    } else {
-      outcome = { kind: 'continue', reason: 'incomplete' };
-    }
-
-    turn.evaluation = outcome;
-
-    if (outcome.kind === 'terminate') {
-      this.fsm.transitionTo('TERMINAL', outcome);
-    } else {
-      this.fsm.transitionTo('THINKING', outcome);
-    }
-  }
-
-  private logTurnSummary(turn: ExecutionTurn): void {
-    console.log(chalk.gray(`\n--- Turn ${turn.turnId} Summary ---`));
-    console.log(chalk.gray(`Duration: ${turn.endTime! - turn.startTime}ms`));
-    if (turn.thought) {
-      console.log(chalk.gray(`Thought: ${turn.thought.type} - ${turn.thought.reasoning?.substring(0, 50)}`));
-    }
-    if (turn.governance) {
-      console.log(chalk.gray(`Governance: ${turn.governance.status} by ${turn.governance.by}`));
-    }
-    if (turn.executionResult) {
-      console.log(chalk.gray(`Execution: ${turn.executionResult.success ? 'success' : 'failed'}`));
-    }
-    console.log(chalk.gray('---\n'));
-  }
-
-  getTurns(): ExecutionTurn[] {
-    return [...this.turns];
-  }
-
-  getFSMState(): AgentState {
-    return this.fsm.current;
-  }
-
-  getContext(): ContextManager {
-    return this.context;
-  }
-}
diff --git a/src/todo.md b/src/todo.md
new file mode 100644
index 0000000..3b9b05b
--- /dev/null
+++ b/src/todo.md
@@ -0,0 +1,7 @@
+#  (Governed Kernel Principles)
+
+1. **** `ActionProposal`
+2. ****Agent  JSON `fs`  `child_process`
+3. ****Governance  `ActionProposal` 
+4. ** (Capabilities)** `read_file`, `shell_run` Audit
+5. ****
