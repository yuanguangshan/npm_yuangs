# yuangs 的非目标（Non-Goals）

> 本文档明确说明 **yuangs 明确不打算做什么**。
>
> 这些不是「尚未实现的功能」，  
> 而是**经过设计后主动排除的能力**，用于保证安全性、可审计性与长期正确性。

yuangs 是一个 **由用户主权控制的执行环境**，  
而不是一个自治 Agent。

---

## 1. 不支持自治执行（No Autonomous Execution）

yuangs **不会**：

- 自动执行由 AI 生成的命令
- 在没有用户明确操作的情况下执行任何命令
- 连续执行多个步骤而不经过用户确认
- 将执行作为推理的副作用触发

**设计理由**

执行（Execution）是系统中风险最高的能力。

一旦允许 AI 跨越「推理 → 执行」的边界，将导致：

- 用户真实意图被弱化
- 行为难以审计与复现
- 不可逆的系统副作用

因此，**所有执行权始终属于用户**。

---

## 2. 不支持自推进 Agent 循环（No Self-Advancing Loops）

yuangs **不会**：

- 自动从一个计划步骤推进到下一个
- 在失败后自动重试命令
- 进入自修复（self-healing）或自纠错循环
- 自主判断“任务完成”并继续下一任务

**设计理由**

即使是“善意”的自动循环，也会引入隐藏的控制流。

yuangs 的核心原则是：

> **任何可能产生副作用的状态变化，  
> 都必须经过一次明确的用户关卡（gate）。**

---

## 3. 不进行隐式上下文扩展（No Implicit Context Expansion）

yuangs **不会**：

- 扫描未明确声明的文件系统路径
- 读取未经 `@` 或 `#` 授权的文件或目录
- 隐式访问环境变量
- 自主访问网络资源

**唯一例外**

- 可注入当前 working tree 的 Git diff
- 该例外是显式的、只读的、范围受限的

**设计理由**

上下文本身是一种能力。

任何能力，都必须被明确授予。

---

## 4. 不存在“AI 拥有的工具”（No AI-Owned Tools）

yuangs **不会**：

- 允许 AI 直接调用工具
- 赋予工具执行权限
- 将工具默认视为“安全的”
- 允许工具在没有用户确认的情况下产生不可逆影响

所有工具在 yuangs 中都只是：

- 提议（Proposal）
- 描述（Description）
- 建议（Suggestion）

**而不是动作（Action）。**

---

## 5. Replay 不具备执行语义（No Execution via Replay）

yuangs **不会**：

- 在 replay 过程中重新执行历史动作
- 将过去的用户确认视为当前执行的授权
- 允许 replay 绕过当前用户意图

Replay 仅用于：

- 审计
- 调试
- 理解历史推理过程

Replay 是 **观察性的（observational）**，  
而非 **操作性的（operational）**。

---

## 6. 不允许隐藏状态跃迁（No Hidden State Transitions）

yuangs **不会**：

- 在没有用户可见输出的情况下推进内部状态
- 执行后台操作
- 静默修改系统状态
- 将执行行为隐藏在抽象之后

所有有意义的动作都必须是：

- 可见的
- 可归因的
- 可复现的

---

## 7. 不允许 AI 宣告目标完成（No Goal Completion Claims）

yuangs **不会**：

- 自主宣告任务“已完成”
- 在没有用户判断的情况下认定成功或失败
- 为了“完成目标”而牺牲正确性

AI 可以 **建议** 任务可能已经完成，  
但 **只有用户才能做出最终判断**。

---

## 8. 不追求通用自治（No General-Purpose Autonomy）

yuangs **不打算成为**：

- 自治 Agent
- 后台任务执行器
- 自我导向系统
- 用户判断的替代品

yuangs 被刻意设计为：

- 强交互
- 可中断
- 保守的系统

---

## 9. 设计取舍声明（Design Trade-offs）

yuangs 明确选择放弃：

- ❌ 高度自动化
- ❌ “魔法式”的用户体验
- ❌ 无人值守执行

以换取：

- ✅ 可预测性
- ✅ 可审计性
- ✅ 语义安全
- ✅ 长期信任

这是一个**有意识的工程决策**。

---

## 10. 总结

> yuangs 可能比自治 Agent 慢。
>
> 但它被设计为：
> - **更难被误用**
> - **更容易被理解**
> - **在最坏情况下更安全**

任何需要违反以上非目标的功能，  
**在定义上即为 out of scope。**
