<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>ULW Minecraft Web Clone</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Courier New', Courier, monospace; user-select: none; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><path d="M10 0v20M0 10h20" stroke="white" stroke-width="2" style="mix-blend-mode:difference"/></svg>') no-repeat center;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 10;
        }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #hotbar {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 5px; background: rgba(0,0,0,0.5); padding: 5px; border-radius: 5px; pointer-events: auto;
        }
        .slot {
            width: 40px; height: 40px; border: 2px solid #555; background: #222;
            display: flex; align-items: center; justify-content: center; color: white; font-size: 10px; cursor: pointer; position: relative;
        }
        .slot.active { border-color: white; }
        .slot span { position: absolute; bottom: 0; right: 2px; }
        #inventory-screen {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px; display: none; pointer-events: auto; color: white;
            text-align: center; width: 400px; height: 300px;
        }
        #crafting-area { margin-bottom: 20px; border-bottom: 1px solid #555; padding-bottom: 10px; }
        button { background: #444; color: white; border: 1px solid #888; padding: 5px 10px; cursor: pointer; }
        button:hover { background: #666; }
        #stats { position: absolute; top: 10px; left: 10px; color: white; text-shadow: 1px 1px 0 #000; }
        #health-bar { position: absolute; bottom: 60px; left: 50%; transform: translateX(-50%); width: 200px; height: 10px; background: #333; border: 1px solid white; }
        #health-fill { width: 100%; height: 100%; background: red; transition: width 0.2s; }
        .block-icon { width: 24px; height: 24px; }
    </style>
</head>
<body>

<div id="crosshair"></div>
<div id="ui-layer">
    <div id="stats">FPS: 60 | XYZ: 0, 0, 0 | Biome: Plains</div>
    <div id="health-bar"><div id="health-fill"></div></div>
    <div id="hotbar">
        <!-- Generated by JS -->
    </div>
    <div id="inventory-screen">
        <h3>合成 & 背包 (按E关闭)</h3>
        <div id="crafting-area">
            <div>可用合成:</div>
            <div id="recipes" style="display:flex; gap:5px; flex-wrap:wrap; justify-content:center; margin-top:5px;"></div>
        </div>
        <div style="text-align:left;">背包内容:</div>
        <div id="inv-grid" style="display:flex; gap:5px; flex-wrap:wrap; margin-top:5px;"></div>
    </div>
</div>

<!-- Libraries -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
<!-- Simplex Noise for Terrain -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>

<script>
    // --- 游戏配置与全局变量 ---
    const RENDER_DISTANCE = 4; // 区块渲染距离
    const CHUNK_SIZE = 16;
    const WORLD_HEIGHT = 32; // 简化高度以提升性能
    const GRAVITY = 25.0;
    const JUMP_FORCE = 10.0;
    const MOVE_SPEED = 6.0;

    // 方块定义 ID
    const BLOCKS = {
        AIR: 0,
        GRASS: 1, DIRT: 2, STONE: 3, LOG: 4, LEAVES: 5,
        PLANKS: 6, COAL_ORE: 7, IRON_ORE: 8, DIAMOND_ORE: 9,
        CRAFTING_TABLE: 10, COBBLESTONE: 11
    };

    // 颜色/材质映射 (使用Canvas生成贴图)
    const BLOCK_COLORS = {
        [BLOCKS.GRASS]: '#567d46',
        [BLOCKS.DIRT]: '#5d4037',
        [BLOCKS.STONE]: '#757575',
        [BLOCKS.LOG]: '#4e342e',
        [BLOCKS.LEAVES]: '#2e7d32',
        [BLOCKS.PLANKS]: '#bcaaa4',
        [BLOCKS.COAL_ORE]: '#212121',
        [BLOCKS.IRON_ORE]: '#d7ccc8',
        [BLOCKS.DIAMOND_ORE]: '#00bcd4',
        [BLOCKS.CRAFTING_TABLE]: '#8d6e63',
        [BLOCKS.COBBLESTONE]: '#616161'
    };

    // --- 纹理生成器 ---
    const textureLoader = new THREE.TextureLoader();
    const textures = {};
    function createTexture(color, noiseIntensity = 0.1) {
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = color;
        ctx.fillRect(0,0,64,64);
        
        // 添加杂色
        for(let i=0; i<400; i++) {
            ctx.fillStyle = `rgba(0,0,0,${Math.random() * noiseIntensity})`;
            ctx.fillRect(Math.random()*64, Math.random()*64, 2, 2);
            ctx.fillStyle = `rgba(255,255,255,${Math.random() * noiseIntensity})`;
            ctx.fillRect(Math.random()*64, Math.random()*64, 2, 2);
        }
        // 边框
        ctx.strokeStyle = 'rgba(0,0,0,0.1)';
        ctx.strokeRect(0,0,64,64);
        
        const tex = new THREE.CanvasTexture(canvas);
        tex.magFilter = THREE.NearestFilter;
        return tex;
    }

    // 初始化材质
    const materials = [];
    // 0 is Air
    materials[0] = null;
    for(let key in BLOCKS) {
        const id = BLOCKS[key];
        if(id === 0) continue;
        const color = BLOCK_COLORS[id] || '#ff00ff';
        // 侧面与顶部不同的处理（简化为全贴图）
        // 只有草方块特殊一点，这里简化处理，全部同色+杂色
        materials[id] = new THREE.MeshLambertMaterial({ map: createTexture(color) });
    }

    // --- 引擎核心 ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); // Sky blue
    scene.fog = new THREE.Fog(0x87CEEB, 20, RENDER_DISTANCE * CHUNK_SIZE - 10);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // 光照
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
    dirLight.position.set(50, 100, 50);
    scene.add(dirLight);

    // 控制器
    const controls = new THREE.PointerLockControls(camera, document.body);
    const instructions = document.body; // 点击任意处开始

    instructions.addEventListener('click', () => {
        if(!isInventoryOpen) controls.lock();
    });

    // 状态
    const worldData = {}; // key: "x,y,z" -> blockID (稀疏存储或区块存储)
    const chunks = {}; // key: "cx,cz" -> Mesh
    const simplex = new SimplexNoise();
    
    // 玩家状态
    const player = {
        position: new THREE.Vector3(0, 20, 0),
        velocity: new THREE.Vector3(),
        onGround: false,
        height: 1.8,
        inventory: {
            [BLOCKS.DIRT]: 0,
            [BLOCKS.STONE]: 0
        },
        hotbar: [BLOCKS.STONE, BLOCKS.GRASS, BLOCKS.LOG, BLOCKS.PLANKS, BLOCKS.CRAFTING_TABLE],
        selectedSlot: 0,
        health: 100
    };

    // --- 世界生成逻辑 ---
    function getChunkKey(x, z) {
        return `${Math.floor(x / CHUNK_SIZE)},${Math.floor(z / CHUNK_SIZE)}`;
    }

    function generateHeight(x, z) {
        // 叠加噪声
        let y = 0;
        y += simplex.noise2D(x / 50, z / 50) * 10;
        y += simplex.noise2D(x / 10, z / 10) * 2;
        return Math.floor(y + 10); // 基准高度
    }

    function getBlock(x, y, z) {
        const key = `${x},${y},${z}`;
        if (worldData[key] !== undefined) return worldData[key];
        
        // 这里的逻辑只用于初始生成查询
        if (y < 0) return BLOCKS.STONE; // 基岩下
        
        const h = generateHeight(x, z);
        
        if (y > h) return BLOCKS.AIR;
        if (y === h) return BLOCKS.GRASS;
        if (y > h - 4) return BLOCKS.DIRT;
        
        // 矿石生成
        if (y < h - 4) {
             const caveNoise = simplex.noise3D(x/15, y/15, z/15);
             if (caveNoise > 0.6) return BLOCKS.AIR; // 洞穴

             const oreNoise = Math.random();
             if (y < 5 && oreNoise > 0.98) return BLOCKS.DIAMOND_ORE;
             if (oreNoise > 0.95) return BLOCKS.IRON_ORE;
             if (oreNoise > 0.90) return BLOCKS.COAL_ORE;
             return BLOCKS.STONE;
        }
        return BLOCKS.AIR;
    }

    // 存储方块到内存（如果是新生成的）
    function setBlockData(x, y, z, id) {
        worldData[`${x},${y},${z}`] = id;
    }

    function generateStructure(cx, cz) {
        // 树木生成
        const seed = simplex.noise2D(cx, cz);
        if (seed > 0.3) {
            // 简单的树
            const localX = Math.floor(Math.abs(seed * 100)) % 10 + 3;
            const localZ = Math.floor(Math.abs(seed * 200)) % 10 + 3;
            const worldX = cx * CHUNK_SIZE + localX;
            const worldZ = cz * CHUNK_SIZE + localZ;
            const y = generateHeight(worldX, worldZ) + 1;
            
            // 树干
            for(let i=0; i<4; i++) setBlockData(worldX, y+i, worldZ, BLOCKS.LOG);
            // 树叶
            for(let lx=-2; lx<=2; lx++) {
                for(let lz=-2; lz<=2; lz++) {
                    for(let ly=2; ly<=3; ly++) {
                        if (Math.abs(lx)+Math.abs(lz) < 3)
                             setBlockData(worldX+lx, y+ly, worldZ+lz, BLOCKS.LEAVES);
                    }
                }
            }
        }
        
        // 极简村庄生成 (概率低)
        if (seed < -0.6) {
             const wx = cx * CHUNK_SIZE + 8;
             const wz = cz * CHUNK_SIZE + 8;
             const wy = generateHeight(wx, wz) + 1;
             // 房子
             for(let dx=-3; dx<=3; dx++) {
                 for(let dz=-3; dz<=3; dz++) {
                     for(let dy=0; dy<4; dy++) {
                         if (dx===-3 || dx===3 || dz===-3 || dz===3 || dy===0 || dy===3) {
                             if (!(dx===0 && dz===-3 && dy<2)) // 门
                                setBlockData(wx+dx, wy+dy, wz+dz, BLOCKS.PLANKS);
                         } else {
                             setBlockData(wx+dx, wy+dy, wz+dz, BLOCKS.AIR);
                         }
                     }
                 }
             }
             // 生成村民
             spawnEntity('villager', wx, wy+1, wz);
        }
    }

    // --- 区块网格构建 ---
    // 为了性能，每个区块合并成一个 InstancedMesh 或 BufferGeometry
    // 这里为了代码简单，使用 InstancedMesh 可能会比较复杂，我们使用简单的 Geometry 合并（Merge）
    // 但在现代Three.js，最好是每种材质一个 InstancedMesh。
    // 这是一个简化版的构建器：每种材质对应一个 InstancedMesh
    
    function updateChunk(cx, cz) {
        const key = `${cx},${cz}`;
        if (chunks[key]) {
            scene.remove(chunks[key]);
            delete chunks[key];
        }

        const chunkGroup = new THREE.Group();
        const dummy = new THREE.Object3D();
        const geometries = {}; // materialID -> count
        const matrices = {}; // materialID -> array of matrices

        // 扫描区块数据
        for (let x = 0; x < CHUNK_SIZE; x++) {
            for (let z = 0; z < CHUNK_SIZE; z++) {
                const wx = cx * CHUNK_SIZE + x;
                const wz = cz * CHUNK_SIZE + z;
                
                // 确保数据存在 (懒加载)
                // 从基岩到最高点扫描
                for (let y = 0; y < WORLD_HEIGHT; y++) {
                     // 如果worldData里没数据，初始化它
                     if (worldData[`${wx},${y},${wz}`] === undefined) {
                         worldData[`${wx},${y},${wz}`] = getBlock(wx, y, wz);
                     }
                     const id = worldData[`${wx},${y},${wz}`];
                     
                     if (id !== BLOCKS.AIR) {
                         // 简单的面剔除 (Culling): 如果四周都有方块，就不渲染
                         // 这里只做个非常简单的检查：如果上面有方块，且不是透明的，可能不需要渲染顶面等。
                         // 为简化，全部渲染。
                         
                         if (!geometries[id]) { geometries[id] = 0; matrices[id] = []; }
                         geometries[id]++;
                         
                         dummy.position.set(wx, y, wz);
                         dummy.updateMatrix();
                         matrices[id].push(dummy.matrix.clone());
                     }
                }
            }
        }

        // 创建 InstancedMesh
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        for (let id in geometries) {
            if (geometries[id] === 0) continue;
            const mesh = new THREE.InstancedMesh(geometry, materials[id], geometries[id]);
            const matArray = matrices[id];
            for (let i = 0; i < matArray.length; i++) {
                mesh.setMatrixAt(i, matArray[i]);
            }
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            chunkGroup.add(mesh);
        }

        chunkGroup.userData = { cx, cz };
        scene.add(chunkGroup);
        chunks[key] = chunkGroup;
    }

    // --- 实体/怪物系统 ---
    const entities = [];
    const entityMaterials = {
        'zombie': new THREE.MeshLambertMaterial({ color: 0x00aa00 }), // 绿色
        'pig': new THREE.MeshLambertMaterial({ color: 0xffaaaa }), // 粉色
        'villager': new THREE.MeshLambertMaterial({ color: 0x8d6e63 }) // 褐色
    };

    function spawnEntity(type, x, y, z) {
        const geo = new THREE.BoxGeometry(0.8, type==='pig'?0.8:1.8, 0.8);
        const mesh = new THREE.Mesh(geo, entityMaterials[type]);
        mesh.position.set(x, y, z);
        scene.add(mesh);
        entities.push({
            mesh: mesh,
            type: type,
            vel: new THREE.Vector3(),
            health: 10,
            timer: 0
        });
    }

    function updateEntities(dt) {
        entities.forEach(ent => {
            // 简单的重力
            ent.vel.y -= GRAVITY * dt;
            
            // 简单的 AI
            ent.timer += dt;
            if (ent.timer > 1) {
                ent.timer = 0;
                if (ent.type === 'zombie') {
                    // 追玩家
                    const dx = player.position.x - ent.mesh.position.x;
                    const dz = player.position.z - ent.mesh.position.z;
                    const dist = Math.sqrt(dx*dx + dz*dz);
                    if (dist < 20) {
                        ent.vel.x = (dx / dist) * 2;
                        ent.vel.z = (dz / dist) * 2;
                    }
                    if (dist < 1.5) {
                        player.health -= 1; // 攻击
                        updateUI();
                    }
                } else {
                    // 随机移动
                    if (Math.random() > 0.5) {
                        ent.vel.x = (Math.random() - 0.5) * 2;
                        ent.vel.z = (Math.random() - 0.5) * 2;
                    } else {
                        ent.vel.x = 0; ent.vel.z = 0;
                    }
                    if (Math.random() > 0.9) ent.vel.y = 5; // 跳跃
                }
            }

            // 碰撞与移动 (简化版，仅对地)
            ent.mesh.position.addScaledVector(ent.vel, dt);
            
            // 地面碰撞
            const bx = Math.round(ent.mesh.position.x);
            const by = Math.round(ent.mesh.position.y - (ent.type==='pig'?0.4:0.9));
            const bz = Math.round(ent.mesh.position.z);
            
            const blk = worldData[`${bx},${by},${bz}`];
            if (blk && blk !== BLOCKS.AIR) {
                ent.mesh.position.y = by + 1 + (ent.type==='pig'?0.4:0.9);
                ent.vel.y = 0;
            }
        });
    }

    // --- 玩家物理与交互 ---
    const raycaster = new THREE.Raycaster();
    const moveState = { forward: false, backward: false, left: false, right: false, jump: false };

    document.addEventListener('keydown', (event) => {
        switch (event.code) {
            case 'KeyW': moveState.forward = true; break;
            case 'KeyS': moveState.backward = true; break;
            case 'KeyA': moveState.left = true; break;
            case 'KeyD': moveState.right = true; break;
            case 'Space': if (player.onGround) player.velocity.y = JUMP_FORCE; break;
            case 'Digit1': player.selectedSlot = 0; updateHotbar(); break;
            case 'Digit2': player.selectedSlot = 1; updateHotbar(); break;
            case 'Digit3': player.selectedSlot = 2; updateHotbar(); break;
            case 'Digit4': player.selectedSlot = 3; updateHotbar(); break;
            case 'Digit5': player.selectedSlot = 4; updateHotbar(); break;
            case 'KeyE': toggleInventory(); break;
        }
    });

    document.addEventListener('keyup', (event) => {
        switch (event.code) {
            case 'KeyW': moveState.forward = false; break;
            case 'KeyS': moveState.backward = false; break;
            case 'KeyA': moveState.left = false; break;
            case 'KeyD': moveState.right = false; break;
        }
    });

    document.addEventListener('mousedown', (event) => {
        if (!controls.isLocked) return;
        if (event.button === 0) breakBlock();
        if (event.button === 2) placeBlock();
    });

    // 防止右键菜单
    document.addEventListener('contextmenu', event => event.preventDefault());

    function checkCollision(pos) {
        // 极简 AABB: 检查玩家脚下和头顶的方块
        const x = Math.round(pos.x);
        const yHead = Math.round(pos.y);
        const yFoot = Math.round(pos.y - 1);
        const z = Math.round(pos.z);
        
        // 返回简单的 true/false
        const bHead = worldData[`${x},${yHead},${z}`];
        const bFoot = worldData[`${x},${yFoot},${z}`];
        
        if (bHead && bHead !== BLOCKS.AIR) return true;
        if (bFoot && bFoot !== BLOCKS.AIR) return true;
        return false;
    }

    function getSelectedBlock() {
        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
        const intersects = raycaster.intersectObjects(scene.children, true);
        // 过滤掉实体，只找方块 (这里简化了，InstancedMesh 也是 Mesh)
        // 但由于使用了 InstancedMesh，我们需要特殊的射线检测逻辑来获取 InstanceID
        // 为简化代码量，我们用纯数学方式检测面前的方块
        
        // 替代方案：步进射线检测 (Voxel Raycast)
        let pos = camera.position.clone();
        let dir = new THREE.Vector3();
        camera.getWorldDirection(dir);
        
        for(let i=0; i<50; i++) { // 5格距离，每步0.1
            pos.addScaledVector(dir, 0.1);
            const bx = Math.round(pos.x);
            const by = Math.round(pos.y);
            const bz = Math.round(pos.z);
            const id = worldData[`${bx},${by},${bz}`];
            if (id && id !== BLOCKS.AIR) {
                return { x: bx, y: by, z: bz, id: id, face: getFace(pos, bx, by, bz) };
            }
        }
        return null;
    }

    function getFace(hitPos, x, y, z) {
        // 简单的面判定
        const dx = hitPos.x - x;
        const dy = hitPos.y - y;
        const dz = hitPos.z - z;
        if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > Math.abs(dz)) return { x: Math.sign(dx), y: 0, z: 0 };
        if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > Math.abs(dz)) return { x: 0, y: Math.sign(dy), z: 0 };
        return { x: 0, y: 0, z: Math.sign(dz) };
    }

    function breakBlock() {
        const hit = getSelectedBlock();
        if (hit) {
            // 掉落物品
            const drop = hit.id; // 简单处理：掉落原方块
            player.inventory[drop] = (player.inventory[drop] || 0) + 1;
            
            delete worldData[`${hit.x},${hit.y},${hit.z}`];
            // 重建该区块
            rebuildChunkAt(hit.x, hit.z);
            updateUI();
        }
    }

    function placeBlock() {
        const hit = getSelectedBlock();
        if (hit) {
            const heldID = player.hotbar[player.selectedSlot];
            if (!heldID || heldID === BLOCKS.AIR) return;

            const tx = hit.x + hit.face.x;
            const ty = hit.y + hit.face.y;
            const tz = hit.z + hit.face.z;
            
            // 碰撞检查：不能放在玩家体内
            if (Math.round(player.position.x) === tx && Math.round(player.position.y) === ty && Math.round(player.position.z) === tz) return;
            if (Math.round(player.position.x) === tx && Math.round(player.position.y-1) === ty && Math.round(player.position.z) === tz) return;

            worldData[`${tx},${ty},${tz}`] = heldID;
            rebuildChunkAt(tx, tz);
        }
    }

    function rebuildChunkAt(x, z) {
        const cx = Math.floor(x / CHUNK_SIZE);
        const cz = Math.floor(z / CHUNK_SIZE);
        updateChunk(cx, cz);
    }

    // --- UI 与合成系统 ---
    let isInventoryOpen = false;
    
    // 简易合成表
    const RECIPES = [
        { out: BLOCKS.PLANKS, count: 4, in: { [BLOCKS.LOG]: 1 } },
        { out: BLOCKS.CRAFTING_TABLE, count: 1, in: { [BLOCKS.PLANKS]: 4 } },
        { out: BLOCKS.COBBLESTONE, count: 1, in: { [BLOCKS.STONE]: 1 } } // 模拟
    ];

    function toggleInventory() {
        isInventoryOpen = !isInventoryOpen;
        const screen = document.getElementById('inventory-screen');
        screen.style.display = isInventoryOpen ? 'block' : 'none';
        if (isInventoryOpen) {
            controls.unlock();
            renderInventory();
        } else {
            controls.lock();
        }
    }

    function updateHotbar() {
        const div = document.getElementById('hotbar');
        div.innerHTML = '';
        player.hotbar.forEach((id, index) => {
            const slot = document.createElement('div');
            slot.className = 'slot' + (index === player.selectedSlot ? ' active' : '');
            if (id) {
                slot.style.backgroundColor = BLOCK_COLORS[id] || '#000';
                slot.innerText = id; // 简化显示ID或名称
            }
            div.appendChild(slot);
        });
    }

    function updateUI() {
        document.getElementById('stats').innerText = `XYZ: ${Math.floor(player.position.x)}, ${Math.floor(player.position.y)}, ${Math.floor(player.position.z)} | Health: ${player.health}`;
        document.getElementById('health-fill').style.width = player.health + '%';
        if (isInventoryOpen) renderInventory();
        updateHotbar();
    }

    function renderInventory() {
        const invGrid = document.getElementById('inv-grid');
        invGrid.innerHTML = '';
        for(let id in player.inventory) {
            if (player.inventory[id] > 0) {
                const btn = document.createElement('button');
                btn.innerText = `${getKeyByValue(BLOCKS, parseInt(id))} x${player.inventory[id]}`;
                // 点击放到快捷栏
                btn.onclick = () => {
                    player.hotbar[player.selectedSlot] = parseInt(id);
                    updateHotbar();
                };
                invGrid.appendChild(btn);
            }
        }

        const recipesDiv = document.getElementById('recipes');
        recipesDiv.innerHTML = '';
        RECIPES.forEach(r => {
            const btn = document.createElement('button');
            const outName = getKeyByValue(BLOCKS, r.out);
            let canCraft = true;
            for(let reqId in r.in) {
                if ((player.inventory[reqId] || 0) < r.in[reqId]) canCraft = false;
            }
            
            btn.innerText = `${outName}`;
            if (!canCraft) btn.style.opacity = 0.5;
            btn.onclick = () => {
                if (!canCraft) return;
                // 扣除材料
                for(let reqId in r.in) {
                    player.inventory[reqId] -= r.in[reqId];
                }
                // 增加产物
                player.inventory[r.out] = (player.inventory[r.out] || 0) + r.count;
                renderInventory();
            };
            recipesDiv.appendChild(btn);
        });
    }
    
    function getKeyByValue(object, value) {
        return Object.keys(object).find(key => object[key] === value);
    }


    // --- 游戏循环 ---
    const clock = new THREE.Clock();
    let lastChunkX = -999, lastChunkZ = -999;

    function animate() {
        requestAnimationFrame(animate);

        const dt = Math.min(clock.getDelta(), 0.1);
        
        if (controls.isLocked) {
            // 物理移动
            player.velocity.x -= player.velocity.x * 10.0 * dt;
            player.velocity.z -= player.velocity.z * 10.0 * dt;
            player.velocity.y -= GRAVITY * dt;

            const direction = new THREE.Vector3();
            direction.z = Number(moveState.forward) - Number(moveState.backward);
            direction.x = Number(moveState.right) - Number(moveState.left);
            direction.normalize();

            if (moveState.forward || moveState.backward) player.velocity.z -= direction.z * 400.0 * dt;
            if (moveState.left || moveState.right) player.velocity.x -= direction.x * 400.0 * dt;

            controls.moveRight(-player.velocity.x * dt);
            controls.moveForward(-player.velocity.z * dt);
            player.position.y += player.velocity.y * dt;
            
            // 简单的地形碰撞 (检测脚下)
            const px = Math.round(camera.position.x);
            const pz = Math.round(camera.position.z);
            // 简化：如果掉到地下，弹回来
            const groundH = getBlock(px, Math.round(player.position.y-2), pz) !== BLOCKS.AIR ? Math.round(player.position.y-2) + 1 : -100;
            
            // 更精确一点的碰撞：检查当前坐标下的最高方块
            let highestY = -100;
            for(let y=Math.floor(player.position.y+2); y>=Math.floor(player.position.y-3); y--) {
                if (worldData[`${px},${y},${pz}`] && worldData[`${px},${y},${pz}`] !== BLOCKS.AIR) {
                    highestY = y;
                    break;
                }
            }

            if (player.position.y < highestY + 1.8) {
                player.velocity.y = 0;
                player.position.y = highestY + 1.8;
                player.onGround = true;
            } else {
                player.onGround = false;
            }
            
            // 重生
            if (player.position.y < -30) {
                player.position.y = 30;
                player.velocity.y = 0;
            }

            camera.position.y = player.position.y;
            player.position.x = camera.position.x;
            player.position.z = camera.position.z;
        }

        // 动态加载区块
        const curChunkX = Math.floor(player.position.x / CHUNK_SIZE);
        const curChunkZ = Math.floor(player.position.z / CHUNK_SIZE);

        if (curChunkX !== lastChunkX || curChunkZ !== lastChunkZ) {
            // 生成周围区块
            for (let x = -RENDER_DISTANCE; x <= RENDER_DISTANCE; x++) {
                for (let z = -RENDER_DISTANCE; z <= RENDER_DISTANCE; z++) {
                    const cx = curChunkX + x;
                    const cz = curChunkZ + z;
                    const key = `${cx},${cz}`;
                    if (!chunks[key]) {
                        // 预先生成数据
                        generateStructure(cx, cz);
                        updateChunk(cx, cz);
                        
                        // 随机生成动物
                        if (Math.random() > 0.95) spawnEntity('pig', cx*CHUNK_SIZE+8, 20, cz*CHUNK_SIZE+8);
                        if (Math.random() > 0.98) spawnEntity('zombie', cx*CHUNK_SIZE+8, 20, cz*CHUNK_SIZE+8);
                    }
                }
            }
            
            // 卸载远处的区块
            for (let key in chunks) {
                 const part = chunks[key].userData;
                 if (Math.abs(part.cx - curChunkX) > RENDER_DISTANCE + 1 || 
                     Math.abs(part.cz - curChunkZ) > RENDER_DISTANCE + 1) {
                     scene.remove(chunks[key]);
                     delete chunks[key];
                 }
            }

            lastChunkX = curChunkX;
            lastChunkZ = curChunkZ;
        }

        updateEntities(dt);
        renderer.render(scene, camera);
        updateUI();
    }

    // 初始化玩家位置
    const initY = generateHeight(0, 0) + 5;
    player.position.y = initY;
    camera.position.y = initY;
    
    updateHotbar();
    animate();

    // Resize handler
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>