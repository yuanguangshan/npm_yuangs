<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>ULW Minecraft 4.0 - Infinite Deep World</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }
        
        /* 准星 */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            background: rgba(255,255,255,0.8);
            clip-path: polygon(40% 0, 60% 0, 60% 40%, 100% 40%, 100% 60%, 60% 60%, 60% 100%, 40% 100%, 40% 60%, 0 60%, 0 40%, 40% 40%);
            transform: translate(-50%, -50%); mix-blend-mode: exclusion; z-index: 100;
        }

        /* UI 层 */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* 右侧背包按钮 */
        #inv-toggle-btn {
            position: absolute; right: 20px; top: 50%; transform: translateY(-50%);
            width: 60px; height: 60px; background: rgba(0,0,0,0.6); border: 2px solid #fff;
            border-radius: 10px; cursor: pointer; pointer-events: auto;
            display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;
            transition: 0.2s;
        }
        #inv-toggle-btn:hover { background: rgba(0,0,0,0.8); scale: 1.1; }

        /* 快捷栏 */
        #hotbar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 8px; background: rgba(0,0,0,0.5); padding: 8px; border-radius: 8px; pointer-events: auto;
        }
        .slot {
            width: 50px; height: 50px; background: #3c3c3c; border: 3px solid #555;
            display: flex; align-items: center; justify-content: center; position: relative; cursor: pointer;
            image-rendering: pixelated;
        }
        .slot.active { border-color: #fff; box-shadow: 0 0 8px white; transform: translateY(-2px); }
        .slot img { width: 36px; height: 36px; image-rendering: pixelated; }
        .slot .count { 
            position: absolute; bottom: 2px; right: 2px; color: white; 
            font-size: 14px; font-weight: bold; text-shadow: 2px 2px 0 #000; font-family: monospace;
        }

        /* 背包界面 */
        #inventory-screen {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 720px; height: 550px; background: #c6c6c6; border: 4px solid #333; pointer-events: auto;
            box-shadow: 0 0 30px rgba(0,0,0,0.8); padding: 20px; border-radius: 4px;
            color: #333;
        }
        
        .panel-title { font-size: 18px; margin-bottom: 10px; font-weight: bold; border-bottom: 2px solid #777; padding-bottom: 5px; }

        #crafting-area {
            display: flex; gap: 10px; overflow-x: auto; padding-bottom: 15px; margin-bottom: 15px;
            background: #b0b0b0; padding: 10px; border-radius: 4px; box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
        }
        .craft-item {
            min-width: 64px; height: 80px; background: #8b8b8b; border: 2px solid #555; cursor: pointer;
            display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative;
        }
        .craft-item:hover { background: #9c9c9c; border-color: #fff; }
        .craft-item.disabled { opacity: 0.4; filter: grayscale(1); cursor: not-allowed; }
        .craft-req { font-size: 10px; color: #eee; margin-top: 2px; text-shadow: 1px 1px 0 #000; }

        #inv-grid { 
            display: grid; grid-template-columns: repeat(10, 1fr); gap: 6px; 
            height: 320px; overflow-y: auto; background: #8b8b8b; padding: 10px; border: inset 3px #555;
        }
        
        #stats { position: absolute; top: 10px; left: 10px; color: white; text-shadow: 2px 2px 0 #000; font-family: monospace; }
        
        /* 提示 */
        #message {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            font-size: 24px; color: #ffeb3b; text-shadow: 2px 2px 4px #000; 
            opacity: 0; transition: opacity 0.5s; pointer-events: none;
        }
    </style>
</head>
<body>

<div id="crosshair"></div>
<div id="message"></div>

<div id="ui-layer">
    <div id="stats">FPS: 60 | Y: 60</div>
    
    <!-- 右侧背包开关 -->
    <div id="inv-toggle-btn" onclick="toggleInventory()">背包<br>(E)</div>

    <div id="hotbar"></div>

    <div id="inventory-screen">
        <div class="panel-title">合成台 (点击图标合成)</div>
        <div id="crafting-area"></div>
        
        <div class="panel-title">物品栏 (64格 - 选中物品后点击快捷栏装备)</div>
        <div id="inv-grid"></div>
        
        <button onclick="toggleInventory()" style="margin-top:10px; padding:8px 30px; cursor:pointer; background:#555; color:white; border:2px solid #333;">关闭</button>
    </div>
</div>

<!-- Three.js 核心库 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>

<script>
    // --- 1. 游戏常量配置 ---
    const CONF = {
        RENDER_DIST: 3,        // 视野距离
        CHUNK_SIZE: 16,        // 区块大小
        WORLD_BOTTOM: -64,     // 地图底部深度
        WORLD_TOP: 64,         // 地图生成最高点 (虽然可以无限高，但生成限制在此)
        SEA_LEVEL: 10,         // 海平面
        GRAVITY: 30.0,
        SPEED: 6.0,
        JUMP: 10.0
    };

    // 方块ID表
    const B = {
        AIR: 0,
        GRASS: 1, DIRT: 2, STONE: 3, BEDROCK: 4,
        LOG: 5, LEAVES: 6, PLANKS: 7,
        COAL_ORE: 8, IRON_ORE: 9, DIAMOND_ORE: 10, GOLD_ORE: 11,
        WATER: 12, LAVA: 13, SAND: 14,
        CRAFTING_TABLE: 15, COBBLESTONE: 16, BRICK: 17,
        // 物品 (ID >= 100)
        SWORD_WOOD: 100, SWORD_STONE: 101, SWORD_IRON: 102, SWORD_DIAMOND: 103,
        MEAT: 104, APPLE: 105
    };

    // --- 2. 纹理与图标生成系统 ---
    // 我们使用 Canvas 动态绘制类似 Minecraft 的像素纹理，并生成 DataURL 给 UI 使用
    const iconCache = {};
    const textures = {};

    function generateTextureAndIcon(id, color, type = 'standard') {
        const size = 64;
        const canvas = document.createElement('canvas');
        canvas.width = size; canvas.height = size;
        const ctx = canvas.getContext('2d');

        // 基础底色
        ctx.fillStyle = color;
        ctx.fillRect(0,0,size,size);

        // 通用杂色
        for(let i=0; i<300; i++) {
            ctx.fillStyle = Math.random()>0.5 ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
            const s = Math.ceil(Math.random()*3);
            ctx.fillRect(Math.random()*size, Math.random()*size, s, s);
        }

        // 特殊纹理逻辑
        if(type === 'ore') {
            ctx.fillStyle = '#000'; // 矿点阴影
            for(let i=0; i<6; i++) ctx.fillRect(Math.random()*40+10, Math.random()*40+10, 10, 10);
            ctx.fillStyle = color; // 矿点高光 (重绘底色)
            for(let i=0; i<6; i++) ctx.fillRect(Math.random()*40+10, Math.random()*40+10, 6, 6);
            // 恢复石头背景
            ctx.globalCompositeOperation = 'destination-over';
            ctx.fillStyle = '#757575';
            ctx.fillRect(0,0,size,size);
        } else if (type === 'log') {
            ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 4;
            for(let i=4; i<size; i+=10) { ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,size); ctx.stroke(); }
            // 年轮顶部(简化)
            ctx.fillStyle = '#5d4037'; ctx.fillRect(0,0,10,10); // 标记一下
        } else if (type === 'brick' || type === 'cobble') {
            ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 2;
            ctx.strokeRect(0,0,size,size);
            ctx.strokeRect(size/2, 0, size/2, size/2);
            ctx.strokeRect(0, size/2, size/2, size/2);
        } else if (type === 'sword') {
            ctx.clearRect(0,0,size,size); // 清空
            ctx.fillStyle = '#4e342e'; // 棍子
            ctx.fillRect(10,50, 15,15);
            ctx.fillStyle = color; // 剑刃
            ctx.beginPath(); ctx.moveTo(20,55); ctx.lineTo(55,20); ctx.lineTo(60,25); ctx.lineTo(25,60); ctx.fill();
        } else if (type === 'meat') {
            ctx.clearRect(0,0,size,size);
            ctx.fillStyle = '#e57373';
            ctx.beginPath(); ctx.arc(32,32, 20, 0, Math.PI*2); ctx.fill();
        }

        // 保存图标 URL
        iconCache[id] = canvas.toDataURL();

        // 返回 Three.js 纹理
        const tex = new THREE.CanvasTexture(canvas);
        tex.magFilter = THREE.NearestFilter;
        return tex;
    }

    // 材质定义
    const matCache = {};
    const DEF = [
        {id: B.GRASS, col:'#567d46', t:'standard'}, {id: B.DIRT, col:'#5d4037', t:'standard'},
        {id: B.STONE, col:'#757575', t:'standard'}, {id: B.BEDROCK, col:'#111', t:'standard'},
        {id: B.LOG, col:'#3e2723', t:'log'}, {id: B.LEAVES, col:'#2e7d32', t:'standard'},
        {id: B.PLANKS, col:'#bcaaa4', t:'wood'}, {id: B.SAND, col:'#fff9c4', t:'standard'},
        {id: B.WATER, col:'#2196f3', t:'standard', tr:true, op:0.6},
        {id: B.LAVA, col:'#ff3d00', t:'standard', glow:true},
        {id: B.COAL_ORE, col:'#212121', t:'ore'}, {id: B.IRON_ORE, col:'#d7ccc8', t:'ore'},
        {id: B.DIAMOND_ORE, col:'#00bcd4', t:'ore'}, {id: B.GOLD_ORE, col:'#ffeb3b', t:'ore'},
        {id: B.CRAFTING_TABLE, col:'#8d6e63', t:'brick'}, {id: B.COBBLESTONE, col:'#616161', t:'cobble'},
        // 物品
        {id: B.SWORD_WOOD, col:'#8d6e63', t:'sword'}, {id: B.SWORD_STONE, col:'#757575', t:'sword'},
        {id: B.SWORD_IRON, col:'#fff', t:'sword'}, {id: B.SWORD_DIAMOND, col:'#00bcd4', t:'sword'},
        {id: B.MEAT, col:'#f48fb1', t:'meat'}
    ];

    DEF.forEach(d => {
        const tex = generateTextureAndIcon(d.id, d.col, d.t);
        if(d.id < 100) { // 只有方块需要3D材质
            matCache[d.id] = new THREE.MeshLambertMaterial({
                map: tex,
                transparent: d.tr || false,
                opacity: d.op || 1.0,
                emissive: d.glow ? d.col : 0x000000,
                emissiveIntensity: d.glow ? 0.5 : 0
            });
        }
    });

    // --- 3. 场景与引擎 ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 20, CONF.RENDER_DIST * CONF.CHUNK_SIZE - 5);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({antialias: false});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // 光照
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    const sun = new THREE.DirectionalLight(0xffffff, 0.8);
    sun.position.set(50, 100, 50);
    scene.add(sun);

    // --- 4. 世界生成 (无限深) ---
    const worldData = {}; // Sparse storage: "x,y,z" -> ID
    const chunks = {};
    const simplex = new SimplexNoise();

    function getBiomeHeight(x, z) {
        let n = simplex.noise2D(x/100, z/100);
        let h = Math.floor(n * 20 + 30); // 基础高度 10~50
        return h;
    }

    function generateChunk(cx, cz) {
        const updates = [];
        // 树木噪声
        const forestNoise = (x,z) => simplex.noise2D(x/50, z/50) > 0.3;

        for(let x=0; x<16; x++) {
            for(let z=0; z<16; z++) {
                const wx = cx*16 + x;
                const wz = cz*16 + z;
                const h = getBiomeHeight(wx, wz);

                // 从底部生成到地表
                for(let y = CONF.WORLD_BOTTOM; y <= Math.max(h, CONF.SEA_LEVEL); y++) {
                    let id = B.AIR;
                    if(y === CONF.WORLD_BOTTOM) id = B.BEDROCK;
                    else if (y < h - 4) {
                        // 地下生成
                        // 3D 噪声生成洞穴
                        const cave = simplex.noise3D(wx/20, y/20, wz/20);
                        if(cave > 0.6) {
                             if(y < -10) id = B.LAVA; // 深层岩浆
                             else id = B.AIR;
                        } else {
                            // 矿石分布
                            const r = Math.random();
                            if(y < 10 && r > 0.99) id = B.DIAMOND_ORE;
                            else if(y < 30 && r > 0.98) id = B.GOLD_ORE;
                            else if(y < 50 && r > 0.97) id = B.IRON_ORE;
                            else if(r > 0.96) id = B.COAL_ORE;
                            else id = B.STONE;
                        }
                    } 
                    else if (y < h) id = B.DIRT;
                    else if (y === h) id = (y <= CONF.SEA_LEVEL) ? B.SAND : B.GRASS;
                    else if (y <= CONF.SEA_LEVEL) id = B.WATER;

                    if(id !== B.AIR) {
                        worldData[`${wx},${y},${wz}`] = id;
                    }
                }

                // 地表装饰：树
                if(h > CONF.SEA_LEVEL && forestNoise(wx, wz) && Math.random() > 0.9) {
                    createTree(wx, h+1, wz);
                }
            }
        }
        
        // 概率生成生物
        if(Math.random() > 0.8) spawnEntity('pig', cx*16+8, getBiomeHeight(cx*16+8, cz*16+8)+2, cz*16+8);
        if(Math.random() > 0.9) spawnEntity('zombie', cx*16+8, getBiomeHeight(cx*16+8, cz*16+8)+2, cz*16+8);
    }

    function createTree(x, y, z) {
        for(let i=0; i<5; i++) worldData[`${x},${y+i},${z}`] = B.LOG;
        for(let lx=-2; lx<=2; lx++)
            for(let lz=-2; lz<=2; lz++)
                for(let ly=3; ly<=5; ly++)
                    if(!worldData[`${x+lx},${y+ly},${z+lz}`]) worldData[`${x+lx},${y+ly},${z+lz}`] = B.LEAVES;
    }

    // --- 5. 区块渲染 ---
    function updateChunkMesh(cx, cz) {
        const key = `${cx},${cz}`;
        if(chunks[key]) { scene.remove(chunks[key]); delete chunks[key]; }

        const group = new THREE.Group();
        const geometries = {}; // id -> count
        const matrices = {};   // id -> matrixArray

        // 仅渲染玩家视野垂直范围内的方块以优化性能
        // 这里做一个简单的剔除，只画不透明方块旁边的
        for(let x=0; x<16; x++) {
            for(let z=0; z<16; z++) {
                const wx = cx*16+x;
                const wz = cz*16+z;
                // 扫描所有高度数据 (优化: 实际应该分层Chunk，这里简化为全高度扫描)
                for(let y=CONF.WORLD_BOTTOM; y<=CONF.WORLD_TOP; y++) {
                     const id = worldData[`${wx},${y},${wz}`];
                     if(id && id !== B.AIR) {
                         if(!geometries[id]) { geometries[id]=0; matrices[id]=[]; }
                         const m = new THREE.Matrix4().makeTranslation(wx, y, wz);
                         matrices[id].push(m);
                         geometries[id]++;
                     }
                }
            }
        }

        const boxGeo = new THREE.BoxGeometry(1,1,1);
        for(let id in geometries) {
            if(!matCache[id]) continue;
            const mesh = new THREE.InstancedMesh(boxGeo, matCache[id], geometries[id]);
            const arr = matrices[id];
            for(let i=0; i<arr.length; i++) mesh.setMatrixAt(i, arr[i]);
            group.add(mesh);
        }
        scene.add(group);
        chunks[key] = group;
    }

    // --- 6. 实体与手持物品 ---
    const entities = [];
    const handGroup = new THREE.Group();
    camera.add(handGroup);
    scene.add(camera);

    // 手臂
    const armMesh = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.8), new THREE.MeshLambertMaterial({color: 0xeebb99}));
    armMesh.position.set(0.5, -0.4, -0.5);
    handGroup.add(armMesh);
    
    // 手持物品 Mesh
    const heldItemMesh = new THREE.Mesh(new THREE.BoxGeometry(0.4,0.4,0.4), matCache[B.DIRT]);
    heldItemMesh.position.set(0.5, -0.3, -0.8);
    heldItemMesh.visible = false;
    handGroup.add(heldItemMesh);

    function spawnEntity(type, x, y, z) {
        const color = type==='zombie'?0x2e7d32 : 0xf48fb1;
        const h = type==='zombie'?1.8:0.8;
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.6, h, 0.6), new THREE.MeshLambertMaterial({color}));
        mesh.position.set(x,y,z);
        scene.add(mesh);
        entities.push({type, mesh, hp:10, vel:new THREE.Vector3(), timer:0});
    }

    // --- 7. 玩家与交互 ---
    const player = {
        inv: new Array(64).fill(null),
        hotbar: [null, null, null, null, null], // pointer to inv index
        sel: 0,
        hp: 20
    };

    const controls = new THREE.PointerLockControls(camera, document.body);
    const keys = {};
    document.addEventListener('keydown', e => keys[e.code] = true);
    document.addEventListener('keyup', e => keys[e.code] = false);

    // UI 开关
    let isInvOpen = false;
    let selectedInvIndex = -1;
    function toggleInventory() {
        isInvOpen = !isInvOpen;
        document.getElementById('inventory-screen').style.display = isInvOpen ? 'block' : 'none';
        if(isInvOpen) {
            controls.unlock();
            renderInv();
        } else {
            controls.lock();
        }
    }

    document.addEventListener('mousedown', e => {
        if(isInvOpen) return;
        if(!controls.isLocked) { controls.lock(); return; }
        
        // 动画
        handGroup.rotation.x = -0.5;
        setTimeout(()=>handGroup.rotation.x=0, 150);

        if(e.button === 0) interact('break'); // 左键
        if(e.button === 2) interact('place'); // 右键
    });
    
    document.addEventListener('keydown', e => {
        if(e.code === 'KeyE') toggleInventory();
        if(e.key >= '1' && e.key <= '5') {
            player.sel = parseInt(e.key) - 1;
            updateHand();
            renderHotbar();
        }
    });
    // 数字键选择
    
    function getLookingAt() {
        const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
        let pos = camera.position.clone();
        for(let i=0; i<80; i++) { // 射线长度 5 (0.06 * 80)
            pos.addScaledVector(dir, 0.06);
            const x=Math.round(pos.x), y=Math.round(pos.y), z=Math.round(pos.z);
            const id = worldData[`${x},${y},${z}`];
            if(id && id!==B.AIR && id!==B.WATER) {
                 const prev = pos.clone().addScaledVector(dir, -0.06);
                 return {x,y,z, id, face:{x:Math.round(prev.x)-x, y:Math.round(prev.y)-y, z:Math.round(prev.z)-z}};
            }
        }
        return null;
    }

    function interact(action) {
        // 1. 攻击实体
        if(action === 'break') {
            const hitEnt = entities.find(e => e.mesh.position.distanceTo(camera.position) < 3);
            if(hitEnt) {
                hitEnt.hp -= 2;
                hitEnt.mesh.material.emissive.setHex(0xff0000);
                setTimeout(()=>hitEnt.mesh.material.emissive.setHex(0x000000), 100);
                hitEnt.vel.y = 5; // 击退
                const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
                hitEnt.vel.add(dir.multiplyScalar(5));
                if(hitEnt.hp<=0) {
                    scene.remove(hitEnt.mesh);
                    entities.splice(entities.indexOf(hitEnt), 1);
                    if(hitEnt.type==='pig') addToInv(B.MEAT, 2);
                }
                return; // 打到怪就不挖方块
            }
        }

        const hit = getLookingAt();
        if(!hit) return;

        if(action === 'break') {
            if(hit.id === B.BEDROCK) return; // 基岩不可破
            delete worldData[`${hit.x},${hit.y},${hit.z}`];
            
            // 掉落
            let drop = hit.id;
            if(hit.id === B.STONE) drop = B.COBBLESTONE;
            if(hit.id === B.GRASS) drop = B.DIRT;
            if(hit.id === B.LEAVES) drop = null; // 树叶不掉(简化)
            
            if(drop) addToInv(drop, 1);
            
            rebuild(hit.x, hit.z);
        } else if (action === 'place') {
            const idx = player.hotbar[player.sel];
            if(idx === null || !player.inv[idx]) return;
            const item = player.inv[idx];
            if(item.id >= 100) return; // 物品不可放置

            const tx=hit.x+hit.face.x, ty=hit.y+hit.face.y, tz=hit.z+hit.face.z;
            // 碰撞检测
            if(Math.abs(camera.position.x-tx)<0.6 && Math.abs(camera.position.y-ty)<1.8 && Math.abs(camera.position.z-tz)<0.6) return;
            
            worldData[`${tx},${ty},${tz}`] = item.id;
            item.count--;
            if(item.count <= 0) player.inv[idx] = null;
            
            renderHotbar(); updateHand();
            rebuild(tx, tz);
        }
    }
    
    function rebuild(x, z) {
        updateChunkMesh(Math.floor(x/16), Math.floor(z/16));
    }

    // --- 8. 物品系统 ---
    function addToInv(id, num) {
        // 堆叠
        for(let i=0; i<64; i++) {
            if(player.inv[i] && player.inv[i].id === id && player.inv[i].count < 64) {
                player.inv[i].count += num;
                showMessage(`获得 ${num}个 物品`);
                renderHotbar(); return;
            }
        }
        // 空位
        for(let i=0; i<64; i++) {
            if(!player.inv[i]) {
                player.inv[i] = {id, count:num};
                showMessage(`获得 新物品`);
                renderHotbar(); updateHand(); return;
            }
        }
        showMessage("背包已满！");
    }

    const RECIPES = [
        {out:B.PLANKS, n:4, in:{[B.LOG]:1}},
        {out:B.CRAFTING_TABLE, n:1, in:{[B.PLANKS]:4}},
        {out:B.SWORD_WOOD, n:1, in:{[B.PLANKS]:2}},
        {out:B.SWORD_STONE, n:1, in:{[B.COBBLESTONE]:2}},
        {out:B.SWORD_IRON, n:1, in:{[B.IRON_ORE]:2}}, // 简化：矿石直接合
        {out:B.SWORD_DIAMOND, n:1, in:{[B.DIAMOND_ORE]:2}},
        {out:B.BRICK, n:1, in:{[B.STONE]:1}}
    ];

    function renderInv() {
        // 渲染背包网格
        const grid = document.getElementById('inv-grid');
        grid.innerHTML = '';
        player.inv.forEach((item, i) => {
            const el = document.createElement('div');
            el.className = 'slot' + (selectedInvIndex===i?' active':'');
            if(item) {
                el.innerHTML = `<img src="${iconCache[item.id]}"><span class="count">${item.count}</span>`;
            }
            el.onclick = () => { selectedInvIndex = i; renderInv(); };
            grid.appendChild(el);
        });

        // 渲染合成表
        const craftArea = document.getElementById('crafting-area');
        craftArea.innerHTML = '';
        RECIPES.forEach(r => {
            const div = document.createElement('div');
            div.className = 'craft-item';
            
            // 检查材料
            let enough = true;
            for(let reqId in r.in) {
                const count = player.inv.reduce((sum, it) => sum + (it && it.id==reqId ? it.count : 0), 0);
                if(count < r.in[reqId]) enough = false;
            }
            if(!enough) div.classList.add('disabled');

            div.innerHTML = `<img src="${iconCache[r.out]}" width="40"><span style="font-size:10px;font-weight:bold">${r.n}</span>`;
            
            div.onclick = () => {
                if(!enough) return;
                // 扣除材料
                for(let reqId in r.in) {
                    let cost = r.in[reqId];
                    for(let i=0; i<64; i++) {
                        if(player.inv[i] && player.inv[i].id==reqId) {
                            let take = Math.min(player.inv[i].count, cost);
                            player.inv[i].count -= take;
                            cost -= take;
                            if(player.inv[i].count===0) player.inv[i] = null;
                            if(cost<=0) break;
                        }
                    }
                }
                addToInv(r.out, r.n);
                renderInv();
            };
            craftArea.appendChild(div);
        });
    }

    function renderHotbar() {
        const bar = document.getElementById('hotbar');
        bar.innerHTML = '';
        for(let i=0; i<5; i++) {
            const idx = player.hotbar[i];
            const item = (idx!==null) ? player.inv[idx] : null;
            const el = document.createElement('div');
            el.className = 'slot ' + (player.sel===i?'active':'');
            if(item) el.innerHTML = `<img src="${iconCache[item.id]}"><span class="count">${item.count}</span>`;
            
            el.onclick = (e) => {
                e.stopPropagation(); // 防止触发挥动
                if(isInvOpen && selectedInvIndex!==-1) {
                    player.hotbar[i] = selectedInvIndex;
                    selectedInvIndex = -1;
                    renderInv(); renderHotbar(); updateHand();
                } else {
                    player.sel = i; renderHotbar(); updateHand();
                }
            };
            bar.appendChild(el);
        }
    }

    function updateHand() {
        const idx = player.hotbar[player.sel];
        const item = (idx!==null)?player.inv[idx]:null;
        
        armMesh.visible = !item;
        heldItemMesh.visible = !!item;
        if(item) {
            if(item.id >= 100) { // 物品
                heldItemMesh.geometry = new THREE.BoxGeometry(0.1, 0.6, 0.1);
                heldItemMesh.rotation.set(Math.PI/4, 0, 0);
            } else { // 方块
                heldItemMesh.geometry = new THREE.BoxGeometry(0.4, 0.4, 0.4);
                heldItemMesh.rotation.set(0, 0, 0);
            }
            // 给手持物品上材质（如果是物品用剑的颜色，方块用方块材质）
            if(matCache[item.id]) heldItemMesh.material = matCache[item.id];
            else heldItemMesh.material = new THREE.MeshBasicMaterial({color:0xffffff}); 
        }
    }

    function showMessage(msg) {
        const m = document.getElementById('message');
        m.innerText = msg; m.style.opacity = 1;
        setTimeout(() => m.style.opacity = 0, 1500);
    }

    // --- 9. 物理与循环 ---
    const clock = new THREE.Clock();
    const vel = new THREE.Vector3();
    let lastCx=-999, lastCz=-999;
    
    // 初始位置
    camera.position.set(0, 50, 0);

    function animate() {
        requestAnimationFrame(animate);
        const dt = Math.min(clock.getDelta(), 0.1);

        if(controls.isLocked) {
            // 物理移动
            vel.x -= vel.x * 10.0 * dt;
            vel.z -= vel.z * 10.0 * dt;
            vel.y -= CONF.GRAVITY * dt;

            const dir = new THREE.Vector3();
            const fwd = (keys['KeyW']?1:0) - (keys['KeyS']?1:0);
            const side = (keys['KeyD']?1:0) - (keys['KeyA']?1:0);
            dir.z = fwd; dir.x = side; dir.normalize();

            if(fwd || side) {
                vel.z -= dir.z * CONF.SPEED * dt;
                vel.x -= dir.x * CONF.SPEED * dt;
            }

            controls.moveRight(-vel.x * dt);
            controls.moveForward(-vel.z * dt);
            camera.position.y += vel.y * dt;

            // 碰撞检测 + 自动跳跃
            checkCollision(dt);

            if(keys['Space'] && onGround) vel.y = CONF.JUMP;
            
            // 掉出世界重置
            if(camera.position.y < CONF.WORLD_BOTTOM - 10) {
                camera.position.set(0, 60, 0); vel.set(0,0,0);
            }
        }

        // 区块更新
        const cx = Math.floor(camera.position.x / 16);
        const cz = Math.floor(camera.position.z / 16);
        if(cx!==lastCx || cz!==lastCz) {
            for(let x=-CONF.RENDER_DIST; x<=CONF.RENDER_DIST; x++) {
                for(let z=-CONF.RENDER_DIST; z<=CONF.RENDER_DIST; z++) {
                    const key = `${cx+x},${cz+z}`;
                    if(!chunks[key]) {
                        generateChunk(cx+x, cz+z);
                        updateChunkMesh(cx+x, cz+z);
                    }
                }
            }
            // 卸载远处
            for(let k in chunks) {
                const parts = k.split(',');
                if(Math.abs(parts[0]-cx) > CONF.RENDER_DIST+1 || Math.abs(parts[1]-cz) > CONF.RENDER_DIST+1) {
                    scene.remove(chunks[k]); delete chunks[k];
                }
            }
            lastCx = cx; lastCz = cz;
        }

        // 实体更新
        entities.forEach(ent => {
            ent.vel.y -= CONF.GRAVITY * dt;
            
            // 简单的AI
            if(ent.type === 'zombie') {
                const dist = ent.mesh.position.distanceTo(camera.position);
                if(dist < 20) {
                    const d = camera.position.clone().sub(ent.mesh.position).normalize();
                    ent.vel.x = d.x * 4; ent.vel.z = d.z * 4;
                }
            } else {
                // 猪漫步
                if(Math.random()>0.98) {
                    ent.vel.x = (Math.random()-0.5)*4; ent.vel.z = (Math.random()-0.5)*4;
                }
            }

            ent.mesh.position.addScaledVector(ent.vel, dt);
            
            // 实体落地检测
            const ex = Math.round(ent.mesh.position.x);
            const ey = Math.round(ent.mesh.position.y);
            const ez = Math.round(ent.mesh.position.z);
            if(worldData[`${ex},${ey},${ez}`] || worldData[`${ex},${ey-1},${ez}`]) {
                if(ent.vel.y < 0) {
                    ent.vel.y = 0; ent.mesh.position.y = ey + 1; // 简单吸附地面
                }
            }
        });

        renderer.render(scene, camera);
        document.getElementById('stats').innerText = `XYZ: ${Math.floor(camera.position.x)},${Math.floor(camera.position.y)},${Math.floor(camera.position.z)}`;
    }

    let onGround = false;
    function checkCollision(dt) {
        const r = 0.3; // 玩家半径
        const x = camera.position.x;
        const y = camera.position.y;
        const z = camera.position.z;

        // 简单的体素碰撞：检查脚下
        const bx = Math.round(x), by = Math.round(y-1.6), bz = Math.round(z);
        
        // 自动跳跃逻辑 (Auto Jump)
        // 检测前方是否阻挡
        const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
        const fx = Math.round(x + dir.x), fz = Math.round(z + dir.z);
        const blockFront = worldData[`${fx},${Math.round(y-1)},${fz}`]; // 腿部前方
        const blockFrontUp = worldData[`${fx},${Math.round(y)},${fz}`]; // 头前方
        
        if(blockFront && !blockFrontUp && onGround && (keys['KeyW'])) {
            vel.y = 6; // 小跳
        }

        // 地面检测
        let hitY = -999;
        for(let k=0; k<=2; k++) {
            if(worldData[`${bx},${by-k},${bz}`] && worldData[`${bx},${by-k},${bz}`] !== B.AIR) {
                hitY = by-k; break;
            }
        }

        if(y < hitY + 2.6) { // 1(block) + 1.6(eye height)
            camera.position.y = hitY + 2.6;
            vel.y = 0;
            onGround = true;
        } else {
            onGround = false;
        }
    }

    // 启动
    updateHand();
    renderHotbar();
    animate();

    window.onresize = () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    };

</script>
</body>
</html>